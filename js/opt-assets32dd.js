/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js-3.2.2/ontraport/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./www/js-3.2.2/ontraport/opt_assets/opt-assets.webpack.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./legacy/include/formEditor/jquery.jb.formconditions.js":
/*!***************************************************************!*\
  !*** ./legacy/include/formEditor/jquery.jb.formconditions.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n    Jquery form conditions\n    allows you to show / hide elements on a form based on element values\n\n    Copyright (c) 2010 Jesse Baird <jebaird@gmail.com>\n   \thttp://jebaird.com/blog/formconditons-jquery-ui-widget-assists-you-create-dynamic-forms\n    3/17/2011\n\n    Dual licensed under the MIT (MIT-LICENSE.txt)\n    and GPL (GPL-LICENSE.txt) licenses.\n\n\n    happy saint pats!\n\n*/\n\n/*\n\nTODO: add support in outcome and rule for callback,\n\n*/\n(function ($) {\n  // Helpers\n  var toLower = function (string) {\n    return string && string.toLowerCase ? string.toLowerCase() : string;\n  },\n      // Stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex/6969486#6969486\n  escapeRegExp = function (str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n  };\n\n  $.widget('jb.formConditions', {\n    options: {\n      // Applied when the outcomes are processed, return null to skip processing\n      outcomeActionMutator: function (outcome, rulesResult) {\n        return outcome.action;\n      },\n\n      /*\n       * Called after the rules are checked, this, an instance\n       * can be used to change how the outcomes are processed\n       * like if you wanted to invert every rule with out supplying the inverse\n       */\n      processorMutator: function (condition, rulesResult) {\n        if (rulesResult == true && condition.tru != undefined) {\n          this._processOutcomes(condition.tru, rulesResult);\n        } else if (rulesResult == false && condition.fal != undefined) {\n          this._processOutcomes(condition.fal, rulesResult);\n        }\n      },\n      // Run the processor on these events\n      inputEvent: 'blur',\n      // This conditions array is shared across multiple instances of this plugin.\n      // When conditions are added, the uuid of the plugin instance will be attached to the condition object.\n      // When the conditions are processed, the uuid of the form conditions processor is checked against\n      // the uuid of the condition to make sure we only processing conditions for the correct form\n      conditions: []\n    },\n    ruleDefaults: {\n      selector: '',\n      // Relative to element that widget is run on\n      operator: '',\n      // String equal to value or function\n      value: ''\n    },\n    outcomeDefaults: {\n      action: 'hide',\n      // String or function\n      selector: ''\n    },\n\n    /*\n     * Build in outcome actions\n     * to add your own use this code\n     * $.extend($.jb.formConditions.prototype.outcomeActions,{\n     * \t'youractionname': function(){}\n     * })\n     */\n    outcomeActions: {\n      show: function (element) {\n        element.parent().show();\n      },\n      hide: function (element) {\n        element.parent().hide();\n      }\n    },\n    operators: {\n      // This is this widget instance\n      equal: function (val, rule, element) {\n        return toLower(val) == toLower(rule.value) ? true : false;\n      },\n      'not-equal': function (val, rule, element) {\n        return !$.jb.formConditions.prototype.operators.equal.apply(this, arguments);\n      },\n      checked: function (val, rule, element) {\n        return element.is(':checked');\n      },\n      'not-checked': function (val, rule, element) {\n        return !$.jb.formConditions.prototype.operators.checked.apply(this, arguments);\n      },\n      // TODO: add support for arrays and objects\n      contains: function (val, rule, element) {\n        var regEx = new RegExp('(' + rule.value + ')', 'gi');\n        return regEx.test(val);\n      },\n      'doesnt-contain': function (val, rule, element) {\n        return !$.jb.formConditions.prototype.operators.contains.apply(this, arguments);\n      },\n      // Starts with\n      'starts-with': function (val, rule, element) {\n        var regEx = new RegExp('^(' + escapeRegExp(rule.value) + ')', 'gi');\n        return regEx.test(val);\n      },\n      'doesnt-start-with': function (val, rule, element) {\n        var regEx = new RegExp('^(' + escapeRegExp(rule.value) + ')', 'gi');\n        return !regEx.test(val);\n      },\n      'ends-with': function (val, rule, element) {\n        var regEx = new RegExp('(' + escapeRegExp(rule.value) + ')$', 'gi');\n        return regEx.test(val);\n      },\n      'doesnt-end-with': function (val, rule, element) {\n        var regEx = new RegExp('(' + escapeRegExp(rule.value) + ')$', 'gi');\n        return !regEx.test(val);\n      }\n    },\n    _create: function () {\n      var self = this,\n          element = self.element,\n          options = self.options,\n          // #\n      conditions = options.conditions,\n          cLen = conditions.length; // Cache the last result of a rule\n\n      self.rulesLastResult = {}; // #### bind on change\n      // like keyup\n\n      element.delegate(':input', (this.options.inputEvent + ' ').split(' ').join('.formConditions '), function () {\n        self._processor();\n      });\n\n      self._processor();\n    },\n\n    /*\n     * This is where the magic happens\n     */\n    _processor: function () {\n      var conditions = this.options.conditions,\n          lastResults = this.rulesLastResult;\n\n      for (var i = 0; i < conditions.length; i++) {\n        var condition = conditions[i]; // If the condition's uuid does not match the uuid of this plugin instance, don't process the condition\n\n        if (condition.hasOwnProperty('uuid') && this.hasOwnProperty('uuid') && condition.uuid !== this.uuid) {\n          continue;\n        }\n\n        var rulesResult = this._checkRules(condition.rules);\n\n        this.options.processorMutator.apply(this, [condition, rulesResult]);\n        lastResults[condition.name] = rulesResult;\n      }\n    },\n    _processOutcomes: function (outcomes, rulesResult) {\n      var element = this.element;\n\n      for (var i = 0; i < outcomes.length; i++) {\n        var outcome = outcomes[i],\n            target = outcome.selector ? element.find(outcome.selector) : undefined,\n            // Use the mutator\n        action = this.options.outcomeActionMutator.apply(this, [outcome, rulesResult]); // If we return null skip the processing\n\n        if (action === null) {\n          continue;\n        }\n\n        var type = typeof action;\n\n        if (type == 'string') {\n          this.outcomeActions[action].apply(this, [target]);\n        } else if (type == 'function') {\n          action.apply(this, [target]);\n        }\n      }\n    },\n    _checkRules: function (rules) {\n      for (var i = 0, $elem = this.element, ruleIsTrue = true; i < rules.length; i++) {\n        var rule = rules[i],\n            target = $elem.find(rule.selector),\n            operator = $.jb.formConditions.prototype.operators[rule.operator]; // Target isn't in the form\n\n        if (target.length == 0) {\n          ruleIsTrue = false;\n          break;\n        }\n\n        if (operator == undefined) {\n          console.error(' rule.operator is undefined ');\n        }\n\n        var val = target.val(),\n            ret = operator.apply(this, [val, rule, target]);\n\n        if (ret == false) {\n          ruleIsTrue = false;\n          break;\n        }\n      }\n\n      return ruleIsTrue;\n    },\n    addCondition: function (c) {\n      // Run condition before we push it on to the stack\n      this._processOutcomes(this._checkRules(c.rules) ? c.tru : c.fal); // Add uuid of the formconditions plugin instance to the condition.\n      // This is necessary to process conditions of a specific form (when multiple are present)\n      // because the condition array is shared across plugin instances\n\n\n      if (this.hasOwnProperty('uuid')) {\n        c.uuid = this.uuid;\n      }\n\n      this.options.conditions.push(c);\n    },\n    removeCondition: function (name) {\n      this.options.conditions = $.map(this.options.conditions, function (condition) {\n        return condition.name == name && typeof condition.name != undefined ? null : condition;\n      });\n    },\n    destroy: function () {\n      this.element.undelegate('.formConditions');\n    }\n  });\n})(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sZWdhY3kvaW5jbHVkZS9mb3JtRWRpdG9yL2pxdWVyeS5qYi5mb3JtY29uZGl0aW9ucy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xlZ2FjeS9pbmNsdWRlL2Zvcm1FZGl0b3IvanF1ZXJ5LmpiLmZvcm1jb25kaXRpb25zLmpzPzI4ODkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBKcXVlcnkgZm9ybSBjb25kaXRpb25zXG4gICAgYWxsb3dzIHlvdSB0byBzaG93IC8gaGlkZSBlbGVtZW50cyBvbiBhIGZvcm0gYmFzZWQgb24gZWxlbWVudCB2YWx1ZXNcblxuICAgIENvcHlyaWdodCAoYykgMjAxMCBKZXNzZSBCYWlyZCA8amViYWlyZEBnbWFpbC5jb20+XG4gICBcdGh0dHA6Ly9qZWJhaXJkLmNvbS9ibG9nL2Zvcm1jb25kaXRvbnMtanF1ZXJ5LXVpLXdpZGdldC1hc3Npc3RzLXlvdS1jcmVhdGUtZHluYW1pYy1mb3Jtc1xuICAgIDMvMTcvMjAxMVxuXG4gICAgRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIChNSVQtTElDRU5TRS50eHQpXG4gICAgYW5kIEdQTCAoR1BMLUxJQ0VOU0UudHh0KSBsaWNlbnNlcy5cblxuXG4gICAgaGFwcHkgc2FpbnQgcGF0cyFcblxuKi9cbi8qXG5cblRPRE86IGFkZCBzdXBwb3J0IGluIG91dGNvbWUgYW5kIHJ1bGUgZm9yIGNhbGxiYWNrLFxuXG4qL1xuKCBmdW5jdGlvbiggJCApIHtcblxuICAgIC8vIEhlbHBlcnNcbiAgICB2YXIgdG9Mb3dlciA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgXHRyZXR1cm4gKCBzdHJpbmcgJiYgc3RyaW5nLnRvTG93ZXJDYXNlICkgPyBzdHJpbmcudG9Mb3dlckNhc2UoKSA6IHN0cmluZztcbiAgICB9LFxuICAgIC8vIFN0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNDQ2MTcwL2VzY2FwZS1zdHJpbmctZm9yLXVzZS1pbi1qYXZhc2NyaXB0LXJlZ2V4LzY5Njk0ODYjNjk2OTQ4NlxuICAgIGVzY2FwZVJlZ0V4cCA9IGZ1bmN0aW9uKCBzdHIgKSB7XG4gICAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoIC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgJ1xcXFwkJicgKTtcblx0fTtcblxuXG4kLndpZGdldCggJ2piLmZvcm1Db25kaXRpb25zJyx7XG4gICAgb3B0aW9uczoge1xuICAgIFx0Ly8gQXBwbGllZCB3aGVuIHRoZSBvdXRjb21lcyBhcmUgcHJvY2Vzc2VkLCByZXR1cm4gbnVsbCB0byBza2lwIHByb2Nlc3NpbmdcbiAgICBcdG91dGNvbWVBY3Rpb25NdXRhdG9yOiBmdW5jdGlvbiggb3V0Y29tZSwgcnVsZXNSZXN1bHQgKSB7XG4gICAgXHRcdHJldHVybiBvdXRjb21lLmFjdGlvbjtcbiAgICBcdH0sXG5cbiAgICBcdC8qXG4gICAgXHQgKiBDYWxsZWQgYWZ0ZXIgdGhlIHJ1bGVzIGFyZSBjaGVja2VkLCB0aGlzLCBhbiBpbnN0YW5jZVxuICAgIFx0ICogY2FuIGJlIHVzZWQgdG8gY2hhbmdlIGhvdyB0aGUgb3V0Y29tZXMgYXJlIHByb2Nlc3NlZFxuICAgIFx0ICogbGlrZSBpZiB5b3Ugd2FudGVkIHRvIGludmVydCBldmVyeSBydWxlIHdpdGggb3V0IHN1cHBseWluZyB0aGUgaW52ZXJzZVxuICAgIFx0ICovXG4gICAgXHRwcm9jZXNzb3JNdXRhdG9yOiBmdW5jdGlvbiggY29uZGl0aW9uLCBydWxlc1Jlc3VsdCApIHtcblxuICAgIFx0XHRpZiAoIHJ1bGVzUmVzdWx0ID09IHRydWUgJiYgY29uZGl0aW9uLnRydSAhPSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl9wcm9jZXNzT3V0Y29tZXMoIGNvbmRpdGlvbi50cnUsIHJ1bGVzUmVzdWx0ICk7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggcnVsZXNSZXN1bHQgPT0gZmFsc2UgJiYgY29uZGl0aW9uLmZhbCAhPSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIFx0dGhpcy5fcHJvY2Vzc091dGNvbWVzKCBjb25kaXRpb24uZmFsLCBydWxlc1Jlc3VsdCApO1xuXG4gICAgICAgICAgICB9XG4gICAgXHR9LFxuICAgIFx0Ly8gUnVuIHRoZSBwcm9jZXNzb3Igb24gdGhlc2UgZXZlbnRzXG4gICAgXHRpbnB1dEV2ZW50OiAnYmx1cicsXG5cblx0XHQvLyBUaGlzIGNvbmRpdGlvbnMgYXJyYXkgaXMgc2hhcmVkIGFjcm9zcyBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhpcyBwbHVnaW4uXG5cdFx0Ly8gV2hlbiBjb25kaXRpb25zIGFyZSBhZGRlZCwgdGhlIHV1aWQgb2YgdGhlIHBsdWdpbiBpbnN0YW5jZSB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBjb25kaXRpb24gb2JqZWN0LlxuXHRcdC8vIFdoZW4gdGhlIGNvbmRpdGlvbnMgYXJlIHByb2Nlc3NlZCwgdGhlIHV1aWQgb2YgdGhlIGZvcm0gY29uZGl0aW9ucyBwcm9jZXNzb3IgaXMgY2hlY2tlZCBhZ2FpbnN0XG5cdFx0Ly8gdGhlIHV1aWQgb2YgdGhlIGNvbmRpdGlvbiB0byBtYWtlIHN1cmUgd2Ugb25seSBwcm9jZXNzaW5nIGNvbmRpdGlvbnMgZm9yIHRoZSBjb3JyZWN0IGZvcm1cbiAgICAgICAgY29uZGl0aW9uczogW11cbiAgICB9LFxuICAgIHJ1bGVEZWZhdWx0czoge1xuICAgICAgICBzZWxlY3RvcjogJycsLy8gUmVsYXRpdmUgdG8gZWxlbWVudCB0aGF0IHdpZGdldCBpcyBydW4gb25cbiAgICAgICAgb3BlcmF0b3I6ICcnLC8vIFN0cmluZyBlcXVhbCB0byB2YWx1ZSBvciBmdW5jdGlvblxuICAgICAgICB2YWx1ZTogJydcbiAgICB9LFxuXG4gICAgb3V0Y29tZURlZmF1bHRzOiB7XG4gICAgICAgIGFjdGlvbjogJ2hpZGUnLC8vIFN0cmluZyBvciBmdW5jdGlvblxuICAgICAgICBzZWxlY3RvcjogJydcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBCdWlsZCBpbiBvdXRjb21lIGFjdGlvbnNcbiAgICAgKiB0byBhZGQgeW91ciBvd24gdXNlIHRoaXMgY29kZVxuICAgICAqICQuZXh0ZW5kKCQuamIuZm9ybUNvbmRpdGlvbnMucHJvdG90eXBlLm91dGNvbWVBY3Rpb25zLHtcbiAgICAgKiBcdCd5b3VyYWN0aW9ubmFtZSc6IGZ1bmN0aW9uKCl7fVxuICAgICAqIH0pXG4gICAgICovXG4gICAgb3V0Y29tZUFjdGlvbnM6IHtcbiAgICBcdHNob3c6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgIFx0XHRlbGVtZW50LnBhcmVudCgpLnNob3coKTtcbiAgICBcdH0sXG5cbiAgICBcdGhpZGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgIFx0XHRlbGVtZW50LnBhcmVudCgpLmhpZGUoKTtcbiAgICBcdH1cbiAgICB9LFxuICAgIG9wZXJhdG9yczoge1xuICAgIFx0Ly8gVGhpcyBpcyB0aGlzIHdpZGdldCBpbnN0YW5jZVxuICAgIFx0ZXF1YWw6IGZ1bmN0aW9uKCB2YWwsIHJ1bGUsIGVsZW1lbnQgKSB7XG4gICAgXHRcdHJldHVybiAoIHRvTG93ZXIoIHZhbCApID09IHRvTG93ZXIoIHJ1bGUudmFsdWUgKSApID8gdHJ1ZSA6IGZhbHNlO1xuICAgIFx0fSxcbiAgICBcdCdub3QtZXF1YWwnOiBmdW5jdGlvbiggdmFsLCBydWxlLCBlbGVtZW50ICkge1xuICAgIFx0XHRyZXR1cm4gISQuamIuZm9ybUNvbmRpdGlvbnMucHJvdG90eXBlLm9wZXJhdG9ycy5lcXVhbC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgXHR9LFxuICAgIFx0Y2hlY2tlZDogZnVuY3Rpb24oIHZhbCwgcnVsZSwgZWxlbWVudCApIHtcbiAgICBcdFx0cmV0dXJuIGVsZW1lbnQuaXMoICc6Y2hlY2tlZCcgKTtcbiAgICBcdH0sXG4gICAgXHQnbm90LWNoZWNrZWQnOiBmdW5jdGlvbiggdmFsLCBydWxlLCBlbGVtZW50ICkge1xuICAgIFx0XHRyZXR1cm4gISQuamIuZm9ybUNvbmRpdGlvbnMucHJvdG90eXBlLm9wZXJhdG9ycy5jaGVja2VkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICBcdH0sXG4gICAgXHQvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzXG4gICAgXHRjb250YWluczogZnVuY3Rpb24oIHZhbCwgcnVsZSwgZWxlbWVudCApIHtcbiAgICBcdFx0dmFyIHJlZ0V4ID0gbmV3IFJlZ0V4cCggJygnKyBydWxlLnZhbHVlICsnKScgLCdnaScgKTtcbiAgICBcdFx0cmV0dXJuIHJlZ0V4LnRlc3QoIHZhbCApO1xuICAgIFx0fSxcbiAgICBcdCdkb2VzbnQtY29udGFpbic6IGZ1bmN0aW9uKCB2YWwsIHJ1bGUsIGVsZW1lbnQgKSB7XG4gICAgXHRcdHJldHVybiAhJC5qYi5mb3JtQ29uZGl0aW9ucy5wcm90b3R5cGUub3BlcmF0b3JzLmNvbnRhaW5zLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICBcdH0sXG4gICAgXHQvLyBTdGFydHMgd2l0aFxuICAgIFx0J3N0YXJ0cy13aXRoJzogZnVuY3Rpb24oIHZhbCwgcnVsZSwgZWxlbWVudCApIHtcbiAgICBcdFx0dmFyIHJlZ0V4ID0gbmV3IFJlZ0V4cCggJ14oJysgKCBlc2NhcGVSZWdFeHAoIHJ1bGUudmFsdWUgKSApICsnKScgLCdnaScgKTtcbiAgICBcdFx0cmV0dXJuIHJlZ0V4LnRlc3QoIHZhbCApO1xuICAgIFx0fSxcbiAgICBcdCdkb2VzbnQtc3RhcnQtd2l0aCc6IGZ1bmN0aW9uKCB2YWwsIHJ1bGUsIGVsZW1lbnQgKSB7XG4gICAgXHRcdHZhciByZWdFeCA9IG5ldyBSZWdFeHAoICdeKCcrICggZXNjYXBlUmVnRXhwKCBydWxlLnZhbHVlICkgKSArJyknICwnZ2knICk7XG4gICAgXHRcdHJldHVybiAhcmVnRXgudGVzdCggdmFsICk7XG4gICAgXHR9LFxuXG4gICAgXHQnZW5kcy13aXRoJzogZnVuY3Rpb24oIHZhbCwgcnVsZSwgZWxlbWVudCApIHtcbiAgICBcdFx0dmFyIHJlZ0V4ID0gbmV3IFJlZ0V4cCggJygnKyAoIGVzY2FwZVJlZ0V4cCggcnVsZS52YWx1ZSApICkgKycpJCcgLCdnaScgKTtcbiAgICBcdFx0cmV0dXJuIHJlZ0V4LnRlc3QoIHZhbCApO1xuICAgIFx0fSxcblxuICAgIFx0J2RvZXNudC1lbmQtd2l0aCc6IGZ1bmN0aW9uKCB2YWwsIHJ1bGUsIGVsZW1lbnQgKSB7XG4gICAgXHRcdHZhciByZWdFeCA9IG5ldyBSZWdFeHAoICcoJysgKCBlc2NhcGVSZWdFeHAoIHJ1bGUudmFsdWUgKSApICsnKSQnICwnZ2knICk7XG4gICAgXHRcdHJldHVybiAhcmVnRXgudGVzdCggdmFsICk7XG4gICAgXHR9XG5cbiAgICB9LFxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG5cdCAgICAgICAgZWxlbWVudCA9IHNlbGYuZWxlbWVudCxcblx0ICAgICAgICBvcHRpb25zID0gc2VsZi5vcHRpb25zLFxuXHQgICAgICAgIC8vICNcblx0ICAgICAgICBjb25kaXRpb25zID0gb3B0aW9ucy5jb25kaXRpb25zLFxuXG5cdCAgICAgICAgY0xlbiA9IGNvbmRpdGlvbnMubGVuZ3RoO1xuXG5cdCAgICAgICAgLy8gQ2FjaGUgdGhlIGxhc3QgcmVzdWx0IG9mIGEgcnVsZVxuXHQgICAgICAgIHNlbGYucnVsZXNMYXN0UmVzdWx0ID0ge307XG5cblxuICAgICAgICAvLyAjIyMjIGJpbmQgb24gY2hhbmdlXG4gICAgICAgIC8vIGxpa2Uga2V5dXBcbiAgICAgICAgZWxlbWVudC5kZWxlZ2F0ZSggJzppbnB1dCcsKCB0aGlzLm9wdGlvbnMuaW5wdXRFdmVudCArJyAnICkuc3BsaXQoICcgJyApLmpvaW4oICcuZm9ybUNvbmRpdGlvbnMgJyApLGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBzZWxmLl9wcm9jZXNzb3IoKTtcblxuICAgICAgICB9ICk7XG5cbiAgICAgICBzZWxmLl9wcm9jZXNzb3IoKTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBUaGlzIGlzIHdoZXJlIHRoZSBtYWdpYyBoYXBwZW5zXG4gICAgICovXG4gICAgX3Byb2Nlc3NvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb25kaXRpb25zID0gdGhpcy5vcHRpb25zLmNvbmRpdGlvbnMsXG5cdFx0XHRsYXN0UmVzdWx0cyA9IHRoaXMucnVsZXNMYXN0UmVzdWx0O1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGNvbmRpdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY29uZGl0aW9uID0gY29uZGl0aW9uc1sgaSBdO1xuXG5cdFx0XHQvLyBJZiB0aGUgY29uZGl0aW9uJ3MgdXVpZCBkb2VzIG5vdCBtYXRjaCB0aGUgdXVpZCBvZiB0aGlzIHBsdWdpbiBpbnN0YW5jZSwgZG9uJ3QgcHJvY2VzcyB0aGUgY29uZGl0aW9uXG5cdFx0XHRpZiAoIGNvbmRpdGlvbi5oYXNPd25Qcm9wZXJ0eSggJ3V1aWQnICkgJiZcblx0XHRcdFx0dGhpcy5oYXNPd25Qcm9wZXJ0eSggJ3V1aWQnICkgJiZcblx0XHRcdFx0Y29uZGl0aW9uLnV1aWQgIT09IHRoaXMudXVpZCApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cbiAgICAgICAgXHR2YXIgcnVsZXNSZXN1bHQgPSB0aGlzLl9jaGVja1J1bGVzKCBjb25kaXRpb24ucnVsZXMgKTtcblxuICAgICAgICBcdHRoaXMub3B0aW9ucy5wcm9jZXNzb3JNdXRhdG9yLmFwcGx5KCB0aGlzLCBbIGNvbmRpdGlvbiwgcnVsZXNSZXN1bHQgXSApO1xuXG4gICAgICAgICAgIGxhc3RSZXN1bHRzWyBjb25kaXRpb24ubmFtZSBdID0gcnVsZXNSZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Byb2Nlc3NPdXRjb21lczogZnVuY3Rpb24oIG91dGNvbWVzLCBydWxlc1Jlc3VsdCApIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgb3V0Y29tZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB2YXIgb3V0Y29tZSA9IG91dGNvbWVzWyBpIF0sXG4gICAgICAgICAgICBcdHRhcmdldCA9ICggb3V0Y29tZS5zZWxlY3RvciApID8gZWxlbWVudC5maW5kKCBvdXRjb21lLnNlbGVjdG9yICkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBcdC8vIFVzZSB0aGUgbXV0YXRvclxuICAgICAgICAgICAgXHRhY3Rpb24gPSB0aGlzLm9wdGlvbnMub3V0Y29tZUFjdGlvbk11dGF0b3IuYXBwbHkoIHRoaXMsIFsgb3V0Y29tZSwgcnVsZXNSZXN1bHQgXSApO1xuICAgICAgICAgICAgXHQvLyBJZiB3ZSByZXR1cm4gbnVsbCBza2lwIHRoZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICBcdGlmICggYWN0aW9uID09PSBudWxsICkge1xuICAgICAgICAgICAgXHRcdGNvbnRpbnVlO1xuICAgICAgICAgICAgXHR9XG5cbiAgICAgICAgXHR2YXIgdHlwZSA9IHR5cGVvZiBhY3Rpb247XG5cbiAgICAgICAgICAgIGlmICggdHlwZSA9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgIFx0dGhpcy5vdXRjb21lQWN0aW9uc1sgYWN0aW9uIF0uYXBwbHkoIHRoaXMsWyB0YXJnZXQgXSApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgXHRhY3Rpb24uYXBwbHkoIHRoaXMsWyB0YXJnZXQgXSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG4gICAgX2NoZWNrUnVsZXM6IGZ1bmN0aW9uKCBydWxlcyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsICRlbGVtID0gdGhpcy5lbGVtZW50LCBydWxlSXNUcnVlID0gdHJ1ZTsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBcdHZhciBydWxlID0gcnVsZXNbIGkgXSxcbiAgICAgICAgXHRcdHRhcmdldCA9ICRlbGVtLmZpbmQoIHJ1bGUuc2VsZWN0b3IgKSxcbiAgICAgICAgXHRcdG9wZXJhdG9yID0gJC5qYi5mb3JtQ29uZGl0aW9ucy5wcm90b3R5cGUub3BlcmF0b3JzWyBydWxlLm9wZXJhdG9yIF07XG5cbiAgICAgICAgXHQvLyBUYXJnZXQgaXNuJ3QgaW4gdGhlIGZvcm1cbiAgICAgICAgXHRpZiAoIHRhcmdldC5sZW5ndGggPT0gMCApIHtcbiAgICAgICAgXHRcdHJ1bGVJc1RydWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgXHR9XG5cblxuICAgICAgICAgICAgaWYgKCBvcGVyYXRvciA9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBcdGNvbnNvbGUuZXJyb3IoICcgcnVsZS5vcGVyYXRvciBpcyB1bmRlZmluZWQgJyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsID0gdGFyZ2V0LnZhbCgpLFxuICAgICAgICAgICAgXHRyZXQgPSBvcGVyYXRvci5hcHBseSggdGhpcywgWyB2YWwsIHJ1bGUsIHRhcmdldCBdICk7XG5cbiAgICAgICAgICAgIGlmICggcmV0ID09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIHJ1bGVJc1RydWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZUlzVHJ1ZTtcbiAgICB9LFxuXG4gICAgYWRkQ29uZGl0aW9uOiBmdW5jdGlvbiggYyApIHtcbiAgICAgICAgLy8gUnVuIGNvbmRpdGlvbiBiZWZvcmUgd2UgcHVzaCBpdCBvbiB0byB0aGUgc3RhY2tcbiAgICAgICAgdGhpcy5fcHJvY2Vzc091dGNvbWVzKCAoIHRoaXMuX2NoZWNrUnVsZXMoIGMucnVsZXMgKSApID8gYy50cnUgOiBjLmZhbCApO1xuXG5cdFx0Ly8gQWRkIHV1aWQgb2YgdGhlIGZvcm1jb25kaXRpb25zIHBsdWdpbiBpbnN0YW5jZSB0byB0aGUgY29uZGl0aW9uLlxuXHRcdC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHByb2Nlc3MgY29uZGl0aW9ucyBvZiBhIHNwZWNpZmljIGZvcm0gKHdoZW4gbXVsdGlwbGUgYXJlIHByZXNlbnQpXG5cdFx0Ly8gYmVjYXVzZSB0aGUgY29uZGl0aW9uIGFycmF5IGlzIHNoYXJlZCBhY3Jvc3MgcGx1Z2luIGluc3RhbmNlc1xuXHRcdGlmICggdGhpcy5oYXNPd25Qcm9wZXJ0eSggJ3V1aWQnICkgKSB7XG5cdFx0XHRjLnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0fVxuXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb25kaXRpb25zLnB1c2goIGMgKTtcblxuICAgIH0sXG5cbiAgICByZW1vdmVDb25kaXRpb246IGZ1bmN0aW9uKCBuYW1lICkge1xuICAgICAgICAgdGhpcy5vcHRpb25zLmNvbmRpdGlvbnMgPSAkLm1hcCggdGhpcy5vcHRpb25zLmNvbmRpdGlvbnMsIGZ1bmN0aW9uKCBjb25kaXRpb24gKSB7XG4gICAgICAgIFx0cmV0dXJuICggY29uZGl0aW9uLm5hbWUgPT0gbmFtZSAmJiB0eXBlb2YgY29uZGl0aW9uLm5hbWUgIT0gdW5kZWZpbmVkICkgPyBudWxsIDogY29uZGl0aW9uO1xuICAgICAgICB9ICk7XG5cbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC51bmRlbGVnYXRlKCAnLmZvcm1Db25kaXRpb25zJyApO1xuICAgIH1cbn0gKTtcblxufSApKCBqUXVlcnkgKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUJBO0FBZ0NBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBeENBO0FBMkNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUpBO0FBQ0E7QUFRQTtBQUlBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUF0T0E7QUF5T0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./legacy/include/formEditor/jquery.jb.formconditions.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./www/js-3.2.2/globalize/globalize.js":
/*!*********************************************!*\
  !*** ./www/js-3.2.2/globalize/globalize.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*** IMPORTS FROM imports-loader ***/\n(function () {\n  /*\n   Globalize\n  \n   http://github.com/jquery/globalize\n  \n   Copyright Software Freedom Conservancy, Inc.\n   Dual licensed under the MIT or GPL Version 2 licenses.\n   http://jquery.org/license\n  */\n  (function (T, U) {\n    var L, G;\n\n    var k = function (a) {\n      return new k.prototype.init(a);\n    };\n\n     true ? module.exports = k : undefined;\n    k.cultures = {};\n    k.prototype = {\n      constructor: k,\n      init: function (a) {\n        this.cultures = k.cultures;\n        this.cultureSelector = a;\n        return this;\n      }\n    };\n    k.prototype.init.prototype = k.prototype;\n    k.cultures[\"default\"] = {\n      name: \"en\",\n      englishName: \"English\",\n      nativeName: \"English\",\n      isRTL: !1,\n      language: \"en\",\n      numberFormat: {\n        pattern: [\"-n\"],\n        decimals: 2,\n        \",\": \",\",\n        \".\": \".\",\n        groupSizes: [3],\n        \"+\": \"+\",\n        \"-\": \"-\",\n        NaN: \"NaN\",\n        negativeInfinity: \"-Infinity\",\n        positiveInfinity: \"Infinity\",\n        percent: {\n          pattern: [\"-n %\", \"n %\"],\n          decimals: 2,\n          groupSizes: [3],\n          \",\": \",\",\n          \".\": \".\",\n          symbol: \"%\"\n        },\n        currency: {\n          pattern: [\"($n)\", \"$n\"],\n          decimals: 2,\n          groupSizes: [3],\n          \",\": \",\",\n          \".\": \".\",\n          symbol: \"$\"\n        }\n      },\n      calendars: {\n        standard: {\n          name: \"Gregorian_USEnglish\",\n          \"/\": \"/\",\n          \":\": \":\",\n          firstDay: 0,\n          days: {\n            names: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n            namesAbbr: \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"),\n            namesShort: \"Su Mo Tu We Th Fr Sa\".split(\" \")\n          },\n          months: {\n            names: \"January February March April May June July August September October November December \".split(\" \"),\n            namesAbbr: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec \".split(\" \")\n          },\n          AM: [\"AM\", \"am\", \"AM\"],\n          PM: [\"PM\", \"pm\", \"PM\"],\n          eras: [{\n            name: \"A.D.\",\n            start: null,\n            offset: 0\n          }],\n          twoDigitYearMax: 2029,\n          patterns: {\n            d: \"M/d/yyyy\",\n            D: \"dddd, MMMM dd, yyyy\",\n            t: \"h:mm tt\",\n            T: \"h:mm:ss tt\",\n            f: \"dddd, MMMM dd, yyyy h:mm tt\",\n            F: \"dddd, MMMM dd, yyyy h:mm:ss tt\",\n            M: \"MMMM dd\",\n            Y: \"yyyy MMMM\",\n            S: \"yyyy'-'MM'-'dd'T'HH':'mm':'ss\"\n          }\n        }\n      },\n      messages: {}\n    };\n    k.cultures[\"default\"].calendar = k.cultures[\"default\"].calendars.standard;\n    k.cultures.en = k.cultures[\"default\"];\n    k.cultureSelector = \"en\";\n    var V = /^0x[a-f0-9]+$/i;\n    var W = /^[+-]?infinity$/i;\n    var X = /^[+-]?\\d*\\.?\\d*(e[+-]?\\d+)?$/;\n    var Y = /^\\s+|\\s+$/g;\n\n    var w = function (a, b) {\n      if (a.indexOf) return a.indexOf(b);\n\n      for (var c = 0, e = a.length; c < e; c++) if (a[c] === b) return c;\n\n      return -1;\n    };\n\n    var H = function (a, b) {\n      return a.substr(a.length - b.length) === b;\n    };\n\n    var N = function (a) {\n      var b,\n          c,\n          e,\n          f = arguments[0] || {},\n          h = 1,\n          g = arguments.length;\n      a = !1;\n      \"boolean\" === typeof f && (a = f, f = arguments[1] || {}, h = 2);\n\n      for (\"object\" === typeof f || Z(f) || (f = {}); h < g; h++) if (null != (b = arguments[h])) for (c in b) {\n        var d = f[c];\n        var l = b[c];\n        f !== l && (a && l && (M(l) || (e = I(l))) ? (e ? (e = !1, d = d && I(d) ? d : []) : d = d && M(d) ? d : {}, f[c] = N(a, d, l)) : l !== U && (f[c] = l));\n      }\n\n      return f;\n    };\n\n    var I = Array.isArray || function (a) {\n      return \"[object Array]\" === Object.prototype.toString.call(a);\n    };\n\n    var Z = function (a) {\n      return \"[object Function]\" === Object.prototype.toString.call(a);\n    };\n\n    var M = function (a) {\n      return \"[object Object]\" === Object.prototype.toString.call(a);\n    };\n\n    var E = function (a, b) {\n      return 0 === a.indexOf(b);\n    };\n\n    var y = function (a) {\n      return (a + \"\").replace(Y, \"\");\n    };\n\n    var O = function (a) {\n      return isNaN(a) ? NaN : a | 0;\n    };\n\n    var z = function (a, b, c) {\n      var e;\n\n      for (e = a.length; e < b; e += 1) a = c ? \"0\" + a : a + \"0\";\n\n      return a;\n    };\n\n    var J = function (a, b) {\n      for (var c = 0, e = !1, f = 0, h = a.length; f < h; f++) {\n        var g = a.charAt(f);\n\n        switch (g) {\n          case \"'\":\n            e ? b.push(\"'\") : c++;\n            e = !1;\n            break;\n\n          case \"\\\\\":\n            e && b.push(\"\\\\\");\n            e = !e;\n            break;\n\n          default:\n            b.push(g), e = !1;\n        }\n      }\n\n      return c;\n    };\n\n    var P = function (a, b) {\n      b = b || \"F\";\n      a = a.patterns;\n      var c = b.length;\n\n      if (1 === c) {\n        a = a[b];\n        if (!a) throw \"Invalid date format string '\" + b + \"'.\";\n        b = a;\n      } else 2 === c && \"%\" === b.charAt(0) && (b = b.charAt(1));\n\n      return b;\n    };\n\n    var Q = function (a, b, c) {\n      function e(a, d) {\n        a += \"\";\n        return 1 < d && a.length < d ? (a = aa[d - 2] + a, a.substr(a.length - d, d)) : a;\n      }\n\n      function f() {\n        if (n || k) return n;\n        n = t.test(b);\n        k = !0;\n        return n;\n      }\n\n      function h(a, d) {\n        if (q) return q[d];\n\n        switch (d) {\n          case 0:\n            return a.getFullYear();\n\n          case 1:\n            return a.getMonth();\n\n          case 2:\n            return a.getDate();\n        }\n      }\n\n      var g = c.calendar,\n          d = g.convert;\n\n      if (!b || !b.length || \"i\" === b) {\n        if (c && c.name.length) {\n          if (d) c = Q(a, g.patterns.F, c);else {\n            c = new Date(a.getTime());\n            var l = C(a, g.eras);\n            c.setFullYear(K(a, g, l));\n            c = c.toLocaleString();\n          }\n        } else c = a.toString();\n        return c;\n      }\n\n      l = g.eras;\n      var R = \"s\" === b;\n      b = P(g, b);\n      c = [];\n      var aa = [\"0\", \"00\", \"000\"],\n          k,\n          t = /([^d]|^)(d|dd)([^d]|$)/g,\n          u = 0,\n          B = S(),\n          q;\n\n      for (!R && d && (q = d.fromGregorian(a));;) {\n        var m = B.lastIndex;\n        d = B.exec(b);\n        m = b.slice(m, d ? d.index : b.length);\n        u += J(m, c);\n        if (!d) break;\n        if (u % 2) c.push(d[0]);else switch (m = d[0], d = m.length, m) {\n          case \"ddd\":\n          case \"dddd\":\n            c.push((3 === d ? g.days.namesAbbr : g.days.names)[a.getDay()]);\n            break;\n\n          case \"d\":\n          case \"dd\":\n            var n = !0;\n            c.push(e(h(a, 2), d));\n            break;\n\n          case \"MMM\":\n          case \"MMMM\":\n            m = h(a, 1);\n            c.push(g.monthsGenitive && f() ? g.monthsGenitive[3 === d ? \"namesAbbr\" : \"names\"][m] : g.months[3 === d ? \"namesAbbr\" : \"names\"][m]);\n            break;\n\n          case \"M\":\n          case \"MM\":\n            c.push(e(h(a, 1) + 1, d));\n            break;\n\n          case \"y\":\n          case \"yy\":\n          case \"yyyy\":\n            m = q ? q[0] : K(a, g, C(a, l), R);\n            4 > d && (m %= 100);\n            c.push(e(m, d));\n            break;\n\n          case \"h\":\n          case \"hh\":\n            m = a.getHours() % 12;\n            0 === m && (m = 12);\n            c.push(e(m, d));\n            break;\n\n          case \"H\":\n          case \"HH\":\n            c.push(e(a.getHours(), d));\n            break;\n\n          case \"m\":\n          case \"mm\":\n            c.push(e(a.getMinutes(), d));\n            break;\n\n          case \"s\":\n          case \"ss\":\n            c.push(e(a.getSeconds(), d));\n            break;\n\n          case \"t\":\n          case \"tt\":\n            m = 12 > a.getHours() ? g.AM ? g.AM[0] : \" \" : g.PM ? g.PM[0] : \" \";\n            c.push(1 === d ? m.charAt(0) : m);\n            break;\n\n          case \"f\":\n          case \"ff\":\n          case \"fff\":\n            c.push(e(a.getMilliseconds(), 3).substr(0, d));\n            break;\n\n          case \"z\":\n          case \"zz\":\n            m = a.getTimezoneOffset() / 60;\n            c.push((0 >= m ? \"+\" : \"-\") + e(Math.floor(Math.abs(m)), d));\n            break;\n\n          case \"zzz\":\n            m = a.getTimezoneOffset() / 60;\n            c.push((0 >= m ? \"+\" : \"-\") + e(Math.floor(Math.abs(m)), 2) + \":\" + e(Math.abs(a.getTimezoneOffset() % 60), 2));\n            break;\n\n          case \"g\":\n          case \"gg\":\n            g.eras && c.push(g.eras[C(a, l)].name);\n            break;\n\n          case \"/\":\n            c.push(g[\"/\"]);\n            break;\n\n          default:\n            throw \"Invalid date format pattern '\" + m + \"'.\";\n        }\n      }\n\n      return c.join(\"\");\n    };\n\n    (function () {\n      var a = function (a, c, e) {\n        var b = e.groupSizes,\n            h = b[0],\n            g = 1,\n            d = Math.pow(10, c);\n        d = Math.round(a * d) / d;\n        isFinite(d) || (d = a);\n        d = (d + \"\").split(/e/i);\n        var l = 1 < d.length ? parseInt(d[1], 10) : 0;\n        a = d[0];\n        d = a.split(\".\");\n        a = d[0];\n        d = 1 < d.length ? d[1] : \"\";\n        0 < l ? (d = z(d, l, !1), a += d.slice(0, l), d = d.substr(l)) : 0 > l && (l = -l, a = z(a, l + 1), d = a.slice(-l, a.length) + d, a = a.slice(0, -l));\n        d = 0 < c ? e[\".\"] + (d.length > c ? d.slice(0, c) : z(d, c)) : \"\";\n        c = a.length - 1;\n        e = e[\",\"];\n\n        for (l = \"\"; 0 <= c;) {\n          if (0 === h || h > c) return a.slice(0, c + 1) + (l.length ? e + l + d : d);\n          l = a.slice(c - h + 1, c + 1) + (l.length ? e + l : \"\");\n          c -= h;\n          g < b.length && (h = b[g], g++);\n        }\n\n        return a.slice(0, c + 1) + e + l + d;\n      };\n\n      L = function (b, c, e) {\n        if (!isFinite(b)) return Infinity === b ? e.numberFormat.positiveInfinity : -Infinity === b ? e.numberFormat.negativeInfinity : e.numberFormat.NaN;\n        if (!c || \"i\" === c) return e.name.length ? b.toLocaleString() : b.toString();\n        c = c || \"D\";\n        e = e.numberFormat;\n        var f = Math.abs(b),\n            h = -1;\n        1 < c.length && (h = parseInt(c.slice(1), 10));\n        var g = c.charAt(0).toUpperCase();\n\n        switch (g) {\n          case \"D\":\n            c = \"n\";\n            f = O(f);\n            -1 !== h && (f = z(\"\" + f, h, !0));\n            0 > b && (f = \"-\" + f);\n            break;\n\n          case \"N\":\n            var d = e;\n\n          case \"C\":\n            d = d || e.currency;\n\n          case \"P\":\n            d = d || e.percent;\n            c = 0 > b ? d.pattern[0] : d.pattern[1] || \"n\";\n            -1 === h && (h = d.decimals);\n            f = a(f * (\"P\" === g ? 100 : 1), h, d);\n            break;\n\n          default:\n            throw \"Bad number format specifier: \" + g;\n        }\n\n        b = /n|\\$|-|%/g;\n\n        for (d = \"\";;) {\n          h = b.lastIndex;\n          g = b.exec(c);\n          d += c.slice(h, g ? g.index : c.length);\n          if (!g) break;\n\n          switch (g[0]) {\n            case \"n\":\n              d += f;\n              break;\n\n            case \"$\":\n              d += e.currency.symbol;\n              break;\n\n            case \"-\":\n              /[1-9]/.test(f) && (d += e[\"-\"]);\n              break;\n\n            case \"%\":\n              d += e.percent.symbol;\n          }\n        }\n\n        return d;\n      };\n    })();\n\n    var S = function () {\n      return /\\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g;\n    };\n\n    var C = function (a, b) {\n      if (!b) return 0;\n\n      for (var c = a.getTime(), e = 0, f = b.length; e < f; e++) if (a = b[e].start, null === a || c >= a) return e;\n\n      return 0;\n    };\n\n    var K = function (a, b, c, e) {\n      a = a.getFullYear();\n      !e && b.eras && (a -= b.eras[c].offset);\n      return a;\n    };\n\n    (function () {\n      var a = function (a, b) {\n        if (100 > b) {\n          var d = new Date(),\n              c = C(d);\n          d = K(d, a, c);\n          a = a.twoDigitYearMax;\n          a = \"string\" === typeof a ? new Date().getFullYear() % 100 + parseInt(a, 10) : a;\n          b += d - d % 100;\n          b > a && (b -= 100);\n        }\n\n        return b;\n      };\n\n      var b = function (a, b, c) {\n        var d = a.days,\n            e = a._upperDays;\n        e || (a._upperDays = e = [g(d.names), g(d.namesAbbr), g(d.namesShort)]);\n        b = h(b);\n        c ? (a = w(e[1], b), -1 === a && (a = w(e[2], b))) : a = w(e[0], b);\n        return a;\n      };\n\n      var c = function (a, b, c) {\n        var d = a.months,\n            e = a.monthsGenitive || a.months,\n            f = a._upperMonths,\n            l = a._upperMonthsGen;\n        f || (a._upperMonths = f = [g(d.names), g(d.namesAbbr)], a._upperMonthsGen = l = [g(e.names), g(e.namesAbbr)]);\n        b = h(b);\n        a = w(c ? f[1] : f[0], b);\n        0 > a && (a = w(c ? l[1] : l[0], b));\n        return a;\n      };\n\n      var e = function (a, b) {\n        var d = a._parseRegExp;\n\n        if (d) {\n          var c = d[b];\n          if (c) return c;\n        } else a._parseRegExp = d = {};\n\n        c = P(a, b).replace(/([\\^\\$\\.\\*\\+\\?\\|\\[\\]\\(\\)\\{\\}])/g, \"\\\\\\\\$1\");\n\n        for (var e = [\"^\"], f = [], g = 0, l = 0, h = S(), k; null !== (k = h.exec(c));) {\n          var n = c.slice(g, k.index);\n          g = h.lastIndex;\n          l += J(n, e);\n          if (l % 2) e.push(k[0]);else {\n            n = k[0];\n            var y = n.length;\n\n            switch (n) {\n              case \"dddd\":\n              case \"ddd\":\n              case \"MMMM\":\n              case \"MMM\":\n              case \"gg\":\n              case \"g\":\n                n = \"(\\\\D+)\";\n                break;\n\n              case \"tt\":\n              case \"t\":\n                n = \"(\\\\D*)\";\n                break;\n\n              case \"yyyy\":\n              case \"fff\":\n              case \"ff\":\n              case \"f\":\n                n = \"(\\\\d{\" + y + \"})\";\n                break;\n\n              case \"dd\":\n              case \"d\":\n              case \"MM\":\n              case \"M\":\n              case \"yy\":\n              case \"y\":\n              case \"HH\":\n              case \"H\":\n              case \"hh\":\n              case \"h\":\n              case \"mm\":\n              case \"m\":\n              case \"ss\":\n              case \"s\":\n                n = \"(\\\\d\\\\d?)\";\n                break;\n\n              case \"zzz\":\n                n = \"([+-]?\\\\d\\\\d?:\\\\d{2})\";\n                break;\n\n              case \"zz\":\n              case \"z\":\n                n = \"([+-]?\\\\d\\\\d?)\";\n                break;\n\n              case \"/\":\n                n = \"(\\\\\" + a[\"/\"] + \")\";\n                break;\n\n              default:\n                throw \"Invalid date format pattern '\" + n + \"'.\";\n            }\n\n            n && e.push(n);\n            f.push(k[0]);\n          }\n        }\n\n        J(c.slice(g), e);\n        e.push(\"$\");\n        a = {\n          regExp: e.join(\"\").replace(/\\s+/g, \"\\\\s+\"),\n          groups: f\n        };\n        return d[b] = a;\n      };\n\n      var f = function (a, b, c) {\n        return a < b || a > c;\n      };\n\n      var h = function (a) {\n        return a.split(\"\\u00a0\").join(\" \").toUpperCase();\n      };\n\n      var g = function (a) {\n        for (var b = [], c = 0, d = a.length; c < d; c++) b[c] = h(a[c]);\n\n        return b;\n      };\n\n      G = function (d, g, h) {\n        d = y(d);\n        h = h.calendar;\n        g = e(h, g);\n        var k = new RegExp(g.regExp).exec(d);\n        if (null === k) return null;\n        var l = g.groups,\n            t = g = d = null,\n            u = null,\n            B = null,\n            q = 0,\n            m = 0,\n            n = 0,\n            w = 0;\n        var x = null;\n\n        for (var z = !1, A = 0, C = l.length; A < C; A++) {\n          var p = k[A + 1];\n\n          if (p) {\n            var r = l[A],\n                D = r.length,\n                v = parseInt(p, 10);\n\n            switch (r) {\n              case \"dd\":\n              case \"d\":\n                u = v;\n                if (f(u, 1, 31)) return null;\n                break;\n\n              case \"MMM\":\n              case \"MMMM\":\n                t = c(h, p, 3 === D);\n                if (f(t, 0, 11)) return null;\n                break;\n\n              case \"M\":\n              case \"MM\":\n                t = v - 1;\n                if (f(t, 0, 11)) return null;\n                break;\n\n              case \"y\":\n              case \"yy\":\n              case \"yyyy\":\n                g = 4 > D ? a(h, v) : v;\n                if (f(g, 0, 9999)) return null;\n                break;\n\n              case \"h\":\n              case \"hh\":\n                q = v;\n                12 === q && (q = 0);\n                if (f(q, 0, 11)) return null;\n                break;\n\n              case \"H\":\n              case \"HH\":\n                q = v;\n                if (f(q, 0, 23)) return null;\n                break;\n\n              case \"m\":\n              case \"mm\":\n                m = v;\n                if (f(m, 0, 59)) return null;\n                break;\n\n              case \"s\":\n              case \"ss\":\n                n = v;\n                if (f(n, 0, 59)) return null;\n                break;\n\n              case \"tt\":\n              case \"t\":\n                z = h.PM && (p === h.PM[0] || p === h.PM[1] || p === h.PM[2]);\n                if (!z && (!h.AM || p !== h.AM[0] && p !== h.AM[1] && p !== h.AM[2])) return null;\n                break;\n\n              case \"f\":\n              case \"ff\":\n              case \"fff\":\n                w = v * Math.pow(10, 3 - D);\n                if (f(w, 0, 999)) return null;\n                break;\n\n              case \"ddd\":\n              case \"dddd\":\n                B = b(h, p, 3 === D);\n                if (f(B, 0, 6)) return null;\n                break;\n\n              case \"zzz\":\n                r = p.split(/:/);\n                if (2 !== r.length) return null;\n                x = parseInt(r[0], 10);\n                if (f(x, -12, 13)) return null;\n                r = parseInt(r[1], 10);\n                if (f(r, 0, 59)) return null;\n                x = 60 * x + (E(p, \"-\") ? -r : r);\n                break;\n\n              case \"z\":\n              case \"zz\":\n                x = v;\n                if (f(x, -12, 13)) return null;\n                x *= 60;\n                break;\n\n              case \"g\":\n              case \"gg\":\n                if (!p || !h.eras) return null;\n                p = y(p.toLowerCase());\n                r = 0;\n\n                for (D = h.eras.length; r < D; r++) if (p === h.eras[r].name.toLowerCase()) {\n                  d = r;\n                  break;\n                }\n\n                if (null === d) return null;\n            }\n          }\n        }\n\n        k = new Date();\n        l = (A = h.convert) ? A.fromGregorian(k)[0] : k.getFullYear();\n        null === g ? g = l : h.eras && (g += h.eras[d || 0].offset);\n        null === t && (t = 0);\n        null === u && (u = 1);\n\n        if (A) {\n          if (k = A.toGregorian(g, t, u), null === k) return null;\n        } else if (k.setFullYear(g, t, u), k.getDate() !== u || null !== B && k.getDay() !== B) return null;\n\n        z && 12 > q && (q += 12);\n        k.setHours(q, m, n, w);\n        null !== x && (h = k.getMinutes() - (x + k.getTimezoneOffset()), k.setHours(k.getHours() + parseInt(h / 60, 10), h % 60));\n        return k;\n      };\n    })();\n\n    var F = function (a, b, c) {\n      var e = b[\"-\"];\n      b = b[\"+\"];\n      var f;\n\n      switch (c) {\n        case \"n -\":\n          e = \" \" + e, b = \" \" + b;\n\n        case \"n-\":\n          H(a, e) ? f = [\"-\", a.substr(0, a.length - e.length)] : H(a, b) && (f = [\"+\", a.substr(0, a.length - b.length)]);\n          break;\n\n        case \"- n\":\n          e += \" \", b += \" \";\n\n        case \"-n\":\n          E(a, e) ? f = [\"-\", a.substr(e.length)] : E(a, b) && (f = [\"+\", a.substr(b.length)]);\n          break;\n\n        case \"(n)\":\n          E(a, \"(\") && H(a, \")\") && (f = [\"-\", a.substr(1, a.length - 2)]);\n      }\n\n      return f || [\"\", a];\n    };\n\n    k.prototype.findClosestCulture = function (a) {\n      return k.findClosestCulture.call(this, a);\n    };\n\n    k.prototype.format = function (a, b, c) {\n      return k.format.call(this, a, b, c);\n    };\n\n    k.prototype.localize = function (a, b) {\n      return k.localize.call(this, a, b);\n    };\n\n    k.prototype.parseInt = function (a, b, c) {\n      return k.parseInt.call(this, a, b, c);\n    };\n\n    k.prototype.parseFloat = function (a, b, c) {\n      return k.parseFloat.call(this, a, b, c);\n    };\n\n    k.prototype.culture = function (a) {\n      return k.culture.call(this, a);\n    };\n\n    k.addCultureInfo = function (a, b, c) {\n      var e = !1;\n      \"string\" !== typeof a ? (c = a, a = this.culture().name, b = this.cultures[a]) : \"string\" !== typeof b ? (c = b, e = null == this.cultures[a], b = this.cultures[a] || this.cultures[\"default\"]) : (e = !0, b = this.cultures[b]);\n      this.cultures[a] = N(!0, {}, b, c);\n      e && (this.cultures[a].calendar = this.cultures[a].calendars.standard);\n    };\n\n    k.findClosestCulture = function (a) {\n      var b;\n      if (!a) return this.cultures[this.cultureSelector] || this.cultures[\"default\"];\n      \"string\" === typeof a && (a = a.split(\",\"));\n\n      if (I(a)) {\n        var c = this.cultures,\n            e = a,\n            f,\n            h = e.length,\n            g = [];\n\n        for (f = 0; f < h; f++) {\n          a = y(e[f]);\n          a = a.split(\";\");\n          var d = y(a[0]);\n          1 === a.length ? a = 1 : (a = y(a[1]), 0 === a.indexOf(\"q=\") ? (a = a.substr(2), a = parseFloat(a), a = isNaN(a) ? 0 : a) : a = 1);\n          g.push({\n            lang: d,\n            pri: a\n          });\n        }\n\n        g.sort(function (a, b) {\n          return a.pri < b.pri ? 1 : -1;\n        });\n\n        for (f = 0; f < h; f++) if (d = g[f].lang, b = c[d]) return b;\n\n        for (f = 0; f < h; f++) {\n          d = g[f].lang;\n\n          do {\n            e = d.lastIndexOf(\"-\");\n            if (-1 === e) break;\n            d = d.substr(0, e);\n            if (b = c[d]) return b;\n          } while (1);\n        }\n\n        for (f = 0; f < h; f++) {\n          d = g[f].lang;\n\n          for (var k in c) if (e = c[k], e.language == d) return e;\n        }\n      } else if (\"object\" === typeof a) return a;\n\n      return b || null;\n    };\n\n    k.format = function (a, b, c) {\n      culture = this.findClosestCulture(c);\n      a instanceof Date ? a = Q(a, b, culture) : \"number\" === typeof a && (a = L(a, b, culture));\n      return a;\n    };\n\n    k.localize = function (a, b) {\n      return this.findClosestCulture(b).messages[a] || this.cultures[\"default\"].messages[a];\n    };\n\n    k.parseDate = function (a, b, c) {\n      c = this.findClosestCulture(c);\n      var e;\n\n      if (b) {\n        if (\"string\" === typeof b && (b = [b]), b.length) {\n          var f = 0;\n\n          for (var h = b.length; f < h; f++) {\n            var g = b[f];\n            if (g && (e = G(a, g, c))) break;\n          }\n        }\n      } else for (f in b = c.calendar.patterns, b) if (e = G(a, b[f], c)) break;\n\n      return e || null;\n    };\n\n    k.parseInt = function (a, b, c) {\n      return O(k.parseFloat(a, b, c));\n    };\n\n    k.parseFloat = function (a, b, c) {\n      \"number\" !== typeof b && (c = b, b = 10);\n      var e = this.findClosestCulture(c);\n      c = NaN;\n      var f = e.numberFormat;\n      -1 < a.indexOf(e.numberFormat.currency.symbol) && (a = a.replace(e.numberFormat.currency.symbol, \"\"), a = a.replace(e.numberFormat.currency[\".\"], e.numberFormat[\".\"]));\n      a = y(a);\n      if (W.test(a)) c = parseFloat(a);else if (!b && V.test(a)) c = parseInt(a, 16);else {\n        e = F(a, f, f.pattern[0]);\n        b = e[0];\n        e = e[1];\n        \"\" === b && \"(n)\" !== f.pattern[0] && (e = F(a, f, \"(n)\"), b = e[0], e = e[1]);\n        \"\" === b && \"-n\" !== f.pattern[0] && (e = F(a, f, \"-n\"), b = e[0], e = e[1]);\n        b = b || \"+\";\n        a = e.indexOf(\"e\");\n        0 > a && (a = e.indexOf(\"E\"));\n\n        if (0 > a) {\n          var h = e;\n          a = null;\n        } else h = e.substr(0, a), a = e.substr(a + 1);\n\n        var g = f[\".\"],\n            d = h.indexOf(g);\n        0 > d ? (e = h, h = null) : (e = h.substr(0, d), h = h.substr(d + g.length));\n        g = f[\",\"];\n        e = e.split(g).join(\"\");\n        d = g.replace(/\\u00A0/g, \" \");\n        g !== d && (e = e.split(d).join(\"\"));\n        b += e;\n        null !== h && (b += \".\" + h);\n        null !== a && (f = F(a, f, \"-n\"), b += \"e\" + (f[0] || \"+\") + f[1]);\n        X.test(b) && (c = parseFloat(b));\n      }\n      return c;\n    };\n\n    k.culture = function (a) {\n      \"undefined\" !== typeof a && (this.cultureSelector = a);\n      return this.findClosestCulture(a) || this.culture[\"default\"];\n    };\n  })(this);\n\n  window.Globalize = module.exports;\n}).call(window);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvZ2xvYmFsaXplL2dsb2JhbGl6ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3d3dy9qcy0zLjIuMi9nbG9iYWxpemUvZ2xvYmFsaXplLmpzP2FkZDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xuKGZ1bmN0aW9uKCkge1xuXG4vKlxuIEdsb2JhbGl6ZVxuXG4gaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxuXG4gQ29weXJpZ2h0IFNvZnR3YXJlIEZyZWVkb20gQ29uc2VydmFuY3ksIEluYy5cbiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4qL1xuKGZ1bmN0aW9uKFQsVSl7dmFyIEwsRzt2YXIgaz1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGsucHJvdG90eXBlLmluaXQoYSl9O1widW5kZWZpbmVkXCIhPT10eXBlb2YgcmVxdWlyZSYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1rOlQuR2xvYmFsaXplPWs7ay5jdWx0dXJlcz17fTtrLnByb3RvdHlwZT17Y29uc3RydWN0b3I6ayxpbml0OmZ1bmN0aW9uKGEpe3RoaXMuY3VsdHVyZXM9ay5jdWx0dXJlczt0aGlzLmN1bHR1cmVTZWxlY3Rvcj1hO3JldHVybiB0aGlzfX07ay5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGU9ay5wcm90b3R5cGU7ay5jdWx0dXJlc1tcImRlZmF1bHRcIl09e25hbWU6XCJlblwiLGVuZ2xpc2hOYW1lOlwiRW5nbGlzaFwiLG5hdGl2ZU5hbWU6XCJFbmdsaXNoXCIsaXNSVEw6ITEsbGFuZ3VhZ2U6XCJlblwiLG51bWJlckZvcm1hdDp7cGF0dGVybjpbXCItblwiXSxkZWNpbWFsczoyLFwiLFwiOlwiLFwiLFwiLlwiOlwiLlwiLFxuICAgICAgICBncm91cFNpemVzOlszXSxcIitcIjpcIitcIixcIi1cIjpcIi1cIixOYU46XCJOYU5cIixuZWdhdGl2ZUluZmluaXR5OlwiLUluZmluaXR5XCIscG9zaXRpdmVJbmZpbml0eTpcIkluZmluaXR5XCIscGVyY2VudDp7cGF0dGVybjpbXCItbiAlXCIsXCJuICVcIl0sZGVjaW1hbHM6Mixncm91cFNpemVzOlszXSxcIixcIjpcIixcIixcIi5cIjpcIi5cIixzeW1ib2w6XCIlXCJ9LGN1cnJlbmN5OntwYXR0ZXJuOltcIigkbilcIixcIiRuXCJdLGRlY2ltYWxzOjIsZ3JvdXBTaXplczpbM10sXCIsXCI6XCIsXCIsXCIuXCI6XCIuXCIsc3ltYm9sOlwiJFwifX0sY2FsZW5kYXJzOntzdGFuZGFyZDp7bmFtZTpcIkdyZWdvcmlhbl9VU0VuZ2xpc2hcIixcIi9cIjpcIi9cIixcIjpcIjpcIjpcIixmaXJzdERheTowLGRheXM6e25hbWVzOlwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksbmFtZXNBYmJyOlwiU3VuIE1vbiBUdWUgV2VkIFRodSBGcmkgU2F0XCIuc3BsaXQoXCIgXCIpLG5hbWVzU2hvcnQ6XCJTdSBNbyBUdSBXZSBUaCBGciBTYVwiLnNwbGl0KFwiIFwiKX0sXG4gICAgICAgICAgICBtb250aHM6e25hbWVzOlwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlciBcIi5zcGxpdChcIiBcIiksbmFtZXNBYmJyOlwiSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWMgXCIuc3BsaXQoXCIgXCIpfSxBTTpbXCJBTVwiLFwiYW1cIixcIkFNXCJdLFBNOltcIlBNXCIsXCJwbVwiLFwiUE1cIl0sZXJhczpbe25hbWU6XCJBLkQuXCIsc3RhcnQ6bnVsbCxvZmZzZXQ6MH1dLHR3b0RpZ2l0WWVhck1heDoyMDI5LHBhdHRlcm5zOntkOlwiTS9kL3l5eXlcIixEOlwiZGRkZCwgTU1NTSBkZCwgeXl5eVwiLHQ6XCJoOm1tIHR0XCIsVDpcImg6bW06c3MgdHRcIixmOlwiZGRkZCwgTU1NTSBkZCwgeXl5eSBoOm1tIHR0XCIsRjpcImRkZGQsIE1NTU0gZGQsIHl5eXkgaDptbTpzcyB0dFwiLE06XCJNTU1NIGRkXCIsWTpcInl5eXkgTU1NTVwiLFM6XCJ5eXl5Jy0nTU0nLSdkZCdUJ0hIJzonbW0nOidzc1wifX19LG1lc3NhZ2VzOnt9fTtcbiAgICBrLmN1bHR1cmVzW1wiZGVmYXVsdFwiXS5jYWxlbmRhcj1rLmN1bHR1cmVzW1wiZGVmYXVsdFwiXS5jYWxlbmRhcnMuc3RhbmRhcmQ7ay5jdWx0dXJlcy5lbj1rLmN1bHR1cmVzW1wiZGVmYXVsdFwiXTtrLmN1bHR1cmVTZWxlY3Rvcj1cImVuXCI7dmFyIFY9L14weFthLWYwLTldKyQvaTt2YXIgVz0vXlsrLV0/aW5maW5pdHkkL2k7dmFyIFg9L15bKy1dP1xcZCpcXC4/XFxkKihlWystXT9cXGQrKT8kLzt2YXIgWT0vXlxccyt8XFxzKyQvZzt2YXIgdz1mdW5jdGlvbihhLGIpe2lmKGEuaW5kZXhPZilyZXR1cm4gYS5pbmRleE9mKGIpO2Zvcih2YXIgYz0wLGU9YS5sZW5ndGg7YzxlO2MrKylpZihhW2NdPT09YilyZXR1cm4gYztyZXR1cm4tMX07dmFyIEg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5zdWJzdHIoYS5sZW5ndGgtYi5sZW5ndGgpPT09Yn07dmFyIE49ZnVuY3Rpb24oYSl7dmFyIGIsYyxlLGY9YXJndW1lbnRzWzBdfHx7fSxoPTEsZz1hcmd1bWVudHMubGVuZ3RoO2E9ITE7XCJib29sZWFuXCI9PT10eXBlb2YgZiYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYT1mLGY9YXJndW1lbnRzWzFdfHx7fSxoPTIpO2ZvcihcIm9iamVjdFwiPT09dHlwZW9mIGZ8fFooZil8fChmPXt9KTtoPGc7aCsrKWlmKG51bGwhPShiPWFyZ3VtZW50c1toXSkpZm9yKGMgaW4gYil7dmFyIGQ9ZltjXTt2YXIgbD1iW2NdO2YhPT1sJiYoYSYmbCYmKE0obCl8fChlPUkobCkpKT8oZT8oZT0hMSxkPWQmJkkoZCk/ZDpbXSk6ZD1kJiZNKGQpP2Q6e30sZltjXT1OKGEsZCxsKSk6bCE9PVUmJihmW2NdPWwpKX1yZXR1cm4gZn07dmFyIEk9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oYSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpfTt2YXIgWj1mdW5jdGlvbihhKXtyZXR1cm5cIltvYmplY3QgRnVuY3Rpb25dXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSl9O3ZhciBNPWZ1bmN0aW9uKGEpe3JldHVyblwiW29iamVjdCBPYmplY3RdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSl9O1xuICAgIHZhciBFPWZ1bmN0aW9uKGEsYil7cmV0dXJuIDA9PT1hLmluZGV4T2YoYil9O3ZhciB5PWZ1bmN0aW9uKGEpe3JldHVybihhK1wiXCIpLnJlcGxhY2UoWSxcIlwiKX07dmFyIE89ZnVuY3Rpb24oYSl7cmV0dXJuIGlzTmFOKGEpP05hTjphfDB9O3ZhciB6PWZ1bmN0aW9uKGEsYixjKXt2YXIgZTtmb3IoZT1hLmxlbmd0aDtlPGI7ZSs9MSlhPWM/XCIwXCIrYTphK1wiMFwiO3JldHVybiBhfTt2YXIgSj1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGU9ITEsZj0wLGg9YS5sZW5ndGg7ZjxoO2YrKyl7dmFyIGc9YS5jaGFyQXQoZik7c3dpdGNoKGcpe2Nhc2UgXCInXCI6ZT9iLnB1c2goXCInXCIpOmMrKztlPSExO2JyZWFrO2Nhc2UgXCJcXFxcXCI6ZSYmYi5wdXNoKFwiXFxcXFwiKTtlPSFlO2JyZWFrO2RlZmF1bHQ6Yi5wdXNoKGcpLGU9ITF9fXJldHVybiBjfTt2YXIgUD1mdW5jdGlvbihhLGIpe2I9Ynx8XCJGXCI7YT1hLnBhdHRlcm5zO3ZhciBjPWIubGVuZ3RoO2lmKDE9PT1jKXthPWFbYl07aWYoIWEpdGhyb3dcIkludmFsaWQgZGF0ZSBmb3JtYXQgc3RyaW5nICdcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiK1wiJy5cIjtiPWF9ZWxzZSAyPT09YyYmXCIlXCI9PT1iLmNoYXJBdCgwKSYmKGI9Yi5jaGFyQXQoMSkpO3JldHVybiBifTt2YXIgUT1mdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZShhLGQpe2ErPVwiXCI7cmV0dXJuIDE8ZCYmYS5sZW5ndGg8ZD8oYT1hYVtkLTJdK2EsYS5zdWJzdHIoYS5sZW5ndGgtZCxkKSk6YX1mdW5jdGlvbiBmKCl7aWYobnx8aylyZXR1cm4gbjtuPXQudGVzdChiKTtrPSEwO3JldHVybiBufWZ1bmN0aW9uIGgoYSxkKXtpZihxKXJldHVybiBxW2RdO3N3aXRjaChkKXtjYXNlIDA6cmV0dXJuIGEuZ2V0RnVsbFllYXIoKTtjYXNlIDE6cmV0dXJuIGEuZ2V0TW9udGgoKTtjYXNlIDI6cmV0dXJuIGEuZ2V0RGF0ZSgpfX12YXIgZz1jLmNhbGVuZGFyLGQ9Zy5jb252ZXJ0O2lmKCFifHwhYi5sZW5ndGh8fFwiaVwiPT09Yil7aWYoYyYmYy5uYW1lLmxlbmd0aClpZihkKWM9UShhLGcucGF0dGVybnMuRixjKTtlbHNle2M9bmV3IERhdGUoYS5nZXRUaW1lKCkpO3ZhciBsPUMoYSxnLmVyYXMpO1xuICAgICAgICBjLnNldEZ1bGxZZWFyKEsoYSxnLGwpKTtjPWMudG9Mb2NhbGVTdHJpbmcoKX1lbHNlIGM9YS50b1N0cmluZygpO3JldHVybiBjfWw9Zy5lcmFzO3ZhciBSPVwic1wiPT09YjtiPVAoZyxiKTtjPVtdO3ZhciBhYT1bXCIwXCIsXCIwMFwiLFwiMDAwXCJdLGssdD0vKFteZF18XikoZHxkZCkoW15kXXwkKS9nLHU9MCxCPVMoKSxxO2ZvcighUiYmZCYmKHE9ZC5mcm9tR3JlZ29yaWFuKGEpKTs7KXt2YXIgbT1CLmxhc3RJbmRleDtkPUIuZXhlYyhiKTttPWIuc2xpY2UobSxkP2QuaW5kZXg6Yi5sZW5ndGgpO3UrPUoobSxjKTtpZighZClicmVhaztpZih1JTIpYy5wdXNoKGRbMF0pO2Vsc2Ugc3dpdGNoKG09ZFswXSxkPW0ubGVuZ3RoLG0pe2Nhc2UgXCJkZGRcIjpjYXNlIFwiZGRkZFwiOmMucHVzaCgoMz09PWQ/Zy5kYXlzLm5hbWVzQWJicjpnLmRheXMubmFtZXMpW2EuZ2V0RGF5KCldKTticmVhaztjYXNlIFwiZFwiOmNhc2UgXCJkZFwiOnZhciBuPSEwO2MucHVzaChlKGgoYSwyKSxkKSk7YnJlYWs7Y2FzZSBcIk1NTVwiOmNhc2UgXCJNTU1NXCI6bT1cbiAgICAgICAgaChhLDEpO2MucHVzaChnLm1vbnRoc0dlbml0aXZlJiZmKCk/Zy5tb250aHNHZW5pdGl2ZVszPT09ZD9cIm5hbWVzQWJiclwiOlwibmFtZXNcIl1bbV06Zy5tb250aHNbMz09PWQ/XCJuYW1lc0FiYnJcIjpcIm5hbWVzXCJdW21dKTticmVhaztjYXNlIFwiTVwiOmNhc2UgXCJNTVwiOmMucHVzaChlKGgoYSwxKSsxLGQpKTticmVhaztjYXNlIFwieVwiOmNhc2UgXCJ5eVwiOmNhc2UgXCJ5eXl5XCI6bT1xP3FbMF06SyhhLGcsQyhhLGwpLFIpOzQ+ZCYmKG0lPTEwMCk7Yy5wdXNoKGUobSxkKSk7YnJlYWs7Y2FzZSBcImhcIjpjYXNlIFwiaGhcIjptPWEuZ2V0SG91cnMoKSUxMjswPT09bSYmKG09MTIpO2MucHVzaChlKG0sZCkpO2JyZWFrO2Nhc2UgXCJIXCI6Y2FzZSBcIkhIXCI6Yy5wdXNoKGUoYS5nZXRIb3VycygpLGQpKTticmVhaztjYXNlIFwibVwiOmNhc2UgXCJtbVwiOmMucHVzaChlKGEuZ2V0TWludXRlcygpLGQpKTticmVhaztjYXNlIFwic1wiOmNhc2UgXCJzc1wiOmMucHVzaChlKGEuZ2V0U2Vjb25kcygpLGQpKTticmVhaztjYXNlIFwidFwiOmNhc2UgXCJ0dFwiOm09XG4gICAgICAgIDEyPmEuZ2V0SG91cnMoKT9nLkFNP2cuQU1bMF06XCIgXCI6Zy5QTT9nLlBNWzBdOlwiIFwiO2MucHVzaCgxPT09ZD9tLmNoYXJBdCgwKTptKTticmVhaztjYXNlIFwiZlwiOmNhc2UgXCJmZlwiOmNhc2UgXCJmZmZcIjpjLnB1c2goZShhLmdldE1pbGxpc2Vjb25kcygpLDMpLnN1YnN0cigwLGQpKTticmVhaztjYXNlIFwielwiOmNhc2UgXCJ6elwiOm09YS5nZXRUaW1lem9uZU9mZnNldCgpLzYwO2MucHVzaCgoMD49bT9cIitcIjpcIi1cIikrZShNYXRoLmZsb29yKE1hdGguYWJzKG0pKSxkKSk7YnJlYWs7Y2FzZSBcInp6elwiOm09YS5nZXRUaW1lem9uZU9mZnNldCgpLzYwO2MucHVzaCgoMD49bT9cIitcIjpcIi1cIikrZShNYXRoLmZsb29yKE1hdGguYWJzKG0pKSwyKStcIjpcIitlKE1hdGguYWJzKGEuZ2V0VGltZXpvbmVPZmZzZXQoKSU2MCksMikpO2JyZWFrO2Nhc2UgXCJnXCI6Y2FzZSBcImdnXCI6Zy5lcmFzJiZjLnB1c2goZy5lcmFzW0MoYSxsKV0ubmFtZSk7YnJlYWs7Y2FzZSBcIi9cIjpjLnB1c2goZ1tcIi9cIl0pO2JyZWFrO2RlZmF1bHQ6dGhyb3dcIkludmFsaWQgZGF0ZSBmb3JtYXQgcGF0dGVybiAnXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0rXCInLlwiO319cmV0dXJuIGMuam9pbihcIlwiKX07KGZ1bmN0aW9uKCl7dmFyIGE9ZnVuY3Rpb24oYSxjLGUpe3ZhciBiPWUuZ3JvdXBTaXplcyxoPWJbMF0sZz0xLGQ9TWF0aC5wb3coMTAsYyk7ZD1NYXRoLnJvdW5kKGEqZCkvZDtpc0Zpbml0ZShkKXx8KGQ9YSk7ZD0oZCtcIlwiKS5zcGxpdCgvZS9pKTt2YXIgbD0xPGQubGVuZ3RoP3BhcnNlSW50KGRbMV0sMTApOjA7YT1kWzBdO2Q9YS5zcGxpdChcIi5cIik7YT1kWzBdO2Q9MTxkLmxlbmd0aD9kWzFdOlwiXCI7MDxsPyhkPXooZCxsLCExKSxhKz1kLnNsaWNlKDAsbCksZD1kLnN1YnN0cihsKSk6MD5sJiYobD0tbCxhPXooYSxsKzEpLGQ9YS5zbGljZSgtbCxhLmxlbmd0aCkrZCxhPWEuc2xpY2UoMCwtbCkpO2Q9MDxjP2VbXCIuXCJdKyhkLmxlbmd0aD5jP2Quc2xpY2UoMCxjKTp6KGQsYykpOlwiXCI7Yz1hLmxlbmd0aC0xO2U9ZVtcIixcIl07Zm9yKGw9XCJcIjswPD1jOyl7aWYoMD09PWh8fGg+YylyZXR1cm4gYS5zbGljZSgwLGMrMSkrKGwubGVuZ3RoP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUrbCtkOmQpO2w9YS5zbGljZShjLWgrMSxjKzEpKyhsLmxlbmd0aD9lK2w6XCJcIik7Yy09aDtnPGIubGVuZ3RoJiYoaD1iW2ddLGcrKyl9cmV0dXJuIGEuc2xpY2UoMCxjKzEpK2UrbCtkfTtMPWZ1bmN0aW9uKGIsYyxlKXtpZighaXNGaW5pdGUoYikpcmV0dXJuIEluZmluaXR5PT09Yj9lLm51bWJlckZvcm1hdC5wb3NpdGl2ZUluZmluaXR5Oi1JbmZpbml0eT09PWI/ZS5udW1iZXJGb3JtYXQubmVnYXRpdmVJbmZpbml0eTplLm51bWJlckZvcm1hdC5OYU47aWYoIWN8fFwiaVwiPT09YylyZXR1cm4gZS5uYW1lLmxlbmd0aD9iLnRvTG9jYWxlU3RyaW5nKCk6Yi50b1N0cmluZygpO2M9Y3x8XCJEXCI7ZT1lLm51bWJlckZvcm1hdDt2YXIgZj1NYXRoLmFicyhiKSxoPS0xOzE8Yy5sZW5ndGgmJihoPXBhcnNlSW50KGMuc2xpY2UoMSksMTApKTt2YXIgZz1jLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO3N3aXRjaChnKXtjYXNlIFwiRFwiOmM9XCJuXCI7Zj1PKGYpOy0xIT09aCYmKGY9eihcIlwiK2YsaCwhMCkpO1xuICAgICAgICAwPmImJihmPVwiLVwiK2YpO2JyZWFrO2Nhc2UgXCJOXCI6dmFyIGQ9ZTtjYXNlIFwiQ1wiOmQ9ZHx8ZS5jdXJyZW5jeTtjYXNlIFwiUFwiOmQ9ZHx8ZS5wZXJjZW50O2M9MD5iP2QucGF0dGVyblswXTpkLnBhdHRlcm5bMV18fFwiblwiOy0xPT09aCYmKGg9ZC5kZWNpbWFscyk7Zj1hKGYqKFwiUFwiPT09Zz8xMDA6MSksaCxkKTticmVhaztkZWZhdWx0OnRocm93XCJCYWQgbnVtYmVyIGZvcm1hdCBzcGVjaWZpZXI6IFwiK2c7fWI9L258XFwkfC18JS9nO2ZvcihkPVwiXCI7Oyl7aD1iLmxhc3RJbmRleDtnPWIuZXhlYyhjKTtkKz1jLnNsaWNlKGgsZz9nLmluZGV4OmMubGVuZ3RoKTtpZighZylicmVhaztzd2l0Y2goZ1swXSl7Y2FzZSBcIm5cIjpkKz1mO2JyZWFrO2Nhc2UgXCIkXCI6ZCs9ZS5jdXJyZW5jeS5zeW1ib2w7YnJlYWs7Y2FzZSBcIi1cIjovWzEtOV0vLnRlc3QoZikmJihkKz1lW1wiLVwiXSk7YnJlYWs7Y2FzZSBcIiVcIjpkKz1lLnBlcmNlbnQuc3ltYm9sfX1yZXR1cm4gZH19KSgpO3ZhciBTPWZ1bmN0aW9uKCl7cmV0dXJuL1xcL3xkZGRkfGRkZHxkZHxkfE1NTU18TU1NfE1NfE18eXl5eXx5eXx5fGhofGh8SEh8SHxtbXxtfHNzfHN8dHR8dHxmZmZ8ZmZ8Znx6enp8enp8enxnZ3xnL2d9O1xuICAgIHZhciBDPWZ1bmN0aW9uKGEsYil7aWYoIWIpcmV0dXJuIDA7Zm9yKHZhciBjPWEuZ2V0VGltZSgpLGU9MCxmPWIubGVuZ3RoO2U8ZjtlKyspaWYoYT1iW2VdLnN0YXJ0LG51bGw9PT1hfHxjPj1hKXJldHVybiBlO3JldHVybiAwfTt2YXIgSz1mdW5jdGlvbihhLGIsYyxlKXthPWEuZ2V0RnVsbFllYXIoKTshZSYmYi5lcmFzJiYoYS09Yi5lcmFzW2NdLm9mZnNldCk7cmV0dXJuIGF9OyhmdW5jdGlvbigpe3ZhciBhPWZ1bmN0aW9uKGEsYil7aWYoMTAwPmIpe3ZhciBkPW5ldyBEYXRlLGM9QyhkKTtkPUsoZCxhLGMpO2E9YS50d29EaWdpdFllYXJNYXg7YT1cInN0cmluZ1wiPT09dHlwZW9mIGE/KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpJTEwMCtwYXJzZUludChhLDEwKTphO2IrPWQtZCUxMDA7Yj5hJiYoYi09MTAwKX1yZXR1cm4gYn07dmFyIGI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEuZGF5cyxlPWEuX3VwcGVyRGF5cztlfHwoYS5fdXBwZXJEYXlzPWU9W2coZC5uYW1lcyksZyhkLm5hbWVzQWJiciksXG4gICAgICAgIGcoZC5uYW1lc1Nob3J0KV0pO2I9aChiKTtjPyhhPXcoZVsxXSxiKSwtMT09PWEmJihhPXcoZVsyXSxiKSkpOmE9dyhlWzBdLGIpO3JldHVybiBhfTt2YXIgYz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5tb250aHMsZT1hLm1vbnRoc0dlbml0aXZlfHxhLm1vbnRocyxmPWEuX3VwcGVyTW9udGhzLGw9YS5fdXBwZXJNb250aHNHZW47Znx8KGEuX3VwcGVyTW9udGhzPWY9W2coZC5uYW1lcyksZyhkLm5hbWVzQWJicildLGEuX3VwcGVyTW9udGhzR2VuPWw9W2coZS5uYW1lcyksZyhlLm5hbWVzQWJicildKTtiPWgoYik7YT13KGM/ZlsxXTpmWzBdLGIpOzA+YSYmKGE9dyhjP2xbMV06bFswXSxiKSk7cmV0dXJuIGF9O3ZhciBlPWZ1bmN0aW9uKGEsYil7dmFyIGQ9YS5fcGFyc2VSZWdFeHA7aWYoZCl7dmFyIGM9ZFtiXTtpZihjKXJldHVybiBjfWVsc2UgYS5fcGFyc2VSZWdFeHA9ZD17fTtjPVAoYSxiKS5yZXBsYWNlKC8oW1xcXlxcJFxcLlxcKlxcK1xcP1xcfFxcW1xcXVxcKFxcKVxce1xcfV0pL2csXCJcXFxcXFxcXCQxXCIpO1xuICAgICAgICBmb3IodmFyIGU9W1wiXlwiXSxmPVtdLGc9MCxsPTAsaD1TKCksaztudWxsIT09KGs9aC5leGVjKGMpKTspe3ZhciBuPWMuc2xpY2UoZyxrLmluZGV4KTtnPWgubGFzdEluZGV4O2wrPUoobixlKTtpZihsJTIpZS5wdXNoKGtbMF0pO2Vsc2V7bj1rWzBdO3ZhciB5PW4ubGVuZ3RoO3N3aXRjaChuKXtjYXNlIFwiZGRkZFwiOmNhc2UgXCJkZGRcIjpjYXNlIFwiTU1NTVwiOmNhc2UgXCJNTU1cIjpjYXNlIFwiZ2dcIjpjYXNlIFwiZ1wiOm49XCIoXFxcXEQrKVwiO2JyZWFrO2Nhc2UgXCJ0dFwiOmNhc2UgXCJ0XCI6bj1cIihcXFxcRCopXCI7YnJlYWs7Y2FzZSBcInl5eXlcIjpjYXNlIFwiZmZmXCI6Y2FzZSBcImZmXCI6Y2FzZSBcImZcIjpuPVwiKFxcXFxke1wiK3krXCJ9KVwiO2JyZWFrO2Nhc2UgXCJkZFwiOmNhc2UgXCJkXCI6Y2FzZSBcIk1NXCI6Y2FzZSBcIk1cIjpjYXNlIFwieXlcIjpjYXNlIFwieVwiOmNhc2UgXCJISFwiOmNhc2UgXCJIXCI6Y2FzZSBcImhoXCI6Y2FzZSBcImhcIjpjYXNlIFwibW1cIjpjYXNlIFwibVwiOmNhc2UgXCJzc1wiOmNhc2UgXCJzXCI6bj1cIihcXFxcZFxcXFxkPylcIjticmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ6enpcIjpuPVwiKFsrLV0/XFxcXGRcXFxcZD86XFxcXGR7Mn0pXCI7YnJlYWs7Y2FzZSBcInp6XCI6Y2FzZSBcInpcIjpuPVwiKFsrLV0/XFxcXGRcXFxcZD8pXCI7YnJlYWs7Y2FzZSBcIi9cIjpuPVwiKFxcXFxcIithW1wiL1wiXStcIilcIjticmVhaztkZWZhdWx0OnRocm93XCJJbnZhbGlkIGRhdGUgZm9ybWF0IHBhdHRlcm4gJ1wiK24rXCInLlwiO31uJiZlLnB1c2gobik7Zi5wdXNoKGtbMF0pfX1KKGMuc2xpY2UoZyksZSk7ZS5wdXNoKFwiJFwiKTthPXtyZWdFeHA6ZS5qb2luKFwiXCIpLnJlcGxhY2UoL1xccysvZyxcIlxcXFxzK1wiKSxncm91cHM6Zn07cmV0dXJuIGRbYl09YX07dmFyIGY9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhPGJ8fGE+Y307dmFyIGg9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3BsaXQoXCJcXHUwMGEwXCIpLmpvaW4oXCIgXCIpLnRvVXBwZXJDYXNlKCl9O3ZhciBnPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPTAsZD1hLmxlbmd0aDtjPGQ7YysrKWJbY109aChhW2NdKTtyZXR1cm4gYn07Rz1mdW5jdGlvbihkLGcsaCl7ZD1cbiAgICAgICAgeShkKTtoPWguY2FsZW5kYXI7Zz1lKGgsZyk7dmFyIGs9KG5ldyBSZWdFeHAoZy5yZWdFeHApKS5leGVjKGQpO2lmKG51bGw9PT1rKXJldHVybiBudWxsO3ZhciBsPWcuZ3JvdXBzLHQ9Zz1kPW51bGwsdT1udWxsLEI9bnVsbCxxPTAsbT0wLG49MCx3PTA7dmFyIHg9bnVsbDtmb3IodmFyIHo9ITEsQT0wLEM9bC5sZW5ndGg7QTxDO0ErKyl7dmFyIHA9a1tBKzFdO2lmKHApe3ZhciByPWxbQV0sRD1yLmxlbmd0aCx2PXBhcnNlSW50KHAsMTApO3N3aXRjaChyKXtjYXNlIFwiZGRcIjpjYXNlIFwiZFwiOnU9djtpZihmKHUsMSwzMSkpcmV0dXJuIG51bGw7YnJlYWs7Y2FzZSBcIk1NTVwiOmNhc2UgXCJNTU1NXCI6dD1jKGgscCwzPT09RCk7aWYoZih0LDAsMTEpKXJldHVybiBudWxsO2JyZWFrO2Nhc2UgXCJNXCI6Y2FzZSBcIk1NXCI6dD12LTE7aWYoZih0LDAsMTEpKXJldHVybiBudWxsO2JyZWFrO2Nhc2UgXCJ5XCI6Y2FzZSBcInl5XCI6Y2FzZSBcInl5eXlcIjpnPTQ+RD9hKGgsdik6djtpZihmKGcsMCw5OTk5KSlyZXR1cm4gbnVsbDtcbiAgICAgICAgYnJlYWs7Y2FzZSBcImhcIjpjYXNlIFwiaGhcIjpxPXY7MTI9PT1xJiYocT0wKTtpZihmKHEsMCwxMSkpcmV0dXJuIG51bGw7YnJlYWs7Y2FzZSBcIkhcIjpjYXNlIFwiSEhcIjpxPXY7aWYoZihxLDAsMjMpKXJldHVybiBudWxsO2JyZWFrO2Nhc2UgXCJtXCI6Y2FzZSBcIm1tXCI6bT12O2lmKGYobSwwLDU5KSlyZXR1cm4gbnVsbDticmVhaztjYXNlIFwic1wiOmNhc2UgXCJzc1wiOm49djtpZihmKG4sMCw1OSkpcmV0dXJuIG51bGw7YnJlYWs7Y2FzZSBcInR0XCI6Y2FzZSBcInRcIjp6PWguUE0mJihwPT09aC5QTVswXXx8cD09PWguUE1bMV18fHA9PT1oLlBNWzJdKTtpZigheiYmKCFoLkFNfHxwIT09aC5BTVswXSYmcCE9PWguQU1bMV0mJnAhPT1oLkFNWzJdKSlyZXR1cm4gbnVsbDticmVhaztjYXNlIFwiZlwiOmNhc2UgXCJmZlwiOmNhc2UgXCJmZmZcIjp3PXYqTWF0aC5wb3coMTAsMy1EKTtpZihmKHcsMCw5OTkpKXJldHVybiBudWxsO2JyZWFrO2Nhc2UgXCJkZGRcIjpjYXNlIFwiZGRkZFwiOkI9YihoLHAsMz09PUQpO2lmKGYoQixcbiAgICAgICAgMCw2KSlyZXR1cm4gbnVsbDticmVhaztjYXNlIFwienp6XCI6cj1wLnNwbGl0KC86Lyk7aWYoMiE9PXIubGVuZ3RoKXJldHVybiBudWxsO3g9cGFyc2VJbnQoclswXSwxMCk7aWYoZih4LC0xMiwxMykpcmV0dXJuIG51bGw7cj1wYXJzZUludChyWzFdLDEwKTtpZihmKHIsMCw1OSkpcmV0dXJuIG51bGw7eD02MCp4KyhFKHAsXCItXCIpPy1yOnIpO2JyZWFrO2Nhc2UgXCJ6XCI6Y2FzZSBcInp6XCI6eD12O2lmKGYoeCwtMTIsMTMpKXJldHVybiBudWxsO3gqPTYwO2JyZWFrO2Nhc2UgXCJnXCI6Y2FzZSBcImdnXCI6aWYoIXB8fCFoLmVyYXMpcmV0dXJuIG51bGw7cD15KHAudG9Mb3dlckNhc2UoKSk7cj0wO2ZvcihEPWguZXJhcy5sZW5ndGg7cjxEO3IrKylpZihwPT09aC5lcmFzW3JdLm5hbWUudG9Mb3dlckNhc2UoKSl7ZD1yO2JyZWFrfWlmKG51bGw9PT1kKXJldHVybiBudWxsfX19az1uZXcgRGF0ZTtsPShBPWguY29udmVydCk/QS5mcm9tR3JlZ29yaWFuKGspWzBdOmsuZ2V0RnVsbFllYXIoKTtudWxsPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZz9nPWw6aC5lcmFzJiYoZys9aC5lcmFzW2R8fDBdLm9mZnNldCk7bnVsbD09PXQmJih0PTApO251bGw9PT11JiYodT0xKTtpZihBKXtpZihrPUEudG9HcmVnb3JpYW4oZyx0LHUpLG51bGw9PT1rKXJldHVybiBudWxsfWVsc2UgaWYoay5zZXRGdWxsWWVhcihnLHQsdSksay5nZXREYXRlKCkhPT11fHxudWxsIT09QiYmay5nZXREYXkoKSE9PUIpcmV0dXJuIG51bGw7eiYmMTI+cSYmKHErPTEyKTtrLnNldEhvdXJzKHEsbSxuLHcpO251bGwhPT14JiYoaD1rLmdldE1pbnV0ZXMoKS0oeCtrLmdldFRpbWV6b25lT2Zmc2V0KCkpLGsuc2V0SG91cnMoay5nZXRIb3VycygpK3BhcnNlSW50KGgvNjAsMTApLGglNjApKTtyZXR1cm4ga319KSgpO3ZhciBGPWZ1bmN0aW9uKGEsYixjKXt2YXIgZT1iW1wiLVwiXTtiPWJbXCIrXCJdO3ZhciBmO3N3aXRjaChjKXtjYXNlIFwibiAtXCI6ZT1cIiBcIitlLGI9XCIgXCIrYjtjYXNlIFwibi1cIjpIKGEsZSk/Zj1bXCItXCIsYS5zdWJzdHIoMCxhLmxlbmd0aC1lLmxlbmd0aCldOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSChhLGIpJiYoZj1bXCIrXCIsYS5zdWJzdHIoMCxhLmxlbmd0aC1iLmxlbmd0aCldKTticmVhaztjYXNlIFwiLSBuXCI6ZSs9XCIgXCIsYis9XCIgXCI7Y2FzZSBcIi1uXCI6RShhLGUpP2Y9W1wiLVwiLGEuc3Vic3RyKGUubGVuZ3RoKV06RShhLGIpJiYoZj1bXCIrXCIsYS5zdWJzdHIoYi5sZW5ndGgpXSk7YnJlYWs7Y2FzZSBcIihuKVwiOkUoYSxcIihcIikmJkgoYSxcIilcIikmJihmPVtcIi1cIixhLnN1YnN0cigxLGEubGVuZ3RoLTIpXSl9cmV0dXJuIGZ8fFtcIlwiLGFdfTtrLnByb3RvdHlwZS5maW5kQ2xvc2VzdEN1bHR1cmU9ZnVuY3Rpb24oYSl7cmV0dXJuIGsuZmluZENsb3Nlc3RDdWx0dXJlLmNhbGwodGhpcyxhKX07ay5wcm90b3R5cGUuZm9ybWF0PWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gay5mb3JtYXQuY2FsbCh0aGlzLGEsYixjKX07ay5wcm90b3R5cGUubG9jYWxpemU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gay5sb2NhbGl6ZS5jYWxsKHRoaXMsYSxiKX07ay5wcm90b3R5cGUucGFyc2VJbnQ9ZnVuY3Rpb24oYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIsYyl7cmV0dXJuIGsucGFyc2VJbnQuY2FsbCh0aGlzLGEsYixjKX07ay5wcm90b3R5cGUucGFyc2VGbG9hdD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGsucGFyc2VGbG9hdC5jYWxsKHRoaXMsYSxiLGMpfTtrLnByb3RvdHlwZS5jdWx0dXJlPWZ1bmN0aW9uKGEpe3JldHVybiBrLmN1bHR1cmUuY2FsbCh0aGlzLGEpfTtrLmFkZEN1bHR1cmVJbmZvPWZ1bmN0aW9uKGEsYixjKXt2YXIgZT0hMTtcInN0cmluZ1wiIT09dHlwZW9mIGE/KGM9YSxhPXRoaXMuY3VsdHVyZSgpLm5hbWUsYj10aGlzLmN1bHR1cmVzW2FdKTpcInN0cmluZ1wiIT09dHlwZW9mIGI/KGM9YixlPW51bGw9PXRoaXMuY3VsdHVyZXNbYV0sYj10aGlzLmN1bHR1cmVzW2FdfHx0aGlzLmN1bHR1cmVzW1wiZGVmYXVsdFwiXSk6KGU9ITAsYj10aGlzLmN1bHR1cmVzW2JdKTt0aGlzLmN1bHR1cmVzW2FdPU4oITAse30sYixjKTtlJiYodGhpcy5jdWx0dXJlc1thXS5jYWxlbmRhcj10aGlzLmN1bHR1cmVzW2FdLmNhbGVuZGFycy5zdGFuZGFyZCl9O1xuICAgIGsuZmluZENsb3Nlc3RDdWx0dXJlPWZ1bmN0aW9uKGEpe3ZhciBiO2lmKCFhKXJldHVybiB0aGlzLmN1bHR1cmVzW3RoaXMuY3VsdHVyZVNlbGVjdG9yXXx8dGhpcy5jdWx0dXJlc1tcImRlZmF1bHRcIl07XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYoYT1hLnNwbGl0KFwiLFwiKSk7aWYoSShhKSl7dmFyIGM9dGhpcy5jdWx0dXJlcyxlPWEsZixoPWUubGVuZ3RoLGc9W107Zm9yKGY9MDtmPGg7ZisrKXthPXkoZVtmXSk7YT1hLnNwbGl0KFwiO1wiKTt2YXIgZD15KGFbMF0pOzE9PT1hLmxlbmd0aD9hPTE6KGE9eShhWzFdKSwwPT09YS5pbmRleE9mKFwicT1cIik/KGE9YS5zdWJzdHIoMiksYT1wYXJzZUZsb2F0KGEpLGE9aXNOYU4oYSk/MDphKTphPTEpO2cucHVzaCh7bGFuZzpkLHByaTphfSl9Zy5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEucHJpPGIucHJpPzE6LTF9KTtmb3IoZj0wO2Y8aDtmKyspaWYoZD1nW2ZdLmxhbmcsYj1jW2RdKXJldHVybiBiO2ZvcihmPTA7ZjxoO2YrKyl7ZD1nW2ZdLmxhbmc7XG4gICAgICAgIGRve2U9ZC5sYXN0SW5kZXhPZihcIi1cIik7aWYoLTE9PT1lKWJyZWFrO2Q9ZC5zdWJzdHIoMCxlKTtpZihiPWNbZF0pcmV0dXJuIGJ9d2hpbGUoMSl9Zm9yKGY9MDtmPGg7ZisrKXtkPWdbZl0ubGFuZztmb3IodmFyIGsgaW4gYylpZihlPWNba10sZS5sYW5ndWFnZT09ZClyZXR1cm4gZX19ZWxzZSBpZihcIm9iamVjdFwiPT09dHlwZW9mIGEpcmV0dXJuIGE7cmV0dXJuIGJ8fG51bGx9O2suZm9ybWF0PWZ1bmN0aW9uKGEsYixjKXtjdWx0dXJlPXRoaXMuZmluZENsb3Nlc3RDdWx0dXJlKGMpO2EgaW5zdGFuY2VvZiBEYXRlP2E9UShhLGIsY3VsdHVyZSk6XCJudW1iZXJcIj09PXR5cGVvZiBhJiYoYT1MKGEsYixjdWx0dXJlKSk7cmV0dXJuIGF9O2subG9jYWxpemU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5maW5kQ2xvc2VzdEN1bHR1cmUoYikubWVzc2FnZXNbYV18fHRoaXMuY3VsdHVyZXNbXCJkZWZhdWx0XCJdLm1lc3NhZ2VzW2FdfTtrLnBhcnNlRGF0ZT1mdW5jdGlvbihhLGIsYyl7Yz10aGlzLmZpbmRDbG9zZXN0Q3VsdHVyZShjKTtcbiAgICAgICAgdmFyIGU7aWYoYil7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBiJiYoYj1bYl0pLGIubGVuZ3RoKXt2YXIgZj0wO2Zvcih2YXIgaD1iLmxlbmd0aDtmPGg7ZisrKXt2YXIgZz1iW2ZdO2lmKGcmJihlPUcoYSxnLGMpKSlicmVha319fWVsc2UgZm9yKGYgaW4gYj1jLmNhbGVuZGFyLnBhdHRlcm5zLGIpaWYoZT1HKGEsYltmXSxjKSlicmVhaztyZXR1cm4gZXx8bnVsbH07ay5wYXJzZUludD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIE8oay5wYXJzZUZsb2F0KGEsYixjKSl9O2sucGFyc2VGbG9hdD1mdW5jdGlvbihhLGIsYyl7XCJudW1iZXJcIiE9PXR5cGVvZiBiJiYoYz1iLGI9MTApO3ZhciBlPXRoaXMuZmluZENsb3Nlc3RDdWx0dXJlKGMpO2M9TmFOO3ZhciBmPWUubnVtYmVyRm9ybWF0Oy0xPGEuaW5kZXhPZihlLm51bWJlckZvcm1hdC5jdXJyZW5jeS5zeW1ib2wpJiYoYT1hLnJlcGxhY2UoZS5udW1iZXJGb3JtYXQuY3VycmVuY3kuc3ltYm9sLFwiXCIpLGE9YS5yZXBsYWNlKGUubnVtYmVyRm9ybWF0LmN1cnJlbmN5W1wiLlwiXSxcbiAgICAgICAgZS5udW1iZXJGb3JtYXRbXCIuXCJdKSk7YT15KGEpO2lmKFcudGVzdChhKSljPXBhcnNlRmxvYXQoYSk7ZWxzZSBpZighYiYmVi50ZXN0KGEpKWM9cGFyc2VJbnQoYSwxNik7ZWxzZXtlPUYoYSxmLGYucGF0dGVyblswXSk7Yj1lWzBdO2U9ZVsxXTtcIlwiPT09YiYmXCIobilcIiE9PWYucGF0dGVyblswXSYmKGU9RihhLGYsXCIobilcIiksYj1lWzBdLGU9ZVsxXSk7XCJcIj09PWImJlwiLW5cIiE9PWYucGF0dGVyblswXSYmKGU9RihhLGYsXCItblwiKSxiPWVbMF0sZT1lWzFdKTtiPWJ8fFwiK1wiO2E9ZS5pbmRleE9mKFwiZVwiKTswPmEmJihhPWUuaW5kZXhPZihcIkVcIikpO2lmKDA+YSl7dmFyIGg9ZTthPW51bGx9ZWxzZSBoPWUuc3Vic3RyKDAsYSksYT1lLnN1YnN0cihhKzEpO3ZhciBnPWZbXCIuXCJdLGQ9aC5pbmRleE9mKGcpOzA+ZD8oZT1oLGg9bnVsbCk6KGU9aC5zdWJzdHIoMCxkKSxoPWguc3Vic3RyKGQrZy5sZW5ndGgpKTtnPWZbXCIsXCJdO2U9ZS5zcGxpdChnKS5qb2luKFwiXCIpO2Q9Zy5yZXBsYWNlKC9cXHUwMEEwL2csXG4gICAgICAgIFwiIFwiKTtnIT09ZCYmKGU9ZS5zcGxpdChkKS5qb2luKFwiXCIpKTtiKz1lO251bGwhPT1oJiYoYis9XCIuXCIraCk7bnVsbCE9PWEmJihmPUYoYSxmLFwiLW5cIiksYis9XCJlXCIrKGZbMF18fFwiK1wiKStmWzFdKTtYLnRlc3QoYikmJihjPXBhcnNlRmxvYXQoYikpfXJldHVybiBjfTtrLmN1bHR1cmU9ZnVuY3Rpb24oYSl7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhJiYodGhpcy5jdWx0dXJlU2VsZWN0b3I9YSk7cmV0dXJuIHRoaXMuZmluZENsb3Nlc3RDdWx0dXJlKGEpfHx0aGlzLmN1bHR1cmVbXCJkZWZhdWx0XCJdfX0pKHRoaXMpO1xuXG53aW5kb3cuR2xvYmFsaXplID0gbW9kdWxlLmV4cG9ydHM7XG5cbn0uY2FsbCh3aW5kb3cpKTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFBQTtBQUNBO0FBRkE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFGQTtBQUdBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUZBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/js-3.2.2/globalize/globalize.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/blocks/common/jQueryCloneVal/jquery-cloneVal.js":
/*!*******************************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/blocks/common/jQueryCloneVal/jquery-cloneVal.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {if (window.$jscomp === undefined) {\n  var $jscomp = $jscomp || {};\n  $jscomp.scope = {};\n\n  $jscomp.findInternal = function (a, c, b) {\n    a instanceof String && (a = String(a));\n\n    for (var d = a.length, e = 0; e < d; e++) {\n      var f = a[e];\n      if (c.call(b, f, e, a)) return {\n        i: e,\n        v: f\n      };\n    }\n\n    return {\n      i: -1,\n      v: void 0\n    };\n  };\n\n  $jscomp.ASSUME_ES5 = !1;\n  $jscomp.ASSUME_NO_NATIVE_MAP = !1;\n  $jscomp.ASSUME_NO_NATIVE_SET = !1;\n  $jscomp.defineProperty = $jscomp.ASSUME_ES5 || \"function\" == typeof Object.defineProperties ? Object.defineProperty : function (a, c, b) {\n    a != Array.prototype && a != Object.prototype && (a[c] = b.value);\n  };\n\n  $jscomp.getGlobal = function (a) {\n    return \"undefined\" != typeof window && window === a ? a : \"undefined\" != typeof global && null != global ? global : a;\n  };\n\n  $jscomp.global = $jscomp.getGlobal(this);\n\n  $jscomp.polyfill = function (a, c, b, d) {\n    if (c) {\n      b = $jscomp.global;\n      a = a.split(\".\");\n\n      for (d = 0; d < a.length - 1; d++) {\n        var e = a[d];\n        e in b || (b[e] = {});\n        b = b[e];\n      }\n\n      a = a[a.length - 1];\n      d = b[a];\n      c = c(d);\n      c != d && null != c && $jscomp.defineProperty(b, a, {\n        configurable: !0,\n        writable: !0,\n        value: c\n      });\n    }\n  };\n\n  $jscomp.polyfill(\"Array.prototype.find\", function (a) {\n    return a ? a : function (a, b) {\n      return $jscomp.findInternal(this, a, b).v;\n    };\n  }, \"es6\", \"es3\");\n\n  (function (a) {\n    a.fn.cloneVal = function (c) {\n      var b = a.extend({}, {\n        cloneOnInit: !1,\n        eventNS: \"cloneVal\",\n        events: [\"change\", \"blur\", \"keyup\"],\n        targets: []\n      }, c),\n          d = b.events.join(\".\" + b.eventNS + \" \") + \".\" + b.eventNS;\n      return this.each(function () {\n        for (var c = b.targets, f = c.length, h = a(this); f--;) {\n          var g = c[f],\n              k = g[0];\n          g = g.slice(1).join(\",\");\n          h.on(d, k, g, function (b) {\n            h.find(b.data).val(a(this).val()).trigger(b.type);\n          });\n          b.cloneOnInit && h.find(k).trigger(b.events[0]);\n        }\n      });\n    };\n  })(jQuery);\n\n  window.$jscomp = $jscomp;\n  module.exports.$jscomp = $jscomp;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvYmxvY2tzL2NvbW1vbi9qUXVlcnlDbG9uZVZhbC9qcXVlcnktY2xvbmVWYWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvYmxvY2tzL2NvbW1vbi9qUXVlcnlDbG9uZVZhbC9qcXVlcnktY2xvbmVWYWwuanM/ZDZlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGpzY29tcD0kanNjb21wfHx7fTskanNjb21wLnNjb3BlPXt9OyRqc2NvbXAuZmluZEludGVybmFsPWZ1bmN0aW9uKGEsYyxiKXthIGluc3RhbmNlb2YgU3RyaW5nJiYoYT1TdHJpbmcoYSkpO2Zvcih2YXIgZD1hLmxlbmd0aCxlPTA7ZTxkO2UrKyl7dmFyIGY9YVtlXTtpZihjLmNhbGwoYixmLGUsYSkpcmV0dXJue2k6ZSx2OmZ9fXJldHVybntpOi0xLHY6dm9pZCAwfX07JGpzY29tcC5BU1NVTUVfRVM1PSExOyRqc2NvbXAuQVNTVU1FX05PX05BVElWRV9NQVA9ITE7JGpzY29tcC5BU1NVTUVfTk9fTkFUSVZFX1NFVD0hMTskanNjb21wLmRlZmluZVByb3BlcnR5PSRqc2NvbXAuQVNTVU1FX0VTNXx8XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnRpZXM/T2JqZWN0LmRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKGEsYyxiKXthIT1BcnJheS5wcm90b3R5cGUmJmEhPU9iamVjdC5wcm90b3R5cGUmJihhW2NdPWIudmFsdWUpfTtcbiRqc2NvbXAuZ2V0R2xvYmFsPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdz09PWE/YTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsJiZudWxsIT1nbG9iYWw/Z2xvYmFsOmF9OyRqc2NvbXAuZ2xvYmFsPSRqc2NvbXAuZ2V0R2xvYmFsKHRoaXMpOyRqc2NvbXAucG9seWZpbGw9ZnVuY3Rpb24oYSxjLGIsZCl7aWYoYyl7Yj0kanNjb21wLmdsb2JhbDthPWEuc3BsaXQoXCIuXCIpO2ZvcihkPTA7ZDxhLmxlbmd0aC0xO2QrKyl7dmFyIGU9YVtkXTtlIGluIGJ8fChiW2VdPXt9KTtiPWJbZV19YT1hW2EubGVuZ3RoLTFdO2Q9YlthXTtjPWMoZCk7YyE9ZCYmbnVsbCE9YyYmJGpzY29tcC5kZWZpbmVQcm9wZXJ0eShiLGEse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpjfSl9fTtcbiRqc2NvbXAucG9seWZpbGwoXCJBcnJheS5wcm90b3R5cGUuZmluZFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhP2E6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gJGpzY29tcC5maW5kSW50ZXJuYWwodGhpcyxhLGIpLnZ9fSxcImVzNlwiLFwiZXMzXCIpO1xuKGZ1bmN0aW9uKGEpe2EuZm4uY2xvbmVWYWw9ZnVuY3Rpb24oYyl7dmFyIGI9YS5leHRlbmQoe30se2Nsb25lT25Jbml0OiExLGV2ZW50TlM6XCJjbG9uZVZhbFwiLGV2ZW50czpbXCJjaGFuZ2VcIixcImJsdXJcIixcImtleXVwXCJdLHRhcmdldHM6W119LGMpLGQ9Yi5ldmVudHMuam9pbihcIi5cIitiLmV2ZW50TlMrXCIgXCIpK1wiLlwiK2IuZXZlbnROUztyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7Zm9yKHZhciBjPWIudGFyZ2V0cyxmPWMubGVuZ3RoLGg9YSh0aGlzKTtmLS07KXt2YXIgZz1jW2ZdLGs9Z1swXTtnPWcuc2xpY2UoMSkuam9pbihcIixcIik7aC5vbihkLGssZyxmdW5jdGlvbihiKXtoLmZpbmQoYi5kYXRhKS52YWwoYSh0aGlzKS52YWwoKSkudHJpZ2dlcihiLnR5cGUpfSk7Yi5jbG9uZU9uSW5pdCYmaC5maW5kKGspLnRyaWdnZXIoYi5ldmVudHNbMF0pfX0pfX0pKGpRdWVyeSk7XG4iXSwibWFwcGluZ3MiOiI7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/blocks/common/jQueryCloneVal/jquery-cloneVal.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/elements_v3/common/materialize-1-dev/dist/js/materialize.js":
/*!*******************************************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/elements_v3/common/materialize-1-dev/dist/js/materialize.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//If window.anime doesn't exist we are in an old page / bad  that defines materialize.js after optassets.\n//Or something went terribly wrong and materialize won't work because it's missing dependancies.\nif (window.anime) {\n  /*!\n   * Materialize vundefined (http://materializecss.com)\n   * Copyright 2014-2017 Materialize\n   * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)\n   */\n  var _get = function get(object, property, receiver) {\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent === null) {\n        return undefined;\n      } else {\n        return get(parent, property, receiver);\n      }\n    } else if (\"value\" in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n\n      if (getter === undefined) {\n        return undefined;\n      }\n\n      return getter.call(receiver);\n    }\n  };\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n  /*! cash-dom 1.3.5, https://github.com/kenwheeler/cash @license MIT */\n\n\n  (function (factory) {\n    window.cash = factory();\n  })(function () {\n    var doc = document,\n        win = window,\n        ArrayProto = Array.prototype,\n        slice = ArrayProto.slice,\n        filter = ArrayProto.filter,\n        push = ArrayProto.push;\n\n    var noop = function () {},\n        isFunction = function (item) {\n      // @see https://crbug.com/568448\n      return typeof item === typeof noop && item.call;\n    },\n        isString = function (item) {\n      return typeof item === typeof \"\";\n    };\n\n    var idMatch = /^#[\\w-]*$/,\n        classMatch = /^\\.[\\w-]*$/,\n        htmlMatch = /<.+>/,\n        singlet = /^\\w+$/;\n\n    function find(selector, context) {\n      context = context || doc;\n      var elems = classMatch.test(selector) ? context.getElementsByClassName(selector.slice(1)) : singlet.test(selector) ? context.getElementsByTagName(selector) : context.querySelectorAll(selector);\n      return elems;\n    }\n\n    var frag;\n\n    function parseHTML(str) {\n      if (!frag) {\n        frag = doc.implementation.createHTMLDocument(null);\n        var base = frag.createElement(\"base\");\n        base.href = doc.location.href;\n        frag.head.appendChild(base);\n      }\n\n      frag.body.innerHTML = str;\n      return frag.body.childNodes;\n    }\n\n    function onReady(fn) {\n      if (doc.readyState !== \"loading\") {\n        fn();\n      } else {\n        doc.addEventListener(\"DOMContentLoaded\", fn);\n      }\n    }\n\n    function Init(selector, context) {\n      if (!selector) {\n        return this;\n      } // If already a cash collection, don't do any further processing\n\n\n      if (selector.cash && selector !== win) {\n        return selector;\n      }\n\n      var elems = selector,\n          i = 0,\n          length;\n\n      if (isString(selector)) {\n        elems = idMatch.test(selector) ? // If an ID use the faster getElementById check\n        doc.getElementById(selector.slice(1)) : htmlMatch.test(selector) ? // If HTML, parse it into real elements\n        parseHTML(selector) : // else use `find`\n        find(selector, context); // If function, use as shortcut for DOM ready\n      } else if (isFunction(selector)) {\n        onReady(selector);\n        return this;\n      }\n\n      if (!elems) {\n        return this;\n      } // If a single DOM element is passed in or received via ID, return the single element\n\n\n      if (elems.nodeType || elems === win) {\n        this[0] = elems;\n        this.length = 1;\n      } else {\n        // Treat like an array and loop through each item.\n        length = this.length = elems.length;\n\n        for (; i < length; i++) {\n          this[i] = elems[i];\n        }\n      }\n\n      return this;\n    }\n\n    function cash(selector, context) {\n      return new Init(selector, context);\n    }\n\n    var fn = cash.fn = cash.prototype = Init.prototype = {\n      // jshint ignore:line\n      cash: true,\n      length: 0,\n      push: push,\n      splice: ArrayProto.splice,\n      map: ArrayProto.map,\n      init: Init\n    };\n    Object.defineProperty(fn, \"constructor\", {\n      value: cash\n    });\n    cash.parseHTML = parseHTML;\n    cash.noop = noop;\n    cash.isFunction = isFunction;\n    cash.isString = isString;\n\n    cash.extend = fn.extend = function (target) {\n      target = target || {};\n      var args = slice.call(arguments),\n          length = args.length,\n          i = 1;\n\n      if (args.length === 1) {\n        target = this;\n        i = 0;\n      }\n\n      for (; i < length; i++) {\n        if (!args[i]) {\n          continue;\n        }\n\n        for (var key in args[i]) {\n          if (args[i].hasOwnProperty(key)) {\n            target[key] = args[i][key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    function each(collection, callback) {\n      var l = collection.length,\n          i = 0;\n\n      for (; i < l; i++) {\n        if (callback.call(collection[i], collection[i], i, collection) === false) {\n          break;\n        }\n      }\n    }\n\n    function matches(el, selector) {\n      var m = el && (el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector || el.oMatchesSelector);\n      return !!m && m.call(el, selector);\n    }\n\n    function getCompareFunction(selector) {\n      return (\n        /* Use browser's `matches` function if string */\n        isString(selector) ? matches :\n        /* Match a cash element */\n        selector.cash ? function (el) {\n          return selector.is(el);\n        } :\n        /* Direct comparison */\n        function (el, selector) {\n          return el === selector;\n        }\n      );\n    }\n\n    function unique(collection) {\n      return cash(slice.call(collection).filter(function (item, index, self) {\n        return self.indexOf(item) === index;\n      }));\n    }\n\n    cash.extend({\n      merge: function (first, second) {\n        var len = +second.length,\n            i = first.length,\n            j = 0;\n\n        for (; j < len; i++, j++) {\n          first[i] = second[j];\n        }\n\n        first.length = i;\n        return first;\n      },\n      each: each,\n      matches: matches,\n      unique: unique,\n      isArray: Array.isArray,\n      isNumeric: function (n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n      }\n    });\n    var uid = cash.uid = \"_cash\" + Date.now();\n\n    function getDataCache(node) {\n      return node[uid] = node[uid] || {};\n    }\n\n    function setData(node, key, value) {\n      return getDataCache(node)[key] = value;\n    }\n\n    function getData(node, key) {\n      var c = getDataCache(node);\n\n      if (c[key] === undefined) {\n        c[key] = node.dataset ? node.dataset[key] : cash(node).attr(\"data-\" + key);\n      }\n\n      return c[key];\n    }\n\n    function removeData(node, key) {\n      var c = getDataCache(node);\n\n      if (c) {\n        delete c[key];\n      } else if (node.dataset) {\n        delete node.dataset[key];\n      } else {\n        cash(node).removeAttr(\"data-\" + name);\n      }\n    }\n\n    fn.extend({\n      data: function (name, value) {\n        if (isString(name)) {\n          return value === undefined ? getData(this[0], name) : this.each(function (v) {\n            return setData(v, name, value);\n          });\n        }\n\n        for (var key in name) {\n          this.data(key, name[key]);\n        }\n\n        return this;\n      },\n      removeData: function (key) {\n        return this.each(function (v) {\n          return removeData(v, key);\n        });\n      }\n    });\n    var notWhiteMatch = /\\S+/g;\n\n    function getClasses(c) {\n      return isString(c) && c.match(notWhiteMatch);\n    }\n\n    function hasClass(v, c) {\n      return v.classList ? v.classList.contains(c) : new RegExp(\"(^| )\" + c + \"( |$)\", \"gi\").test(v.className);\n    }\n\n    function addClass(v, c, spacedName) {\n      if (v.classList) {\n        v.classList.add(c);\n      } else if (spacedName.indexOf(\" \" + c + \" \")) {\n        v.className += \" \" + c;\n      }\n    }\n\n    function removeClass(v, c) {\n      if (v.classList) {\n        v.classList.remove(c);\n      } else {\n        v.className = v.className.replace(c, \"\");\n      }\n    }\n\n    fn.extend({\n      addClass: function (c) {\n        var classes = getClasses(c);\n        return classes ? this.each(function (v) {\n          var spacedName = \" \" + v.className + \" \";\n          each(classes, function (c) {\n            addClass(v, c, spacedName);\n          });\n        }) : this;\n      },\n      attr: function (name, value) {\n        if (!name) {\n          return undefined;\n        }\n\n        if (isString(name)) {\n          if (value === undefined) {\n            return this[0] ? this[0].getAttribute ? this[0].getAttribute(name) : this[0][name] : undefined;\n          }\n\n          return this.each(function (v) {\n            if (v.setAttribute) {\n              v.setAttribute(name, value);\n            } else {\n              v[name] = value;\n            }\n          });\n        }\n\n        for (var key in name) {\n          this.attr(key, name[key]);\n        }\n\n        return this;\n      },\n      hasClass: function (c) {\n        var check = false,\n            classes = getClasses(c);\n\n        if (classes && classes.length) {\n          this.each(function (v) {\n            check = hasClass(v, classes[0]);\n            return !check;\n          });\n        }\n\n        return check;\n      },\n      prop: function (name, value) {\n        if (isString(name)) {\n          return value === undefined ? this[0][name] : this.each(function (v) {\n            v[name] = value;\n          });\n        }\n\n        for (var key in name) {\n          this.prop(key, name[key]);\n        }\n\n        return this;\n      },\n      removeAttr: function (name) {\n        return this.each(function (v) {\n          if (v.removeAttribute) {\n            v.removeAttribute(name);\n          } else {\n            delete v[name];\n          }\n        });\n      },\n      removeClass: function (c) {\n        if (!arguments.length) {\n          return this.attr(\"class\", \"\");\n        }\n\n        var classes = getClasses(c);\n        return classes ? this.each(function (v) {\n          each(classes, function (c) {\n            removeClass(v, c);\n          });\n        }) : this;\n      },\n      removeProp: function (name) {\n        return this.each(function (v) {\n          delete v[name];\n        });\n      },\n      toggleClass: function (c, state) {\n        if (state !== undefined) {\n          return this[state ? \"addClass\" : \"removeClass\"](c);\n        }\n\n        var classes = getClasses(c);\n        return classes ? this.each(function (v) {\n          var spacedName = \" \" + v.className + \" \";\n          each(classes, function (c) {\n            if (hasClass(v, c)) {\n              removeClass(v, c);\n            } else {\n              addClass(v, c, spacedName);\n            }\n          });\n        }) : this;\n      }\n    });\n    fn.extend({\n      add: function (selector, context) {\n        return unique(cash.merge(this, cash(selector, context)));\n      },\n      each: function (callback) {\n        each(this, callback);\n        return this;\n      },\n      eq: function (index) {\n        return cash(this.get(index));\n      },\n      filter: function (selector) {\n        if (!selector) {\n          return this;\n        }\n\n        var comparator = isFunction(selector) ? selector : getCompareFunction(selector);\n        return cash(filter.call(this, function (e) {\n          return comparator(e, selector);\n        }));\n      },\n      first: function () {\n        return this.eq(0);\n      },\n      get: function (index) {\n        if (index === undefined) {\n          return slice.call(this);\n        }\n\n        return index < 0 ? this[index + this.length] : this[index];\n      },\n      index: function (elem) {\n        var child = elem ? cash(elem)[0] : this[0],\n            collection = elem ? this : cash(child).parent().children();\n        return slice.call(collection).indexOf(child);\n      },\n      last: function () {\n        return this.eq(-1);\n      }\n    });\n\n    var camelCase = function () {\n      var camelRegex = /(?:^\\w|[A-Z]|\\b\\w)/g,\n          whiteSpace = /[\\s-_]+/g;\n      return function (str) {\n        return str.replace(camelRegex, function (letter, index) {\n          return letter[index === 0 ? \"toLowerCase\" : \"toUpperCase\"]();\n        }).replace(whiteSpace, \"\");\n      };\n    }();\n\n    var getPrefixedProp = function () {\n      var cache = {},\n          doc = document,\n          div = doc.createElement(\"div\"),\n          style = div.style;\n      return function (prop) {\n        prop = camelCase(prop);\n\n        if (cache[prop]) {\n          return cache[prop];\n        }\n\n        var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),\n            prefixes = [\"webkit\", \"moz\", \"ms\", \"o\"],\n            props = (prop + \" \" + prefixes.join(ucProp + \" \") + ucProp).split(\" \");\n        each(props, function (p) {\n          if (p in style) {\n            cache[p] = prop = cache[prop] = p;\n            return false;\n          }\n        });\n        return cache[prop];\n      };\n    }();\n\n    cash.prefixedProp = getPrefixedProp;\n    cash.camelCase = camelCase;\n    fn.extend({\n      css: function (prop, value) {\n        if (isString(prop)) {\n          prop = getPrefixedProp(prop);\n          return arguments.length > 1 ? this.each(function (v) {\n            return v.style[prop] = value;\n          }) : win.getComputedStyle(this[0])[prop];\n        }\n\n        for (var key in prop) {\n          this.css(key, prop[key]);\n        }\n\n        return this;\n      }\n    });\n\n    function compute(el, prop) {\n      return parseInt(win.getComputedStyle(el[0], null)[prop], 10) || 0;\n    }\n\n    each([\"Width\", \"Height\"], function (v) {\n      var lower = v.toLowerCase();\n\n      fn[lower] = function () {\n        return this[0].getBoundingClientRect()[lower];\n      };\n\n      fn[\"inner\" + v] = function () {\n        return this[0][\"client\" + v];\n      };\n\n      fn[\"outer\" + v] = function (margins) {\n        return this[0][\"offset\" + v] + (margins ? compute(this, \"margin\" + (v === \"Width\" ? \"Left\" : \"Top\")) + compute(this, \"margin\" + (v === \"Width\" ? \"Right\" : \"Bottom\")) : 0);\n      };\n    });\n\n    function registerEvent(node, eventName, callback) {\n      var eventCache = getData(node, \"_cashEvents\") || setData(node, \"_cashEvents\", {});\n      eventCache[eventName] = eventCache[eventName] || [];\n      eventCache[eventName].push(callback);\n      node.addEventListener(eventName, callback);\n    }\n\n    function removeEvent(node, eventName, callback) {\n      var events = getData(node, \"_cashEvents\"),\n          eventCache = events && events[eventName],\n          index;\n\n      if (!eventCache) {\n        return;\n      }\n\n      if (callback) {\n        node.removeEventListener(eventName, callback);\n        index = eventCache.indexOf(callback);\n\n        if (index >= 0) {\n          eventCache.splice(index, 1);\n        }\n      } else {\n        each(eventCache, function (event) {\n          node.removeEventListener(eventName, event);\n        });\n        eventCache = [];\n      }\n    }\n\n    fn.extend({\n      off: function (eventName, callback) {\n        return this.each(function (v) {\n          return removeEvent(v, eventName, callback);\n        });\n      },\n      on: function (eventName, delegate, callback, runOnce) {\n        // jshint ignore:line\n        var originalCallback;\n\n        if (!isString(eventName)) {\n          for (var key in eventName) {\n            this.on(key, delegate, eventName[key]);\n          }\n\n          return this;\n        }\n\n        if (isFunction(delegate)) {\n          callback = delegate;\n          delegate = null;\n        }\n\n        if (eventName === \"ready\") {\n          onReady(callback);\n          return this;\n        }\n\n        if (delegate) {\n          originalCallback = callback;\n\n          callback = function (e) {\n            var t = e.target;\n\n            while (!matches(t, delegate)) {\n              if (t === this || t === null) {\n                return t = false;\n              }\n\n              t = t.parentNode;\n            }\n\n            if (t) {\n              originalCallback.call(t, e);\n            }\n          };\n        }\n\n        return this.each(function (v) {\n          var finalCallback = callback;\n\n          if (runOnce) {\n            finalCallback = function () {\n              callback.apply(this, arguments);\n              removeEvent(v, eventName, finalCallback);\n            };\n          }\n\n          registerEvent(v, eventName, finalCallback);\n        });\n      },\n      one: function (eventName, delegate, callback) {\n        return this.on(eventName, delegate, callback, true);\n      },\n      ready: onReady,\n\n      /**\n       * Modified\n       * Triggers browser event\n       * @param String eventName\n       * @param Object data - Add properties to event object\n       */\n      trigger: function (eventName, data) {\n        if (document.createEvent) {\n          var evt = document.createEvent('HTMLEvents');\n          evt.initEvent(eventName, true, false);\n          evt = this.extend(evt, data);\n          return this.each(function (v) {\n            return v.dispatchEvent(evt);\n          });\n        }\n      }\n    });\n\n    function encode(name, value) {\n      return \"&\" + encodeURIComponent(name) + \"=\" + encodeURIComponent(value).replace(/%20/g, \"+\");\n    }\n\n    function getSelectMultiple_(el) {\n      var values = [];\n      each(el.options, function (o) {\n        if (o.selected) {\n          values.push(o.value);\n        }\n      });\n      return values.length ? values : null;\n    }\n\n    function getSelectSingle_(el) {\n      var selectedIndex = el.selectedIndex;\n      return selectedIndex >= 0 ? el.options[selectedIndex].value : null;\n    }\n\n    function getValue(el) {\n      var type = el.type;\n\n      if (!type) {\n        return null;\n      }\n\n      switch (type.toLowerCase()) {\n        case \"select-one\":\n          return getSelectSingle_(el);\n\n        case \"select-multiple\":\n          return getSelectMultiple_(el);\n\n        case \"radio\":\n          return el.checked ? el.value : null;\n\n        case \"checkbox\":\n          return el.checked ? el.value : null;\n\n        default:\n          return el.value ? el.value : null;\n      }\n    }\n\n    fn.extend({\n      serialize: function () {\n        var query = \"\";\n        each(this[0].elements || this, function (el) {\n          if (el.disabled || el.tagName === \"FIELDSET\") {\n            return;\n          }\n\n          var name = el.name;\n\n          switch (el.type.toLowerCase()) {\n            case \"file\":\n            case \"reset\":\n            case \"submit\":\n            case \"button\":\n              break;\n\n            case \"select-multiple\":\n              var values = getValue(el);\n\n              if (values !== null) {\n                each(values, function (value) {\n                  query += encode(name, value);\n                });\n              }\n\n              break;\n\n            default:\n              var value = getValue(el);\n\n              if (value !== null) {\n                query += encode(name, value);\n              }\n\n          }\n        });\n        return query.substr(1);\n      },\n      val: function (value) {\n        if (value === undefined) {\n          return getValue(this[0]);\n        }\n\n        return this.each(function (v) {\n          return v.value = value;\n        });\n      }\n    });\n\n    function insertElement(el, child, prepend) {\n      if (prepend) {\n        var first = el.childNodes[0];\n        el.insertBefore(child, first);\n      } else {\n        el.appendChild(child);\n      }\n    }\n\n    function insertContent(parent, child, prepend) {\n      var str = isString(child);\n\n      if (!str && child.length) {\n        each(child, function (v) {\n          return insertContent(parent, v, prepend);\n        });\n        return;\n      }\n\n      each(parent, str ? function (v) {\n        return v.insertAdjacentHTML(prepend ? \"afterbegin\" : \"beforeend\", child);\n      } : function (v, i) {\n        return insertElement(v, i === 0 ? child : child.cloneNode(true), prepend);\n      });\n    }\n\n    fn.extend({\n      after: function (selector) {\n        cash(selector).insertAfter(this);\n        return this;\n      },\n      append: function (content) {\n        insertContent(this, content);\n        return this;\n      },\n      appendTo: function (parent) {\n        insertContent(cash(parent), this);\n        return this;\n      },\n      before: function (selector) {\n        cash(selector).insertBefore(this);\n        return this;\n      },\n      clone: function () {\n        return cash(this.map(function (v) {\n          return v.cloneNode(true);\n        }));\n      },\n      empty: function () {\n        this.html(\"\");\n        return this;\n      },\n      html: function (content) {\n        if (content === undefined) {\n          return this[0].innerHTML;\n        }\n\n        var source = content.nodeType ? content[0].outerHTML : content;\n        return this.each(function (v) {\n          return v.innerHTML = source;\n        });\n      },\n      insertAfter: function (selector) {\n        var _this = this;\n\n        cash(selector).each(function (el, i) {\n          var parent = el.parentNode,\n              sibling = el.nextSibling;\n\n          _this.each(function (v) {\n            parent.insertBefore(i === 0 ? v : v.cloneNode(true), sibling);\n          });\n        });\n        return this;\n      },\n      insertBefore: function (selector) {\n        var _this2 = this;\n\n        cash(selector).each(function (el, i) {\n          var parent = el.parentNode;\n\n          _this2.each(function (v) {\n            parent.insertBefore(i === 0 ? v : v.cloneNode(true), el);\n          });\n        });\n        return this;\n      },\n      prepend: function (content) {\n        insertContent(this, content, true);\n        return this;\n      },\n      prependTo: function (parent) {\n        insertContent(cash(parent), this, true);\n        return this;\n      },\n      remove: function () {\n        return this.each(function (v) {\n          if (!!v.parentNode) {\n            return v.parentNode.removeChild(v);\n          }\n        });\n      },\n      text: function (content) {\n        if (content === undefined) {\n          return this[0].textContent;\n        }\n\n        return this.each(function (v) {\n          return v.textContent = content;\n        });\n      }\n    });\n    var docEl = doc.documentElement;\n    fn.extend({\n      position: function () {\n        var el = this[0];\n        return {\n          left: el.offsetLeft,\n          top: el.offsetTop\n        };\n      },\n      offset: function () {\n        var rect = this[0].getBoundingClientRect();\n        return {\n          top: rect.top + win.pageYOffset - docEl.clientTop,\n          left: rect.left + win.pageXOffset - docEl.clientLeft\n        };\n      },\n      offsetParent: function () {\n        return cash(this[0].offsetParent);\n      }\n    });\n    fn.extend({\n      children: function (selector) {\n        var elems = [];\n        this.each(function (el) {\n          push.apply(elems, el.children);\n        });\n        elems = unique(elems);\n        return !selector ? elems : elems.filter(function (v) {\n          return matches(v, selector);\n        });\n      },\n      closest: function (selector) {\n        if (!selector || this.length < 1) {\n          return cash();\n        }\n\n        if (this.is(selector)) {\n          return this.filter(selector);\n        }\n\n        return this.parent().closest(selector);\n      },\n      is: function (selector) {\n        if (!selector) {\n          return false;\n        }\n\n        var match = false,\n            comparator = getCompareFunction(selector);\n        this.each(function (el) {\n          match = comparator(el, selector);\n          return !match;\n        });\n        return match;\n      },\n      find: function (selector) {\n        if (!selector || selector.nodeType) {\n          return cash(selector && this.has(selector).length ? selector : null);\n        }\n\n        var elems = [];\n        this.each(function (el) {\n          push.apply(elems, find(selector, el));\n        });\n        return unique(elems);\n      },\n      has: function (selector) {\n        var comparator = isString(selector) ? function (el) {\n          return find(selector, el).length !== 0;\n        } : function (el) {\n          return el.contains(selector);\n        };\n        return this.filter(comparator);\n      },\n      next: function () {\n        return cash(this[0].nextElementSibling);\n      },\n      not: function (selector) {\n        if (!selector) {\n          return this;\n        }\n\n        var comparator = getCompareFunction(selector);\n        return this.filter(function (el) {\n          return !comparator(el, selector);\n        });\n      },\n      parent: function () {\n        var result = [];\n        this.each(function (item) {\n          if (item && item.parentNode) {\n            result.push(item.parentNode);\n          }\n        });\n        return unique(result);\n      },\n      parents: function (selector) {\n        var last,\n            result = [];\n        this.each(function (item) {\n          last = item;\n\n          while (last && last.parentNode && last !== doc.body.parentNode) {\n            last = last.parentNode;\n\n            if (!selector || selector && matches(last, selector)) {\n              result.push(last);\n            }\n          }\n        });\n        return unique(result);\n      },\n      prev: function () {\n        return cash(this[0].previousElementSibling);\n      },\n      siblings: function (selector) {\n        var collection = this.parent().children(selector),\n            el = this[0];\n        return collection.filter(function (i) {\n          return i !== el;\n        });\n      }\n    });\n    return cash;\n  });\n\n  ;\n\n  var Component = function () {\n    /**\n     * Generic constructor for all components\n     * @constructor\n     * @param {Element} el\n     * @param {Object} options\n     */\n    function Component(classDef, el, options) {\n      _classCallCheck(this, Component); // Display error if el is valid HTML Element\n\n\n      if (!(el instanceof Element)) {\n        console.error(Error(el + ' is not an HTML Element'));\n      } // If exists, destroy and reinitialize in child\n\n\n      var ins = classDef.getInstance(el);\n\n      if (!!ins) {\n        ins.destroy();\n      }\n\n      this.el = el;\n      this.$el = cash(el);\n    }\n    /**\n     * Initializes components\n     * @param {class} classDef\n     * @param {Element | NodeList | jQuery} els\n     * @param {Object} options\n     */\n\n\n    _createClass(Component, null, [{\n      key: \"init\",\n      value: function init(classDef, els, options) {\n        var instances = null;\n\n        if (els instanceof Element) {\n          instances = new classDef(els, options);\n        } else if (!!els && (els.jquery || els.cash || els instanceof NodeList)) {\n          var instancesArr = [];\n\n          for (var i = 0; i < els.length; i++) {\n            instancesArr.push(new classDef(els[i], options));\n          }\n\n          instances = instancesArr;\n        }\n\n        return instances;\n      }\n    }]);\n\n    return Component;\n  }();\n\n  ; // Required for Meteor package, the use of window prevents export by Meteor\n\n  (function (window) {\n    if (window.Package) {\n      M = {};\n    } else {\n      window.M = {};\n    } // Check for jQuery\n\n\n    M.jQueryLoaded = !!window.jQuery;\n  })(window); // AMD\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return M;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // Common JS\n  } else {}\n\n  M.anime = window.anime;\n  M.version = '1.0.0';\n  M.keys = {\n    TAB: 9,\n    ENTER: 13,\n    ESC: 27,\n    ARROW_UP: 38,\n    ARROW_DOWN: 40\n  };\n  /**\n   * TabPress Keydown handler\n   */\n\n  M.tabPressed = false;\n  M.keyDown = false;\n\n  var docHandleKeydown = function (e) {\n    M.keyDown = true;\n\n    if (e.which === M.keys.TAB || e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) {\n      M.tabPressed = true;\n    }\n  };\n\n  var docHandleKeyup = function (e) {\n    M.keyDown = false;\n\n    if (e.which === M.keys.TAB || e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) {\n      M.tabPressed = false;\n    }\n  };\n\n  var docHandleFocus = function (e) {\n    if (M.keyDown) {\n      document.body.classList.add('keyboard-focused');\n    }\n  };\n\n  var docHandleBlur = function (e) {\n    document.body.classList.remove('keyboard-focused');\n  };\n\n  document.addEventListener('keydown', docHandleKeydown, true);\n  document.addEventListener('keyup', docHandleKeyup, true);\n  document.addEventListener('focus', docHandleFocus, true);\n  document.addEventListener('blur', docHandleBlur, true);\n  /**\n   * Initialize jQuery wrapper for plugin\n   * @param {Class} plugin  javascript class\n   * @param {string} pluginName  jQuery plugin name\n   * @param {string} classRef  Class reference name\n   */\n\n  M.initializeJqueryWrapper = function (plugin, pluginName, classRef) {\n    jQuery.fn[pluginName] = function (methodOrOptions) {\n      // Call plugin method if valid method name is passed in\n      if (plugin.prototype[methodOrOptions]) {\n        var params = Array.prototype.slice.call(arguments, 1); // Getter methods\n\n        if (methodOrOptions.slice(0, 3) === 'get') {\n          var instance = this.first()[0][classRef];\n          return instance[methodOrOptions].apply(instance, params);\n        } // Void methods\n\n\n        return this.each(function () {\n          var instance = this[classRef];\n          instance[methodOrOptions].apply(instance, params);\n        }); // Initialize plugin if options or no argument is passed in\n      } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {\n        plugin.init(this, arguments[0]);\n        return this;\n      } // Return error if an unrecognized  method name is passed in\n\n\n      jQuery.error(\"Method \" + methodOrOptions + \" does not exist on jQuery.\" + pluginName);\n    };\n  };\n  /**\n   * Automatically initialize components\n   * @param {Element} context  DOM Element to search within for components\n   */\n\n\n  M.AutoInit = function (context) {\n    // Use document.body if no context is given\n    var root = !!context ? context : document.body;\n    var registry = {\n      Autocomplete: root.querySelectorAll('.autocomplete:not(.no-autoinit)'),\n      Carousel: root.querySelectorAll('.carousel:not(.no-autoinit)'),\n      Chips: root.querySelectorAll('.chips:not(.no-autoinit)'),\n      Collapsible: root.querySelectorAll('.collapsible:not(.no-autoinit)'),\n      Datepicker: root.querySelectorAll('.datepicker:not(.no-autoinit)'),\n      Dropdown: root.querySelectorAll('.dropdown-trigger:not(.no-autoinit)'),\n      Materialbox: root.querySelectorAll('.materialboxed:not(.no-autoinit)'),\n      Modal: root.querySelectorAll('.modal:not(.no-autoinit)'),\n      Parallax: root.querySelectorAll('.parallax:not(.no-autoinit)'),\n      Pushpin: root.querySelectorAll('.pushpin:not(.no-autoinit)'),\n      ScrollSpy: root.querySelectorAll('.scrollspy:not(.no-autoinit)'),\n      FormSelect: root.querySelectorAll('select:not(.no-autoinit)'),\n      Sidenav: root.querySelectorAll('.sidenav:not(.no-autoinit)'),\n      Tabs: root.querySelectorAll('.tabs:not(.no-autoinit)'),\n      TapTarget: root.querySelectorAll('.tap-target:not(.no-autoinit)'),\n      Timepicker: root.querySelectorAll('.timepicker:not(.no-autoinit)'),\n      Tooltip: root.querySelectorAll('.tooltipped:not(.no-autoinit)'),\n      FloatingActionButton: root.querySelectorAll('.fixed-action-btn:not(.no-autoinit)')\n    };\n\n    for (var pluginName in registry) {\n      var plugin = M[pluginName];\n      plugin.init(registry[pluginName]);\n    }\n  };\n  /**\n   * Generate approximated selector string for a jQuery object\n   * @param {jQuery} obj  jQuery object to be parsed\n   * @returns {string}\n   */\n\n\n  M.objectSelectorString = function (obj) {\n    var tagStr = obj.prop('tagName') || '';\n    var idStr = obj.attr('id') || '';\n    var classStr = obj.attr('class') || '';\n    return (tagStr + idStr + classStr).replace(/\\s/g, '');\n  }; // Unique Random ID\n\n\n  M.guid = function () {\n    function s4() {\n      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    }\n\n    return function () {\n      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n    };\n  }();\n  /**\n   * Escapes hash from special characters\n   * @param {string} hash  String returned from this.hash\n   * @returns {string}\n   */\n\n\n  M.escapeHash = function (hash) {\n    return hash.replace(/(:|\\.|\\[|\\]|,|=|\\/)/g, '\\\\$1');\n  };\n\n  M.elementOrParentIsFixed = function (element) {\n    var $element = $(element);\n    var $checkElements = $element.add($element.parents());\n    var isFixed = false;\n    $checkElements.each(function () {\n      if ($(this).css('position') === 'fixed') {\n        isFixed = true;\n        return false;\n      }\n    });\n    return isFixed;\n  };\n  /**\n   * @typedef {Object} Edges\n   * @property {Boolean} top  If the top edge was exceeded\n   * @property {Boolean} right  If the right edge was exceeded\n   * @property {Boolean} bottom  If the bottom edge was exceeded\n   * @property {Boolean} left  If the left edge was exceeded\n   */\n\n  /**\n   * @typedef {Object} Bounding\n   * @property {Number} left  left offset coordinate\n   * @property {Number} top  top offset coordinate\n   * @property {Number} width\n   * @property {Number} height\n   */\n\n  /**\n   * Escapes hash from special characters\n   * @param {Element} container  Container element that acts as the boundary\n   * @param {Bounding} bounding  element bounding that is being checked\n   * @param {Number} offset  offset from edge that counts as exceeding\n   * @returns {Edges}\n   */\n\n\n  M.checkWithinContainer = function (container, bounding, offset) {\n    var edges = {\n      top: false,\n      right: false,\n      bottom: false,\n      left: false\n    };\n    var containerRect = container.getBoundingClientRect(); // If body element is smaller than viewport, use viewport height instead.\n\n    var containerBottom = container === document.body ? Math.max(containerRect.bottom, window.innerHeight) : containerRect.bottom;\n    var scrollLeft = container.scrollLeft;\n    var scrollTop = container.scrollTop;\n    var scrolledX = bounding.left - scrollLeft;\n    var scrolledY = bounding.top - scrollTop; // Check for container and viewport for each edge\n\n    if (scrolledX < containerRect.left + offset || scrolledX < offset) {\n      edges.left = true;\n    }\n\n    if (scrolledX + bounding.width > containerRect.right - offset || scrolledX + bounding.width > window.innerWidth - offset) {\n      edges.right = true;\n    }\n\n    if (scrolledY < containerRect.top + offset || scrolledY < offset) {\n      edges.top = true;\n    }\n\n    if (scrolledY + bounding.height > containerBottom - offset || scrolledY + bounding.height > window.innerHeight - offset) {\n      edges.bottom = true;\n    }\n\n    return edges;\n  };\n\n  M.checkPossibleAlignments = function (el, container, bounding, offset) {\n    var canAlign = {\n      top: true,\n      right: true,\n      bottom: true,\n      left: true,\n      spaceOnTop: null,\n      spaceOnRight: null,\n      spaceOnBottom: null,\n      spaceOnLeft: null\n    };\n    var containerAllowsOverflow = getComputedStyle(container).overflow === 'visible';\n    var containerRect = container.getBoundingClientRect();\n    var containerHeight = Math.min(containerRect.height, window.innerHeight);\n    var containerWidth = Math.min(containerRect.width, window.innerWidth);\n    var elOffsetRect = el.getBoundingClientRect();\n    var scrollLeft = container.scrollLeft;\n    var scrollTop = container.scrollTop;\n    var scrolledX = bounding.left - scrollLeft;\n    var scrolledYTopEdge = bounding.top - scrollTop;\n    var scrolledYBottomEdge = bounding.top + elOffsetRect.height - scrollTop; // Check for container and viewport for left\n\n    canAlign.spaceOnRight = !containerAllowsOverflow ? containerWidth - (scrolledX + bounding.width) : window.innerWidth - (elOffsetRect.left + bounding.width);\n\n    if (canAlign.spaceOnRight < 0) {\n      canAlign.left = false;\n    } // Check for container and viewport for Right\n\n\n    canAlign.spaceOnLeft = !containerAllowsOverflow ? scrolledX - bounding.width + elOffsetRect.width : elOffsetRect.right - bounding.width;\n\n    if (canAlign.spaceOnLeft < 0) {\n      canAlign.right = false;\n    } // Check for container and viewport for Top\n\n\n    canAlign.spaceOnBottom = !containerAllowsOverflow ? containerHeight - (scrolledYTopEdge + bounding.height + offset) : window.innerHeight - (elOffsetRect.top + bounding.height + offset);\n\n    if (canAlign.spaceOnBottom < 0) {\n      canAlign.top = false;\n    } // Check for container and viewport for Bottom\n\n\n    canAlign.spaceOnTop = !containerAllowsOverflow ? scrolledYBottomEdge - (bounding.height - offset) : elOffsetRect.bottom - (bounding.height + offset);\n\n    if (canAlign.spaceOnTop < 0) {\n      canAlign.bottom = false;\n    }\n\n    return canAlign;\n  };\n\n  M.getOverflowParent = function (element) {\n    if (element == null) {\n      return null;\n    }\n\n    if (element === document.body || getComputedStyle(element).overflow !== 'visible') {\n      return element;\n    }\n\n    return M.getOverflowParent(element.parentElement);\n  };\n  /**\n   * Gets id of component from a trigger\n   * @param {Element} trigger  trigger\n   * @returns {string}\n   */\n\n\n  M.getIdFromTrigger = function (trigger) {\n    var id = trigger.getAttribute('data-target');\n\n    if (!id) {\n      id = trigger.getAttribute('href');\n\n      if (id) {\n        id = id.slice(1);\n      } else {\n        id = '';\n      }\n    }\n\n    return id;\n  };\n  /**\n   * Multi browser support for document scroll top\n   * @returns {Number}\n   */\n\n\n  M.getDocumentScrollTop = function () {\n    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n  };\n  /**\n   * Multi browser support for document scroll left\n   * @returns {Number}\n   */\n\n\n  M.getDocumentScrollLeft = function () {\n    return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\n  };\n  /**\n   * @typedef {Object} Edges\n   * @property {Boolean} top  If the top edge was exceeded\n   * @property {Boolean} right  If the right edge was exceeded\n   * @property {Boolean} bottom  If the bottom edge was exceeded\n   * @property {Boolean} left  If the left edge was exceeded\n   */\n\n  /**\n   * @typedef {Object} Bounding\n   * @property {Number} left  left offset coordinate\n   * @property {Number} top  top offset coordinate\n   * @property {Number} width\n   * @property {Number} height\n   */\n\n  /**\n   * Get time in ms\n   * @license https://raw.github.com/jashkenas/underscore/master/LICENSE\n   * @type {function}\n   * @return {number}\n   */\n\n\n  var getTime = Date.now || function () {\n    return new Date().getTime();\n  };\n  /**\n   * Returns a function, that, when invoked, will only be triggered at most once\n   * during a given window of time. Normally, the throttled function will run\n   * as much as it can, without ever going more than once per `wait` duration;\n   * but if you'd like to disable the execution on the leading edge, pass\n   * `{leading: false}`. To disable execution on the trailing edge, ditto.\n   * @license https://raw.github.com/jashkenas/underscore/master/LICENSE\n   * @param {function} func\n   * @param {number} wait\n   * @param {Object=} options\n   * @returns {Function}\n   */\n\n\n  M.throttle = function (func, wait, options) {\n    var context = void 0,\n        args = void 0,\n        result = void 0;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n\n    var later = function () {\n      previous = options.leading === false ? 0 : getTime();\n      timeout = null;\n      result = func.apply(context, args);\n      context = args = null;\n    };\n\n    return function () {\n      var now = getTime();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n\n      return result;\n    };\n  };\n\n  ;\n\n  (function ($, anim) {\n    'use strict';\n\n    var _defaults = {\n      alignment: 'left',\n      autoFocus: true,\n      constrainWidth: true,\n      container: null,\n      coverTrigger: true,\n      closeOnClick: true,\n      hover: false,\n      inDuration: 150,\n      outDuration: 250,\n      onOpenStart: null,\n      onOpenEnd: null,\n      onCloseStart: null,\n      onCloseEnd: null,\n      onItemClick: null\n    };\n    /**\n     * @class\n     */\n\n    var Dropdown = function (_Component) {\n      _inherits(Dropdown, _Component);\n\n      function Dropdown(el, options) {\n        _classCallCheck(this, Dropdown);\n\n        var _this3 = _possibleConstructorReturn(this, (Dropdown.__proto__ || Object.getPrototypeOf(Dropdown)).call(this, Dropdown, el, options));\n\n        _this3.el.M_Dropdown = _this3;\n\n        Dropdown._dropdowns.push(_this3);\n\n        _this3.id = M.getIdFromTrigger(el);\n        _this3.dropdownEl = document.getElementById(_this3.id);\n        _this3.$dropdownEl = $(_this3.dropdownEl);\n        /**\n         * Options for the dropdown\n         * @member Dropdown#options\n         * @prop {String} [alignment='left'] - Edge which the dropdown is aligned to\n         * @prop {Boolean} [autoFocus=true] - Automatically focus dropdown el for keyboard\n         * @prop {Boolean} [constrainWidth=true] - Constrain width to width of the button\n         * @prop {Element} container - Container element to attach dropdown to (optional)\n         * @prop {Boolean} [coverTrigger=true] - Place dropdown over trigger\n         * @prop {Boolean} [closeOnClick=true] - Close on click of dropdown item\n         * @prop {Boolean} [hover=false] - Open dropdown on hover\n         * @prop {Number} [inDuration=150] - Duration of open animation in ms\n         * @prop {Number} [outDuration=250] - Duration of close animation in ms\n         * @prop {Function} onOpenStart - Function called when dropdown starts opening\n         * @prop {Function} onOpenEnd - Function called when dropdown finishes opening\n         * @prop {Function} onCloseStart - Function called when dropdown starts closing\n         * @prop {Function} onCloseEnd - Function called when dropdown finishes closing\n         */\n\n        _this3.options = $.extend({}, Dropdown.defaults, options);\n        /**\n         * Describes open/close state of dropdown\n         * @type {Boolean}\n         */\n\n        _this3.isOpen = false;\n        /**\n         * Describes if dropdown content is scrollable\n         * @type {Boolean}\n         */\n\n        _this3.isScrollable = false;\n        /**\n         * Describes if touch moving on dropdown content\n         * @type {Boolean}\n         */\n\n        _this3.isTouchMoving = false;\n        _this3.focusedIndex = -1;\n        _this3.filterQuery = []; // Move dropdown-content after dropdown-trigger\n\n        if (!!_this3.options.container) {\n          $(_this3.options.container).append(_this3.dropdownEl);\n        } else {\n          _this3.$el.after(_this3.dropdownEl);\n        }\n\n        _this3._makeDropdownFocusable();\n\n        _this3._resetFilterQueryBound = _this3._resetFilterQuery.bind(_this3);\n        _this3._handleDocumentClickBound = _this3._handleDocumentClick.bind(_this3);\n        _this3._handleDocumentTouchmoveBound = _this3._handleDocumentTouchmove.bind(_this3);\n        _this3._handleDropdownClickBound = _this3._handleDropdownClick.bind(_this3);\n        _this3._handleDropdownKeydownBound = _this3._handleDropdownKeydown.bind(_this3);\n        _this3._handleTriggerKeydownBound = _this3._handleTriggerKeydown.bind(_this3);\n\n        _this3._setupEventHandlers();\n\n        return _this3;\n      }\n\n      _createClass(Dropdown, [{\n        key: \"destroy\",\n\n        /**\n         * Teardown component\n         */\n        value: function destroy() {\n          this._resetDropdownStyles();\n\n          this._removeEventHandlers();\n\n          Dropdown._dropdowns.splice(Dropdown._dropdowns.indexOf(this), 1);\n\n          this.el.M_Dropdown = undefined;\n        }\n        /**\n         * Setup Event Handlers\n         */\n\n      }, {\n        key: \"_setupEventHandlers\",\n        value: function _setupEventHandlers() {\n          // Trigger keydown handler\n          this.el.addEventListener('keydown', this._handleTriggerKeydownBound); // Item click handler\n\n          this.dropdownEl.addEventListener('click', this._handleDropdownClickBound); // Hover event handlers\n\n          if (this.options.hover) {\n            this._handleMouseEnterBound = this._handleMouseEnter.bind(this);\n            this.el.addEventListener('mouseenter', this._handleMouseEnterBound);\n            this._handleMouseLeaveBound = this._handleMouseLeave.bind(this);\n            this.el.addEventListener('mouseleave', this._handleMouseLeaveBound);\n            this.dropdownEl.addEventListener('mouseleave', this._handleMouseLeaveBound); // Click event handlers\n          } else {\n            this._handleClickBound = this._handleClick.bind(this);\n            this.el.addEventListener('click', this._handleClickBound);\n          }\n        }\n        /**\n         * Remove Event Handlers\n         */\n\n      }, {\n        key: \"_removeEventHandlers\",\n        value: function _removeEventHandlers() {\n          this.el.removeEventListener('keydown', this._handleTriggerKeydownBound);\n          this.dropdownEl.removeEventListener('click', this._handleDropdownClickBound);\n\n          if (this.options.hover) {\n            this.el.removeEventListener('mouseenter', this._handleMouseEnterBound);\n            this.el.removeEventListener('mouseleave', this._handleMouseLeaveBound);\n            this.dropdownEl.removeEventListener('mouseleave', this._handleMouseLeaveBound);\n          } else {\n            this.el.removeEventListener('click', this._handleClickBound);\n          }\n        }\n      }, {\n        key: \"_setupTemporaryEventHandlers\",\n        value: function _setupTemporaryEventHandlers() {\n          // Use capture phase event handler to prevent click\n          document.body.addEventListener('click', this._handleDocumentClickBound, true);\n          document.body.addEventListener('touchend', this._handleDocumentClickBound);\n          document.body.addEventListener('touchmove', this._handleDocumentTouchmoveBound);\n          this.dropdownEl.addEventListener('keydown', this._handleDropdownKeydownBound);\n        }\n      }, {\n        key: \"_removeTemporaryEventHandlers\",\n        value: function _removeTemporaryEventHandlers() {\n          // Use capture phase event handler to prevent click\n          document.body.removeEventListener('click', this._handleDocumentClickBound, true);\n          document.body.removeEventListener('touchend', this._handleDocumentClickBound);\n          document.body.removeEventListener('touchmove', this._handleDocumentTouchmoveBound);\n          this.dropdownEl.removeEventListener('keydown', this._handleDropdownKeydownBound);\n        }\n      }, {\n        key: \"_handleClick\",\n        value: function _handleClick(e) {\n          e.preventDefault();\n          this.open();\n        }\n      }, {\n        key: \"_handleMouseEnter\",\n        value: function _handleMouseEnter() {\n          this.open();\n        }\n      }, {\n        key: \"_handleMouseLeave\",\n        value: function _handleMouseLeave(e) {\n          var toEl = e.toElement || e.relatedTarget;\n          var leaveToDropdownContent = !!$(toEl).closest('.dropdown-content').length;\n          var leaveToActiveDropdownTrigger = false;\n          var $closestTrigger = $(toEl).closest('.dropdown-trigger');\n\n          if ($closestTrigger.length && !!$closestTrigger[0].M_Dropdown && $closestTrigger[0].M_Dropdown.isOpen) {\n            leaveToActiveDropdownTrigger = true;\n          } // Close hover dropdown if mouse did not leave to either active dropdown-trigger or dropdown-content\n\n\n          if (!leaveToActiveDropdownTrigger && !leaveToDropdownContent) {\n            this.close();\n          }\n        }\n      }, {\n        key: \"_handleDocumentClick\",\n        value: function _handleDocumentClick(e) {\n          var _this4 = this;\n\n          var $target = $(e.target);\n\n          if (this.options.closeOnClick && $target.closest('.dropdown-content').length && !this.isTouchMoving) {\n            // isTouchMoving to check if scrolling on mobile.\n            setTimeout(function () {\n              _this4.close();\n            }, 0);\n          } else if ($target.closest('.dropdown-trigger').length || !$target.closest('.dropdown-content').length) {\n            setTimeout(function () {\n              _this4.close();\n            }, 0);\n          }\n\n          this.isTouchMoving = false;\n        }\n      }, {\n        key: \"_handleTriggerKeydown\",\n        value: function _handleTriggerKeydown(e) {\n          // ARROW DOWN OR ENTER WHEN SELECT IS CLOSED - open Dropdown\n          if ((e.which === M.keys.ARROW_DOWN || e.which === M.keys.ENTER) && !this.isOpen) {\n            e.preventDefault();\n            this.open();\n          }\n        }\n        /**\n         * Handle Document Touchmove\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleDocumentTouchmove\",\n        value: function _handleDocumentTouchmove(e) {\n          var $target = $(e.target);\n\n          if ($target.closest('.dropdown-content').length) {\n            this.isTouchMoving = true;\n          }\n        }\n        /**\n         * Handle Dropdown Click\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleDropdownClick\",\n        value: function _handleDropdownClick(e) {\n          // onItemClick callback\n          if (typeof this.options.onItemClick === 'function') {\n            var itemEl = $(e.target).closest('li')[0];\n            this.options.onItemClick.call(this, itemEl);\n          }\n        }\n        /**\n         * Handle Dropdown Keydown\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleDropdownKeydown\",\n        value: function _handleDropdownKeydown(e) {\n          if (e.which === M.keys.TAB) {\n            e.preventDefault();\n            this.close(); // Navigate down dropdown list\n          } else if ((e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) && this.isOpen) {\n            e.preventDefault();\n            var direction = e.which === M.keys.ARROW_DOWN ? 1 : -1;\n            var newFocusedIndex = this.focusedIndex;\n            var foundNewIndex = false;\n\n            do {\n              newFocusedIndex = newFocusedIndex + direction;\n\n              if (!!this.dropdownEl.children[newFocusedIndex] && this.dropdownEl.children[newFocusedIndex].tabIndex !== -1) {\n                foundNewIndex = true;\n                break;\n              }\n            } while (newFocusedIndex < this.dropdownEl.children.length && newFocusedIndex >= 0);\n\n            if (foundNewIndex) {\n              this.focusedIndex = newFocusedIndex;\n\n              this._focusFocusedItem();\n            } // ENTER selects choice on focused item\n\n          } else if (e.which === M.keys.ENTER && this.isOpen) {\n            // Search for <a> and <button>\n            var focusedElement = this.dropdownEl.children[this.focusedIndex];\n            var $activatableElement = $(focusedElement).find('a, button').first(); // Click a or button tag if exists, otherwise click li tag\n\n            if (!!$activatableElement.length) {\n              $activatableElement[0].click();\n            } else if (!!focusedElement) {\n              focusedElement.click();\n            } // Close dropdown on ESC\n\n          } else if (e.which === M.keys.ESC && this.isOpen) {\n            e.preventDefault();\n            this.close();\n          } // CASE WHEN USER TYPE LETTERS\n\n\n          var letter = String.fromCharCode(e.which).toLowerCase(),\n              nonLetters = [9, 13, 27, 38, 40];\n\n          if (letter && nonLetters.indexOf(e.which) === -1) {\n            this.filterQuery.push(letter);\n            var string = this.filterQuery.join(''),\n                newOptionEl = $(this.dropdownEl).find('li').filter(function (el) {\n              return $(el).text().toLowerCase().indexOf(string) === 0;\n            })[0];\n\n            if (newOptionEl) {\n              this.focusedIndex = $(newOptionEl).index();\n\n              this._focusFocusedItem();\n            }\n          }\n\n          this.filterTimeout = setTimeout(this._resetFilterQueryBound, 1000);\n        }\n        /**\n         * Setup dropdown\n         */\n\n      }, {\n        key: \"_resetFilterQuery\",\n        value: function _resetFilterQuery() {\n          this.filterQuery = [];\n        }\n      }, {\n        key: \"_resetDropdownStyles\",\n        value: function _resetDropdownStyles() {\n          this.$dropdownEl.css({\n            display: '',\n            width: '',\n            height: '',\n            left: '',\n            top: '',\n            'transform-origin': '',\n            transform: '',\n            opacity: ''\n          });\n        }\n      }, {\n        key: \"_makeDropdownFocusable\",\n        value: function _makeDropdownFocusable() {\n          // Needed for arrow key navigation\n          this.dropdownEl.tabIndex = 0; // Only set tabindex if it hasn't been set by user\n\n          $(this.dropdownEl).children().each(function (el) {\n            if (!el.getAttribute('tabindex')) {\n              el.setAttribute('tabindex', 0);\n            }\n          });\n        }\n      }, {\n        key: \"_focusFocusedItem\",\n        value: function _focusFocusedItem() {\n          if (this.focusedIndex >= 0 && this.focusedIndex < this.dropdownEl.children.length && this.options.autoFocus) {\n            this.dropdownEl.children[this.focusedIndex].focus();\n          }\n        }\n      }, {\n        key: \"_getDropdownPosition\",\n        value: function _getDropdownPosition() {\n          var offsetParentBRect = this.el.offsetParent.getBoundingClientRect();\n          var triggerBRect = this.el.getBoundingClientRect();\n          var dropdownBRect = this.dropdownEl.getBoundingClientRect();\n          var idealHeight = dropdownBRect.height;\n          var idealWidth = dropdownBRect.width;\n          var idealXPos = triggerBRect.left - dropdownBRect.left;\n          var idealYPos = triggerBRect.top - dropdownBRect.top;\n          var dropdownBounds = {\n            left: idealXPos,\n            top: idealYPos,\n            height: idealHeight,\n            width: idealWidth\n          }; // Countainer here will be closest ancestor with overflow: hidden\n\n          var closestOverflowParent = !!this.dropdownEl.offsetParent ? this.dropdownEl.offsetParent : this.dropdownEl.parentNode;\n          var alignments = M.checkPossibleAlignments(this.el, closestOverflowParent, dropdownBounds, this.options.coverTrigger ? 0 : triggerBRect.height);\n          var verticalAlignment = 'top';\n          var horizontalAlignment = this.options.alignment;\n          idealYPos += this.options.coverTrigger ? 0 : triggerBRect.height; // Reset isScrollable\n\n          this.isScrollable = false;\n\n          if (!alignments.top) {\n            if (alignments.bottom) {\n              verticalAlignment = 'bottom';\n            } else {\n              this.isScrollable = true; // Determine which side has most space and cutoff at correct height\n\n              if (alignments.spaceOnTop > alignments.spaceOnBottom) {\n                verticalAlignment = 'bottom';\n                idealHeight += alignments.spaceOnTop;\n                idealYPos -= alignments.spaceOnTop;\n              } else {\n                idealHeight += alignments.spaceOnBottom;\n              }\n            }\n          } // If preferred horizontal alignment is possible\n\n\n          if (!alignments[horizontalAlignment]) {\n            var oppositeAlignment = horizontalAlignment === 'left' ? 'right' : 'left';\n\n            if (alignments[oppositeAlignment]) {\n              horizontalAlignment = oppositeAlignment;\n            } else {\n              // Determine which side has most space and cutoff at correct height\n              if (alignments.spaceOnLeft > alignments.spaceOnRight) {\n                horizontalAlignment = 'right';\n                idealWidth += alignments.spaceOnLeft;\n                idealXPos -= alignments.spaceOnLeft;\n              } else {\n                horizontalAlignment = 'left';\n                idealWidth += alignments.spaceOnRight;\n              }\n            }\n          }\n\n          if (verticalAlignment === 'bottom') {\n            idealYPos = idealYPos - dropdownBRect.height + (this.options.coverTrigger ? triggerBRect.height : 0);\n          }\n\n          if (horizontalAlignment === 'right') {\n            idealXPos = idealXPos - dropdownBRect.width + triggerBRect.width;\n          }\n\n          return {\n            x: idealXPos,\n            y: idealYPos,\n            verticalAlignment: verticalAlignment,\n            horizontalAlignment: horizontalAlignment,\n            height: idealHeight,\n            width: idealWidth\n          };\n        }\n        /**\n         * Animate in dropdown\n         */\n\n      }, {\n        key: \"_animateIn\",\n        value: function _animateIn() {\n          var _this5 = this;\n\n          anim.remove(this.dropdownEl);\n          anim({\n            targets: this.dropdownEl,\n            opacity: {\n              value: [0, 1],\n              easing: 'easeOutQuad'\n            },\n            scaleX: [0.3, 1],\n            scaleY: [0.3, 1],\n            duration: this.options.inDuration,\n            easing: 'easeOutQuint',\n            complete: function (anim) {\n              if (_this5.options.autoFocus) {\n                _this5.dropdownEl.focus();\n              } // onOpenEnd callback\n\n\n              if (typeof _this5.options.onOpenEnd === 'function') {\n                _this5.options.onOpenEnd.call(_this5, _this5.el);\n              }\n            }\n          });\n        }\n        /**\n         * Animate out dropdown\n         */\n\n      }, {\n        key: \"_animateOut\",\n        value: function _animateOut() {\n          var _this6 = this;\n\n          anim.remove(this.dropdownEl);\n          anim({\n            targets: this.dropdownEl,\n            opacity: {\n              value: 0,\n              easing: 'easeOutQuint'\n            },\n            scaleX: 0.3,\n            scaleY: 0.3,\n            duration: this.options.outDuration,\n            easing: 'easeOutQuint',\n            complete: function (anim) {\n              _this6._resetDropdownStyles(); // onCloseEnd callback\n\n\n              if (typeof _this6.options.onCloseEnd === 'function') {\n                _this6.options.onCloseEnd.call(_this6, _this6.el);\n              }\n            }\n          });\n        }\n        /**\n         * Place dropdown\n         */\n\n      }, {\n        key: \"_placeDropdown\",\n        value: function _placeDropdown() {\n          // Set width before calculating positionInfo\n          var idealWidth = this.options.constrainWidth ? this.el.getBoundingClientRect().width : this.dropdownEl.getBoundingClientRect().width;\n          this.dropdownEl.style.width = idealWidth + 'px';\n\n          var positionInfo = this._getDropdownPosition();\n\n          this.dropdownEl.style.left = positionInfo.x + 'px';\n          this.dropdownEl.style.top = positionInfo.y + 'px';\n          this.dropdownEl.style.height = positionInfo.height + 'px';\n          this.dropdownEl.style.width = positionInfo.width + 'px';\n          this.dropdownEl.style.transformOrigin = (positionInfo.horizontalAlignment === 'left' ? '0' : '100%') + \" \" + (positionInfo.verticalAlignment === 'top' ? '0' : '100%');\n        }\n        /**\n         * Open Dropdown\n         */\n\n      }, {\n        key: \"open\",\n        value: function open() {\n          if (this.isOpen) {\n            return;\n          }\n\n          this.isOpen = true; // onOpenStart callback\n\n          if (typeof this.options.onOpenStart === 'function') {\n            this.options.onOpenStart.call(this, this.el);\n          } // Reset styles\n\n\n          this._resetDropdownStyles();\n\n          this.dropdownEl.style.display = 'block';\n\n          this._placeDropdown();\n\n          this._animateIn();\n\n          this._setupTemporaryEventHandlers();\n        }\n        /**\n         * Close Dropdown\n         */\n\n      }, {\n        key: \"close\",\n        value: function close() {\n          if (!this.isOpen) {\n            return;\n          }\n\n          this.isOpen = false;\n          this.focusedIndex = -1; // onCloseStart callback\n\n          if (typeof this.options.onCloseStart === 'function') {\n            this.options.onCloseStart.call(this, this.el);\n          }\n\n          this._animateOut();\n\n          this._removeTemporaryEventHandlers();\n\n          if (this.options.autoFocus) {\n            this.el.focus();\n          }\n        }\n        /**\n         * Recalculate dimensions\n         */\n\n      }, {\n        key: \"recalculateDimensions\",\n        value: function recalculateDimensions() {\n          if (this.isOpen) {\n            this.$dropdownEl.css({\n              width: '',\n              height: '',\n              left: '',\n              top: '',\n              'transform-origin': ''\n            });\n\n            this._placeDropdown();\n          }\n        }\n      }], [{\n        key: \"init\",\n        value: function init(els, options) {\n          return _get(Dropdown.__proto__ || Object.getPrototypeOf(Dropdown), \"init\", this).call(this, this, els, options);\n        }\n        /**\n         * Get Instance\n         */\n\n      }, {\n        key: \"getInstance\",\n        value: function getInstance(el) {\n          var domElem = !!el.jquery ? el[0] : el;\n          return domElem.M_Dropdown;\n        }\n      }, {\n        key: \"defaults\",\n        get: function () {\n          return _defaults;\n        }\n      }]);\n\n      return Dropdown;\n    }(Component);\n    /**\n     * @static\n     * @memberof Dropdown\n     */\n\n\n    Dropdown._dropdowns = [];\n    M.Dropdown = Dropdown;\n\n    if (M.jQueryLoaded) {\n      M.initializeJqueryWrapper(Dropdown, 'dropdown', 'M_Dropdown');\n    }\n  })(cash, M.anime);\n\n  ;\n\n  (function ($, anim) {\n    'use strict';\n\n    var _defaults = {\n      opacity: 0.5,\n      inDuration: 250,\n      outDuration: 250,\n      onOpenStart: null,\n      onOpenEnd: null,\n      onCloseStart: null,\n      onCloseEnd: null,\n      preventScrolling: true,\n      dismissible: true,\n      startingTop: '4%',\n      endingTop: '10%'\n    };\n    /**\n     * @class\n     *\n     */\n\n    var Modal = function (_Component2) {\n      _inherits(Modal, _Component2);\n      /**\n       * Construct Modal instance and set up overlay\n       * @constructor\n       * @param {Element} el\n       * @param {Object} options\n       */\n\n\n      function Modal(el, options) {\n        _classCallCheck(this, Modal);\n\n        var _this7 = _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, Modal, el, options));\n\n        _this7.el.M_Modal = _this7;\n        /**\n         * Options for the modal\n         * @member Modal#options\n         * @prop {Number} [opacity=0.5] - Opacity of the modal overlay\n         * @prop {Number} [inDuration=250] - Length in ms of enter transition\n         * @prop {Number} [outDuration=250] - Length in ms of exit transition\n         * @prop {Function} onOpenStart - Callback function called before modal is opened\n         * @prop {Function} onOpenEnd - Callback function called after modal is opened\n         * @prop {Function} onCloseStart - Callback function called before modal is closed\n         * @prop {Function} onCloseEnd - Callback function called after modal is closed\n         * @prop {Boolean} [dismissible=true] - Allow modal to be dismissed by keyboard or overlay click\n         * @prop {String} [startingTop='4%'] - startingTop\n         * @prop {String} [endingTop='10%'] - endingTop\n         */\n\n        _this7.options = $.extend({}, Modal.defaults, options);\n        /**\n         * Describes open/close state of modal\n         * @type {Boolean}\n         */\n\n        _this7.isOpen = false;\n        _this7.id = _this7.$el.attr('id');\n        _this7._openingTrigger = undefined;\n        _this7.$overlay = $('<div class=\"modal-overlay\"></div>');\n        _this7.el.tabIndex = 0;\n        _this7._nthModalOpened = 0;\n        Modal._count++;\n\n        _this7._setupEventHandlers();\n\n        return _this7;\n      }\n\n      _createClass(Modal, [{\n        key: \"destroy\",\n\n        /**\n         * Teardown component\n         */\n        value: function destroy() {\n          Modal._count--;\n\n          this._removeEventHandlers();\n\n          this.el.removeAttribute('style');\n          this.$overlay.remove();\n          this.el.M_Modal = undefined;\n        }\n        /**\n         * Setup Event Handlers\n         */\n\n      }, {\n        key: \"_setupEventHandlers\",\n        value: function _setupEventHandlers() {\n          this._handleOverlayClickBound = this._handleOverlayClick.bind(this);\n          this._handleModalCloseClickBound = this._handleModalCloseClick.bind(this);\n\n          if (Modal._count === 1) {\n            document.body.addEventListener('click', this._handleTriggerClick);\n          }\n\n          this.$overlay[0].addEventListener('click', this._handleOverlayClickBound);\n          this.el.addEventListener('click', this._handleModalCloseClickBound);\n        }\n        /**\n         * Remove Event Handlers\n         */\n\n      }, {\n        key: \"_removeEventHandlers\",\n        value: function _removeEventHandlers() {\n          if (Modal._count === 0) {\n            document.body.removeEventListener('click', this._handleTriggerClick);\n          }\n\n          this.$overlay[0].removeEventListener('click', this._handleOverlayClickBound);\n          this.el.removeEventListener('click', this._handleModalCloseClickBound);\n        }\n        /**\n         * Handle Trigger Click\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleTriggerClick\",\n        value: function _handleTriggerClick(e) {\n          var $trigger = $(e.target).closest('.modal-trigger');\n\n          if ($trigger.length) {\n            var modalId = M.getIdFromTrigger($trigger[0]);\n            var modalInstance = document.getElementById(modalId).M_Modal;\n\n            if (modalInstance) {\n              modalInstance.open($trigger);\n            }\n\n            e.preventDefault();\n          }\n        }\n        /**\n         * Handle Overlay Click\n         */\n\n      }, {\n        key: \"_handleOverlayClick\",\n        value: function _handleOverlayClick() {\n          if (this.options.dismissible) {\n            this.close();\n          }\n        }\n        /**\n         * Handle Modal Close Click\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleModalCloseClick\",\n        value: function _handleModalCloseClick(e) {\n          var $closeTrigger = $(e.target).closest('.modal-close');\n\n          if ($closeTrigger.length) {\n            this.close();\n          }\n        }\n        /**\n         * Handle Keydown\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleKeydown\",\n        value: function _handleKeydown(e) {\n          // ESC key\n          if (e.keyCode === 27 && this.options.dismissible) {\n            this.close();\n          }\n        }\n        /**\n         * Handle Focus\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleFocus\",\n        value: function _handleFocus(e) {\n          // Only trap focus if this modal is the last model opened (prevents loops in nested modals).\n          if (!this.el.contains(e.target) && this._nthModalOpened === Modal._modalsOpen) {\n            this.el.focus();\n          }\n        }\n        /**\n         * Animate in modal\n         */\n\n      }, {\n        key: \"_animateIn\",\n        value: function _animateIn() {\n          var _this8 = this; // Set initial styles\n\n\n          $.extend(this.el.style, {\n            display: 'block',\n            opacity: 0\n          });\n          $.extend(this.$overlay[0].style, {\n            display: 'block',\n            opacity: 0\n          }); // Animate overlay\n\n          anim({\n            targets: this.$overlay[0],\n            opacity: this.options.opacity,\n            duration: this.options.inDuration,\n            easing: 'easeOutQuad'\n          }); // Define modal animation options\n\n          var enterAnimOptions = {\n            targets: this.el,\n            duration: this.options.inDuration,\n            easing: 'easeOutCubic',\n            // Handle modal onOpenEnd callback\n            complete: function () {\n              if (typeof _this8.options.onOpenEnd === 'function') {\n                _this8.options.onOpenEnd.call(_this8, _this8.el, _this8._openingTrigger);\n              }\n            }\n          }; // Bottom sheet animation\n\n          if (this.el.classList.contains('bottom-sheet')) {\n            $.extend(enterAnimOptions, {\n              bottom: 0,\n              opacity: 1\n            });\n            anim(enterAnimOptions); // Normal modal animation\n          } else {\n            $.extend(enterAnimOptions, {\n              top: [this.options.startingTop, this.options.endingTop],\n              opacity: 1,\n              scaleX: [0.8, 1],\n              scaleY: [0.8, 1]\n            });\n            anim(enterAnimOptions);\n          }\n        }\n        /**\n         * Animate out modal\n         */\n\n      }, {\n        key: \"_animateOut\",\n        value: function _animateOut() {\n          var _this9 = this; // Animate overlay\n\n\n          anim({\n            targets: this.$overlay[0],\n            opacity: 0,\n            duration: this.options.outDuration,\n            easing: 'easeOutQuart'\n          }); // Define modal animation options\n\n          var exitAnimOptions = {\n            targets: this.el,\n            duration: this.options.outDuration,\n            easing: 'easeOutCubic',\n            // Handle modal ready callback\n            complete: function () {\n              _this9.el.style.display = 'none';\n\n              _this9.$overlay.remove(); // Call onCloseEnd callback\n\n\n              if (typeof _this9.options.onCloseEnd === 'function') {\n                _this9.options.onCloseEnd.call(_this9, _this9.el);\n              }\n            }\n          }; // Bottom sheet animation\n\n          if (this.el.classList.contains('bottom-sheet')) {\n            $.extend(exitAnimOptions, {\n              bottom: '-100%',\n              opacity: 0\n            });\n            anim(exitAnimOptions); // Normal modal animation\n          } else {\n            $.extend(exitAnimOptions, {\n              top: [this.options.endingTop, this.options.startingTop],\n              opacity: 0,\n              scaleX: 0.8,\n              scaleY: 0.8\n            });\n            anim(exitAnimOptions);\n          }\n        }\n        /**\n         * Open Modal\n         * @param {cash} [$trigger]\n         */\n\n      }, {\n        key: \"open\",\n        value: function open($trigger) {\n          if (this.isOpen) {\n            return;\n          }\n\n          this.isOpen = true;\n          Modal._modalsOpen++;\n          this._nthModalOpened = Modal._modalsOpen; // Set Z-Index based on number of currently open modals\n\n          this.$overlay[0].style.zIndex = 1000 + Modal._modalsOpen * 2;\n          this.el.style.zIndex = 1000 + Modal._modalsOpen * 2 + 1; // Set opening trigger, undefined indicates modal was opened by javascript\n\n          this._openingTrigger = !!$trigger ? $trigger[0] : undefined; // onOpenStart callback\n\n          if (typeof this.options.onOpenStart === 'function') {\n            this.options.onOpenStart.call(this, this.el, this._openingTrigger);\n          }\n\n          if (this.options.preventScrolling) {\n            document.body.style.overflow = 'hidden';\n          }\n\n          this.el.classList.add('open');\n          this.el.insertAdjacentElement('afterend', this.$overlay[0]);\n\n          if (this.options.dismissible) {\n            this._handleKeydownBound = this._handleKeydown.bind(this);\n            this._handleFocusBound = this._handleFocus.bind(this);\n            document.addEventListener('keydown', this._handleKeydownBound);\n            document.addEventListener('focus', this._handleFocusBound, true);\n          }\n\n          anim.remove(this.el);\n          anim.remove(this.$overlay[0]);\n\n          this._animateIn(); // Focus modal\n\n\n          this.el.focus();\n          return this;\n        }\n        /**\n         * Close Modal\n         */\n\n      }, {\n        key: \"close\",\n        value: function close() {\n          if (!this.isOpen) {\n            return;\n          }\n\n          this.isOpen = false;\n          Modal._modalsOpen--;\n          this._nthModalOpened = 0; // Call onCloseStart callback\n\n          if (typeof this.options.onCloseStart === 'function') {\n            this.options.onCloseStart.call(this, this.el);\n          }\n\n          this.el.classList.remove('open'); // Enable body scrolling only if there are no more modals open.\n\n          if (Modal._modalsOpen === 0) {\n            document.body.style.overflow = '';\n          }\n\n          if (this.options.dismissible) {\n            document.removeEventListener('keydown', this._handleKeydownBound);\n            document.removeEventListener('focus', this._handleFocusBound, true);\n          }\n\n          anim.remove(this.el);\n          anim.remove(this.$overlay[0]);\n\n          this._animateOut();\n\n          return this;\n        }\n      }], [{\n        key: \"init\",\n        value: function init(els, options) {\n          return _get(Modal.__proto__ || Object.getPrototypeOf(Modal), \"init\", this).call(this, this, els, options);\n        }\n        /**\n         * Get Instance\n         */\n\n      }, {\n        key: \"getInstance\",\n        value: function getInstance(el) {\n          var domElem = !!el.jquery ? el[0] : el;\n          return domElem.M_Modal;\n        }\n      }, {\n        key: \"defaults\",\n        get: function () {\n          return _defaults;\n        }\n      }]);\n\n      return Modal;\n    }(Component);\n    /**\n     * @static\n     * @memberof Modal\n     */\n\n\n    Modal._modalsOpen = 0;\n    /**\n     * @static\n     * @memberof Modal\n     */\n\n    Modal._count = 0;\n    M.Modal = Modal;\n\n    if (M.jQueryLoaded) {\n      M.initializeJqueryWrapper(Modal, 'modal', 'M_Modal');\n    }\n  })(cash, M.anime);\n\n  ;\n\n  (function ($) {\n    // Function to update labels of text fields\n    M.updateTextFields = function () {\n      var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea';\n      $(input_selector).each(function (element, index) {\n        var $this = $(this);\n\n        if (element.value.length > 0 || $(element).is(':focus') || element.autofocus || $this.attr('placeholder') !== null) {\n          $this.siblings('label').addClass('active');\n        } else if (element.validity) {\n          $this.siblings('label').toggleClass('active', element.validity.badInput === true);\n        } else {\n          $this.siblings('label').removeClass('active');\n        }\n      });\n    };\n\n    M.validate_field = function (object) {\n      var hasLength = object.attr('data-length') !== null;\n      var lenAttr = parseInt(object.attr('data-length'));\n      var len = object[0].value.length;\n\n      if (len === 0 && object[0].validity.badInput === false && !object.is(':required')) {\n        if (object.hasClass('validate')) {\n          object.removeClass('valid');\n          object.removeClass('invalid');\n        }\n      } else {\n        if (object.hasClass('validate')) {\n          // Check for character counter attributes\n          if (object.is(':valid') && hasLength && len <= lenAttr || object.is(':valid') && !hasLength) {\n            object.removeClass('invalid');\n            object.addClass('valid');\n          } else {\n            object.removeClass('valid');\n            object.addClass('invalid');\n          }\n        }\n      }\n    };\n\n    M.textareaAutoResize = function ($textarea) {\n      // Wrap if native element\n      if ($textarea instanceof Element) {\n        $textarea = $($textarea);\n      }\n\n      if (!$textarea.length) {\n        console.error('No textarea element found');\n        return;\n      } // Textarea Auto Resize\n\n\n      var hiddenDiv = $('.hiddendiv').first();\n\n      if (!hiddenDiv.length) {\n        hiddenDiv = $('<div class=\"hiddendiv common\"></div>');\n        $('body').append(hiddenDiv);\n      } // Set font properties of hiddenDiv\n\n\n      var fontFamily = $textarea.css('font-family');\n      var fontSize = $textarea.css('font-size');\n      var lineHeight = $textarea.css('line-height'); // Firefox can't handle padding shorthand.\n\n      var paddingTop = $textarea.css('padding-top');\n      var paddingRight = $textarea.css('padding-right');\n      var paddingBottom = $textarea.css('padding-bottom');\n      var paddingLeft = $textarea.css('padding-left');\n\n      if (fontSize) {\n        hiddenDiv.css('font-size', fontSize);\n      }\n\n      if (fontFamily) {\n        hiddenDiv.css('font-family', fontFamily);\n      }\n\n      if (lineHeight) {\n        hiddenDiv.css('line-height', lineHeight);\n      }\n\n      if (paddingTop) {\n        hiddenDiv.css('padding-top', paddingTop);\n      }\n\n      if (paddingRight) {\n        hiddenDiv.css('padding-right', paddingRight);\n      }\n\n      if (paddingBottom) {\n        hiddenDiv.css('padding-bottom', paddingBottom);\n      }\n\n      if (paddingLeft) {\n        hiddenDiv.css('padding-left', paddingLeft);\n      } // Set original-height, if none\n\n\n      if (!$textarea.data('original-height')) {\n        $textarea.data('original-height', $textarea.height());\n      }\n\n      if ($textarea.attr('wrap') === 'off') {\n        hiddenDiv.css('overflow-wrap', 'normal').css('white-space', 'pre');\n      }\n\n      hiddenDiv.text($textarea[0].value + '\\n');\n      var content = hiddenDiv.html().replace(/\\n/g, '<br>');\n      hiddenDiv.html(content); // When textarea is hidden, width goes crazy.\n      // Approximate with half of window size\n\n      if ($textarea[0].offsetWidth > 0 && $textarea[0].offsetHeight > 0) {\n        hiddenDiv.css('width', $textarea.width() + 'px');\n      } else {\n        hiddenDiv.css('width', window.innerWidth / 2 + 'px');\n      }\n      /**\n       * Resize if the new height is greater than the\n       * original height of the textarea\n       */\n\n\n      if ($textarea.data('original-height') <= hiddenDiv.innerHeight()) {\n        $textarea.css('height', hiddenDiv.innerHeight() + 'px');\n      } else if ($textarea[0].value.length < $textarea.data('previous-length')) {\n        /**\n         * In case the new height is less than original height, it\n         * means the textarea has less text than before\n         * So we set the height to the original one\n         */\n        $textarea.css('height', $textarea.data('original-height') + 'px');\n      }\n\n      $textarea.data('previous-length', $textarea[0].value.length);\n    };\n\n    $(document).ready(function () {\n      // Text based inputs\n      var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea'; // Add active if form auto complete\n\n      $(document).on('change', input_selector, function () {\n        if (this.value.length !== 0 || $(this).attr('placeholder') !== null) {\n          $(this).siblings('label').addClass('active');\n        }\n\n        M.validate_field($(this));\n      }); // Add active if input element has been pre-populated on document ready\n\n      $(document).ready(function () {\n        M.updateTextFields();\n      }); // HTML DOM FORM RESET handling\n\n      $(document).on('reset', function (e) {\n        var formReset = $(e.target);\n\n        if (formReset.is('form')) {\n          formReset.find(input_selector).removeClass('valid').removeClass('invalid');\n          formReset.find(input_selector).each(function (e) {\n            if (this.value.length) {\n              $(this).siblings('label').removeClass('active');\n            }\n          }); // Reset select (after native reset)\n\n          setTimeout(function () {\n            formReset.find('select').each(function () {\n              // check if initialized\n              if (this.M_FormSelect) {\n                $(this).trigger('change');\n              }\n            });\n          }, 0);\n        }\n      });\n      /**\n       * Add active when element has focus\n       * @param {Event} e\n       */\n\n      document.addEventListener('focus', function (e) {\n        if ($(e.target).is(input_selector)) {\n          $(e.target).siblings('label, .prefix').addClass('active');\n        }\n      }, true);\n      /**\n       * Remove active when element is blurred\n       * @param {Event} e\n       */\n\n      document.addEventListener('blur', function (e) {\n        var $inputElement = $(e.target);\n\n        if ($inputElement.is(input_selector)) {\n          var selector = '.prefix';\n\n          if ($inputElement[0].value.length === 0 && $inputElement[0].validity.badInput !== true && $inputElement.attr('placeholder') === null) {\n            selector += ', label';\n          }\n\n          $inputElement.siblings(selector).removeClass('active');\n          M.validate_field($inputElement);\n        }\n      }, true); // Radio and Checkbox focus class\n\n      var radio_checkbox = 'input[type=radio], input[type=checkbox]';\n      $(document).on('keyup', radio_checkbox, function (e) {\n        // TAB, check if tabbing to radio or checkbox.\n        if (e.which === M.keys.TAB) {\n          $(this).addClass('tabbed');\n          var $this = $(this);\n          $this.one('blur', function (e) {\n            $(this).removeClass('tabbed');\n          });\n          return;\n        }\n      });\n      var text_area_selector = '.materialize-textarea';\n      $(text_area_selector).each(function () {\n        var $textarea = $(this);\n        /**\n         * Resize textarea on document load after storing\n         * the original height and the original length\n         */\n\n        $textarea.data('original-height', $textarea.height());\n        $textarea.data('previous-length', this.value.length);\n        M.textareaAutoResize($textarea);\n      });\n      $(document).on('keyup', text_area_selector, function () {\n        M.textareaAutoResize($(this));\n      });\n      $(document).on('keydown', text_area_selector, function () {\n        M.textareaAutoResize($(this));\n      }); // File Input Path\n\n      $(document).on('change', '.file-field input[type=\"file\"]', function () {\n        var file_field = $(this).closest('.file-field');\n        var path_input = file_field.find('input.file-path');\n        var files = $(this)[0].files;\n        var file_names = [];\n\n        for (var i = 0; i < files.length; i++) {\n          file_names.push(files[i].name);\n        }\n\n        path_input[0].value = file_names.join(', ');\n        path_input.trigger('change');\n      });\n    }); // End of $(document).ready\n  })(cash);\n\n  ;\n\n  (function ($, anim) {\n    'use strict';\n\n    var _defaults = {\n      direction: 'top',\n      hoverEnabled: true,\n      toolbarEnabled: false\n    };\n    $.fn.reverse = [].reverse;\n    /**\n     * @class\n     *\n     */\n\n    var FloatingActionButton = function (_Component3) {\n      _inherits(FloatingActionButton, _Component3);\n      /**\n       * Construct FloatingActionButton instance\n       * @constructor\n       * @param {Element} el\n       * @param {Object} options\n       */\n\n\n      function FloatingActionButton(el, options) {\n        _classCallCheck(this, FloatingActionButton);\n\n        var _this10 = _possibleConstructorReturn(this, (FloatingActionButton.__proto__ || Object.getPrototypeOf(FloatingActionButton)).call(this, FloatingActionButton, el, options));\n\n        _this10.el.M_FloatingActionButton = _this10;\n        /**\n         * Options for the fab\n         * @member FloatingActionButton#options\n         * @prop {Boolean} [direction] - Direction fab menu opens\n         * @prop {Boolean} [hoverEnabled=true] - Enable hover vs click\n         * @prop {Boolean} [toolbarEnabled=false] - Enable toolbar transition\n         */\n\n        _this10.options = $.extend({}, FloatingActionButton.defaults, options);\n        _this10.isOpen = false;\n        _this10.$anchor = _this10.$el.children('a').first();\n        _this10.$menu = _this10.$el.children('ul').first();\n        _this10.$floatingBtns = _this10.$el.find('ul .btn-floating');\n        _this10.$floatingBtnsReverse = _this10.$el.find('ul .btn-floating').reverse();\n        _this10.offsetY = 0;\n        _this10.offsetX = 0;\n\n        _this10.$el.addClass(\"direction-\" + _this10.options.direction);\n\n        if (_this10.options.direction === 'top') {\n          _this10.offsetY = 40;\n        } else if (_this10.options.direction === 'right') {\n          _this10.offsetX = -40;\n        } else if (_this10.options.direction === 'bottom') {\n          _this10.offsetY = -40;\n        } else {\n          _this10.offsetX = 40;\n        }\n\n        _this10._setupEventHandlers();\n\n        return _this10;\n      }\n\n      _createClass(FloatingActionButton, [{\n        key: \"destroy\",\n\n        /**\n         * Teardown component\n         */\n        value: function destroy() {\n          this._removeEventHandlers();\n\n          this.el.M_FloatingActionButton = undefined;\n        }\n        /**\n         * Setup Event Handlers\n         */\n\n      }, {\n        key: \"_setupEventHandlers\",\n        value: function _setupEventHandlers() {\n          this._handleFABClickBound = this._handleFABClick.bind(this);\n          this._handleOpenBound = this.open.bind(this);\n          this._handleCloseBound = this.close.bind(this);\n\n          if (this.options.hoverEnabled && !this.options.toolbarEnabled) {\n            this.el.addEventListener('mouseenter', this._handleOpenBound);\n            this.el.addEventListener('mouseleave', this._handleCloseBound);\n          } else {\n            this.el.addEventListener('click', this._handleFABClickBound);\n          }\n        }\n        /**\n         * Remove Event Handlers\n         */\n\n      }, {\n        key: \"_removeEventHandlers\",\n        value: function _removeEventHandlers() {\n          if (this.options.hoverEnabled && !this.options.toolbarEnabled) {\n            this.el.removeEventListener('mouseenter', this._handleOpenBound);\n            this.el.removeEventListener('mouseleave', this._handleCloseBound);\n          } else {\n            this.el.removeEventListener('click', this._handleFABClickBound);\n          }\n        }\n        /**\n         * Handle FAB Click\n         */\n\n      }, {\n        key: \"_handleFABClick\",\n        value: function _handleFABClick() {\n          if (this.isOpen) {\n            this.close();\n          } else {\n            this.open();\n          }\n        }\n        /**\n         * Handle Document Click\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleDocumentClick\",\n        value: function _handleDocumentClick(e) {\n          if (!$(e.target).closest(this.$menu).length) {\n            this.close();\n          }\n        }\n        /**\n         * Open FAB\n         */\n\n      }, {\n        key: \"open\",\n        value: function open() {\n          if (this.isOpen) {\n            return;\n          }\n\n          if (this.options.toolbarEnabled) {\n            this._animateInToolbar();\n          } else {\n            this._animateInFAB();\n          }\n\n          this.isOpen = true;\n        }\n        /**\n         * Close FAB\n         */\n\n      }, {\n        key: \"close\",\n        value: function close() {\n          if (!this.isOpen) {\n            return;\n          }\n\n          if (this.options.toolbarEnabled) {\n            window.removeEventListener('scroll', this._handleCloseBound, true);\n            document.body.removeEventListener('click', this._handleDocumentClickBound, true);\n\n            this._animateOutToolbar();\n          } else {\n            this._animateOutFAB();\n          }\n\n          this.isOpen = false;\n        }\n        /**\n         * Classic FAB Menu open\n         */\n\n      }, {\n        key: \"_animateInFAB\",\n        value: function _animateInFAB() {\n          var _this11 = this;\n\n          this.$el.addClass('active');\n          var time = 0;\n          this.$floatingBtnsReverse.each(function (el) {\n            anim({\n              targets: el,\n              opacity: 1,\n              scale: [0.4, 1],\n              translateY: [_this11.offsetY, 0],\n              translateX: [_this11.offsetX, 0],\n              duration: 275,\n              delay: time,\n              easing: 'easeInOutQuad'\n            });\n            time += 40;\n          });\n        }\n        /**\n         * Classic FAB Menu close\n         */\n\n      }, {\n        key: \"_animateOutFAB\",\n        value: function _animateOutFAB() {\n          var _this12 = this;\n\n          this.$floatingBtnsReverse.each(function (el) {\n            anim.remove(el);\n            anim({\n              targets: el,\n              opacity: 0,\n              scale: 0.4,\n              translateY: _this12.offsetY,\n              translateX: _this12.offsetX,\n              duration: 175,\n              easing: 'easeOutQuad',\n              complete: function () {\n                _this12.$el.removeClass('active');\n              }\n            });\n          });\n        }\n        /**\n         * Toolbar transition Menu open\n         */\n\n      }, {\n        key: \"_animateInToolbar\",\n        value: function _animateInToolbar() {\n          var _this13 = this;\n\n          var scaleFactor = void 0;\n          var windowWidth = window.innerWidth;\n          var windowHeight = window.innerHeight;\n          var btnRect = this.el.getBoundingClientRect();\n          var backdrop = $('<div class=\"fab-backdrop\"></div>');\n          var fabColor = this.$anchor.css('background-color');\n          this.$anchor.append(backdrop);\n          this.offsetX = btnRect.left - windowWidth / 2 + btnRect.width / 2;\n          this.offsetY = windowHeight - btnRect.bottom;\n          scaleFactor = windowWidth / backdrop[0].clientWidth;\n          this.btnBottom = btnRect.bottom;\n          this.btnLeft = btnRect.left;\n          this.btnWidth = btnRect.width; // Set initial state\n\n          this.$el.addClass('active');\n          this.$el.css({\n            'text-align': 'center',\n            width: '100%',\n            bottom: 0,\n            left: 0,\n            transform: 'translateX(' + this.offsetX + 'px)',\n            transition: 'none'\n          });\n          this.$anchor.css({\n            transform: 'translateY(' + -this.offsetY + 'px)',\n            transition: 'none'\n          });\n          backdrop.css({\n            'background-color': fabColor\n          });\n          setTimeout(function () {\n            _this13.$el.css({\n              transform: '',\n              transition: 'transform .2s cubic-bezier(0.550, 0.085, 0.680, 0.530), background-color 0s linear .2s'\n            });\n\n            _this13.$anchor.css({\n              overflow: 'visible',\n              transform: '',\n              transition: 'transform .2s'\n            });\n\n            setTimeout(function () {\n              _this13.$el.css({\n                overflow: 'hidden',\n                'background-color': fabColor\n              });\n\n              backdrop.css({\n                transform: 'scale(' + scaleFactor + ')',\n                transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'\n              });\n\n              _this13.$menu.children('li').children('a').css({\n                opacity: 1\n              }); // Scroll to close.\n\n\n              _this13._handleDocumentClickBound = _this13._handleDocumentClick.bind(_this13);\n              window.addEventListener('scroll', _this13._handleCloseBound, true);\n              document.body.addEventListener('click', _this13._handleDocumentClickBound, true);\n            }, 100);\n          }, 0);\n        }\n        /**\n         * Toolbar transition Menu close\n         */\n\n      }, {\n        key: \"_animateOutToolbar\",\n        value: function _animateOutToolbar() {\n          var _this14 = this;\n\n          var windowWidth = window.innerWidth;\n          var windowHeight = window.innerHeight;\n          var backdrop = this.$el.find('.fab-backdrop');\n          var fabColor = this.$anchor.css('background-color');\n          this.offsetX = this.btnLeft - windowWidth / 2 + this.btnWidth / 2;\n          this.offsetY = windowHeight - this.btnBottom; // Hide backdrop\n\n          this.$el.removeClass('active');\n          this.$el.css({\n            'background-color': 'transparent',\n            transition: 'none'\n          });\n          this.$anchor.css({\n            transition: 'none'\n          });\n          backdrop.css({\n            transform: 'scale(0)',\n            'background-color': fabColor\n          });\n          this.$menu.children('li').children('a').css({\n            opacity: ''\n          });\n          setTimeout(function () {\n            backdrop.remove(); // Set initial state.\n\n            _this14.$el.css({\n              'text-align': '',\n              width: '',\n              bottom: '',\n              left: '',\n              overflow: '',\n              'background-color': '',\n              transform: 'translate3d(' + -_this14.offsetX + 'px,0,0)'\n            });\n\n            _this14.$anchor.css({\n              overflow: '',\n              transform: 'translate3d(0,' + _this14.offsetY + 'px,0)'\n            });\n\n            setTimeout(function () {\n              _this14.$el.css({\n                transform: 'translate3d(0,0,0)',\n                transition: 'transform .2s'\n              });\n\n              _this14.$anchor.css({\n                transform: 'translate3d(0,0,0)',\n                transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'\n              });\n            }, 20);\n          }, 200);\n        }\n      }], [{\n        key: \"init\",\n        value: function init(els, options) {\n          return _get(FloatingActionButton.__proto__ || Object.getPrototypeOf(FloatingActionButton), \"init\", this).call(this, this, els, options);\n        }\n        /**\n         * Get Instance\n         */\n\n      }, {\n        key: \"getInstance\",\n        value: function getInstance(el) {\n          var domElem = !!el.jquery ? el[0] : el;\n          return domElem.M_FloatingActionButton;\n        }\n      }, {\n        key: \"defaults\",\n        get: function () {\n          return _defaults;\n        }\n      }]);\n\n      return FloatingActionButton;\n    }(Component);\n\n    M.FloatingActionButton = FloatingActionButton;\n\n    if (M.jQueryLoaded) {\n      M.initializeJqueryWrapper(FloatingActionButton, 'floatingActionButton', 'M_FloatingActionButton');\n    }\n  })(cash, M.anime);\n\n  ;\n\n  (function ($) {\n    'use strict';\n\n    var _defaults = {\n      // Close when date is selected\n      autoClose: false,\n      // the default output format for the input field value\n      format: 'mmm dd, yyyy',\n      // Used to create date object from current input string\n      parse: null,\n      // The initial date to view when first opened\n      defaultDate: null,\n      // Make the `defaultDate` the initial selected value\n      setDefaultDate: false,\n      disableWeekends: false,\n      disableDayFn: null,\n      // First day of week (0: Sunday, 1: Monday etc)\n      firstDay: 0,\n      // The earliest date that can be selected\n      minDate: null,\n      // Thelatest date that can be selected\n      maxDate: null,\n      // Number of years either side, or array of upper/lower range\n      yearRange: 10,\n      // used internally (don't config outside)\n      minYear: 0,\n      maxYear: 9999,\n      minMonth: undefined,\n      maxMonth: undefined,\n      startRange: null,\n      endRange: null,\n      isRTL: false,\n      // Render the month after year in the calendar title\n      showMonthAfterYear: false,\n      // Render days of the calendar grid that fall in the next or previous month\n      showDaysInNextAndPreviousMonths: false,\n      // Specify a DOM element to render the calendar in\n      container: null,\n      // Show clear button\n      showClearBtn: false,\n      // internationalization\n      i18n: {\n        cancel: 'Cancel',\n        clear: 'Clear',\n        done: 'Ok',\n        previousMonth: '‹',\n        nextMonth: '›',\n        months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n        monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n        weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n        weekdaysAbbrev: ['S', 'M', 'T', 'W', 'T', 'F', 'S']\n      },\n      // events array\n      events: [],\n      // callback function\n      onSelect: null,\n      onOpen: null,\n      onClose: null,\n      onDraw: null\n    };\n    /**\n     * @class\n     *\n     */\n\n    var Datepicker = function (_Component4) {\n      _inherits(Datepicker, _Component4);\n      /**\n       * Construct Datepicker instance and set up overlay\n       * @constructor\n       * @param {Element} el\n       * @param {Object} options\n       */\n\n\n      function Datepicker(el, options) {\n        _classCallCheck(this, Datepicker);\n\n        var _this15 = _possibleConstructorReturn(this, (Datepicker.__proto__ || Object.getPrototypeOf(Datepicker)).call(this, Datepicker, el, options));\n\n        _this15.el.M_Datepicker = _this15;\n        _this15.options = $.extend({}, Datepicker.defaults, options); // make sure i18n defaults are not lost when only few i18n option properties are passed\n\n        if (!!options && options.hasOwnProperty('i18n') && typeof options.i18n === 'object') {\n          _this15.options.i18n = $.extend({}, Datepicker.defaults.i18n, options.i18n);\n        } // Remove time component from minDate and maxDate options\n\n\n        if (_this15.options.minDate) _this15.options.minDate.setHours(0, 0, 0, 0);\n        if (_this15.options.maxDate) _this15.options.maxDate.setHours(0, 0, 0, 0);\n        _this15.id = M.guid();\n\n        _this15._setupVariables();\n\n        _this15._insertHTMLIntoDOM();\n\n        _this15._setupModal();\n\n        _this15._setupEventHandlers();\n\n        if (!_this15.options.defaultDate) {\n          _this15.options.defaultDate = new Date(Date.parse(_this15.el.value));\n        }\n\n        var defDate = _this15.options.defaultDate;\n\n        if (Datepicker._isDate(defDate)) {\n          if (_this15.options.setDefaultDate) {\n            _this15.setDate(defDate, true);\n\n            _this15.setInputValue();\n          } else {\n            _this15.gotoDate(defDate);\n          }\n        } else {\n          _this15.gotoDate(new Date());\n        }\n        /**\n         * Describes open/close state of datepicker\n         * @type {Boolean}\n         */\n\n\n        _this15.isOpen = false;\n        return _this15;\n      }\n\n      _createClass(Datepicker, [{\n        key: \"destroy\",\n\n        /**\n         * Teardown component\n         */\n        value: function destroy() {\n          this._removeEventHandlers();\n\n          this.modal.destroy();\n          $(this.modalEl).remove();\n          this.destroySelects();\n          this.el.M_Datepicker = undefined;\n        }\n      }, {\n        key: \"destroySelects\",\n        value: function destroySelects() {\n          var oldYearSelect = this.calendarEl.querySelector('.orig-select-year');\n\n          if (oldYearSelect) {\n            M.FormSelect.getInstance(oldYearSelect).destroy();\n          }\n\n          var oldMonthSelect = this.calendarEl.querySelector('.orig-select-month');\n\n          if (oldMonthSelect) {\n            M.FormSelect.getInstance(oldMonthSelect).destroy();\n          }\n        }\n      }, {\n        key: \"_insertHTMLIntoDOM\",\n        value: function _insertHTMLIntoDOM() {\n          if (this.options.showClearBtn) {\n            $(this.clearBtn).css({\n              visibility: ''\n            });\n            this.clearBtn.innerHTML = this.options.i18n.clear;\n          }\n\n          this.doneBtn.innerHTML = this.options.i18n.done;\n          this.cancelBtn.innerHTML = this.options.i18n.cancel;\n\n          if (this.options.container) {\n            this.$modalEl.appendTo(this.options.container);\n          } else {\n            this.$modalEl.insertBefore(this.el);\n          }\n        }\n      }, {\n        key: \"_setupModal\",\n        value: function _setupModal() {\n          var _this16 = this;\n\n          this.modalEl.id = 'modal-' + this.id;\n          this.modal = M.Modal.init(this.modalEl, {\n            onCloseEnd: function () {\n              _this16.isOpen = false;\n            }\n          });\n        }\n      }, {\n        key: \"toString\",\n        value: function toString(format) {\n          var _this17 = this;\n\n          format = format || this.options.format;\n\n          if (!Datepicker._isDate(this.date)) {\n            return '';\n          }\n\n          var formatArray = format.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);\n          var formattedDate = formatArray.map(function (label) {\n            if (_this17.formats[label]) {\n              return _this17.formats[label]();\n            }\n\n            return label;\n          }).join('');\n          return formattedDate;\n        }\n      }, {\n        key: \"setDate\",\n        value: function setDate(date, preventOnSelect) {\n          if (!date) {\n            this.date = null;\n\n            this._renderDateDisplay();\n\n            return this.draw();\n          }\n\n          if (typeof date === 'string') {\n            date = new Date(Date.parse(date));\n          }\n\n          if (!Datepicker._isDate(date)) {\n            return;\n          }\n\n          var min = this.options.minDate,\n              max = this.options.maxDate;\n\n          if (Datepicker._isDate(min) && date < min) {\n            date = min;\n          } else if (Datepicker._isDate(max) && date > max) {\n            date = max;\n          }\n\n          this.date = new Date(date.getTime());\n\n          this._renderDateDisplay();\n\n          Datepicker._setToStartOfDay(this.date);\n\n          this.gotoDate(this.date);\n\n          if (!preventOnSelect && typeof this.options.onSelect === 'function') {\n            this.options.onSelect.call(this, this.date);\n          }\n        }\n      }, {\n        key: \"setInputValue\",\n        value: function setInputValue() {\n          this.el.value = this.toString();\n          this.$el.trigger('change', {\n            firedBy: this\n          });\n        }\n      }, {\n        key: \"_renderDateDisplay\",\n        value: function _renderDateDisplay() {\n          var displayDate = Datepicker._isDate(this.date) ? this.date : new Date();\n          var i18n = this.options.i18n;\n          var day = i18n.weekdaysShort[displayDate.getDay()];\n          var month = i18n.monthsShort[displayDate.getMonth()];\n          var date = displayDate.getDate();\n          this.yearTextEl.innerHTML = displayDate.getFullYear();\n          this.dateTextEl.innerHTML = day + \", \" + month + \" \" + date;\n        }\n        /**\n         * change view to a specific date\n         */\n\n      }, {\n        key: \"gotoDate\",\n        value: function gotoDate(date) {\n          var newCalendar = true;\n\n          if (!Datepicker._isDate(date)) {\n            return;\n          }\n\n          if (this.calendars) {\n            var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),\n                lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1),\n                visibleDate = date.getTime(); // get the end of the month\n\n            lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);\n            lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);\n            newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;\n          }\n\n          if (newCalendar) {\n            this.calendars = [{\n              month: date.getMonth(),\n              year: date.getFullYear()\n            }];\n          }\n\n          this.adjustCalendars();\n        }\n      }, {\n        key: \"adjustCalendars\",\n        value: function adjustCalendars() {\n          this.calendars[0] = this.adjustCalendar(this.calendars[0]);\n          this.draw();\n        }\n      }, {\n        key: \"adjustCalendar\",\n        value: function adjustCalendar(calendar) {\n          if (calendar.month < 0) {\n            calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);\n            calendar.month += 12;\n          }\n\n          if (calendar.month > 11) {\n            calendar.year += Math.floor(Math.abs(calendar.month) / 12);\n            calendar.month -= 12;\n          }\n\n          return calendar;\n        }\n      }, {\n        key: \"nextMonth\",\n        value: function nextMonth() {\n          this.calendars[0].month++;\n          this.adjustCalendars();\n        }\n      }, {\n        key: \"prevMonth\",\n        value: function prevMonth() {\n          this.calendars[0].month--;\n          this.adjustCalendars();\n        }\n      }, {\n        key: \"render\",\n        value: function render(year, month, randId) {\n          var opts = this.options,\n              now = new Date(),\n              days = Datepicker._getDaysInMonth(year, month),\n              before = new Date(year, month, 1).getDay(),\n              data = [],\n              row = [];\n\n          Datepicker._setToStartOfDay(now);\n\n          if (opts.firstDay > 0) {\n            before -= opts.firstDay;\n\n            if (before < 0) {\n              before += 7;\n            }\n          }\n\n          var previousMonth = month === 0 ? 11 : month - 1,\n              nextMonth = month === 11 ? 0 : month + 1,\n              yearOfPreviousMonth = month === 0 ? year - 1 : year,\n              yearOfNextMonth = month === 11 ? year + 1 : year,\n              daysInPreviousMonth = Datepicker._getDaysInMonth(yearOfPreviousMonth, previousMonth);\n\n          var cells = days + before,\n              after = cells;\n\n          while (after > 7) {\n            after -= 7;\n          }\n\n          cells += 7 - after;\n          var isWeekSelected = false;\n\n          for (var i = 0, r = 0; i < cells; i++) {\n            var day = new Date(year, month, 1 + (i - before)),\n                isSelected = Datepicker._isDate(this.date) ? Datepicker._compareDates(day, this.date) : false,\n                isToday = Datepicker._compareDates(day, now),\n                hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,\n                isEmpty = i < before || i >= days + before,\n                dayNumber = 1 + (i - before),\n                monthNumber = month,\n                yearNumber = year,\n                isStartRange = opts.startRange && Datepicker._compareDates(opts.startRange, day),\n                isEndRange = opts.endRange && Datepicker._compareDates(opts.endRange, day),\n                isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,\n                isDisabled = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && Datepicker._isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);\n\n            if (isEmpty) {\n              if (i < before) {\n                dayNumber = daysInPreviousMonth + dayNumber;\n                monthNumber = previousMonth;\n                yearNumber = yearOfPreviousMonth;\n              } else {\n                dayNumber = dayNumber - days;\n                monthNumber = nextMonth;\n                yearNumber = yearOfNextMonth;\n              }\n            }\n\n            var dayConfig = {\n              day: dayNumber,\n              month: monthNumber,\n              year: yearNumber,\n              hasEvent: hasEvent,\n              isSelected: isSelected,\n              isToday: isToday,\n              isDisabled: isDisabled,\n              isEmpty: isEmpty,\n              isStartRange: isStartRange,\n              isEndRange: isEndRange,\n              isInRange: isInRange,\n              showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths\n            };\n            row.push(this.renderDay(dayConfig));\n\n            if (++r === 7) {\n              data.push(this.renderRow(row, opts.isRTL, isWeekSelected));\n              row = [];\n              r = 0;\n              isWeekSelected = false;\n            }\n          }\n\n          return this.renderTable(opts, data, randId);\n        }\n      }, {\n        key: \"renderDay\",\n        value: function renderDay(opts) {\n          var arr = [];\n          var ariaSelected = 'false';\n\n          if (opts.isEmpty) {\n            if (opts.showDaysInNextAndPreviousMonths) {\n              arr.push('is-outside-current-month');\n              arr.push('is-selection-disabled');\n            } else {\n              return '<td class=\"is-empty\"></td>';\n            }\n          }\n\n          if (opts.isDisabled) {\n            arr.push('is-disabled');\n          }\n\n          if (opts.isToday) {\n            arr.push('is-today');\n          }\n\n          if (opts.isSelected) {\n            arr.push('is-selected');\n            ariaSelected = 'true';\n          }\n\n          if (opts.hasEvent) {\n            arr.push('has-event');\n          }\n\n          if (opts.isInRange) {\n            arr.push('is-inrange');\n          }\n\n          if (opts.isStartRange) {\n            arr.push('is-startrange');\n          }\n\n          if (opts.isEndRange) {\n            arr.push('is-endrange');\n          }\n\n          return \"<td data-day=\\\"\" + opts.day + \"\\\" class=\\\"\" + arr.join(' ') + \"\\\" aria-selected=\\\"\" + ariaSelected + \"\\\">\" + (\"<button class=\\\"datepicker-day-button\\\" type=\\\"button\\\" data-year=\\\"\" + opts.year + \"\\\" data-month=\\\"\" + opts.month + \"\\\" data-day=\\\"\" + opts.day + \"\\\">\" + opts.day + \"</button>\") + '</td>';\n        }\n      }, {\n        key: \"renderRow\",\n        value: function renderRow(days, isRTL, isRowSelected) {\n          return '<tr class=\"datepicker-row' + (isRowSelected ? ' is-selected' : '') + '\">' + (isRTL ? days.reverse() : days).join('') + '</tr>';\n        }\n      }, {\n        key: \"renderTable\",\n        value: function renderTable(opts, data, randId) {\n          return '<div class=\"datepicker-table-wrapper\"><table cellpadding=\"0\" cellspacing=\"0\" class=\"datepicker-table\" role=\"grid\" aria-labelledby=\"' + randId + '\">' + this.renderHead(opts) + this.renderBody(data) + '</table></div>';\n        }\n      }, {\n        key: \"renderHead\",\n        value: function renderHead(opts) {\n          var i = void 0,\n              arr = [];\n\n          for (i = 0; i < 7; i++) {\n            arr.push(\"<th scope=\\\"col\\\"><abbr title=\\\"\" + this.renderDayName(opts, i) + \"\\\">\" + this.renderDayName(opts, i, true) + \"</abbr></th>\");\n          }\n\n          return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';\n        }\n      }, {\n        key: \"renderBody\",\n        value: function renderBody(rows) {\n          return '<tbody>' + rows.join('') + '</tbody>';\n        }\n      }, {\n        key: \"renderTitle\",\n        value: function renderTitle(instance, c, year, month, refYear, randId) {\n          var i = void 0,\n              j = void 0,\n              arr = void 0,\n              opts = this.options,\n              isMinYear = year === opts.minYear,\n              isMaxYear = year === opts.maxYear,\n              html = '<div id=\"' + randId + '\" class=\"datepicker-controls\" role=\"heading\" aria-live=\"assertive\">',\n              monthHtml = void 0,\n              yearHtml = void 0,\n              prev = true,\n              next = true;\n\n          for (arr = [], i = 0; i < 12; i++) {\n            arr.push('<option value=\"' + (year === refYear ? i - c : 12 + i - c) + '\"' + (i === month ? ' selected=\"selected\"' : '') + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? 'disabled=\"disabled\"' : '') + '>' + opts.i18n.months[i] + '</option>');\n          }\n\n          monthHtml = '<select class=\"datepicker-select orig-select-month\" tabindex=\"-1\">' + arr.join('') + '</select>';\n\n          if ($.isArray(opts.yearRange)) {\n            i = opts.yearRange[0];\n            j = opts.yearRange[1] + 1;\n          } else {\n            i = year - opts.yearRange;\n            j = 1 + year + opts.yearRange;\n          }\n\n          for (arr = []; i < j && i <= opts.maxYear; i++) {\n            if (i >= opts.minYear) {\n              arr.push(\"<option value=\\\"\" + i + \"\\\" \" + (i === year ? 'selected=\"selected\"' : '') + \">\" + i + \"</option>\");\n            }\n          }\n\n          yearHtml = \"<select class=\\\"datepicker-select orig-select-year\\\" tabindex=\\\"-1\\\">\" + arr.join('') + \"</select>\";\n          var leftArrow = '<svg fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z\"/><path d=\"M0-.5h24v24H0z\" fill=\"none\"/></svg>';\n          html += \"<button class=\\\"month-prev\" + (prev ? '' : ' is-disabled') + \"\\\" type=\\\"button\\\">\" + leftArrow + \"</button>\";\n          html += '<div class=\"selects-container\">';\n\n          if (opts.showMonthAfterYear) {\n            html += yearHtml + monthHtml;\n          } else {\n            html += monthHtml + yearHtml;\n          }\n\n          html += '</div>';\n\n          if (isMinYear && (month === 0 || opts.minMonth >= month)) {\n            prev = false;\n          }\n\n          if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {\n            next = false;\n          }\n\n          var rightArrow = '<svg fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z\"/><path d=\"M0-.25h24v24H0z\" fill=\"none\"/></svg>';\n          html += \"<button class=\\\"month-next\" + (next ? '' : ' is-disabled') + \"\\\" type=\\\"button\\\">\" + rightArrow + \"</button>\";\n          return html += '</div>';\n        }\n        /**\n         * refresh the HTML\n         */\n\n      }, {\n        key: \"draw\",\n        value: function draw(force) {\n          if (!this.isOpen && !force) {\n            return;\n          }\n\n          var opts = this.options,\n              minYear = opts.minYear,\n              maxYear = opts.maxYear,\n              minMonth = opts.minMonth,\n              maxMonth = opts.maxMonth,\n              html = '',\n              randId = void 0;\n\n          if (this._y <= minYear) {\n            this._y = minYear;\n\n            if (!isNaN(minMonth) && this._m < minMonth) {\n              this._m = minMonth;\n            }\n          }\n\n          if (this._y >= maxYear) {\n            this._y = maxYear;\n\n            if (!isNaN(maxMonth) && this._m > maxMonth) {\n              this._m = maxMonth;\n            }\n          }\n\n          randId = 'datepicker-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);\n\n          for (var c = 0; c < 1; c++) {\n            this._renderDateDisplay();\n\n            html += this.renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId);\n          }\n\n          this.destroySelects();\n          this.calendarEl.innerHTML = html; // Init Materialize Select\n\n          var yearSelect = this.calendarEl.querySelector('.orig-select-year');\n          var monthSelect = this.calendarEl.querySelector('.orig-select-month');\n          M.FormSelect.init(yearSelect, {\n            classes: 'select-year',\n            dropdownOptions: {\n              container: document.body,\n              constrainWidth: false\n            }\n          });\n          M.FormSelect.init(monthSelect, {\n            classes: 'select-month',\n            dropdownOptions: {\n              container: document.body,\n              constrainWidth: false\n            }\n          }); // Add change handlers for select\n\n          yearSelect.addEventListener('change', this._handleYearChange.bind(this));\n          monthSelect.addEventListener('change', this._handleMonthChange.bind(this));\n\n          if (typeof this.options.onDraw === 'function') {\n            this.options.onDraw(this);\n          }\n        }\n        /**\n         * Setup Event Handlers\n         */\n\n      }, {\n        key: \"_setupEventHandlers\",\n        value: function _setupEventHandlers() {\n          this._handleInputKeydownBound = this._handleInputKeydown.bind(this);\n          this._handleInputClickBound = this._handleInputClick.bind(this);\n          this._handleInputChangeBound = this._handleInputChange.bind(this);\n          this._handleCalendarClickBound = this._handleCalendarClick.bind(this);\n          this._finishSelectionBound = this._finishSelection.bind(this);\n          this._handleMonthChange = this._handleMonthChange.bind(this);\n          this._closeBound = this.close.bind(this);\n          this.el.addEventListener('click', this._handleInputClickBound);\n          this.el.addEventListener('keydown', this._handleInputKeydownBound);\n          this.el.addEventListener('change', this._handleInputChangeBound);\n          this.calendarEl.addEventListener('click', this._handleCalendarClickBound);\n          this.doneBtn.addEventListener('click', this._finishSelectionBound);\n          this.cancelBtn.addEventListener('click', this._closeBound);\n\n          if (this.options.showClearBtn) {\n            this._handleClearClickBound = this._handleClearClick.bind(this);\n            this.clearBtn.addEventListener('click', this._handleClearClickBound);\n          }\n        }\n      }, {\n        key: \"_setupVariables\",\n        value: function _setupVariables() {\n          var _this18 = this;\n\n          this.$modalEl = $(Datepicker._template);\n          this.modalEl = this.$modalEl[0];\n          this.calendarEl = this.modalEl.querySelector('.datepicker-calendar');\n          this.yearTextEl = this.modalEl.querySelector('.year-text');\n          this.dateTextEl = this.modalEl.querySelector('.date-text');\n\n          if (this.options.showClearBtn) {\n            this.clearBtn = this.modalEl.querySelector('.datepicker-clear');\n          }\n\n          this.doneBtn = this.modalEl.querySelector('.datepicker-done');\n          this.cancelBtn = this.modalEl.querySelector('.datepicker-cancel');\n          this.formats = {\n            d: function () {\n              return _this18.date.getDate();\n            },\n            dd: function () {\n              var d = _this18.date.getDate();\n\n              return (d < 10 ? '0' : '') + d;\n            },\n            ddd: function () {\n              return _this18.options.i18n.weekdaysShort[_this18.date.getDay()];\n            },\n            dddd: function () {\n              return _this18.options.i18n.weekdays[_this18.date.getDay()];\n            },\n            m: function () {\n              return _this18.date.getMonth() + 1;\n            },\n            mm: function () {\n              var m = _this18.date.getMonth() + 1;\n              return (m < 10 ? '0' : '') + m;\n            },\n            mmm: function () {\n              return _this18.options.i18n.monthsShort[_this18.date.getMonth()];\n            },\n            mmmm: function () {\n              return _this18.options.i18n.months[_this18.date.getMonth()];\n            },\n            yy: function () {\n              return ('' + _this18.date.getFullYear()).slice(2);\n            },\n            yyyy: function () {\n              return _this18.date.getFullYear();\n            }\n          };\n        }\n        /**\n         * Remove Event Handlers\n         */\n\n      }, {\n        key: \"_removeEventHandlers\",\n        value: function _removeEventHandlers() {\n          this.el.removeEventListener('click', this._handleInputClickBound);\n          this.el.removeEventListener('keydown', this._handleInputKeydownBound);\n          this.el.removeEventListener('change', this._handleInputChangeBound);\n          this.calendarEl.removeEventListener('click', this._handleCalendarClickBound);\n        }\n      }, {\n        key: \"_handleInputClick\",\n        value: function _handleInputClick() {\n          this.open();\n        }\n      }, {\n        key: \"_handleInputKeydown\",\n        value: function _handleInputKeydown(e) {\n          if (e.which === M.keys.ENTER) {\n            e.preventDefault();\n            this.open();\n          }\n        }\n      }, {\n        key: \"_handleCalendarClick\",\n        value: function _handleCalendarClick(e) {\n          if (!this.isOpen) {\n            return;\n          }\n\n          var $target = $(e.target);\n\n          if (!$target.hasClass('is-disabled')) {\n            if ($target.hasClass('datepicker-day-button') && !$target.hasClass('is-empty') && !$target.parent().hasClass('is-disabled')) {\n              this.setDate(new Date(e.target.getAttribute('data-year'), e.target.getAttribute('data-month'), e.target.getAttribute('data-day')));\n\n              if (this.options.autoClose) {\n                this._finishSelection();\n              }\n            } else if ($target.closest('.month-prev').length) {\n              this.prevMonth();\n            } else if ($target.closest('.month-next').length) {\n              this.nextMonth();\n            }\n          }\n        }\n      }, {\n        key: \"_handleClearClick\",\n        value: function _handleClearClick() {\n          this.date = null;\n          this.setInputValue();\n          this.close();\n        }\n      }, {\n        key: \"_handleMonthChange\",\n        value: function _handleMonthChange(e) {\n          this.gotoMonth(e.target.value);\n        }\n      }, {\n        key: \"_handleYearChange\",\n        value: function _handleYearChange(e) {\n          this.gotoYear(e.target.value);\n        }\n        /**\n         * change view to a specific month (zero-index, e.g. 0: January)\n         */\n\n      }, {\n        key: \"gotoMonth\",\n        value: function gotoMonth(month) {\n          if (!isNaN(month)) {\n            this.calendars[0].month = parseInt(month, 10);\n            this.adjustCalendars();\n          }\n        }\n        /**\n         * change view to a specific full year (e.g. \"2012\")\n         */\n\n      }, {\n        key: \"gotoYear\",\n        value: function gotoYear(year) {\n          if (!isNaN(year)) {\n            this.calendars[0].year = parseInt(year, 10);\n            this.adjustCalendars();\n          }\n        }\n      }, {\n        key: \"_handleInputChange\",\n        value: function _handleInputChange(e) {\n          var date = void 0; // Prevent change event from being fired when triggered by the plugin\n\n          if (e.firedBy === this) {\n            return;\n          }\n\n          if (this.options.parse) {\n            date = this.options.parse(this.el.value, this.options.format);\n          } else {\n            date = new Date(Date.parse(this.el.value));\n          }\n\n          if (Datepicker._isDate(date)) {\n            this.setDate(date);\n          }\n        }\n      }, {\n        key: \"renderDayName\",\n        value: function renderDayName(opts, day, abbr) {\n          day += opts.firstDay;\n\n          while (day >= 7) {\n            day -= 7;\n          }\n\n          return abbr ? opts.i18n.weekdaysAbbrev[day] : opts.i18n.weekdays[day];\n        }\n        /**\n         * Set input value to the selected date and close Datepicker\n         */\n\n      }, {\n        key: \"_finishSelection\",\n        value: function _finishSelection() {\n          this.setInputValue();\n          this.close();\n        }\n        /**\n         * Open Datepicker\n         */\n\n      }, {\n        key: \"open\",\n        value: function open() {\n          if (this.isOpen) {\n            return;\n          }\n\n          this.isOpen = true;\n\n          if (typeof this.options.onOpen === 'function') {\n            this.options.onOpen.call(this);\n          }\n\n          this.draw();\n          this.modal.open();\n          return this;\n        }\n        /**\n         * Close Datepicker\n         */\n\n      }, {\n        key: \"close\",\n        value: function close() {\n          if (!this.isOpen) {\n            return;\n          }\n\n          this.isOpen = false;\n\n          if (typeof this.options.onClose === 'function') {\n            this.options.onClose.call(this);\n          }\n\n          this.modal.close();\n          return this;\n        }\n      }], [{\n        key: \"init\",\n        value: function init(els, options) {\n          return _get(Datepicker.__proto__ || Object.getPrototypeOf(Datepicker), \"init\", this).call(this, this, els, options);\n        }\n      }, {\n        key: \"_isDate\",\n        value: function _isDate(obj) {\n          return /Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());\n        }\n      }, {\n        key: \"_isWeekend\",\n        value: function _isWeekend(date) {\n          var day = date.getDay();\n          return day === 0 || day === 6;\n        }\n      }, {\n        key: \"_setToStartOfDay\",\n        value: function _setToStartOfDay(date) {\n          if (Datepicker._isDate(date)) date.setHours(0, 0, 0, 0);\n        }\n      }, {\n        key: \"_getDaysInMonth\",\n        value: function _getDaysInMonth(year, month) {\n          return [31, Datepicker._isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n        }\n      }, {\n        key: \"_isLeapYear\",\n        value: function _isLeapYear(year) {\n          // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951\n          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n        }\n      }, {\n        key: \"_compareDates\",\n        value: function _compareDates(a, b) {\n          // weak date comparison (use setToStartOfDay(date) to ensure correct result)\n          return a.getTime() === b.getTime();\n        }\n      }, {\n        key: \"_setToStartOfDay\",\n        value: function _setToStartOfDay(date) {\n          if (Datepicker._isDate(date)) date.setHours(0, 0, 0, 0);\n        }\n        /**\n         * Get Instance\n         */\n\n      }, {\n        key: \"getInstance\",\n        value: function getInstance(el) {\n          var domElem = !!el.jquery ? el[0] : el;\n          return domElem.M_Datepicker;\n        }\n      }, {\n        key: \"defaults\",\n        get: function () {\n          return _defaults;\n        }\n      }]);\n\n      return Datepicker;\n    }(Component);\n\n    Datepicker._template = ['<div class= \"modal datepicker-modal\">', '<div class=\"modal-content datepicker-container\">', '<div class=\"datepicker-date-display\">', '<span class=\"year-text\"></span>', '<span class=\"date-text\"></span>', '</div>', '<div class=\"datepicker-calendar-container\">', '<div class=\"datepicker-calendar\"></div>', '<div class=\"datepicker-footer\">', '<button class=\"btn-flat datepicker-clear waves-effect\" style=\"visibility: hidden;\" type=\"button\"></button>', '<div class=\"confirmation-btns\">', '<button class=\"btn-flat datepicker-cancel waves-effect\" type=\"button\"></button>', '<button class=\"btn-flat datepicker-done waves-effect\" type=\"button\"></button>', '</div>', '</div>', '</div>', '</div>', '</div>'].join('');\n    M.Datepicker = Datepicker;\n\n    if (M.jQueryLoaded) {\n      M.initializeJqueryWrapper(Datepicker, 'datepicker', 'M_Datepicker');\n    }\n  })(cash);\n\n  ;\n\n  (function ($) {\n    'use strict';\n\n    var _defaults = {\n      dialRadius: 135,\n      outerRadius: 105,\n      innerRadius: 70,\n      tickRadius: 20,\n      duration: 350,\n      container: null,\n      defaultTime: 'now',\n      // default time, 'now' or '13:14' e.g.\n      fromNow: 0,\n      // Millisecond offset from the defaultTime\n      showClearBtn: false,\n      // internationalization\n      i18n: {\n        cancel: 'Cancel',\n        clear: 'Clear',\n        done: 'Ok'\n      },\n      autoClose: false,\n      // auto close when minute is selected\n      twelveHour: true,\n      // change to 12 hour AM/PM clock from 24 hour\n      vibrate: true,\n      // vibrate the device when dragging clock hand\n      // Callbacks\n      onOpenStart: null,\n      onOpenEnd: null,\n      onCloseStart: null,\n      onCloseEnd: null,\n      onSelect: null\n    };\n    /**\n     * @class\n     *\n     */\n\n    var Timepicker = function (_Component5) {\n      _inherits(Timepicker, _Component5);\n\n      function Timepicker(el, options) {\n        _classCallCheck(this, Timepicker);\n\n        var _this19 = _possibleConstructorReturn(this, (Timepicker.__proto__ || Object.getPrototypeOf(Timepicker)).call(this, Timepicker, el, options));\n\n        _this19.el.M_Timepicker = _this19;\n        _this19.options = $.extend({}, Timepicker.defaults, options);\n        _this19.id = M.guid();\n\n        _this19._insertHTMLIntoDOM();\n\n        _this19._setupModal();\n\n        _this19._setupVariables();\n\n        _this19._setupEventHandlers();\n\n        _this19._clockSetup();\n\n        _this19._pickerSetup();\n\n        return _this19;\n      }\n\n      _createClass(Timepicker, [{\n        key: \"destroy\",\n\n        /**\n         * Teardown component\n         */\n        value: function destroy() {\n          this._removeEventHandlers();\n\n          this.modal.destroy();\n          $(this.modalEl).remove();\n          this.el.M_Timepicker = undefined;\n        }\n        /**\n         * Setup Event Handlers\n         */\n\n      }, {\n        key: \"_setupEventHandlers\",\n        value: function _setupEventHandlers() {\n          this._handleInputKeydownBound = this._handleInputKeydown.bind(this);\n          this._handleInputClickBound = this._handleInputClick.bind(this);\n          this._handleClockClickStartBound = this._handleClockClickStart.bind(this);\n          this._handleDocumentClickMoveBound = this._handleDocumentClickMove.bind(this);\n          this._handleDocumentClickEndBound = this._handleDocumentClickEnd.bind(this);\n          this.el.addEventListener('click', this._handleInputClickBound);\n          this.el.addEventListener('keydown', this._handleInputKeydownBound);\n          this.plate.addEventListener('mousedown', this._handleClockClickStartBound);\n          this.plate.addEventListener('touchstart', this._handleClockClickStartBound);\n          $(this.spanHours).on('click', this.showView.bind(this, 'hours'));\n          $(this.spanMinutes).on('click', this.showView.bind(this, 'minutes'));\n        }\n      }, {\n        key: \"_removeEventHandlers\",\n        value: function _removeEventHandlers() {\n          this.el.removeEventListener('click', this._handleInputClickBound);\n          this.el.removeEventListener('keydown', this._handleInputKeydownBound);\n        }\n      }, {\n        key: \"_handleInputClick\",\n        value: function _handleInputClick() {\n          this.open();\n        }\n      }, {\n        key: \"_handleInputKeydown\",\n        value: function _handleInputKeydown(e) {\n          if (e.which === M.keys.ENTER) {\n            e.preventDefault();\n            this.open();\n          }\n        }\n      }, {\n        key: \"_handleClockClickStart\",\n        value: function _handleClockClickStart(e) {\n          e.preventDefault();\n          var clockPlateBR = this.plate.getBoundingClientRect();\n          var offset = {\n            x: clockPlateBR.left,\n            y: clockPlateBR.top\n          };\n          this.x0 = offset.x + this.options.dialRadius;\n          this.y0 = offset.y + this.options.dialRadius;\n          this.moved = false;\n\n          var clickPos = Timepicker._Pos(e);\n\n          this.dx = clickPos.x - this.x0;\n          this.dy = clickPos.y - this.y0; // Set clock hands\n\n          this.setHand(this.dx, this.dy, false); // Mousemove on document\n\n          document.addEventListener('mousemove', this._handleDocumentClickMoveBound);\n          document.addEventListener('touchmove', this._handleDocumentClickMoveBound); // Mouseup on document\n\n          document.addEventListener('mouseup', this._handleDocumentClickEndBound);\n          document.addEventListener('touchend', this._handleDocumentClickEndBound);\n        }\n      }, {\n        key: \"_handleDocumentClickMove\",\n        value: function _handleDocumentClickMove(e) {\n          e.preventDefault();\n\n          var clickPos = Timepicker._Pos(e);\n\n          var x = clickPos.x - this.x0;\n          var y = clickPos.y - this.y0;\n          this.moved = true;\n          this.setHand(x, y, false, true);\n        }\n      }, {\n        key: \"_handleDocumentClickEnd\",\n        value: function _handleDocumentClickEnd(e) {\n          var _this20 = this;\n\n          e.preventDefault();\n          document.removeEventListener('mouseup', this._handleDocumentClickEndBound);\n          document.removeEventListener('touchend', this._handleDocumentClickEndBound);\n\n          var clickPos = Timepicker._Pos(e);\n\n          var x = clickPos.x - this.x0;\n          var y = clickPos.y - this.y0;\n\n          if (this.moved && x === this.dx && y === this.dy) {\n            this.setHand(x, y);\n          }\n\n          if (this.currentView === 'hours') {\n            this.showView('minutes', this.options.duration / 2);\n          } else if (this.options.autoClose) {\n            $(this.minutesView).addClass('timepicker-dial-out');\n            setTimeout(function () {\n              _this20.done();\n            }, this.options.duration / 2);\n          }\n\n          if (typeof this.options.onSelect === 'function') {\n            this.options.onSelect.call(this, this.hours, this.minutes);\n          } // Unbind mousemove event\n\n\n          document.removeEventListener('mousemove', this._handleDocumentClickMoveBound);\n          document.removeEventListener('touchmove', this._handleDocumentClickMoveBound);\n        }\n      }, {\n        key: \"_insertHTMLIntoDOM\",\n        value: function _insertHTMLIntoDOM() {\n          this.$modalEl = $(Timepicker._template);\n          this.modalEl = this.$modalEl[0];\n          this.modalEl.id = 'modal-' + this.id; // Append popover to input by default\n\n          var containerEl = document.querySelector(this.options.container);\n\n          if (this.options.container && !!containerEl) {\n            this.$modalEl.appendTo(containerEl);\n          } else {\n            this.$modalEl.insertBefore(this.el);\n          }\n        }\n      }, {\n        key: \"_setupModal\",\n        value: function _setupModal() {\n          var _this21 = this;\n\n          this.modal = M.Modal.init(this.modalEl, {\n            onOpenStart: this.options.onOpenStart,\n            onOpenEnd: this.options.onOpenEnd,\n            onCloseStart: this.options.onCloseStart,\n            onCloseEnd: function () {\n              if (typeof _this21.options.onCloseEnd === 'function') {\n                _this21.options.onCloseEnd.call(_this21);\n              }\n\n              _this21.isOpen = false;\n            }\n          });\n        }\n      }, {\n        key: \"_setupVariables\",\n        value: function _setupVariables() {\n          this.currentView = 'hours';\n          this.vibrate = navigator.vibrate ? 'vibrate' : navigator.webkitVibrate ? 'webkitVibrate' : null;\n          this._canvas = this.modalEl.querySelector('.timepicker-canvas');\n          this.plate = this.modalEl.querySelector('.timepicker-plate');\n          this.hoursView = this.modalEl.querySelector('.timepicker-hours');\n          this.minutesView = this.modalEl.querySelector('.timepicker-minutes');\n          this.spanHours = this.modalEl.querySelector('.timepicker-span-hours');\n          this.spanMinutes = this.modalEl.querySelector('.timepicker-span-minutes');\n          this.spanAmPm = this.modalEl.querySelector('.timepicker-span-am-pm');\n          this.footer = this.modalEl.querySelector('.timepicker-footer');\n          this.amOrPm = 'PM';\n        }\n      }, {\n        key: \"_pickerSetup\",\n        value: function _pickerSetup() {\n          var $clearBtn = $(\"<button class=\\\"btn-flat timepicker-clear waves-effect\\\" style=\\\"visibility: hidden;\\\" type=\\\"button\\\" tabindex=\\\"\" + (this.options.twelveHour ? '3' : '1') + \"\\\">\" + this.options.i18n.clear + \"</button>\").appendTo(this.footer).on('click', this.clear.bind(this));\n\n          if (this.options.showClearBtn) {\n            $clearBtn.css({\n              visibility: ''\n            });\n          }\n\n          var confirmationBtnsContainer = $('<div class=\"confirmation-btns\"></div>');\n          $('<button class=\"btn-flat timepicker-close waves-effect\" type=\"button\" tabindex=\"' + (this.options.twelveHour ? '3' : '1') + '\">' + this.options.i18n.cancel + '</button>').appendTo(confirmationBtnsContainer).on('click', this.close.bind(this));\n          $('<button class=\"btn-flat timepicker-close waves-effect\" type=\"button\" tabindex=\"' + (this.options.twelveHour ? '3' : '1') + '\">' + this.options.i18n.done + '</button>').appendTo(confirmationBtnsContainer).on('click', this.done.bind(this));\n          confirmationBtnsContainer.appendTo(this.footer);\n        }\n      }, {\n        key: \"_clockSetup\",\n        value: function _clockSetup() {\n          if (this.options.twelveHour) {\n            this.$amBtn = $('<div class=\"am-btn\">AM</div>');\n            this.$pmBtn = $('<div class=\"pm-btn\">PM</div>');\n            this.$amBtn.on('click', this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm);\n            this.$pmBtn.on('click', this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm);\n          }\n\n          this._buildHoursView();\n\n          this._buildMinutesView();\n\n          this._buildSVGClock();\n        }\n      }, {\n        key: \"_buildSVGClock\",\n        value: function _buildSVGClock() {\n          // Draw clock hands and others\n          var dialRadius = this.options.dialRadius;\n          var tickRadius = this.options.tickRadius;\n          var diameter = dialRadius * 2;\n\n          var svg = Timepicker._createSVGEl('svg');\n\n          svg.setAttribute('class', 'timepicker-svg');\n          svg.setAttribute('width', diameter);\n          svg.setAttribute('height', diameter);\n\n          var g = Timepicker._createSVGEl('g');\n\n          g.setAttribute('transform', 'translate(' + dialRadius + ',' + dialRadius + ')');\n\n          var bearing = Timepicker._createSVGEl('circle');\n\n          bearing.setAttribute('class', 'timepicker-canvas-bearing');\n          bearing.setAttribute('cx', 0);\n          bearing.setAttribute('cy', 0);\n          bearing.setAttribute('r', 4);\n\n          var hand = Timepicker._createSVGEl('line');\n\n          hand.setAttribute('x1', 0);\n          hand.setAttribute('y1', 0);\n\n          var bg = Timepicker._createSVGEl('circle');\n\n          bg.setAttribute('class', 'timepicker-canvas-bg');\n          bg.setAttribute('r', tickRadius);\n          g.appendChild(hand);\n          g.appendChild(bg);\n          g.appendChild(bearing);\n          svg.appendChild(g);\n\n          this._canvas.appendChild(svg);\n\n          this.hand = hand;\n          this.bg = bg;\n          this.bearing = bearing;\n          this.g = g;\n        }\n      }, {\n        key: \"_buildHoursView\",\n        value: function _buildHoursView() {\n          var $tick = $('<div class=\"timepicker-tick\"></div>'); // Hours view\n\n          if (this.options.twelveHour) {\n            for (var i = 1; i < 13; i += 1) {\n              var tick = $tick.clone();\n              var radian = i / 6 * Math.PI;\n              var radius = this.options.outerRadius;\n              tick.css({\n                left: this.options.dialRadius + Math.sin(radian) * radius - this.options.tickRadius + 'px',\n                top: this.options.dialRadius - Math.cos(radian) * radius - this.options.tickRadius + 'px'\n              });\n              tick.html(i === 0 ? '00' : i);\n              this.hoursView.appendChild(tick[0]); // tick.on(mousedownEvent, mousedown);\n            }\n          } else {\n            for (var _i = 0; _i < 24; _i += 1) {\n              var _tick = $tick.clone();\n\n              var _radian = _i / 6 * Math.PI;\n\n              var inner = _i > 0 && _i < 13;\n\n              var _radius = inner ? this.options.innerRadius : this.options.outerRadius;\n\n              _tick.css({\n                left: this.options.dialRadius + Math.sin(_radian) * _radius - this.options.tickRadius + 'px',\n                top: this.options.dialRadius - Math.cos(_radian) * _radius - this.options.tickRadius + 'px'\n              });\n\n              _tick.html(_i === 0 ? '00' : _i);\n\n              this.hoursView.appendChild(_tick[0]); // tick.on(mousedownEvent, mousedown);\n            }\n          }\n        }\n      }, {\n        key: \"_buildMinutesView\",\n        value: function _buildMinutesView() {\n          var $tick = $('<div class=\"timepicker-tick\"></div>'); // Minutes view\n\n          for (var i = 0; i < 60; i += 5) {\n            var tick = $tick.clone();\n            var radian = i / 30 * Math.PI;\n            tick.css({\n              left: this.options.dialRadius + Math.sin(radian) * this.options.outerRadius - this.options.tickRadius + 'px',\n              top: this.options.dialRadius - Math.cos(radian) * this.options.outerRadius - this.options.tickRadius + 'px'\n            });\n            tick.html(Timepicker._addLeadingZero(i));\n            this.minutesView.appendChild(tick[0]);\n          }\n        }\n      }, {\n        key: \"_handleAmPmClick\",\n        value: function _handleAmPmClick(e) {\n          var $btnClicked = $(e.target);\n          this.amOrPm = $btnClicked.hasClass('am-btn') ? 'AM' : 'PM';\n\n          this._updateAmPmView();\n        }\n      }, {\n        key: \"_updateAmPmView\",\n        value: function _updateAmPmView() {\n          if (this.options.twelveHour) {\n            this.$amBtn.toggleClass('text-primary', this.amOrPm === 'AM');\n            this.$pmBtn.toggleClass('text-primary', this.amOrPm === 'PM');\n          }\n        }\n      }, {\n        key: \"_updateTimeFromInput\",\n        value: function _updateTimeFromInput() {\n          // Get the time\n          var value = ((this.el.value || this.options.defaultTime || '') + '').split(':');\n\n          if (this.options.twelveHour && !(typeof value[1] === 'undefined')) {\n            if (value[1].toUpperCase().indexOf('AM') > 0) {\n              this.amOrPm = 'AM';\n            } else {\n              this.amOrPm = 'PM';\n            }\n\n            value[1] = value[1].replace('AM', '').replace('PM', '');\n          }\n\n          if (value[0] === 'now') {\n            var now = new Date(+new Date() + this.options.fromNow);\n            value = [now.getHours(), now.getMinutes()];\n\n            if (this.options.twelveHour) {\n              this.amOrPm = value[0] >= 12 && value[0] < 24 ? 'PM' : 'AM';\n            }\n          }\n\n          this.hours = +value[0] || 0;\n          this.minutes = +value[1] || 0;\n          this.spanHours.innerHTML = this.hours;\n          this.spanMinutes.innerHTML = Timepicker._addLeadingZero(this.minutes);\n\n          this._updateAmPmView();\n        }\n      }, {\n        key: \"showView\",\n        value: function showView(view, delay) {\n          if (view === 'minutes' && $(this.hoursView).css('visibility') === 'visible') {// raiseCallback(this.options.beforeHourSelect);\n          }\n\n          var isHours = view === 'hours',\n              nextView = isHours ? this.hoursView : this.minutesView,\n              hideView = isHours ? this.minutesView : this.hoursView;\n          this.currentView = view;\n          $(this.spanHours).toggleClass('text-primary', isHours);\n          $(this.spanMinutes).toggleClass('text-primary', !isHours); // Transition view\n\n          hideView.classList.add('timepicker-dial-out');\n          $(nextView).css('visibility', 'visible').removeClass('timepicker-dial-out'); // Reset clock hand\n\n          this.resetClock(delay); // After transitions ended\n\n          clearTimeout(this.toggleViewTimer);\n          this.toggleViewTimer = setTimeout(function () {\n            $(hideView).css('visibility', 'hidden');\n          }, this.options.duration);\n        }\n      }, {\n        key: \"resetClock\",\n        value: function resetClock(delay) {\n          var view = this.currentView,\n              value = this[view],\n              isHours = view === 'hours',\n              unit = Math.PI / (isHours ? 6 : 30),\n              radian = value * unit,\n              radius = isHours && value > 0 && value < 13 ? this.options.innerRadius : this.options.outerRadius,\n              x = Math.sin(radian) * radius,\n              y = -Math.cos(radian) * radius,\n              self = this;\n\n          if (delay) {\n            $(this.canvas).addClass('timepicker-canvas-out');\n            setTimeout(function () {\n              $(self.canvas).removeClass('timepicker-canvas-out');\n              self.setHand(x, y);\n            }, delay);\n          } else {\n            this.setHand(x, y);\n          }\n        }\n      }, {\n        key: \"setHand\",\n        value: function setHand(x, y, roundBy5) {\n          var _this22 = this;\n\n          var radian = Math.atan2(x, -y),\n              isHours = this.currentView === 'hours',\n              unit = Math.PI / (isHours || roundBy5 ? 6 : 30),\n              z = Math.sqrt(x * x + y * y),\n              inner = isHours && z < (this.options.outerRadius + this.options.innerRadius) / 2,\n              radius = inner ? this.options.innerRadius : this.options.outerRadius;\n\n          if (this.options.twelveHour) {\n            radius = this.options.outerRadius;\n          } // Radian should in range [0, 2PI]\n\n\n          if (radian < 0) {\n            radian = Math.PI * 2 + radian;\n          } // Get the round value\n\n\n          var value = Math.round(radian / unit); // Get the round radian\n\n          radian = value * unit; // Correct the hours or minutes\n\n          if (this.options.twelveHour) {\n            if (isHours) {\n              if (value === 0) value = 12;\n            } else {\n              if (roundBy5) value *= 5;\n              if (value === 60) value = 0;\n            }\n          } else {\n            if (isHours) {\n              if (value === 12) {\n                value = 0;\n              }\n\n              value = inner ? value === 0 ? 12 : value : value === 0 ? 0 : value + 12;\n            } else {\n              if (roundBy5) {\n                value *= 5;\n              }\n\n              if (value === 60) {\n                value = 0;\n              }\n            }\n          } // Once hours or minutes changed, vibrate the device\n\n\n          if (this[this.currentView] !== value) {\n            if (this.vibrate && this.options.vibrate) {\n              // Do not vibrate too frequently\n              if (!this.vibrateTimer) {\n                navigator[this.vibrate](10);\n                this.vibrateTimer = setTimeout(function () {\n                  _this22.vibrateTimer = null;\n                }, 100);\n              }\n            }\n          }\n\n          this[this.currentView] = value;\n\n          if (isHours) {\n            this['spanHours'].innerHTML = value;\n          } else {\n            this['spanMinutes'].innerHTML = Timepicker._addLeadingZero(value);\n          } // Set clock hand and others' position\n\n\n          var cx1 = Math.sin(radian) * (radius - this.options.tickRadius),\n              cy1 = -Math.cos(radian) * (radius - this.options.tickRadius),\n              cx2 = Math.sin(radian) * radius,\n              cy2 = -Math.cos(radian) * radius;\n          this.hand.setAttribute('x2', cx1);\n          this.hand.setAttribute('y2', cy1);\n          this.bg.setAttribute('cx', cx2);\n          this.bg.setAttribute('cy', cy2);\n        }\n      }, {\n        key: \"open\",\n        value: function open() {\n          if (this.isOpen) {\n            return;\n          }\n\n          this.isOpen = true;\n\n          this._updateTimeFromInput();\n\n          this.showView('hours');\n          this.modal.open();\n        }\n      }, {\n        key: \"close\",\n        value: function close() {\n          if (!this.isOpen) {\n            return;\n          }\n\n          this.isOpen = false;\n          this.modal.close();\n        }\n        /**\n         * Finish timepicker selection.\n         */\n\n      }, {\n        key: \"done\",\n        value: function done(e, clearValue) {\n          // Set input value\n          var last = this.el.value;\n          var value = clearValue ? '' : Timepicker._addLeadingZero(this.hours) + ':' + Timepicker._addLeadingZero(this.minutes);\n          this.time = value;\n\n          if (!clearValue && this.options.twelveHour) {\n            value = value + \" \" + this.amOrPm;\n          }\n\n          this.el.value = value; // Trigger change event\n\n          if (value !== last) {\n            this.$el.trigger('change');\n          }\n\n          this.close();\n          this.el.focus();\n        }\n      }, {\n        key: \"clear\",\n        value: function clear() {\n          this.done(null, true);\n        }\n      }], [{\n        key: \"init\",\n        value: function init(els, options) {\n          return _get(Timepicker.__proto__ || Object.getPrototypeOf(Timepicker), \"init\", this).call(this, this, els, options);\n        }\n      }, {\n        key: \"_addLeadingZero\",\n        value: function _addLeadingZero(num) {\n          return (num < 10 ? '0' : '') + num;\n        }\n      }, {\n        key: \"_createSVGEl\",\n        value: function _createSVGEl(name) {\n          var svgNS = 'http://www.w3.org/2000/svg';\n          return document.createElementNS(svgNS, name);\n        }\n        /**\n         * @typedef {Object} Point\n         * @property {number} x The X Coordinate\n         * @property {number} y The Y Coordinate\n         */\n\n        /**\n         * Get x position of mouse or touch event\n         * @param {Event} e\n         * @return {Point} x and y location\n         */\n\n      }, {\n        key: \"_Pos\",\n        value: function _Pos(e) {\n          if (e.targetTouches && e.targetTouches.length >= 1) {\n            return {\n              x: e.targetTouches[0].clientX,\n              y: e.targetTouches[0].clientY\n            };\n          } // mouse event\n\n\n          return {\n            x: e.clientX,\n            y: e.clientY\n          };\n        }\n        /**\n         * Get Instance\n         */\n\n      }, {\n        key: \"getInstance\",\n        value: function getInstance(el) {\n          var domElem = !!el.jquery ? el[0] : el;\n          return domElem.M_Timepicker;\n        }\n      }, {\n        key: \"defaults\",\n        get: function () {\n          return _defaults;\n        }\n      }]);\n\n      return Timepicker;\n    }(Component);\n\n    Timepicker._template = ['<div class= \"modal timepicker-modal\">', '<div class=\"modal-content timepicker-container\">', '<div class=\"timepicker-digital-display\">', '<div class=\"timepicker-text-container\">', '<div class=\"timepicker-display-column\">', '<span class=\"timepicker-span-hours text-primary\"></span>', ':', '<span class=\"timepicker-span-minutes\"></span>', '</div>', '<div class=\"timepicker-display-column timepicker-display-am-pm\">', '<div class=\"timepicker-span-am-pm\"></div>', '</div>', '</div>', '</div>', '<div class=\"timepicker-analog-display\">', '<div class=\"timepicker-plate\">', '<div class=\"timepicker-canvas\"></div>', '<div class=\"timepicker-dial timepicker-hours\"></div>', '<div class=\"timepicker-dial timepicker-minutes timepicker-dial-out\"></div>', '</div>', '<div class=\"timepicker-footer\"></div>', '</div>', '</div>', '</div>'].join('');\n    M.Timepicker = Timepicker;\n\n    if (M.jQueryLoaded) {\n      M.initializeJqueryWrapper(Timepicker, 'timepicker', 'M_Timepicker');\n    }\n  })(cash);\n\n  ;\n\n  (function ($) {\n    'use strict';\n\n    var _defaults = {\n      classes: '',\n      dropdownOptions: {}\n    };\n    /**\n     * @class\n     *\n     */\n\n    var FormSelect = function (_Component6) {\n      _inherits(FormSelect, _Component6);\n      /**\n       * Construct FormSelect instance\n       * @constructor\n       * @param {Element} el\n       * @param {Object} options\n       */\n\n\n      function FormSelect(el, options) {\n        _classCallCheck(this, FormSelect); // Don't init if browser default version\n\n\n        var _this23 = _possibleConstructorReturn(this, (FormSelect.__proto__ || Object.getPrototypeOf(FormSelect)).call(this, FormSelect, el, options));\n\n        if (_this23.$el.hasClass('browser-default')) {\n          return _possibleConstructorReturn(_this23);\n        }\n\n        _this23.el.M_FormSelect = _this23;\n        /**\n         * Options for the select\n         * @member FormSelect#options\n         */\n\n        _this23.options = $.extend({}, FormSelect.defaults, options);\n        _this23.isMultiple = _this23.$el.prop('multiple'); // Setup\n\n        _this23.el.tabIndex = -1;\n        _this23._keysSelected = {};\n        _this23._valueDict = {}; // Maps key to original and generated option element.\n\n        _this23._setupDropdown();\n\n        _this23._setupEventHandlers();\n\n        return _this23;\n      }\n\n      _createClass(FormSelect, [{\n        key: \"destroy\",\n\n        /**\n         * Teardown component\n         */\n        value: function destroy() {\n          this._removeEventHandlers();\n\n          this._removeDropdown();\n\n          this.el.M_FormSelect = undefined;\n        }\n        /**\n         * Setup Event Handlers\n         */\n\n      }, {\n        key: \"_setupEventHandlers\",\n        value: function _setupEventHandlers() {\n          var _this24 = this;\n\n          this._handleSelectChangeBound = this._handleSelectChange.bind(this);\n          this._handleOptionClickBound = this._handleOptionClick.bind(this);\n          this._handleInputClickBound = this._handleInputClick.bind(this);\n          $(this.dropdownOptions).find('li:not(.optgroup)').each(function (el) {\n            el.addEventListener('click', _this24._handleOptionClickBound);\n          });\n          this.el.addEventListener('change', this._handleSelectChangeBound);\n          this.input.addEventListener('click', this._handleInputClickBound);\n        }\n        /**\n         * Remove Event Handlers\n         */\n\n      }, {\n        key: \"_removeEventHandlers\",\n        value: function _removeEventHandlers() {\n          var _this25 = this;\n\n          $(this.dropdownOptions).find('li:not(.optgroup)').each(function (el) {\n            el.removeEventListener('click', _this25._handleOptionClickBound);\n          });\n          this.el.removeEventListener('change', this._handleSelectChangeBound);\n          this.input.removeEventListener('click', this._handleInputClickBound);\n        }\n        /**\n         * Handle Select Change\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleSelectChange\",\n        value: function _handleSelectChange(e) {\n          this._setValueToInput();\n        }\n        /**\n         * Handle Option Click\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleOptionClick\",\n        value: function _handleOptionClick(e) {\n          e.preventDefault();\n          var option = $(e.target).closest('li')[0];\n          var key = option.id;\n\n          if (!$(option).hasClass('disabled') && !$(option).hasClass('optgroup') && key.length) {\n            var selected = true;\n\n            if (this.isMultiple) {\n              // Deselect placeholder option if still selected.\n              var placeholderOption = $(this.dropdownOptions).find('li.disabled.selected');\n\n              if (placeholderOption.length) {\n                placeholderOption.removeClass('selected');\n                placeholderOption.find('input[type=\"checkbox\"]').prop('checked', false);\n\n                this._toggleEntryFromArray(placeholderOption[0].id);\n              }\n\n              selected = this._toggleEntryFromArray(key);\n            } else {\n              $(this.dropdownOptions).find('li').removeClass('selected');\n              $(option).toggleClass('selected', selected);\n              this._keysSelected = {};\n              this._keysSelected[option.id] = true;\n            } // Set selected on original select option\n            // Only trigger if selected state changed\n\n\n            var prevSelected = $(this._valueDict[key].el).prop('selected');\n\n            if (prevSelected !== selected) {\n              $(this._valueDict[key].el).prop('selected', selected);\n              this.$el.trigger('change');\n            }\n          }\n\n          e.stopPropagation();\n        }\n        /**\n         * Handle Input Click\n         */\n\n      }, {\n        key: \"_handleInputClick\",\n        value: function _handleInputClick() {\n          if (this.dropdown && this.dropdown.isOpen) {\n            this._setValueToInput();\n\n            this._setSelectedStates();\n          }\n        }\n        /**\n         * Setup dropdown\n         */\n\n      }, {\n        key: \"_setupDropdown\",\n        value: function _setupDropdown() {\n          var _this26 = this;\n\n          this.wrapper = document.createElement('div');\n          $(this.wrapper).addClass('select-wrapper ' + this.options.classes);\n          this.$el.before($(this.wrapper));\n          this.wrapper.appendChild(this.el);\n\n          if (this.el.disabled) {\n            this.wrapper.classList.add('disabled');\n          } // Create dropdown\n\n\n          this.$selectOptions = this.$el.children('option, optgroup');\n          this.dropdownOptions = document.createElement('ul');\n          this.dropdownOptions.id = \"select-options-\" + M.guid();\n          $(this.dropdownOptions).addClass('dropdown-content select-dropdown ' + (this.isMultiple ? 'multiple-select-dropdown' : '')); // Create dropdown structure.\n\n          if (this.$selectOptions.length) {\n            this.$selectOptions.each(function (el) {\n              if ($(el).is('option')) {\n                // Direct descendant option.\n                var optionEl = void 0;\n\n                if (_this26.isMultiple) {\n                  optionEl = _this26._appendOptionWithIcon(_this26.$el, el, 'multiple');\n                } else {\n                  optionEl = _this26._appendOptionWithIcon(_this26.$el, el);\n                }\n\n                _this26._addOptionToValueDict(el, optionEl);\n              } else if ($(el).is('optgroup')) {\n                // Optgroup.\n                var selectOptions = $(el).children('option');\n                $(_this26.dropdownOptions).append($('<li class=\"optgroup\"><span>' + el.getAttribute('label') + '</span></li>')[0]);\n                selectOptions.each(function (el) {\n                  var optionEl = _this26._appendOptionWithIcon(_this26.$el, el, 'optgroup-option');\n\n                  _this26._addOptionToValueDict(el, optionEl);\n                });\n              }\n            });\n          }\n\n          this.$el.after(this.dropdownOptions); // Add input dropdown\n\n          this.input = document.createElement('input');\n          $(this.input).addClass('select-dropdown dropdown-trigger');\n          this.input.setAttribute('type', 'text');\n          this.input.setAttribute('readonly', 'true');\n          this.input.setAttribute('data-target', this.dropdownOptions.id);\n\n          if (this.el.disabled) {\n            $(this.input).prop('disabled', 'true');\n          }\n\n          this.$el.before(this.input);\n\n          this._setValueToInput(); // Add caret\n\n\n          var dropdownIcon = $('<svg class=\"caret\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7 10l5 5 5-5z\"/><path d=\"M0 0h24v24H0z\" fill=\"none\"/></svg>');\n          this.$el.before(dropdownIcon[0]); // Initialize dropdown\n\n          if (!this.el.disabled) {\n            var dropdownOptions = $.extend({}, this.options.dropdownOptions); // Add callback for centering selected option when dropdown content is scrollable\n\n            dropdownOptions.onOpenEnd = function (el) {\n              var selectedOption = $(_this26.dropdownOptions).find('.selected').first();\n\n              if (selectedOption.length) {\n                // Focus selected option in dropdown\n                M.keyDown = true;\n                _this26.dropdown.focusedIndex = selectedOption.index();\n\n                _this26.dropdown._focusFocusedItem();\n\n                M.keyDown = false; // Handle scrolling to selected option\n\n                if (_this26.dropdown.isScrollable) {\n                  var scrollOffset = selectedOption[0].getBoundingClientRect().top - _this26.dropdownOptions.getBoundingClientRect().top; // scroll to selected option\n\n\n                  scrollOffset -= _this26.dropdownOptions.clientHeight / 2; // center in dropdown\n\n                  _this26.dropdownOptions.scrollTop = scrollOffset;\n                }\n              }\n            };\n\n            if (this.isMultiple) {\n              dropdownOptions.closeOnClick = false;\n            }\n\n            this.dropdown = M.Dropdown.init(this.input, dropdownOptions);\n          } // Add initial selections\n\n\n          this._setSelectedStates();\n        }\n        /**\n         * Add option to value dict\n         * @param {Element} el  original option element\n         * @param {Element} optionEl  generated option element\n         */\n\n      }, {\n        key: \"_addOptionToValueDict\",\n        value: function _addOptionToValueDict(el, optionEl) {\n          var index = Object.keys(this._valueDict).length;\n          var key = this.dropdownOptions.id + index;\n          var obj = {};\n          optionEl.id = key;\n          obj.el = el;\n          obj.optionEl = optionEl;\n          this._valueDict[key] = obj;\n        }\n        /**\n         * Remove dropdown\n         */\n\n      }, {\n        key: \"_removeDropdown\",\n        value: function _removeDropdown() {\n          $(this.wrapper).find('.caret').remove();\n          $(this.input).remove();\n          $(this.dropdownOptions).remove();\n          $(this.wrapper).before(this.$el);\n          $(this.wrapper).remove();\n        }\n        /**\n         * Setup dropdown\n         * @param {Element} select  select element\n         * @param {Element} option  option element from select\n         * @param {String} type\n         * @return {Element}  option element added\n         */\n\n      }, {\n        key: \"_appendOptionWithIcon\",\n        value: function _appendOptionWithIcon(select, option, type) {\n          // Add disabled attr if disabled\n          var disabledClass = option.disabled ? 'disabled ' : '';\n          var optgroupClass = type === 'optgroup-option' ? 'optgroup-option ' : '';\n          var multipleCheckbox = this.isMultiple ? \"<label><input type=\\\"checkbox\\\"\" + disabledClass + \"\\\"/><span>\" + option.innerHTML + \"</span></label>\" : option.innerHTML;\n          var liEl = $('<li></li>');\n          var spanEl = $('<span></span>');\n          spanEl.html(multipleCheckbox);\n          liEl.addClass(disabledClass + \" \" + optgroupClass);\n          liEl.append(spanEl); // add icons\n\n          var iconUrl = option.getAttribute('data-icon');\n\n          if (!!iconUrl) {\n            var imgEl = $(\"<img alt=\\\"\\\" src=\\\"\" + iconUrl + \"\\\">\");\n            liEl.prepend(imgEl);\n          } // Check for multiple type.\n\n\n          $(this.dropdownOptions).append(liEl[0]);\n          return liEl[0];\n        }\n        /**\n         * Toggle entry from option\n         * @param {String} key  Option key\n         * @return {Boolean}  if entry was added or removed\n         */\n\n      }, {\n        key: \"_toggleEntryFromArray\",\n        value: function _toggleEntryFromArray(key) {\n          var notAdded = !this._keysSelected.hasOwnProperty(key);\n          var $optionLi = $(this._valueDict[key].optionEl);\n\n          if (notAdded) {\n            this._keysSelected[key] = true;\n          } else {\n            delete this._keysSelected[key];\n          }\n\n          $optionLi.toggleClass('selected', notAdded); // Set checkbox checked value\n\n          $optionLi.find('input[type=\"checkbox\"]').prop('checked', notAdded); // use notAdded instead of true (to detect if the option is selected or not)\n\n          $optionLi.prop('selected', notAdded);\n          return notAdded;\n        }\n        /**\n         * Set text value to input\n         */\n\n      }, {\n        key: \"_setValueToInput\",\n        value: function _setValueToInput() {\n          var values = [];\n          var options = this.$el.find('option');\n          options.each(function (el) {\n            if ($(el).prop('selected')) {\n              var text = $(el).text();\n              values.push(text);\n            }\n          });\n\n          if (!values.length) {\n            var firstDisabled = this.$el.find('option:disabled').eq(0);\n\n            if (firstDisabled.length && firstDisabled[0].value === '') {\n              values.push(firstDisabled.text());\n            }\n          }\n\n          this.input.value = values.join(', ');\n        }\n        /**\n         * Set selected state of dropdown to match actual select element\n         */\n\n      }, {\n        key: \"_setSelectedStates\",\n        value: function _setSelectedStates() {\n          this._keysSelected = {};\n\n          for (var key in this._valueDict) {\n            var option = this._valueDict[key];\n            var optionIsSelected = $(option.el).prop('selected');\n            $(option.optionEl).find('input[type=\"checkbox\"]').prop('checked', optionIsSelected);\n\n            if (optionIsSelected) {\n              this._activateOption($(this.dropdownOptions), $(option.optionEl));\n\n              this._keysSelected[key] = true;\n            } else {\n              $(option.optionEl).removeClass('selected');\n            }\n          }\n        }\n        /**\n         * Make option as selected and scroll to selected position\n         * @param {jQuery} collection  Select options jQuery element\n         * @param {Element} newOption  element of the new option\n         */\n\n      }, {\n        key: \"_activateOption\",\n        value: function _activateOption(collection, newOption) {\n          if (newOption) {\n            if (!this.isMultiple) {\n              collection.find('li.selected').removeClass('selected');\n            }\n\n            var option = $(newOption);\n            option.addClass('selected');\n          }\n        }\n        /**\n         * Get Selected Values\n         * @return {Array}  Array of selected values\n         */\n\n      }, {\n        key: \"getSelectedValues\",\n        value: function getSelectedValues() {\n          var selectedValues = [];\n\n          for (var key in this._keysSelected) {\n            selectedValues.push(this._valueDict[key].el.value);\n          }\n\n          return selectedValues;\n        }\n      }], [{\n        key: \"init\",\n        value: function init(els, options) {\n          return _get(FormSelect.__proto__ || Object.getPrototypeOf(FormSelect), \"init\", this).call(this, this, els, options);\n        }\n        /**\n         * Get Instance\n         */\n\n      }, {\n        key: \"getInstance\",\n        value: function getInstance(el) {\n          var domElem = !!el.jquery ? el[0] : el;\n          return domElem.M_FormSelect;\n        }\n      }, {\n        key: \"defaults\",\n        get: function () {\n          return _defaults;\n        }\n      }]);\n\n      return FormSelect;\n    }(Component);\n\n    M.FormSelect = FormSelect;\n\n    if (M.jQueryLoaded) {\n      M.initializeJqueryWrapper(FormSelect, 'formSelect', 'M_FormSelect');\n    }\n  })(cash);\n\n  ;\n\n  (function ($, anim) {\n    'use strict';\n\n    var _defaults = {};\n    /**\n     * @class\n     *\n     */\n\n    var Range = function (_Component7) {\n      _inherits(Range, _Component7);\n      /**\n       * Construct Range instance\n       * @constructor\n       * @param {Element} el\n       * @param {Object} options\n       */\n\n\n      function Range(el, options) {\n        _classCallCheck(this, Range);\n\n        var _this27 = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this, Range, el, options));\n\n        _this27.el.M_Range = _this27;\n        /**\n         * Options for the range\n         * @member Range#options\n         */\n\n        _this27.options = $.extend({}, Range.defaults, options);\n        _this27._mousedown = false; // Setup\n\n        _this27._setupThumb();\n\n        _this27._setupEventHandlers();\n\n        return _this27;\n      }\n\n      _createClass(Range, [{\n        key: \"destroy\",\n\n        /**\n         * Teardown component\n         */\n        value: function destroy() {\n          this._removeEventHandlers();\n\n          this._removeThumb();\n\n          this.el.M_Range = undefined;\n        }\n        /**\n         * Setup Event Handlers\n         */\n\n      }, {\n        key: \"_setupEventHandlers\",\n        value: function _setupEventHandlers() {\n          this._handleRangeChangeBound = this._handleRangeChange.bind(this);\n          this._handleRangeMousedownTouchstartBound = this._handleRangeMousedownTouchstart.bind(this);\n          this._handleRangeInputMousemoveTouchmoveBound = this._handleRangeInputMousemoveTouchmove.bind(this);\n          this._handleRangeMouseupTouchendBound = this._handleRangeMouseupTouchend.bind(this);\n          this._handleRangeBlurMouseoutTouchleaveBound = this._handleRangeBlurMouseoutTouchleave.bind(this);\n          this.el.addEventListener('change', this._handleRangeChangeBound);\n          this.el.addEventListener('mousedown', this._handleRangeMousedownTouchstartBound);\n          this.el.addEventListener('touchstart', this._handleRangeMousedownTouchstartBound);\n          this.el.addEventListener('input', this._handleRangeInputMousemoveTouchmoveBound);\n          this.el.addEventListener('mousemove', this._handleRangeInputMousemoveTouchmoveBound);\n          this.el.addEventListener('touchmove', this._handleRangeInputMousemoveTouchmoveBound);\n          this.el.addEventListener('mouseup', this._handleRangeMouseupTouchendBound);\n          this.el.addEventListener('touchend', this._handleRangeMouseupTouchendBound);\n          this.el.addEventListener('blur', this._handleRangeBlurMouseoutTouchleaveBound);\n          this.el.addEventListener('mouseout', this._handleRangeBlurMouseoutTouchleaveBound);\n          this.el.addEventListener('touchleave', this._handleRangeBlurMouseoutTouchleaveBound);\n        }\n        /**\n         * Remove Event Handlers\n         */\n\n      }, {\n        key: \"_removeEventHandlers\",\n        value: function _removeEventHandlers() {\n          this.el.removeEventListener('change', this._handleRangeChangeBound);\n          this.el.removeEventListener('mousedown', this._handleRangeMousedownTouchstartBound);\n          this.el.removeEventListener('touchstart', this._handleRangeMousedownTouchstartBound);\n          this.el.removeEventListener('input', this._handleRangeInputMousemoveTouchmoveBound);\n          this.el.removeEventListener('mousemove', this._handleRangeInputMousemoveTouchmoveBound);\n          this.el.removeEventListener('touchmove', this._handleRangeInputMousemoveTouchmoveBound);\n          this.el.removeEventListener('mouseup', this._handleRangeMouseupTouchendBound);\n          this.el.removeEventListener('touchend', this._handleRangeMouseupTouchendBound);\n          this.el.removeEventListener('blur', this._handleRangeBlurMouseoutTouchleaveBound);\n          this.el.removeEventListener('mouseout', this._handleRangeBlurMouseoutTouchleaveBound);\n          this.el.removeEventListener('touchleave', this._handleRangeBlurMouseoutTouchleaveBound);\n        }\n        /**\n         * Handle Range Change\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleRangeChange\",\n        value: function _handleRangeChange() {\n          $(this.value).html(this.$el.val());\n\n          if (!$(this.thumb).hasClass('active')) {\n            this._showRangeBubble();\n          }\n\n          var offsetLeft = this._calcRangeOffset();\n\n          $(this.thumb).addClass('active').css('left', offsetLeft + 'px');\n        }\n        /**\n         * Handle Range Mousedown and Touchstart\n         * @param {Event} e\n         */\n\n      }, {\n        key: \"_handleRangeMousedownTouchstart\",\n        value: function _handleRangeMousedownTouchstart(e) {\n          // Set indicator value\n          $(this.value).html(this.$el.val());\n          this._mousedown = true;\n          this.$el.addClass('active');\n\n          if (!$(this.thumb).hasClass('active')) {\n            this._showRangeBubble();\n          }\n\n          if (e.type !== 'input') {\n            var offsetLeft = this._calcRangeOffset();\n\n            $(this.thumb).addClass('active').css('left', offsetLeft + 'px');\n          }\n        }\n        /**\n         * Handle Range Input, Mousemove and Touchmove\n         */\n\n      }, {\n        key: \"_handleRangeInputMousemoveTouchmove\",\n        value: function _handleRangeInputMousemoveTouchmove() {\n          if (this._mousedown) {\n            if (!$(this.thumb).hasClass('active')) {\n              this._showRangeBubble();\n            }\n\n            var offsetLeft = this._calcRangeOffset();\n\n            $(this.thumb).addClass('active').css('left', offsetLeft + 'px');\n            $(this.value).html(this.$el.val());\n          }\n        }\n        /**\n         * Handle Range Mouseup and Touchend\n         */\n\n      }, {\n        key: \"_handleRangeMouseupTouchend\",\n        value: function _handleRangeMouseupTouchend() {\n          this._mousedown = false;\n          this.$el.removeClass('active');\n        }\n        /**\n         * Handle Range Blur, Mouseout and Touchleave\n         */\n\n      }, {\n        key: \"_handleRangeBlurMouseoutTouchleave\",\n        value: function _handleRangeBlurMouseoutTouchleave() {\n          if (!this._mousedown) {\n            var paddingLeft = parseInt(this.$el.css('padding-left'));\n            var marginLeft = 7 + paddingLeft + 'px';\n\n            if ($(this.thumb).hasClass('active')) {\n              anim.remove(this.thumb);\n              anim({\n                targets: this.thumb,\n                height: 0,\n                width: 0,\n                top: 10,\n                easing: 'easeOutQuad',\n                marginLeft: marginLeft,\n                duration: 100\n              });\n            }\n\n            $(this.thumb).removeClass('active');\n          }\n        }\n        /**\n         * Setup dropdown\n         */\n\n      }, {\n        key: \"_setupThumb\",\n        value: function _setupThumb() {\n          this.thumb = document.createElement('span');\n          this.value = document.createElement('span');\n          $(this.thumb).addClass('thumb');\n          $(this.value).addClass('value');\n          $(this.thumb).append(this.value);\n          this.$el.after(this.thumb);\n        }\n        /**\n         * Remove dropdown\n         */\n\n      }, {\n        key: \"_removeThumb\",\n        value: function _removeThumb() {\n          $(this.thumb).remove();\n        }\n        /**\n         * morph thumb into bubble\n         */\n\n      }, {\n        key: \"_showRangeBubble\",\n        value: function _showRangeBubble() {\n          var paddingLeft = parseInt($(this.thumb).parent().css('padding-left'));\n          var marginLeft = -7 + paddingLeft + 'px'; // TODO: fix magic number?\n\n          anim.remove(this.thumb);\n          anim({\n            targets: this.thumb,\n            height: 30,\n            width: 30,\n            top: -30,\n            marginLeft: marginLeft,\n            duration: 300,\n            easing: 'easeOutQuint'\n          });\n        }\n        /**\n         * Calculate the offset of the thumb\n         * @return {Number}  offset in pixels\n         */\n\n      }, {\n        key: \"_calcRangeOffset\",\n        value: function _calcRangeOffset() {\n          var width = this.$el.width() - 15;\n          var max = parseFloat(this.$el.attr('max')) || 100; // Range default max\n\n          var min = parseFloat(this.$el.attr('min')) || 0; // Range default min\n\n          var percent = (parseFloat(this.$el.val()) - min) / (max - min);\n          return percent * width;\n        }\n      }], [{\n        key: \"init\",\n        value: function init(els, options) {\n          return _get(Range.__proto__ || Object.getPrototypeOf(Range), \"init\", this).call(this, this, els, options);\n        }\n        /**\n         * Get Instance\n         */\n\n      }, {\n        key: \"getInstance\",\n        value: function getInstance(el) {\n          var domElem = !!el.jquery ? el[0] : el;\n          return domElem.M_Range;\n        }\n      }, {\n        key: \"defaults\",\n        get: function () {\n          return _defaults;\n        }\n      }]);\n\n      return Range;\n    }(Component);\n\n    M.Range = Range;\n\n    if (M.jQueryLoaded) {\n      M.initializeJqueryWrapper(Range, 'range', 'M_Range');\n    }\n\n    Range.init($('input[type=range]'));\n  })(cash, M.anime);\n} //end if window.anime//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvZWxlbWVudHNfdjMvY29tbW9uL21hdGVyaWFsaXplLTEtZGV2L2Rpc3QvanMvbWF0ZXJpYWxpemUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvZWxlbWVudHNfdjMvY29tbW9uL21hdGVyaWFsaXplLTEtZGV2L2Rpc3QvanMvbWF0ZXJpYWxpemUuanM/MGJhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vSWYgd2luZG93LmFuaW1lIGRvZXNuJ3QgZXhpc3Qgd2UgYXJlIGluIGFuIG9sZCBwYWdlIC8gYmFkICB0aGF0IGRlZmluZXMgbWF0ZXJpYWxpemUuanMgYWZ0ZXIgb3B0YXNzZXRzLlxuLy9PciBzb21ldGhpbmcgd2VudCB0ZXJyaWJseSB3cm9uZyBhbmQgbWF0ZXJpYWxpemUgd29uJ3Qgd29yayBiZWNhdXNlIGl0J3MgbWlzc2luZyBkZXBlbmRhbmNpZXMuXG5pZiggd2luZG93LmFuaW1lICkge1xuXG5cbi8qIVxuICogTWF0ZXJpYWxpemUgdnVuZGVmaW5lZCAoaHR0cDovL21hdGVyaWFsaXplY3NzLmNvbSlcbiAqIENvcHlyaWdodCAyMDE0LTIwMTcgTWF0ZXJpYWxpemVcbiAqIE1JVCBMaWNlbnNlIChodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vRG9nZmFsby9tYXRlcmlhbGl6ZS9tYXN0ZXIvTElDRU5TRSlcbiAqL1xudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qISBjYXNoLWRvbSAxLjMuNSwgaHR0cHM6Ly9naXRodWIuY29tL2tlbndoZWVsZXIvY2FzaCBAbGljZW5zZSBNSVQgKi9cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICB3aW5kb3cuY2FzaCA9IGZhY3RvcnkoKTtcbn0pKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRvYyA9IGRvY3VtZW50LFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgIHNsaWNlID0gQXJyYXlQcm90by5zbGljZSxcbiAgICAgIGZpbHRlciA9IEFycmF5UHJvdG8uZmlsdGVyLFxuICAgICAgcHVzaCA9IEFycmF5UHJvdG8ucHVzaDtcblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgLy8gQHNlZSBodHRwczovL2NyYnVnLmNvbS81Njg0NDhcbiAgICByZXR1cm4gdHlwZW9mIGl0ZW0gPT09IHR5cGVvZiBub29wICYmIGl0ZW0uY2FsbDtcbiAgfSxcbiAgICAgIGlzU3RyaW5nID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ZW0gPT09IHR5cGVvZiBcIlwiO1xuICB9O1xuXG4gIHZhciBpZE1hdGNoID0gL14jW1xcdy1dKiQvLFxuICAgICAgY2xhc3NNYXRjaCA9IC9eXFwuW1xcdy1dKiQvLFxuICAgICAgaHRtbE1hdGNoID0gLzwuKz4vLFxuICAgICAgc2luZ2xldCA9IC9eXFx3KyQvO1xuXG4gIGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2M7XG4gICAgdmFyIGVsZW1zID0gY2xhc3NNYXRjaC50ZXN0KHNlbGVjdG9yKSA/IGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShzZWxlY3Rvci5zbGljZSgxKSkgOiBzaW5nbGV0LnRlc3Qoc2VsZWN0b3IpID8gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWxlY3RvcikgOiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIHJldHVybiBlbGVtcztcbiAgfVxuXG4gIHZhciBmcmFnO1xuICBmdW5jdGlvbiBwYXJzZUhUTUwoc3RyKSB7XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICBmcmFnID0gZG9jLmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChudWxsKTtcbiAgICAgIHZhciBiYXNlID0gZnJhZy5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKTtcbiAgICAgIGJhc2UuaHJlZiA9IGRvYy5sb2NhdGlvbi5ocmVmO1xuICAgICAgZnJhZy5oZWFkLmFwcGVuZENoaWxkKGJhc2UpO1xuICAgIH1cblxuICAgIGZyYWcuYm9keS5pbm5lckhUTUwgPSBzdHI7XG5cbiAgICByZXR1cm4gZnJhZy5ib2R5LmNoaWxkTm9kZXM7XG4gIH1cblxuICBmdW5jdGlvbiBvblJlYWR5KGZuKSB7XG4gICAgaWYgKGRvYy5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikge1xuICAgICAgZm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBJbml0KHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gSWYgYWxyZWFkeSBhIGNhc2ggY29sbGVjdGlvbiwgZG9uJ3QgZG8gYW55IGZ1cnRoZXIgcHJvY2Vzc2luZ1xuICAgIGlmIChzZWxlY3Rvci5jYXNoICYmIHNlbGVjdG9yICE9PSB3aW4pIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbXMgPSBzZWxlY3RvcixcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGxlbmd0aDtcblxuICAgIGlmIChpc1N0cmluZyhzZWxlY3RvcikpIHtcbiAgICAgIGVsZW1zID0gaWRNYXRjaC50ZXN0KHNlbGVjdG9yKSA/XG4gICAgICAvLyBJZiBhbiBJRCB1c2UgdGhlIGZhc3RlciBnZXRFbGVtZW50QnlJZCBjaGVja1xuICAgICAgZG9jLmdldEVsZW1lbnRCeUlkKHNlbGVjdG9yLnNsaWNlKDEpKSA6IGh0bWxNYXRjaC50ZXN0KHNlbGVjdG9yKSA/XG4gICAgICAvLyBJZiBIVE1MLCBwYXJzZSBpdCBpbnRvIHJlYWwgZWxlbWVudHNcbiAgICAgIHBhcnNlSFRNTChzZWxlY3RvcikgOlxuICAgICAgLy8gZWxzZSB1c2UgYGZpbmRgXG4gICAgICBmaW5kKHNlbGVjdG9yLCBjb250ZXh0KTtcblxuICAgICAgLy8gSWYgZnVuY3Rpb24sIHVzZSBhcyBzaG9ydGN1dCBmb3IgRE9NIHJlYWR5XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkge1xuICAgICAgb25SZWFkeShzZWxlY3Rvcik7cmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gSWYgYSBzaW5nbGUgRE9NIGVsZW1lbnQgaXMgcGFzc2VkIGluIG9yIHJlY2VpdmVkIHZpYSBJRCwgcmV0dXJuIHRoZSBzaW5nbGUgZWxlbWVudFxuICAgIGlmIChlbGVtcy5ub2RlVHlwZSB8fCBlbGVtcyA9PT0gd2luKSB7XG4gICAgICB0aGlzWzBdID0gZWxlbXM7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyZWF0IGxpa2UgYW4gYXJyYXkgYW5kIGxvb3AgdGhyb3VnaCBlYWNoIGl0ZW0uXG4gICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpc1tpXSA9IGVsZW1zW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FzaChzZWxlY3RvciwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgSW5pdChzZWxlY3RvciwgY29udGV4dCk7XG4gIH1cblxuICB2YXIgZm4gPSBjYXNoLmZuID0gY2FzaC5wcm90b3R5cGUgPSBJbml0LnByb3RvdHlwZSA9IHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgY2FzaDogdHJ1ZSxcbiAgICBsZW5ndGg6IDAsXG4gICAgcHVzaDogcHVzaCxcbiAgICBzcGxpY2U6IEFycmF5UHJvdG8uc3BsaWNlLFxuICAgIG1hcDogQXJyYXlQcm90by5tYXAsXG4gICAgaW5pdDogSW5pdFxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBjYXNoIH0pO1xuXG4gIGNhc2gucGFyc2VIVE1MID0gcGFyc2VIVE1MO1xuICBjYXNoLm5vb3AgPSBub29wO1xuICBjYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICBjYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbiAgY2FzaC5leHRlbmQgPSBmbi5leHRlbmQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuXG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICBpID0gMTtcblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGFyZ2V0ID0gdGhpcztcbiAgICAgIGkgPSAwO1xuICAgIH1cblxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghYXJnc1tpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBhcmdzW2ldKSB7XG4gICAgICAgIGlmIChhcmdzW2ldLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IGFyZ3NbaV1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gZWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xuICAgIHZhciBsID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChjYWxsYmFjay5jYWxsKGNvbGxlY3Rpb25baV0sIGNvbGxlY3Rpb25baV0sIGksIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaGVzKGVsLCBzZWxlY3Rvcikge1xuICAgIHZhciBtID0gZWwgJiYgKGVsLm1hdGNoZXMgfHwgZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3RvciB8fCBlbC5vTWF0Y2hlc1NlbGVjdG9yKTtcbiAgICByZXR1cm4gISFtICYmIG0uY2FsbChlbCwgc2VsZWN0b3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcGFyZUZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qIFVzZSBicm93c2VyJ3MgYG1hdGNoZXNgIGZ1bmN0aW9uIGlmIHN0cmluZyAqL1xuICAgICAgaXNTdHJpbmcoc2VsZWN0b3IpID8gbWF0Y2hlcyA6XG4gICAgICAvKiBNYXRjaCBhIGNhc2ggZWxlbWVudCAqL1xuICAgICAgc2VsZWN0b3IuY2FzaCA/IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IuaXMoZWwpO1xuICAgICAgfSA6XG4gICAgICAvKiBEaXJlY3QgY29tcGFyaXNvbiAqL1xuICAgICAgZnVuY3Rpb24gKGVsLCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZWwgPT09IHNlbGVjdG9yO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiB1bmlxdWUoY29sbGVjdGlvbikge1xuICAgIHJldHVybiBjYXNoKHNsaWNlLmNhbGwoY29sbGVjdGlvbikuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCwgc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXg7XG4gICAgfSkpO1xuICB9XG5cbiAgY2FzaC5leHRlbmQoe1xuICAgIG1lcmdlOiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgdmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuICAgICAgICAgIGkgPSBmaXJzdC5sZW5ndGgsXG4gICAgICAgICAgaiA9IDA7XG5cbiAgICAgIGZvciAoOyBqIDwgbGVuOyBpKyssIGorKykge1xuICAgICAgICBmaXJzdFtpXSA9IHNlY29uZFtqXTtcbiAgICAgIH1cblxuICAgICAgZmlyc3QubGVuZ3RoID0gaTtcbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9LFxuXG4gICAgZWFjaDogZWFjaCxcbiAgICBtYXRjaGVzOiBtYXRjaGVzLFxuICAgIHVuaXF1ZTogdW5pcXVlLFxuICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG4gICAgaXNOdW1lcmljOiBmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgdmFyIHVpZCA9IGNhc2gudWlkID0gXCJfY2FzaFwiICsgRGF0ZS5ub3coKTtcblxuICBmdW5jdGlvbiBnZXREYXRhQ2FjaGUobm9kZSkge1xuICAgIHJldHVybiBub2RlW3VpZF0gPSBub2RlW3VpZF0gfHwge307XG4gIH1cblxuICBmdW5jdGlvbiBzZXREYXRhKG5vZGUsIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZ2V0RGF0YUNhY2hlKG5vZGUpW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERhdGEobm9kZSwga2V5KSB7XG4gICAgdmFyIGMgPSBnZXREYXRhQ2FjaGUobm9kZSk7XG4gICAgaWYgKGNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjW2tleV0gPSBub2RlLmRhdGFzZXQgPyBub2RlLmRhdGFzZXRba2V5XSA6IGNhc2gobm9kZSkuYXR0cihcImRhdGEtXCIgKyBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gY1trZXldO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRGF0YShub2RlLCBrZXkpIHtcbiAgICB2YXIgYyA9IGdldERhdGFDYWNoZShub2RlKTtcbiAgICBpZiAoYykge1xuICAgICAgZGVsZXRlIGNba2V5XTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuZGF0YXNldCkge1xuICAgICAgZGVsZXRlIG5vZGUuZGF0YXNldFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXNoKG5vZGUpLnJlbW92ZUF0dHIoXCJkYXRhLVwiICsgbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZm4uZXh0ZW5kKHtcbiAgICBkYXRhOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChpc1N0cmluZyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGdldERhdGEodGhpc1swXSwgbmFtZSkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gc2V0RGF0YSh2LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgICB0aGlzLmRhdGEoa2V5LCBuYW1lW2tleV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRGF0YSh2LCBrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIHZhciBub3RXaGl0ZU1hdGNoID0gL1xcUysvZztcblxuICBmdW5jdGlvbiBnZXRDbGFzc2VzKGMpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcoYykgJiYgYy5tYXRjaChub3RXaGl0ZU1hdGNoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKHYsIGMpIHtcbiAgICByZXR1cm4gdi5jbGFzc0xpc3QgPyB2LmNsYXNzTGlzdC5jb250YWlucyhjKSA6IG5ldyBSZWdFeHAoXCIoXnwgKVwiICsgYyArIFwiKCB8JClcIiwgXCJnaVwiKS50ZXN0KHYuY2xhc3NOYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENsYXNzKHYsIGMsIHNwYWNlZE5hbWUpIHtcbiAgICBpZiAodi5jbGFzc0xpc3QpIHtcbiAgICAgIHYuY2xhc3NMaXN0LmFkZChjKTtcbiAgICB9IGVsc2UgaWYgKHNwYWNlZE5hbWUuaW5kZXhPZihcIiBcIiArIGMgKyBcIiBcIikpIHtcbiAgICAgIHYuY2xhc3NOYW1lICs9IFwiIFwiICsgYztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyh2LCBjKSB7XG4gICAgaWYgKHYuY2xhc3NMaXN0KSB7XG4gICAgICB2LmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHYuY2xhc3NOYW1lID0gdi5jbGFzc05hbWUucmVwbGFjZShjLCBcIlwiKTtcbiAgICB9XG4gIH1cblxuICBmbi5leHRlbmQoe1xuICAgIGFkZENsYXNzOiBmdW5jdGlvbiAoYykge1xuICAgICAgdmFyIGNsYXNzZXMgPSBnZXRDbGFzc2VzKGMpO1xuXG4gICAgICByZXR1cm4gY2xhc3NlcyA/IHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgc3BhY2VkTmFtZSA9IFwiIFwiICsgdi5jbGFzc05hbWUgKyBcIiBcIjtcbiAgICAgICAgZWFjaChjbGFzc2VzLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGFkZENsYXNzKHYsIGMsIHNwYWNlZE5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pIDogdGhpcztcbiAgICB9LFxuXG4gICAgYXR0cjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKG5hbWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdLmdldEF0dHJpYnV0ZSA/IHRoaXNbMF0uZ2V0QXR0cmlidXRlKG5hbWUpIDogdGhpc1swXVtuYW1lXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBpZiAodi5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHYuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdltuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXR0cihrZXksIG5hbWVba2V5XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBoYXNDbGFzczogZnVuY3Rpb24gKGMpIHtcbiAgICAgIHZhciBjaGVjayA9IGZhbHNlLFxuICAgICAgICAgIGNsYXNzZXMgPSBnZXRDbGFzc2VzKGMpO1xuICAgICAgaWYgKGNsYXNzZXMgJiYgY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgY2hlY2sgPSBoYXNDbGFzcyh2LCBjbGFzc2VzWzBdKTtcbiAgICAgICAgICByZXR1cm4gIWNoZWNrO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9LFxuXG4gICAgcHJvcDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoaXNTdHJpbmcobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB0aGlzWzBdW25hbWVdIDogdGhpcy5lYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgdltuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgICAgdGhpcy5wcm9wKGtleSwgbmFtZVtrZXldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh2LnJlbW92ZUF0dHJpYnV0ZSkge1xuICAgICAgICAgIHYucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB2W25hbWVdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cihcImNsYXNzXCIsIFwiXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGNsYXNzZXMgPSBnZXRDbGFzc2VzKGMpO1xuICAgICAgcmV0dXJuIGNsYXNzZXMgPyB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgZWFjaChjbGFzc2VzLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHYsIGMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pIDogdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlUHJvcDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgZGVsZXRlIHZbbmFtZV07XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIChjLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbc3RhdGUgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKGMpO1xuICAgICAgfVxuICAgICAgdmFyIGNsYXNzZXMgPSBnZXRDbGFzc2VzKGMpO1xuICAgICAgcmV0dXJuIGNsYXNzZXMgPyB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIHNwYWNlZE5hbWUgPSBcIiBcIiArIHYuY2xhc3NOYW1lICsgXCIgXCI7XG4gICAgICAgIGVhY2goY2xhc3NlcywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBpZiAoaGFzQ2xhc3ModiwgYykpIHtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKHYsIGMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRDbGFzcyh2LCBjLCBzcGFjZWROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSkgOiB0aGlzO1xuICAgIH0gfSk7XG5cbiAgZm4uZXh0ZW5kKHtcbiAgICBhZGQ6IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHVuaXF1ZShjYXNoLm1lcmdlKHRoaXMsIGNhc2goc2VsZWN0b3IsIGNvbnRleHQpKSk7XG4gICAgfSxcblxuICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgZWFjaCh0aGlzLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZXE6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIGNhc2godGhpcy5nZXQoaW5kZXgpKTtcbiAgICB9LFxuXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wYXJhdG9yID0gaXNGdW5jdGlvbihzZWxlY3RvcikgPyBzZWxlY3RvciA6IGdldENvbXBhcmVGdW5jdGlvbihzZWxlY3Rvcik7XG5cbiAgICAgIHJldHVybiBjYXNoKGZpbHRlci5jYWxsKHRoaXMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yKGUsIHNlbGVjdG9yKTtcbiAgICAgIH0pKTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVxKDApO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXggPCAwID8gdGhpc1tpbmRleCArIHRoaXMubGVuZ3RoXSA6IHRoaXNbaW5kZXhdO1xuICAgIH0sXG5cbiAgICBpbmRleDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHZhciBjaGlsZCA9IGVsZW0gPyBjYXNoKGVsZW0pWzBdIDogdGhpc1swXSxcbiAgICAgICAgICBjb2xsZWN0aW9uID0gZWxlbSA/IHRoaXMgOiBjYXNoKGNoaWxkKS5wYXJlbnQoKS5jaGlsZHJlbigpO1xuICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoY29sbGVjdGlvbikuaW5kZXhPZihjaGlsZCk7XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVxKC0xKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgdmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FtZWxSZWdleCA9IC8oPzpeXFx3fFtBLVpdfFxcYlxcdykvZyxcbiAgICAgICAgd2hpdGVTcGFjZSA9IC9bXFxzLV9dKy9nO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxSZWdleCwgZnVuY3Rpb24gKGxldHRlciwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlcltpbmRleCA9PT0gMCA/IFwidG9Mb3dlckNhc2VcIiA6IFwidG9VcHBlckNhc2VcIl0oKTtcbiAgICAgIH0pLnJlcGxhY2Uod2hpdGVTcGFjZSwgXCJcIik7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBnZXRQcmVmaXhlZFByb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhY2hlID0ge30sXG4gICAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgICBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgc3R5bGUgPSBkaXYuc3R5bGU7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHByb3AgPSBjYW1lbENhc2UocHJvcCk7XG4gICAgICBpZiAoY2FjaGVbcHJvcF0pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICB2YXIgdWNQcm9wID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSksXG4gICAgICAgICAgcHJlZml4ZXMgPSBbXCJ3ZWJraXRcIiwgXCJtb3pcIiwgXCJtc1wiLCBcIm9cIl0sXG4gICAgICAgICAgcHJvcHMgPSAocHJvcCArIFwiIFwiICsgcHJlZml4ZXMuam9pbih1Y1Byb3AgKyBcIiBcIikgKyB1Y1Byb3ApLnNwbGl0KFwiIFwiKTtcblxuICAgICAgZWFjaChwcm9wcywgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgaWYgKHAgaW4gc3R5bGUpIHtcbiAgICAgICAgICBjYWNoZVtwXSA9IHByb3AgPSBjYWNoZVtwcm9wXSA9IHA7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNhY2hlW3Byb3BdO1xuICAgIH07XG4gIH0oKTtcblxuICBjYXNoLnByZWZpeGVkUHJvcCA9IGdldFByZWZpeGVkUHJvcDtcbiAgY2FzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5cbiAgZm4uZXh0ZW5kKHtcbiAgICBjc3M6IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgaWYgKGlzU3RyaW5nKHByb3ApKSB7XG4gICAgICAgIHByb3AgPSBnZXRQcmVmaXhlZFByb3AocHJvcCk7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiB2LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH0pIDogd2luLmdldENvbXB1dGVkU3R5bGUodGhpc1swXSlbcHJvcF07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wKSB7XG4gICAgICAgIHRoaXMuY3NzKGtleSwgcHJvcFtrZXldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGNvbXB1dGUoZWwsIHByb3ApIHtcbiAgICByZXR1cm4gcGFyc2VJbnQod2luLmdldENvbXB1dGVkU3R5bGUoZWxbMF0sIG51bGwpW3Byb3BdLCAxMCkgfHwgMDtcbiAgfVxuXG4gIGVhY2goW1wiV2lkdGhcIiwgXCJIZWlnaHRcIl0sIGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGxvd2VyID0gdi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgZm5bbG93ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbbG93ZXJdO1xuICAgIH07XG5cbiAgICBmbltcImlubmVyXCIgKyB2XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzWzBdW1wiY2xpZW50XCIgKyB2XTtcbiAgICB9O1xuXG4gICAgZm5bXCJvdXRlclwiICsgdl0gPSBmdW5jdGlvbiAobWFyZ2lucykge1xuICAgICAgcmV0dXJuIHRoaXNbMF1bXCJvZmZzZXRcIiArIHZdICsgKG1hcmdpbnMgPyBjb21wdXRlKHRoaXMsIFwibWFyZ2luXCIgKyAodiA9PT0gXCJXaWR0aFwiID8gXCJMZWZ0XCIgOiBcIlRvcFwiKSkgKyBjb21wdXRlKHRoaXMsIFwibWFyZ2luXCIgKyAodiA9PT0gXCJXaWR0aFwiID8gXCJSaWdodFwiIDogXCJCb3R0b21cIikpIDogMCk7XG4gICAgfTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJFdmVudChub2RlLCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGV2ZW50Q2FjaGUgPSBnZXREYXRhKG5vZGUsIFwiX2Nhc2hFdmVudHNcIikgfHwgc2V0RGF0YShub2RlLCBcIl9jYXNoRXZlbnRzXCIsIHt9KTtcbiAgICBldmVudENhY2hlW2V2ZW50TmFtZV0gPSBldmVudENhY2hlW2V2ZW50TmFtZV0gfHwgW107XG4gICAgZXZlbnRDYWNoZVtldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUV2ZW50KG5vZGUsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZXZlbnRzID0gZ2V0RGF0YShub2RlLCBcIl9jYXNoRXZlbnRzXCIpLFxuICAgICAgICBldmVudENhY2hlID0gZXZlbnRzICYmIGV2ZW50c1tldmVudE5hbWVdLFxuICAgICAgICBpbmRleDtcblxuICAgIGlmICghZXZlbnRDYWNoZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgaW5kZXggPSBldmVudENhY2hlLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgZXZlbnRDYWNoZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlYWNoKGV2ZW50Q2FjaGUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICB9KTtcbiAgICAgIGV2ZW50Q2FjaGUgPSBbXTtcbiAgICB9XG4gIH1cblxuICBmbi5leHRlbmQoe1xuICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUV2ZW50KHYsIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBkZWxlZ2F0ZSwgY2FsbGJhY2ssIHJ1bk9uY2UpIHtcbiAgICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2s7XG4gICAgICBpZiAoIWlzU3RyaW5nKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50TmFtZSkge1xuICAgICAgICAgIHRoaXMub24oa2V5LCBkZWxlZ2F0ZSwgZXZlbnROYW1lW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihkZWxlZ2F0ZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBkZWxlZ2F0ZTtcbiAgICAgICAgZGVsZWdhdGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnROYW1lID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgb25SZWFkeShjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHQgPSBlLnRhcmdldDtcbiAgICAgICAgICB3aGlsZSAoIW1hdGNoZXModCwgZGVsZWdhdGUpKSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gdGhpcyB8fCB0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHQgPSB0LnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suY2FsbCh0LCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIGZpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHJ1bk9uY2UpIHtcbiAgICAgICAgICBmaW5hbENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50KHYsIGV2ZW50TmFtZSwgZmluYWxDYWxsYmFjayk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlckV2ZW50KHYsIGV2ZW50TmFtZSwgZmluYWxDYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgb25lOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBkZWxlZ2F0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50TmFtZSwgZGVsZWdhdGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgcmVhZHk6IG9uUmVhZHksXG5cbiAgICAvKipcbiAgICAgKiBNb2RpZmllZFxuICAgICAqIFRyaWdnZXJzIGJyb3dzZXIgZXZlbnRcbiAgICAgKiBAcGFyYW0gU3RyaW5nIGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSBPYmplY3QgZGF0YSAtIEFkZCBwcm9wZXJ0aWVzIHRvIGV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICAgICAgZXZ0LmluaXRFdmVudChldmVudE5hbWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgZXZ0ID0gdGhpcy5leHRlbmQoZXZ0LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiB2LmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGVuY29kZShuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBcIiZcIiArIGVuY29kZVVSSUNvbXBvbmVudChuYW1lKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKS5yZXBsYWNlKC8lMjAvZywgXCIrXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VsZWN0TXVsdGlwbGVfKGVsKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGVhY2goZWwub3B0aW9ucywgZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmIChvLnNlbGVjdGVkKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKG8udmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlbGVjdFNpbmdsZV8oZWwpIHtcbiAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IGVsLnNlbGVjdGVkSW5kZXg7XG4gICAgcmV0dXJuIHNlbGVjdGVkSW5kZXggPj0gMCA/IGVsLm9wdGlvbnNbc2VsZWN0ZWRJbmRleF0udmFsdWUgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUoZWwpIHtcbiAgICB2YXIgdHlwZSA9IGVsLnR5cGU7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJzZWxlY3Qtb25lXCI6XG4gICAgICAgIHJldHVybiBnZXRTZWxlY3RTaW5nbGVfKGVsKTtcbiAgICAgIGNhc2UgXCJzZWxlY3QtbXVsdGlwbGVcIjpcbiAgICAgICAgcmV0dXJuIGdldFNlbGVjdE11bHRpcGxlXyhlbCk7XG4gICAgICBjYXNlIFwicmFkaW9cIjpcbiAgICAgICAgcmV0dXJuIGVsLmNoZWNrZWQgPyBlbC52YWx1ZSA6IG51bGw7XG4gICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgcmV0dXJuIGVsLmNoZWNrZWQgPyBlbC52YWx1ZSA6IG51bGw7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZWwudmFsdWUgPyBlbC52YWx1ZSA6IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZm4uZXh0ZW5kKHtcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBxdWVyeSA9IFwiXCI7XG5cbiAgICAgIGVhY2godGhpc1swXS5lbGVtZW50cyB8fCB0aGlzLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsLmRpc2FibGVkIHx8IGVsLnRhZ05hbWUgPT09IFwiRklFTERTRVRcIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IGVsLm5hbWU7XG4gICAgICAgIHN3aXRjaCAoZWwudHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgICBjYXNlIFwicmVzZXRcIjpcbiAgICAgICAgICBjYXNlIFwic3VibWl0XCI6XG4gICAgICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNlbGVjdC1tdWx0aXBsZVwiOlxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGdldFZhbHVlKGVsKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZWFjaCh2YWx1ZXMsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ICs9IGVuY29kZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKGVsKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBxdWVyeSArPSBlbmNvZGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHF1ZXJ5LnN1YnN0cigxKTtcbiAgICB9LFxuXG4gICAgdmFsOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBnZXRWYWx1ZSh0aGlzWzBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGluc2VydEVsZW1lbnQoZWwsIGNoaWxkLCBwcmVwZW5kKSB7XG4gICAgaWYgKHByZXBlbmQpIHtcbiAgICAgIHZhciBmaXJzdCA9IGVsLmNoaWxkTm9kZXNbMF07XG4gICAgICBlbC5pbnNlcnRCZWZvcmUoY2hpbGQsIGZpcnN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydENvbnRlbnQocGFyZW50LCBjaGlsZCwgcHJlcGVuZCkge1xuICAgIHZhciBzdHIgPSBpc1N0cmluZyhjaGlsZCk7XG5cbiAgICBpZiAoIXN0ciAmJiBjaGlsZC5sZW5ndGgpIHtcbiAgICAgIGVhY2goY2hpbGQsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBpbnNlcnRDb250ZW50KHBhcmVudCwgdiwgcHJlcGVuZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlYWNoKHBhcmVudCwgc3RyID8gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2Lmluc2VydEFkamFjZW50SFRNTChwcmVwZW5kID8gXCJhZnRlcmJlZ2luXCIgOiBcImJlZm9yZWVuZFwiLCBjaGlsZCk7XG4gICAgfSA6IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICByZXR1cm4gaW5zZXJ0RWxlbWVudCh2LCBpID09PSAwID8gY2hpbGQgOiBjaGlsZC5jbG9uZU5vZGUodHJ1ZSksIHByZXBlbmQpO1xuICAgIH0pO1xuICB9XG5cbiAgZm4uZXh0ZW5kKHtcbiAgICBhZnRlcjogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBjYXNoKHNlbGVjdG9yKS5pbnNlcnRBZnRlcih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhcHBlbmQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICBpbnNlcnRDb250ZW50KHRoaXMsIGNvbnRlbnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFwcGVuZFRvOiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICBpbnNlcnRDb250ZW50KGNhc2gocGFyZW50KSwgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYmVmb3JlOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGNhc2goc2VsZWN0b3IpLmluc2VydEJlZm9yZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNhc2godGhpcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5odG1sKFwiXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGh0bWw6IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdLmlubmVySFRNTDtcbiAgICAgIH1cbiAgICAgIHZhciBzb3VyY2UgPSBjb250ZW50Lm5vZGVUeXBlID8gY29udGVudFswXS5vdXRlckhUTUwgOiBjb250ZW50O1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi5pbm5lckhUTUwgPSBzb3VyY2U7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0QWZ0ZXI6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgY2FzaChzZWxlY3RvcikuZWFjaChmdW5jdGlvbiAoZWwsIGkpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGUsXG4gICAgICAgICAgICBzaWJsaW5nID0gZWwubmV4dFNpYmxpbmc7XG4gICAgICAgIF90aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGkgPT09IDAgPyB2IDogdi5jbG9uZU5vZGUodHJ1ZSksIHNpYmxpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgY2FzaChzZWxlY3RvcikuZWFjaChmdW5jdGlvbiAoZWwsIGkpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIF90aGlzMi5lYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShpID09PSAwID8gdiA6IHYuY2xvbmVOb2RlKHRydWUpLCBlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcHJlcGVuZDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgIGluc2VydENvbnRlbnQodGhpcywgY29udGVudCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcHJlcGVuZFRvOiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICBpbnNlcnRDb250ZW50KGNhc2gocGFyZW50KSwgdGhpcywgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICghIXYucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHJldHVybiB2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0ZXh0OiBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpc1swXS50ZXh0Q29udGVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIHZhciBkb2NFbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgZm4uZXh0ZW5kKHtcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVsID0gdGhpc1swXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGVsLm9mZnNldExlZnQsXG4gICAgICAgIHRvcDogZWwub2Zmc2V0VG9wXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBvZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZWN0ID0gdGhpc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbC5jbGllbnRUb3AsXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsLmNsaWVudExlZnRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNhc2godGhpc1swXS5vZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICB9KTtcblxuICBmbi5leHRlbmQoe1xuICAgIGNoaWxkcmVuOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBlbGVtcyA9IFtdO1xuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBwdXNoLmFwcGx5KGVsZW1zLCBlbC5jaGlsZHJlbik7XG4gICAgICB9KTtcbiAgICAgIGVsZW1zID0gdW5pcXVlKGVsZW1zKTtcblxuICAgICAgcmV0dXJuICFzZWxlY3RvciA/IGVsZW1zIDogZWxlbXMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzKHYsIHNlbGVjdG9yKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0OiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmICghc2VsZWN0b3IgfHwgdGhpcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBjYXNoKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICBpczogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoID0gZmFsc2UsXG4gICAgICAgICAgY29tcGFyYXRvciA9IGdldENvbXBhcmVGdW5jdGlvbihzZWxlY3Rvcik7XG5cbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgbWF0Y2ggPSBjb21wYXJhdG9yKGVsLCBzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiAhbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0sXG5cbiAgICBmaW5kOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3Iubm9kZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNhc2goc2VsZWN0b3IgJiYgdGhpcy5oYXMoc2VsZWN0b3IpLmxlbmd0aCA/IHNlbGVjdG9yIDogbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtcyA9IFtdO1xuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBwdXNoLmFwcGx5KGVsZW1zLCBmaW5kKHNlbGVjdG9yLCBlbCkpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB1bmlxdWUoZWxlbXMpO1xuICAgIH0sXG5cbiAgICBoYXM6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBpc1N0cmluZyhzZWxlY3RvcikgPyBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGZpbmQoc2VsZWN0b3IsIGVsKS5sZW5ndGggIT09IDA7XG4gICAgICB9IDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5jb250YWlucyhzZWxlY3Rvcik7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoY29tcGFyYXRvcik7XG4gICAgfSxcblxuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjYXNoKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgICB9LFxuXG4gICAgbm90OiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wYXJhdG9yID0gZ2V0Q29tcGFyZUZ1bmN0aW9uKHNlbGVjdG9yKTtcblxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gIWNvbXBhcmF0b3IoZWwsIHNlbGVjdG9yKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwYXJlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0ucGFyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdW5pcXVlKHJlc3VsdCk7XG4gICAgfSxcblxuICAgIHBhcmVudHM6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGxhc3QsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBsYXN0ID0gaXRlbTtcblxuICAgICAgICB3aGlsZSAobGFzdCAmJiBsYXN0LnBhcmVudE5vZGUgJiYgbGFzdCAhPT0gZG9jLmJvZHkucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGxhc3QgPSBsYXN0LnBhcmVudE5vZGU7XG5cbiAgICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yICYmIG1hdGNoZXMobGFzdCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChsYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdW5pcXVlKHJlc3VsdCk7XG4gICAgfSxcblxuICAgIHByZXY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjYXNoKHRoaXNbMF0ucHJldmlvdXNFbGVtZW50U2libGluZyk7XG4gICAgfSxcblxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5wYXJlbnQoKS5jaGlsZHJlbihzZWxlY3RvciksXG4gICAgICAgICAgZWwgPSB0aGlzWzBdO1xuXG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkgIT09IGVsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIHJldHVybiBjYXNoO1xufSk7XG47XG52YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogR2VuZXJpYyBjb25zdHJ1Y3RvciBmb3IgYWxsIGNvbXBvbmVudHNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudChjbGFzc0RlZiwgZWwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9uZW50KTtcblxuICAgIC8vIERpc3BsYXkgZXJyb3IgaWYgZWwgaXMgdmFsaWQgSFRNTCBFbGVtZW50XG4gICAgaWYgKCEoZWwgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihFcnJvcihlbCArICcgaXMgbm90IGFuIEhUTUwgRWxlbWVudCcpKTtcbiAgICB9XG5cbiAgICAvLyBJZiBleGlzdHMsIGRlc3Ryb3kgYW5kIHJlaW5pdGlhbGl6ZSBpbiBjaGlsZFxuICAgIHZhciBpbnMgPSBjbGFzc0RlZi5nZXRJbnN0YW5jZShlbCk7XG4gICAgaWYgKCEhaW5zKSB7XG4gICAgICBpbnMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB0aGlzLiRlbCA9IGNhc2goZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGNvbXBvbmVudHNcbiAgICogQHBhcmFtIHtjbGFzc30gY2xhc3NEZWZcbiAgICogQHBhcmFtIHtFbGVtZW50IHwgTm9kZUxpc3QgfCBqUXVlcnl9IGVsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDb21wb25lbnQsIG51bGwsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChjbGFzc0RlZiwgZWxzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgaW5zdGFuY2VzID0gbnVsbDtcbiAgICAgIGlmIChlbHMgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIGluc3RhbmNlcyA9IG5ldyBjbGFzc0RlZihlbHMsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICghIWVscyAmJiAoZWxzLmpxdWVyeSB8fCBlbHMuY2FzaCB8fCBlbHMgaW5zdGFuY2VvZiBOb2RlTGlzdCkpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlc0FyciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGluc3RhbmNlc0Fyci5wdXNoKG5ldyBjbGFzc0RlZihlbHNbaV0sIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZXMgPSBpbnN0YW5jZXNBcnI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbXBvbmVudDtcbn0oKTtcblxuOyAvLyBSZXF1aXJlZCBmb3IgTWV0ZW9yIHBhY2thZ2UsIHRoZSB1c2Ugb2Ygd2luZG93IHByZXZlbnRzIGV4cG9ydCBieSBNZXRlb3JcbihmdW5jdGlvbiAod2luZG93KSB7XG4gIGlmICh3aW5kb3cuUGFja2FnZSkge1xuICAgIE0gPSB7fTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuTSA9IHt9O1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGpRdWVyeVxuICBNLmpRdWVyeUxvYWRlZCA9ICEhd2luZG93LmpRdWVyeTtcbn0pKHdpbmRvdyk7XG5cbi8vIEFNRFxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoJ00nLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNO1xuICB9KTtcblxuICAvLyBDb21tb24gSlNcbn0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnICYmICFleHBvcnRzLm5vZGVUeXBlKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTTtcbiAgfVxuICBleHBvcnRzLmRlZmF1bHQgPSBNO1xufVxuXG5NLmFuaW1lID0gd2luZG93LmFuaW1lO1xuXG5NLnZlcnNpb24gPSAnMS4wLjAnO1xuXG5NLmtleXMgPSB7XG4gIFRBQjogOSxcbiAgRU5URVI6IDEzLFxuICBFU0M6IDI3LFxuICBBUlJPV19VUDogMzgsXG4gIEFSUk9XX0RPV046IDQwXG59O1xuXG4vKipcbiAqIFRhYlByZXNzIEtleWRvd24gaGFuZGxlclxuICovXG5NLnRhYlByZXNzZWQgPSBmYWxzZTtcbk0ua2V5RG93biA9IGZhbHNlO1xudmFyIGRvY0hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZSkge1xuICBNLmtleURvd24gPSB0cnVlO1xuICBpZiAoZS53aGljaCA9PT0gTS5rZXlzLlRBQiB8fCBlLndoaWNoID09PSBNLmtleXMuQVJST1dfRE9XTiB8fCBlLndoaWNoID09PSBNLmtleXMuQVJST1dfVVApIHtcbiAgICBNLnRhYlByZXNzZWQgPSB0cnVlO1xuICB9XG59O1xudmFyIGRvY0hhbmRsZUtleXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgTS5rZXlEb3duID0gZmFsc2U7XG4gIGlmIChlLndoaWNoID09PSBNLmtleXMuVEFCIHx8IGUud2hpY2ggPT09IE0ua2V5cy5BUlJPV19ET1dOIHx8IGUud2hpY2ggPT09IE0ua2V5cy5BUlJPV19VUCkge1xuICAgIE0udGFiUHJlc3NlZCA9IGZhbHNlO1xuICB9XG59O1xudmFyIGRvY0hhbmRsZUZvY3VzID0gZnVuY3Rpb24gKGUpIHtcbiAgaWYgKE0ua2V5RG93bikge1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgna2V5Ym9hcmQtZm9jdXNlZCcpO1xuICB9XG59O1xudmFyIGRvY0hhbmRsZUJsdXIgPSBmdW5jdGlvbiAoZSkge1xuICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2tleWJvYXJkLWZvY3VzZWQnKTtcbn07XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG9jSGFuZGxlS2V5ZG93biwgdHJ1ZSk7XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGRvY0hhbmRsZUtleXVwLCB0cnVlKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZG9jSGFuZGxlRm9jdXMsIHRydWUpO1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGRvY0hhbmRsZUJsdXIsIHRydWUpO1xuXG4vKipcbiAqIEluaXRpYWxpemUgalF1ZXJ5IHdyYXBwZXIgZm9yIHBsdWdpblxuICogQHBhcmFtIHtDbGFzc30gcGx1Z2luICBqYXZhc2NyaXB0IGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gcGx1Z2luTmFtZSAgalF1ZXJ5IHBsdWdpbiBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NSZWYgIENsYXNzIHJlZmVyZW5jZSBuYW1lXG4gKi9cbk0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIgPSBmdW5jdGlvbiAocGx1Z2luLCBwbHVnaW5OYW1lLCBjbGFzc1JlZikge1xuICBqUXVlcnkuZm5bcGx1Z2luTmFtZV0gPSBmdW5jdGlvbiAobWV0aG9kT3JPcHRpb25zKSB7XG4gICAgLy8gQ2FsbCBwbHVnaW4gbWV0aG9kIGlmIHZhbGlkIG1ldGhvZCBuYW1lIGlzIHBhc3NlZCBpblxuICAgIGlmIChwbHVnaW4ucHJvdG90eXBlW21ldGhvZE9yT3B0aW9uc10pIHtcbiAgICAgIHZhciBwYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgICAvLyBHZXR0ZXIgbWV0aG9kc1xuICAgICAgaWYgKG1ldGhvZE9yT3B0aW9ucy5zbGljZSgwLCAzKSA9PT0gJ2dldCcpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5maXJzdCgpWzBdW2NsYXNzUmVmXTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlW21ldGhvZE9yT3B0aW9uc10uYXBwbHkoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZvaWQgbWV0aG9kc1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXNbY2xhc3NSZWZdO1xuICAgICAgICBpbnN0YW5jZVttZXRob2RPck9wdGlvbnNdLmFwcGx5KGluc3RhbmNlLCBwYXJhbXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgcGx1Z2luIGlmIG9wdGlvbnMgb3Igbm8gYXJndW1lbnQgaXMgcGFzc2VkIGluXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWV0aG9kT3JPcHRpb25zID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kT3JPcHRpb25zKSB7XG4gICAgICBwbHVnaW4uaW5pdCh0aGlzLCBhcmd1bWVudHNbMF0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGVycm9yIGlmIGFuIHVucmVjb2duaXplZCAgbWV0aG9kIG5hbWUgaXMgcGFzc2VkIGluXG4gICAgalF1ZXJ5LmVycm9yKFwiTWV0aG9kIFwiICsgbWV0aG9kT3JPcHRpb25zICsgXCIgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5LlwiICsgcGx1Z2luTmFtZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgaW5pdGlhbGl6ZSBjb21wb25lbnRzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHQgIERPTSBFbGVtZW50IHRvIHNlYXJjaCB3aXRoaW4gZm9yIGNvbXBvbmVudHNcbiAqL1xuTS5BdXRvSW5pdCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIC8vIFVzZSBkb2N1bWVudC5ib2R5IGlmIG5vIGNvbnRleHQgaXMgZ2l2ZW5cbiAgdmFyIHJvb3QgPSAhIWNvbnRleHQgPyBjb250ZXh0IDogZG9jdW1lbnQuYm9keTtcblxuICB2YXIgcmVnaXN0cnkgPSB7XG4gICAgQXV0b2NvbXBsZXRlOiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5hdXRvY29tcGxldGU6bm90KC5uby1hdXRvaW5pdCknKSxcbiAgICBDYXJvdXNlbDogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcuY2Fyb3VzZWw6bm90KC5uby1hdXRvaW5pdCknKSxcbiAgICBDaGlwczogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcuY2hpcHM6bm90KC5uby1hdXRvaW5pdCknKSxcbiAgICBDb2xsYXBzaWJsZTogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcuY29sbGFwc2libGU6bm90KC5uby1hdXRvaW5pdCknKSxcbiAgICBEYXRlcGlja2VyOiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kYXRlcGlja2VyOm5vdCgubm8tYXV0b2luaXQpJyksXG4gICAgRHJvcGRvd246IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLmRyb3Bkb3duLXRyaWdnZXI6bm90KC5uby1hdXRvaW5pdCknKSxcbiAgICBNYXRlcmlhbGJveDogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcubWF0ZXJpYWxib3hlZDpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIE1vZGFsOiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb2RhbDpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIFBhcmFsbGF4OiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wYXJhbGxheDpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIFB1c2hwaW46IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLnB1c2hwaW46bm90KC5uby1hdXRvaW5pdCknKSxcbiAgICBTY3JvbGxTcHk6IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLnNjcm9sbHNweTpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIEZvcm1TZWxlY3Q6IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0Om5vdCgubm8tYXV0b2luaXQpJyksXG4gICAgU2lkZW5hdjogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcuc2lkZW5hdjpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIFRhYnM6IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLnRhYnM6bm90KC5uby1hdXRvaW5pdCknKSxcbiAgICBUYXBUYXJnZXQ6IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLnRhcC10YXJnZXQ6bm90KC5uby1hdXRvaW5pdCknKSxcbiAgICBUaW1lcGlja2VyOiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy50aW1lcGlja2VyOm5vdCgubm8tYXV0b2luaXQpJyksXG4gICAgVG9vbHRpcDogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcudG9vbHRpcHBlZDpub3QoLm5vLWF1dG9pbml0KScpLFxuICAgIEZsb2F0aW5nQWN0aW9uQnV0dG9uOiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5maXhlZC1hY3Rpb24tYnRuOm5vdCgubm8tYXV0b2luaXQpJylcbiAgfTtcblxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIHJlZ2lzdHJ5KSB7XG4gICAgdmFyIHBsdWdpbiA9IE1bcGx1Z2luTmFtZV07XG4gICAgcGx1Z2luLmluaXQocmVnaXN0cnlbcGx1Z2luTmFtZV0pO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGFwcHJveGltYXRlZCBzZWxlY3RvciBzdHJpbmcgZm9yIGEgalF1ZXJ5IG9iamVjdFxuICogQHBhcmFtIHtqUXVlcnl9IG9iaiAgalF1ZXJ5IG9iamVjdCB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk0ub2JqZWN0U2VsZWN0b3JTdHJpbmcgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciB0YWdTdHIgPSBvYmoucHJvcCgndGFnTmFtZScpIHx8ICcnO1xuICB2YXIgaWRTdHIgPSBvYmouYXR0cignaWQnKSB8fCAnJztcbiAgdmFyIGNsYXNzU3RyID0gb2JqLmF0dHIoJ2NsYXNzJykgfHwgJyc7XG4gIHJldHVybiAodGFnU3RyICsgaWRTdHIgKyBjbGFzc1N0cikucmVwbGFjZSgvXFxzL2csICcnKTtcbn07XG5cbi8vIFVuaXF1ZSBSYW5kb20gSURcbk0uZ3VpZCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gczQoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gIH07XG59KCk7XG5cbi8qKlxuICogRXNjYXBlcyBoYXNoIGZyb20gc3BlY2lhbCBjaGFyYWN0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAgU3RyaW5nIHJldHVybmVkIGZyb20gdGhpcy5oYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5NLmVzY2FwZUhhc2ggPSBmdW5jdGlvbiAoaGFzaCkge1xuICByZXR1cm4gaGFzaC5yZXBsYWNlKC8oOnxcXC58XFxbfFxcXXwsfD18XFwvKS9nLCAnXFxcXCQxJyk7XG59O1xuXG5NLmVsZW1lbnRPclBhcmVudElzRml4ZWQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICB2YXIgJGNoZWNrRWxlbWVudHMgPSAkZWxlbWVudC5hZGQoJGVsZW1lbnQucGFyZW50cygpKTtcbiAgdmFyIGlzRml4ZWQgPSBmYWxzZTtcbiAgJGNoZWNrRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCQodGhpcykuY3NzKCdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgICBpc0ZpeGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaXNGaXhlZDtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRWRnZXNcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdG9wICBJZiB0aGUgdG9wIGVkZ2Ugd2FzIGV4Y2VlZGVkXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHJpZ2h0ICBJZiB0aGUgcmlnaHQgZWRnZSB3YXMgZXhjZWVkZWRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYm90dG9tICBJZiB0aGUgYm90dG9tIGVkZ2Ugd2FzIGV4Y2VlZGVkXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGxlZnQgIElmIHRoZSBsZWZ0IGVkZ2Ugd2FzIGV4Y2VlZGVkXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCb3VuZGluZ1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGxlZnQgIGxlZnQgb2Zmc2V0IGNvb3JkaW5hdGVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0b3AgIHRvcCBvZmZzZXQgY29vcmRpbmF0ZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHdpZHRoXG4gKiBAcHJvcGVydHkge051bWJlcn0gaGVpZ2h0XG4gKi9cblxuLyoqXG4gKiBFc2NhcGVzIGhhc2ggZnJvbSBzcGVjaWFsIGNoYXJhY3RlcnNcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICBDb250YWluZXIgZWxlbWVudCB0aGF0IGFjdHMgYXMgdGhlIGJvdW5kYXJ5XG4gKiBAcGFyYW0ge0JvdW5kaW5nfSBib3VuZGluZyAgZWxlbWVudCBib3VuZGluZyB0aGF0IGlzIGJlaW5nIGNoZWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgIG9mZnNldCBmcm9tIGVkZ2UgdGhhdCBjb3VudHMgYXMgZXhjZWVkaW5nXG4gKiBAcmV0dXJucyB7RWRnZXN9XG4gKi9cbk0uY2hlY2tXaXRoaW5Db250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBib3VuZGluZywgb2Zmc2V0KSB7XG4gIHZhciBlZGdlcyA9IHtcbiAgICB0b3A6IGZhbHNlLFxuICAgIHJpZ2h0OiBmYWxzZSxcbiAgICBib3R0b206IGZhbHNlLFxuICAgIGxlZnQ6IGZhbHNlXG4gIH07XG5cbiAgdmFyIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIC8vIElmIGJvZHkgZWxlbWVudCBpcyBzbWFsbGVyIHRoYW4gdmlld3BvcnQsIHVzZSB2aWV3cG9ydCBoZWlnaHQgaW5zdGVhZC5cbiAgdmFyIGNvbnRhaW5lckJvdHRvbSA9IGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSA/IE1hdGgubWF4KGNvbnRhaW5lclJlY3QuYm90dG9tLCB3aW5kb3cuaW5uZXJIZWlnaHQpIDogY29udGFpbmVyUmVjdC5ib3R0b207XG5cbiAgdmFyIHNjcm9sbExlZnQgPSBjb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgdmFyIHNjcm9sbFRvcCA9IGNvbnRhaW5lci5zY3JvbGxUb3A7XG5cbiAgdmFyIHNjcm9sbGVkWCA9IGJvdW5kaW5nLmxlZnQgLSBzY3JvbGxMZWZ0O1xuICB2YXIgc2Nyb2xsZWRZID0gYm91bmRpbmcudG9wIC0gc2Nyb2xsVG9wO1xuXG4gIC8vIENoZWNrIGZvciBjb250YWluZXIgYW5kIHZpZXdwb3J0IGZvciBlYWNoIGVkZ2VcbiAgaWYgKHNjcm9sbGVkWCA8IGNvbnRhaW5lclJlY3QubGVmdCArIG9mZnNldCB8fCBzY3JvbGxlZFggPCBvZmZzZXQpIHtcbiAgICBlZGdlcy5sZWZ0ID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzY3JvbGxlZFggKyBib3VuZGluZy53aWR0aCA+IGNvbnRhaW5lclJlY3QucmlnaHQgLSBvZmZzZXQgfHwgc2Nyb2xsZWRYICsgYm91bmRpbmcud2lkdGggPiB3aW5kb3cuaW5uZXJXaWR0aCAtIG9mZnNldCkge1xuICAgIGVkZ2VzLnJpZ2h0ID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzY3JvbGxlZFkgPCBjb250YWluZXJSZWN0LnRvcCArIG9mZnNldCB8fCBzY3JvbGxlZFkgPCBvZmZzZXQpIHtcbiAgICBlZGdlcy50b3AgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHNjcm9sbGVkWSArIGJvdW5kaW5nLmhlaWdodCA+IGNvbnRhaW5lckJvdHRvbSAtIG9mZnNldCB8fCBzY3JvbGxlZFkgKyBib3VuZGluZy5oZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBvZmZzZXQpIHtcbiAgICBlZGdlcy5ib3R0b20gPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGVkZ2VzO1xufTtcblxuTS5jaGVja1Bvc3NpYmxlQWxpZ25tZW50cyA9IGZ1bmN0aW9uIChlbCwgY29udGFpbmVyLCBib3VuZGluZywgb2Zmc2V0KSB7XG4gIHZhciBjYW5BbGlnbiA9IHtcbiAgICB0b3A6IHRydWUsXG4gICAgcmlnaHQ6IHRydWUsXG4gICAgYm90dG9tOiB0cnVlLFxuICAgIGxlZnQ6IHRydWUsXG4gICAgc3BhY2VPblRvcDogbnVsbCxcbiAgICBzcGFjZU9uUmlnaHQ6IG51bGwsXG4gICAgc3BhY2VPbkJvdHRvbTogbnVsbCxcbiAgICBzcGFjZU9uTGVmdDogbnVsbFxuICB9O1xuXG4gIHZhciBjb250YWluZXJBbGxvd3NPdmVyZmxvdyA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5vdmVyZmxvdyA9PT0gJ3Zpc2libGUnO1xuICB2YXIgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGNvbnRhaW5lckhlaWdodCA9IE1hdGgubWluKGNvbnRhaW5lclJlY3QuaGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICB2YXIgY29udGFpbmVyV2lkdGggPSBNYXRoLm1pbihjb250YWluZXJSZWN0LndpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCk7XG4gIHZhciBlbE9mZnNldFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICB2YXIgc2Nyb2xsTGVmdCA9IGNvbnRhaW5lci5zY3JvbGxMZWZ0O1xuICB2YXIgc2Nyb2xsVG9wID0gY29udGFpbmVyLnNjcm9sbFRvcDtcblxuICB2YXIgc2Nyb2xsZWRYID0gYm91bmRpbmcubGVmdCAtIHNjcm9sbExlZnQ7XG4gIHZhciBzY3JvbGxlZFlUb3BFZGdlID0gYm91bmRpbmcudG9wIC0gc2Nyb2xsVG9wO1xuICB2YXIgc2Nyb2xsZWRZQm90dG9tRWRnZSA9IGJvdW5kaW5nLnRvcCArIGVsT2Zmc2V0UmVjdC5oZWlnaHQgLSBzY3JvbGxUb3A7XG5cbiAgLy8gQ2hlY2sgZm9yIGNvbnRhaW5lciBhbmQgdmlld3BvcnQgZm9yIGxlZnRcbiAgY2FuQWxpZ24uc3BhY2VPblJpZ2h0ID0gIWNvbnRhaW5lckFsbG93c092ZXJmbG93ID8gY29udGFpbmVyV2lkdGggLSAoc2Nyb2xsZWRYICsgYm91bmRpbmcud2lkdGgpIDogd2luZG93LmlubmVyV2lkdGggLSAoZWxPZmZzZXRSZWN0LmxlZnQgKyBib3VuZGluZy53aWR0aCk7XG4gIGlmIChjYW5BbGlnbi5zcGFjZU9uUmlnaHQgPCAwKSB7XG4gICAgY2FuQWxpZ24ubGVmdCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGNvbnRhaW5lciBhbmQgdmlld3BvcnQgZm9yIFJpZ2h0XG4gIGNhbkFsaWduLnNwYWNlT25MZWZ0ID0gIWNvbnRhaW5lckFsbG93c092ZXJmbG93ID8gc2Nyb2xsZWRYIC0gYm91bmRpbmcud2lkdGggKyBlbE9mZnNldFJlY3Qud2lkdGggOiBlbE9mZnNldFJlY3QucmlnaHQgLSBib3VuZGluZy53aWR0aDtcbiAgaWYgKGNhbkFsaWduLnNwYWNlT25MZWZ0IDwgMCkge1xuICAgIGNhbkFsaWduLnJpZ2h0ID0gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgY29udGFpbmVyIGFuZCB2aWV3cG9ydCBmb3IgVG9wXG4gIGNhbkFsaWduLnNwYWNlT25Cb3R0b20gPSAhY29udGFpbmVyQWxsb3dzT3ZlcmZsb3cgPyBjb250YWluZXJIZWlnaHQgLSAoc2Nyb2xsZWRZVG9wRWRnZSArIGJvdW5kaW5nLmhlaWdodCArIG9mZnNldCkgOiB3aW5kb3cuaW5uZXJIZWlnaHQgLSAoZWxPZmZzZXRSZWN0LnRvcCArIGJvdW5kaW5nLmhlaWdodCArIG9mZnNldCk7XG4gIGlmIChjYW5BbGlnbi5zcGFjZU9uQm90dG9tIDwgMCkge1xuICAgIGNhbkFsaWduLnRvcCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGNvbnRhaW5lciBhbmQgdmlld3BvcnQgZm9yIEJvdHRvbVxuICBjYW5BbGlnbi5zcGFjZU9uVG9wID0gIWNvbnRhaW5lckFsbG93c092ZXJmbG93ID8gc2Nyb2xsZWRZQm90dG9tRWRnZSAtIChib3VuZGluZy5oZWlnaHQgLSBvZmZzZXQpIDogZWxPZmZzZXRSZWN0LmJvdHRvbSAtIChib3VuZGluZy5oZWlnaHQgKyBvZmZzZXQpO1xuICBpZiAoY2FuQWxpZ24uc3BhY2VPblRvcCA8IDApIHtcbiAgICBjYW5BbGlnbi5ib3R0b20gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjYW5BbGlnbjtcbn07XG5cbk0uZ2V0T3ZlcmZsb3dQYXJlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoZWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLm92ZXJmbG93ICE9PSAndmlzaWJsZScpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBNLmdldE92ZXJmbG93UGFyZW50KGVsZW1lbnQucGFyZW50RWxlbWVudCk7XG59O1xuXG4vKipcbiAqIEdldHMgaWQgb2YgY29tcG9uZW50IGZyb20gYSB0cmlnZ2VyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRyaWdnZXIgIHRyaWdnZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk0uZ2V0SWRGcm9tVHJpZ2dlciA9IGZ1bmN0aW9uICh0cmlnZ2VyKSB7XG4gIHZhciBpZCA9IHRyaWdnZXIuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpO1xuICBpZiAoIWlkKSB7XG4gICAgaWQgPSB0cmlnZ2VyLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIGlmIChpZCkge1xuICAgICAgaWQgPSBpZC5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWQgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlkO1xufTtcblxuLyoqXG4gKiBNdWx0aSBicm93c2VyIHN1cHBvcnQgZm9yIGRvY3VtZW50IHNjcm9sbCB0b3BcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbk0uZ2V0RG9jdW1lbnRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCB8fCAwO1xufTtcblxuLyoqXG4gKiBNdWx0aSBicm93c2VyIHN1cHBvcnQgZm9yIGRvY3VtZW50IHNjcm9sbCBsZWZ0XG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5NLmdldERvY3VtZW50U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgMDtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRWRnZXNcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdG9wICBJZiB0aGUgdG9wIGVkZ2Ugd2FzIGV4Y2VlZGVkXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHJpZ2h0ICBJZiB0aGUgcmlnaHQgZWRnZSB3YXMgZXhjZWVkZWRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYm90dG9tICBJZiB0aGUgYm90dG9tIGVkZ2Ugd2FzIGV4Y2VlZGVkXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGxlZnQgIElmIHRoZSBsZWZ0IGVkZ2Ugd2FzIGV4Y2VlZGVkXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCb3VuZGluZ1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGxlZnQgIGxlZnQgb2Zmc2V0IGNvb3JkaW5hdGVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0b3AgIHRvcCBvZmZzZXQgY29vcmRpbmF0ZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHdpZHRoXG4gKiBAcHJvcGVydHkge051bWJlcn0gaGVpZ2h0XG4gKi9cblxuLyoqXG4gKiBHZXQgdGltZSBpbiBtc1xuICogQGxpY2Vuc2UgaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9tYXN0ZXIvTElDRU5TRVxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG52YXIgZ2V0VGltZSA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAqIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICogYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICogYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAqIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9tYXN0ZXIvTElDRU5TRVxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtudW1iZXJ9IHdhaXRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5NLnRocm90dGxlID0gZnVuY3Rpb24gKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRleHQgPSB2b2lkIDAsXG4gICAgICBhcmdzID0gdm9pZCAwLFxuICAgICAgcmVzdWx0ID0gdm9pZCAwO1xuICB2YXIgdGltZW91dCA9IG51bGw7XG4gIHZhciBwcmV2aW91cyA9IDA7XG4gIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogZ2V0VGltZSgpO1xuICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3cgPSBnZXRUaW1lKCk7XG4gICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcbjsoZnVuY3Rpb24gKCQsIGFuaW0pIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfZGVmYXVsdHMgPSB7XG4gICAgYWxpZ25tZW50OiAnbGVmdCcsXG4gICAgYXV0b0ZvY3VzOiB0cnVlLFxuICAgIGNvbnN0cmFpbldpZHRoOiB0cnVlLFxuICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICBjb3ZlclRyaWdnZXI6IHRydWUsXG4gICAgY2xvc2VPbkNsaWNrOiB0cnVlLFxuICAgIGhvdmVyOiBmYWxzZSxcbiAgICBpbkR1cmF0aW9uOiAxNTAsXG4gICAgb3V0RHVyYXRpb246IDI1MCxcbiAgICBvbk9wZW5TdGFydDogbnVsbCxcbiAgICBvbk9wZW5FbmQ6IG51bGwsXG4gICAgb25DbG9zZVN0YXJ0OiBudWxsLFxuICAgIG9uQ2xvc2VFbmQ6IG51bGwsXG4gICAgb25JdGVtQ2xpY2s6IG51bGxcbiAgfTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqL1xuXG4gIHZhciBEcm9wZG93biA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKERyb3Bkb3duLCBfQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIERyb3Bkb3duKGVsLCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcGRvd24pO1xuXG4gICAgICB2YXIgX3RoaXMzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERyb3Bkb3duLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24pKS5jYWxsKHRoaXMsIERyb3Bkb3duLCBlbCwgb3B0aW9ucykpO1xuXG4gICAgICBfdGhpczMuZWwuTV9Ecm9wZG93biA9IF90aGlzMztcbiAgICAgIERyb3Bkb3duLl9kcm9wZG93bnMucHVzaChfdGhpczMpO1xuXG4gICAgICBfdGhpczMuaWQgPSBNLmdldElkRnJvbVRyaWdnZXIoZWwpO1xuICAgICAgX3RoaXMzLmRyb3Bkb3duRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChfdGhpczMuaWQpO1xuICAgICAgX3RoaXMzLiRkcm9wZG93bkVsID0gJChfdGhpczMuZHJvcGRvd25FbCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9ucyBmb3IgdGhlIGRyb3Bkb3duXG4gICAgICAgKiBAbWVtYmVyIERyb3Bkb3duI29wdGlvbnNcbiAgICAgICAqIEBwcm9wIHtTdHJpbmd9IFthbGlnbm1lbnQ9J2xlZnQnXSAtIEVkZ2Ugd2hpY2ggdGhlIGRyb3Bkb3duIGlzIGFsaWduZWQgdG9cbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBbYXV0b0ZvY3VzPXRydWVdIC0gQXV0b21hdGljYWxseSBmb2N1cyBkcm9wZG93biBlbCBmb3Iga2V5Ym9hcmRcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBbY29uc3RyYWluV2lkdGg9dHJ1ZV0gLSBDb25zdHJhaW4gd2lkdGggdG8gd2lkdGggb2YgdGhlIGJ1dHRvblxuICAgICAgICogQHByb3Age0VsZW1lbnR9IGNvbnRhaW5lciAtIENvbnRhaW5lciBlbGVtZW50IHRvIGF0dGFjaCBkcm9wZG93biB0byAob3B0aW9uYWwpXG4gICAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gW2NvdmVyVHJpZ2dlcj10cnVlXSAtIFBsYWNlIGRyb3Bkb3duIG92ZXIgdHJpZ2dlclxuICAgICAgICogQHByb3Age0Jvb2xlYW59IFtjbG9zZU9uQ2xpY2s9dHJ1ZV0gLSBDbG9zZSBvbiBjbGljayBvZiBkcm9wZG93biBpdGVtXG4gICAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gW2hvdmVyPWZhbHNlXSAtIE9wZW4gZHJvcGRvd24gb24gaG92ZXJcbiAgICAgICAqIEBwcm9wIHtOdW1iZXJ9IFtpbkR1cmF0aW9uPTE1MF0gLSBEdXJhdGlvbiBvZiBvcGVuIGFuaW1hdGlvbiBpbiBtc1xuICAgICAgICogQHByb3Age051bWJlcn0gW291dER1cmF0aW9uPTI1MF0gLSBEdXJhdGlvbiBvZiBjbG9zZSBhbmltYXRpb24gaW4gbXNcbiAgICAgICAqIEBwcm9wIHtGdW5jdGlvbn0gb25PcGVuU3RhcnQgLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiBkcm9wZG93biBzdGFydHMgb3BlbmluZ1xuICAgICAgICogQHByb3Age0Z1bmN0aW9ufSBvbk9wZW5FbmQgLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiBkcm9wZG93biBmaW5pc2hlcyBvcGVuaW5nXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uQ2xvc2VTdGFydCAtIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGRyb3Bkb3duIHN0YXJ0cyBjbG9zaW5nXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uQ2xvc2VFbmQgLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiBkcm9wZG93biBmaW5pc2hlcyBjbG9zaW5nXG4gICAgICAgKi9cbiAgICAgIF90aGlzMy5vcHRpb25zID0gJC5leHRlbmQoe30sIERyb3Bkb3duLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXNjcmliZXMgb3Blbi9jbG9zZSBzdGF0ZSBvZiBkcm9wZG93blxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIF90aGlzMy5pc09wZW4gPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXNjcmliZXMgaWYgZHJvcGRvd24gY29udGVudCBpcyBzY3JvbGxhYmxlXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgX3RoaXMzLmlzU2Nyb2xsYWJsZSA9IGZhbHNlO1xuXG4gICAgICAvKipcbiAgICAgICAqIERlc2NyaWJlcyBpZiB0b3VjaCBtb3Zpbmcgb24gZHJvcGRvd24gY29udGVudFxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIF90aGlzMy5pc1RvdWNoTW92aW5nID0gZmFsc2U7XG5cbiAgICAgIF90aGlzMy5mb2N1c2VkSW5kZXggPSAtMTtcbiAgICAgIF90aGlzMy5maWx0ZXJRdWVyeSA9IFtdO1xuXG4gICAgICAvLyBNb3ZlIGRyb3Bkb3duLWNvbnRlbnQgYWZ0ZXIgZHJvcGRvd24tdHJpZ2dlclxuICAgICAgaWYgKCEhX3RoaXMzLm9wdGlvbnMuY29udGFpbmVyKSB7XG4gICAgICAgICQoX3RoaXMzLm9wdGlvbnMuY29udGFpbmVyKS5hcHBlbmQoX3RoaXMzLmRyb3Bkb3duRWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMzLiRlbC5hZnRlcihfdGhpczMuZHJvcGRvd25FbCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzMy5fbWFrZURyb3Bkb3duRm9jdXNhYmxlKCk7XG4gICAgICBfdGhpczMuX3Jlc2V0RmlsdGVyUXVlcnlCb3VuZCA9IF90aGlzMy5fcmVzZXRGaWx0ZXJRdWVyeS5iaW5kKF90aGlzMyk7XG4gICAgICBfdGhpczMuX2hhbmRsZURvY3VtZW50Q2xpY2tCb3VuZCA9IF90aGlzMy5faGFuZGxlRG9jdW1lbnRDbGljay5iaW5kKF90aGlzMyk7XG4gICAgICBfdGhpczMuX2hhbmRsZURvY3VtZW50VG91Y2htb3ZlQm91bmQgPSBfdGhpczMuX2hhbmRsZURvY3VtZW50VG91Y2htb3ZlLmJpbmQoX3RoaXMzKTtcbiAgICAgIF90aGlzMy5faGFuZGxlRHJvcGRvd25DbGlja0JvdW5kID0gX3RoaXMzLl9oYW5kbGVEcm9wZG93bkNsaWNrLmJpbmQoX3RoaXMzKTtcbiAgICAgIF90aGlzMy5faGFuZGxlRHJvcGRvd25LZXlkb3duQm91bmQgPSBfdGhpczMuX2hhbmRsZURyb3Bkb3duS2V5ZG93bi5iaW5kKF90aGlzMyk7XG4gICAgICBfdGhpczMuX2hhbmRsZVRyaWdnZXJLZXlkb3duQm91bmQgPSBfdGhpczMuX2hhbmRsZVRyaWdnZXJLZXlkb3duLmJpbmQoX3RoaXMzKTtcbiAgICAgIF90aGlzMy5fc2V0dXBFdmVudEhhbmRsZXJzKCk7XG4gICAgICByZXR1cm4gX3RoaXMzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhEcm9wZG93biwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBjb21wb25lbnRcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0RHJvcGRvd25TdHlsZXMoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICBEcm9wZG93bi5fZHJvcGRvd25zLnNwbGljZShEcm9wZG93bi5fZHJvcGRvd25zLmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgICB0aGlzLmVsLk1fRHJvcGRvd24gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICAvLyBUcmlnZ2VyIGtleWRvd24gaGFuZGxlclxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVUcmlnZ2VyS2V5ZG93bkJvdW5kKTtcblxuICAgICAgICAvLyBJdGVtIGNsaWNrIGhhbmRsZXJcbiAgICAgICAgdGhpcy5kcm9wZG93bkVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlRHJvcGRvd25DbGlja0JvdW5kKTtcblxuICAgICAgICAvLyBIb3ZlciBldmVudCBoYW5kbGVyc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlTW91c2VFbnRlckJvdW5kID0gdGhpcy5faGFuZGxlTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMuX2hhbmRsZU1vdXNlRW50ZXJCb3VuZCk7XG4gICAgICAgICAgdGhpcy5faGFuZGxlTW91c2VMZWF2ZUJvdW5kID0gdGhpcy5faGFuZGxlTW91c2VMZWF2ZS5iaW5kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX2hhbmRsZU1vdXNlTGVhdmVCb3VuZCk7XG4gICAgICAgICAgdGhpcy5kcm9wZG93bkVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9oYW5kbGVNb3VzZUxlYXZlQm91bmQpO1xuXG4gICAgICAgICAgLy8gQ2xpY2sgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVDbGlja0JvdW5kID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlQ2xpY2tCb3VuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZVRyaWdnZXJLZXlkb3duQm91bmQpO1xuICAgICAgICB0aGlzLmRyb3Bkb3duRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrQm91bmQpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXIpIHtcbiAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9oYW5kbGVNb3VzZUVudGVyQm91bmQpO1xuICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX2hhbmRsZU1vdXNlTGVhdmVCb3VuZCk7XG4gICAgICAgICAgdGhpcy5kcm9wZG93bkVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9oYW5kbGVNb3VzZUxlYXZlQm91bmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVDbGlja0JvdW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBUZW1wb3JhcnlFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwVGVtcG9yYXJ5RXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgLy8gVXNlIGNhcHR1cmUgcGhhc2UgZXZlbnQgaGFuZGxlciB0byBwcmV2ZW50IGNsaWNrXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrQm91bmQsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja0JvdW5kKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVEb2N1bWVudFRvdWNobW92ZUJvdW5kKTtcbiAgICAgICAgdGhpcy5kcm9wZG93bkVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVEcm9wZG93bktleWRvd25Cb3VuZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVUZW1wb3JhcnlFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZVRlbXBvcmFyeUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIC8vIFVzZSBjYXB0dXJlIHBoYXNlIGV2ZW50IGhhbmRsZXIgdG8gcHJldmVudCBjbGlja1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja0JvdW5kLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tCb3VuZCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRG9jdW1lbnRUb3VjaG1vdmVCb3VuZCk7XG4gICAgICAgIHRoaXMuZHJvcGRvd25FbC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlRHJvcGRvd25LZXlkb3duQm91bmQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlQ2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2xpY2soZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlTW91c2VFbnRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVNb3VzZUVudGVyKCkge1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZU1vdXNlTGVhdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTW91c2VMZWF2ZShlKSB7XG4gICAgICAgIHZhciB0b0VsID0gZS50b0VsZW1lbnQgfHwgZS5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICB2YXIgbGVhdmVUb0Ryb3Bkb3duQ29udGVudCA9ICEhJCh0b0VsKS5jbG9zZXN0KCcuZHJvcGRvd24tY29udGVudCcpLmxlbmd0aDtcbiAgICAgICAgdmFyIGxlYXZlVG9BY3RpdmVEcm9wZG93blRyaWdnZXIgPSBmYWxzZTtcblxuICAgICAgICB2YXIgJGNsb3Nlc3RUcmlnZ2VyID0gJCh0b0VsKS5jbG9zZXN0KCcuZHJvcGRvd24tdHJpZ2dlcicpO1xuICAgICAgICBpZiAoJGNsb3Nlc3RUcmlnZ2VyLmxlbmd0aCAmJiAhISRjbG9zZXN0VHJpZ2dlclswXS5NX0Ryb3Bkb3duICYmICRjbG9zZXN0VHJpZ2dlclswXS5NX0Ryb3Bkb3duLmlzT3Blbikge1xuICAgICAgICAgIGxlYXZlVG9BY3RpdmVEcm9wZG93blRyaWdnZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xvc2UgaG92ZXIgZHJvcGRvd24gaWYgbW91c2UgZGlkIG5vdCBsZWF2ZSB0byBlaXRoZXIgYWN0aXZlIGRyb3Bkb3duLXRyaWdnZXIgb3IgZHJvcGRvd24tY29udGVudFxuICAgICAgICBpZiAoIWxlYXZlVG9BY3RpdmVEcm9wZG93blRyaWdnZXIgJiYgIWxlYXZlVG9Ecm9wZG93bkNvbnRlbnQpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZURvY3VtZW50Q2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRG9jdW1lbnRDbGljayhlKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHZhciAkdGFyZ2V0ID0gJChlLnRhcmdldCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICYmICR0YXJnZXQuY2xvc2VzdCgnLmRyb3Bkb3duLWNvbnRlbnQnKS5sZW5ndGggJiYgIXRoaXMuaXNUb3VjaE1vdmluZykge1xuICAgICAgICAgIC8vIGlzVG91Y2hNb3ZpbmcgdG8gY2hlY2sgaWYgc2Nyb2xsaW5nIG9uIG1vYmlsZS5cbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNC5jbG9zZSgpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2UgaWYgKCR0YXJnZXQuY2xvc2VzdCgnLmRyb3Bkb3duLXRyaWdnZXInKS5sZW5ndGggfHwgISR0YXJnZXQuY2xvc2VzdCgnLmRyb3Bkb3duLWNvbnRlbnQnKS5sZW5ndGgpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNC5jbG9zZSgpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNUb3VjaE1vdmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlVHJpZ2dlcktleWRvd25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVHJpZ2dlcktleWRvd24oZSkge1xuICAgICAgICAvLyBBUlJPVyBET1dOIE9SIEVOVEVSIFdIRU4gU0VMRUNUIElTIENMT1NFRCAtIG9wZW4gRHJvcGRvd25cbiAgICAgICAgaWYgKChlLndoaWNoID09PSBNLmtleXMuQVJST1dfRE9XTiB8fCBlLndoaWNoID09PSBNLmtleXMuRU5URVIpICYmICF0aGlzLmlzT3Blbikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBEb2N1bWVudCBUb3VjaG1vdmVcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVEb2N1bWVudFRvdWNobW92ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVEb2N1bWVudFRvdWNobW92ZShlKSB7XG4gICAgICAgIHZhciAkdGFyZ2V0ID0gJChlLnRhcmdldCk7XG4gICAgICAgIGlmICgkdGFyZ2V0LmNsb3Nlc3QoJy5kcm9wZG93bi1jb250ZW50JykubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5pc1RvdWNoTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBEcm9wZG93biBDbGlja1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZURyb3Bkb3duQ2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRHJvcGRvd25DbGljayhlKSB7XG4gICAgICAgIC8vIG9uSXRlbUNsaWNrIGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uSXRlbUNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGl0ZW1FbCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ2xpJylbMF07XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9uSXRlbUNsaWNrLmNhbGwodGhpcywgaXRlbUVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBEcm9wZG93biBLZXlkb3duXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlRHJvcGRvd25LZXlkb3duXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZURyb3Bkb3duS2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChlLndoaWNoID09PSBNLmtleXMuVEFCKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcblxuICAgICAgICAgIC8vIE5hdmlnYXRlIGRvd24gZHJvcGRvd24gbGlzdFxuICAgICAgICB9IGVsc2UgaWYgKChlLndoaWNoID09PSBNLmtleXMuQVJST1dfRE9XTiB8fCBlLndoaWNoID09PSBNLmtleXMuQVJST1dfVVApICYmIHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBlLndoaWNoID09PSBNLmtleXMuQVJST1dfRE9XTiA/IDEgOiAtMTtcbiAgICAgICAgICB2YXIgbmV3Rm9jdXNlZEluZGV4ID0gdGhpcy5mb2N1c2VkSW5kZXg7XG4gICAgICAgICAgdmFyIGZvdW5kTmV3SW5kZXggPSBmYWxzZTtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBuZXdGb2N1c2VkSW5kZXggPSBuZXdGb2N1c2VkSW5kZXggKyBkaXJlY3Rpb247XG5cbiAgICAgICAgICAgIGlmICghIXRoaXMuZHJvcGRvd25FbC5jaGlsZHJlbltuZXdGb2N1c2VkSW5kZXhdICYmIHRoaXMuZHJvcGRvd25FbC5jaGlsZHJlbltuZXdGb2N1c2VkSW5kZXhdLnRhYkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICBmb3VuZE5ld0luZGV4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobmV3Rm9jdXNlZEluZGV4IDwgdGhpcy5kcm9wZG93bkVsLmNoaWxkcmVuLmxlbmd0aCAmJiBuZXdGb2N1c2VkSW5kZXggPj0gMCk7XG5cbiAgICAgICAgICBpZiAoZm91bmROZXdJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkSW5kZXggPSBuZXdGb2N1c2VkSW5kZXg7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c0ZvY3VzZWRJdGVtKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRU5URVIgc2VsZWN0cyBjaG9pY2Ugb24gZm9jdXNlZCBpdGVtXG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PT0gTS5rZXlzLkVOVEVSICYmIHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgLy8gU2VhcmNoIGZvciA8YT4gYW5kIDxidXR0b24+XG4gICAgICAgICAgdmFyIGZvY3VzZWRFbGVtZW50ID0gdGhpcy5kcm9wZG93bkVsLmNoaWxkcmVuW3RoaXMuZm9jdXNlZEluZGV4XTtcbiAgICAgICAgICB2YXIgJGFjdGl2YXRhYmxlRWxlbWVudCA9ICQoZm9jdXNlZEVsZW1lbnQpLmZpbmQoJ2EsIGJ1dHRvbicpLmZpcnN0KCk7XG5cbiAgICAgICAgICAvLyBDbGljayBhIG9yIGJ1dHRvbiB0YWcgaWYgZXhpc3RzLCBvdGhlcndpc2UgY2xpY2sgbGkgdGFnXG4gICAgICAgICAgaWYgKCEhJGFjdGl2YXRhYmxlRWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICRhY3RpdmF0YWJsZUVsZW1lbnRbMF0uY2xpY2soKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhZm9jdXNlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGZvY3VzZWRFbGVtZW50LmNsaWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2xvc2UgZHJvcGRvd24gb24gRVNDXG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PT0gTS5rZXlzLkVTQyAmJiB0aGlzLmlzT3Blbikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDQVNFIFdIRU4gVVNFUiBUWVBFIExFVFRFUlNcbiAgICAgICAgdmFyIGxldHRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS53aGljaCkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIG5vbkxldHRlcnMgPSBbOSwgMTMsIDI3LCAzOCwgNDBdO1xuICAgICAgICBpZiAobGV0dGVyICYmIG5vbkxldHRlcnMuaW5kZXhPZihlLndoaWNoKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aGlzLmZpbHRlclF1ZXJ5LnB1c2gobGV0dGVyKTtcblxuICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzLmZpbHRlclF1ZXJ5LmpvaW4oJycpLFxuICAgICAgICAgICAgICBuZXdPcHRpb25FbCA9ICQodGhpcy5kcm9wZG93bkVsKS5maW5kKCdsaScpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkKGVsKS50ZXh0KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cmluZykgPT09IDA7XG4gICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICBpZiAobmV3T3B0aW9uRWwpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZEluZGV4ID0gJChuZXdPcHRpb25FbCkuaW5kZXgoKTtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzRm9jdXNlZEl0ZW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbHRlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3Jlc2V0RmlsdGVyUXVlcnlCb3VuZCwgMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgZHJvcGRvd25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZXNldEZpbHRlclF1ZXJ5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2V0RmlsdGVyUXVlcnkoKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyUXVlcnkgPSBbXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3Jlc2V0RHJvcGRvd25TdHlsZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzZXREcm9wZG93blN0eWxlcygpIHtcbiAgICAgICAgdGhpcy4kZHJvcGRvd25FbC5jc3Moe1xuICAgICAgICAgIGRpc3BsYXk6ICcnLFxuICAgICAgICAgIHdpZHRoOiAnJyxcbiAgICAgICAgICBoZWlnaHQ6ICcnLFxuICAgICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgJ3RyYW5zZm9ybS1vcmlnaW4nOiAnJyxcbiAgICAgICAgICB0cmFuc2Zvcm06ICcnLFxuICAgICAgICAgIG9wYWNpdHk6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfbWFrZURyb3Bkb3duRm9jdXNhYmxlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VEcm9wZG93bkZvY3VzYWJsZSgpIHtcbiAgICAgICAgLy8gTmVlZGVkIGZvciBhcnJvdyBrZXkgbmF2aWdhdGlvblxuICAgICAgICB0aGlzLmRyb3Bkb3duRWwudGFiSW5kZXggPSAwO1xuXG4gICAgICAgIC8vIE9ubHkgc2V0IHRhYmluZGV4IGlmIGl0IGhhc24ndCBiZWVuIHNldCBieSB1c2VyXG4gICAgICAgICQodGhpcy5kcm9wZG93bkVsKS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgaWYgKCFlbC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZm9jdXNGb2N1c2VkSXRlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mb2N1c0ZvY3VzZWRJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5mb2N1c2VkSW5kZXggPj0gMCAmJiB0aGlzLmZvY3VzZWRJbmRleCA8IHRoaXMuZHJvcGRvd25FbC5jaGlsZHJlbi5sZW5ndGggJiYgdGhpcy5vcHRpb25zLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRoaXMuZHJvcGRvd25FbC5jaGlsZHJlblt0aGlzLmZvY3VzZWRJbmRleF0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0RHJvcGRvd25Qb3NpdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREcm9wZG93blBvc2l0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50QlJlY3QgPSB0aGlzLmVsLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHRyaWdnZXJCUmVjdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBkcm9wZG93bkJSZWN0ID0gdGhpcy5kcm9wZG93bkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHZhciBpZGVhbEhlaWdodCA9IGRyb3Bkb3duQlJlY3QuaGVpZ2h0O1xuICAgICAgICB2YXIgaWRlYWxXaWR0aCA9IGRyb3Bkb3duQlJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBpZGVhbFhQb3MgPSB0cmlnZ2VyQlJlY3QubGVmdCAtIGRyb3Bkb3duQlJlY3QubGVmdDtcbiAgICAgICAgdmFyIGlkZWFsWVBvcyA9IHRyaWdnZXJCUmVjdC50b3AgLSBkcm9wZG93bkJSZWN0LnRvcDtcblxuICAgICAgICB2YXIgZHJvcGRvd25Cb3VuZHMgPSB7XG4gICAgICAgICAgbGVmdDogaWRlYWxYUG9zLFxuICAgICAgICAgIHRvcDogaWRlYWxZUG9zLFxuICAgICAgICAgIGhlaWdodDogaWRlYWxIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IGlkZWFsV2lkdGhcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDb3VudGFpbmVyIGhlcmUgd2lsbCBiZSBjbG9zZXN0IGFuY2VzdG9yIHdpdGggb3ZlcmZsb3c6IGhpZGRlblxuICAgICAgICB2YXIgY2xvc2VzdE92ZXJmbG93UGFyZW50ID0gISF0aGlzLmRyb3Bkb3duRWwub2Zmc2V0UGFyZW50ID8gdGhpcy5kcm9wZG93bkVsLm9mZnNldFBhcmVudCA6IHRoaXMuZHJvcGRvd25FbC5wYXJlbnROb2RlO1xuXG4gICAgICAgIHZhciBhbGlnbm1lbnRzID0gTS5jaGVja1Bvc3NpYmxlQWxpZ25tZW50cyh0aGlzLmVsLCBjbG9zZXN0T3ZlcmZsb3dQYXJlbnQsIGRyb3Bkb3duQm91bmRzLCB0aGlzLm9wdGlvbnMuY292ZXJUcmlnZ2VyID8gMCA6IHRyaWdnZXJCUmVjdC5oZWlnaHQpO1xuXG4gICAgICAgIHZhciB2ZXJ0aWNhbEFsaWdubWVudCA9ICd0b3AnO1xuICAgICAgICB2YXIgaG9yaXpvbnRhbEFsaWdubWVudCA9IHRoaXMub3B0aW9ucy5hbGlnbm1lbnQ7XG4gICAgICAgIGlkZWFsWVBvcyArPSB0aGlzLm9wdGlvbnMuY292ZXJUcmlnZ2VyID8gMCA6IHRyaWdnZXJCUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgLy8gUmVzZXQgaXNTY3JvbGxhYmxlXG4gICAgICAgIHRoaXMuaXNTY3JvbGxhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFhbGlnbm1lbnRzLnRvcCkge1xuICAgICAgICAgIGlmIChhbGlnbm1lbnRzLmJvdHRvbSkge1xuICAgICAgICAgICAgdmVydGljYWxBbGlnbm1lbnQgPSAnYm90dG9tJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc1Njcm9sbGFibGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2lkZSBoYXMgbW9zdCBzcGFjZSBhbmQgY3V0b2ZmIGF0IGNvcnJlY3QgaGVpZ2h0XG4gICAgICAgICAgICBpZiAoYWxpZ25tZW50cy5zcGFjZU9uVG9wID4gYWxpZ25tZW50cy5zcGFjZU9uQm90dG9tKSB7XG4gICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25tZW50ID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgIGlkZWFsSGVpZ2h0ICs9IGFsaWdubWVudHMuc3BhY2VPblRvcDtcbiAgICAgICAgICAgICAgaWRlYWxZUG9zIC09IGFsaWdubWVudHMuc3BhY2VPblRvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlkZWFsSGVpZ2h0ICs9IGFsaWdubWVudHMuc3BhY2VPbkJvdHRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBwcmVmZXJyZWQgaG9yaXpvbnRhbCBhbGlnbm1lbnQgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKCFhbGlnbm1lbnRzW2hvcml6b250YWxBbGlnbm1lbnRdKSB7XG4gICAgICAgICAgdmFyIG9wcG9zaXRlQWxpZ25tZW50ID0gaG9yaXpvbnRhbEFsaWdubWVudCA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICBpZiAoYWxpZ25tZW50c1tvcHBvc2l0ZUFsaWdubWVudF0pIHtcbiAgICAgICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQgPSBvcHBvc2l0ZUFsaWdubWVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpZGUgaGFzIG1vc3Qgc3BhY2UgYW5kIGN1dG9mZiBhdCBjb3JyZWN0IGhlaWdodFxuICAgICAgICAgICAgaWYgKGFsaWdubWVudHMuc3BhY2VPbkxlZnQgPiBhbGlnbm1lbnRzLnNwYWNlT25SaWdodCkge1xuICAgICAgICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50ID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgaWRlYWxXaWR0aCArPSBhbGlnbm1lbnRzLnNwYWNlT25MZWZ0O1xuICAgICAgICAgICAgICBpZGVhbFhQb3MgLT0gYWxpZ25tZW50cy5zcGFjZU9uTGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQgPSAnbGVmdCc7XG4gICAgICAgICAgICAgIGlkZWFsV2lkdGggKz0gYWxpZ25tZW50cy5zcGFjZU9uUmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZlcnRpY2FsQWxpZ25tZW50ID09PSAnYm90dG9tJykge1xuICAgICAgICAgIGlkZWFsWVBvcyA9IGlkZWFsWVBvcyAtIGRyb3Bkb3duQlJlY3QuaGVpZ2h0ICsgKHRoaXMub3B0aW9ucy5jb3ZlclRyaWdnZXIgPyB0cmlnZ2VyQlJlY3QuaGVpZ2h0IDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvcml6b250YWxBbGlnbm1lbnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBpZGVhbFhQb3MgPSBpZGVhbFhQb3MgLSBkcm9wZG93bkJSZWN0LndpZHRoICsgdHJpZ2dlckJSZWN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogaWRlYWxYUG9zLFxuICAgICAgICAgIHk6IGlkZWFsWVBvcyxcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWdubWVudDogdmVydGljYWxBbGlnbm1lbnQsXG4gICAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudDogaG9yaXpvbnRhbEFsaWdubWVudCxcbiAgICAgICAgICBoZWlnaHQ6IGlkZWFsSGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBpZGVhbFdpZHRoXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQW5pbWF0ZSBpbiBkcm9wZG93blxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FuaW1hdGVJblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlSW4oKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIGFuaW0ucmVtb3ZlKHRoaXMuZHJvcGRvd25FbCk7XG4gICAgICAgIGFuaW0oe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMuZHJvcGRvd25FbCxcbiAgICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgICB2YWx1ZTogWzAsIDFdLFxuICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzY2FsZVg6IFswLjMsIDFdLFxuICAgICAgICAgIHNjYWxlWTogWzAuMywgMV0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5pbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWludCcsXG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uIChhbmltKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXM1Lm9wdGlvbnMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgICAgIF90aGlzNS5kcm9wZG93bkVsLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9uT3BlbkVuZCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczUub3B0aW9ucy5vbk9wZW5FbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgX3RoaXM1Lm9wdGlvbnMub25PcGVuRW5kLmNhbGwoX3RoaXM1LCBfdGhpczUuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQW5pbWF0ZSBvdXQgZHJvcGRvd25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hbmltYXRlT3V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVPdXQoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIGFuaW0ucmVtb3ZlKHRoaXMuZHJvcGRvd25FbCk7XG4gICAgICAgIGFuaW0oe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMuZHJvcGRvd25FbCxcbiAgICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWludCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNjYWxlWDogMC4zLFxuICAgICAgICAgIHNjYWxlWTogMC4zLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMub3V0RHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1aW50JyxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKGFuaW0pIHtcbiAgICAgICAgICAgIF90aGlzNi5fcmVzZXREcm9wZG93blN0eWxlcygpO1xuXG4gICAgICAgICAgICAvLyBvbkNsb3NlRW5kIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzNi5vcHRpb25zLm9uQ2xvc2VFbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgX3RoaXM2Lm9wdGlvbnMub25DbG9zZUVuZC5jYWxsKF90aGlzNiwgX3RoaXM2LmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlIGRyb3Bkb3duXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcGxhY2VEcm9wZG93blwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZURyb3Bkb3duKCkge1xuICAgICAgICAvLyBTZXQgd2lkdGggYmVmb3JlIGNhbGN1bGF0aW5nIHBvc2l0aW9uSW5mb1xuICAgICAgICB2YXIgaWRlYWxXaWR0aCA9IHRoaXMub3B0aW9ucy5jb25zdHJhaW5XaWR0aCA/IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggOiB0aGlzLmRyb3Bkb3duRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIHRoaXMuZHJvcGRvd25FbC5zdHlsZS53aWR0aCA9IGlkZWFsV2lkdGggKyAncHgnO1xuXG4gICAgICAgIHZhciBwb3NpdGlvbkluZm8gPSB0aGlzLl9nZXREcm9wZG93blBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuZHJvcGRvd25FbC5zdHlsZS5sZWZ0ID0gcG9zaXRpb25JbmZvLnggKyAncHgnO1xuICAgICAgICB0aGlzLmRyb3Bkb3duRWwuc3R5bGUudG9wID0gcG9zaXRpb25JbmZvLnkgKyAncHgnO1xuICAgICAgICB0aGlzLmRyb3Bkb3duRWwuc3R5bGUuaGVpZ2h0ID0gcG9zaXRpb25JbmZvLmhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuZHJvcGRvd25FbC5zdHlsZS53aWR0aCA9IHBvc2l0aW9uSW5mby53aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuZHJvcGRvd25FbC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAocG9zaXRpb25JbmZvLmhvcml6b250YWxBbGlnbm1lbnQgPT09ICdsZWZ0JyA/ICcwJyA6ICcxMDAlJykgKyBcIiBcIiArIChwb3NpdGlvbkluZm8udmVydGljYWxBbGlnbm1lbnQgPT09ICd0b3AnID8gJzAnIDogJzEwMCUnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPcGVuIERyb3Bkb3duXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJvcGVuXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcblxuICAgICAgICAvLyBvbk9wZW5TdGFydCBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbk9wZW5TdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbk9wZW5TdGFydC5jYWxsKHRoaXMsIHRoaXMuZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgc3R5bGVzXG4gICAgICAgIHRoaXMuX3Jlc2V0RHJvcGRvd25TdHlsZXMoKTtcbiAgICAgICAgdGhpcy5kcm9wZG93bkVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgIHRoaXMuX3BsYWNlRHJvcGRvd24oKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZUluKCk7XG4gICAgICAgIHRoaXMuX3NldHVwVGVtcG9yYXJ5RXZlbnRIYW5kbGVycygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsb3NlIERyb3Bkb3duXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9jdXNlZEluZGV4ID0gLTE7XG5cbiAgICAgICAgLy8gb25DbG9zZVN0YXJ0IGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uQ2xvc2VTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkNsb3NlU3RhcnQuY2FsbCh0aGlzLCB0aGlzLmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FuaW1hdGVPdXQoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVGVtcG9yYXJ5RXZlbnRIYW5kbGVycygpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5lbC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVjYWxjdWxhdGUgZGltZW5zaW9uc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVjYWxjdWxhdGVEaW1lbnNpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjYWxjdWxhdGVEaW1lbnNpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICB0aGlzLiRkcm9wZG93bkVsLmNzcyh7XG4gICAgICAgICAgICB3aWR0aDogJycsXG4gICAgICAgICAgICBoZWlnaHQ6ICcnLFxuICAgICAgICAgICAgbGVmdDogJycsXG4gICAgICAgICAgICB0b3A6ICcnLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybS1vcmlnaW4nOiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX3BsYWNlRHJvcGRvd24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGVscywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX2dldChEcm9wZG93bi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERyb3Bkb3duKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fRHJvcGRvd247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlZmF1bHRzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRHJvcGRvd247XG4gIH0oQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgRHJvcGRvd25cbiAgICovXG5cblxuICBEcm9wZG93bi5fZHJvcGRvd25zID0gW107XG5cbiAgTS5Ecm9wZG93biA9IERyb3Bkb3duO1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoRHJvcGRvd24sICdkcm9wZG93bicsICdNX0Ryb3Bkb3duJyk7XG4gIH1cbn0pKGNhc2gsIE0uYW5pbWUpO1xuOyhmdW5jdGlvbiAoJCwgYW5pbSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9kZWZhdWx0cyA9IHtcbiAgICBvcGFjaXR5OiAwLjUsXG4gICAgaW5EdXJhdGlvbjogMjUwLFxuICAgIG91dER1cmF0aW9uOiAyNTAsXG4gICAgb25PcGVuU3RhcnQ6IG51bGwsXG4gICAgb25PcGVuRW5kOiBudWxsLFxuICAgIG9uQ2xvc2VTdGFydDogbnVsbCxcbiAgICBvbkNsb3NlRW5kOiBudWxsLFxuICAgIHByZXZlbnRTY3JvbGxpbmc6IHRydWUsXG4gICAgZGlzbWlzc2libGU6IHRydWUsXG4gICAgc3RhcnRpbmdUb3A6ICc0JScsXG4gICAgZW5kaW5nVG9wOiAnMTAlJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICovXG5cbiAgdmFyIE1vZGFsID0gZnVuY3Rpb24gKF9Db21wb25lbnQyKSB7XG4gICAgX2luaGVyaXRzKE1vZGFsLCBfQ29tcG9uZW50Mik7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgTW9kYWwgaW5zdGFuY2UgYW5kIHNldCB1cCBvdmVybGF5XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTW9kYWwoZWwsIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbCk7XG5cbiAgICAgIHZhciBfdGhpczcgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTW9kYWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNb2RhbCkpLmNhbGwodGhpcywgTW9kYWwsIGVsLCBvcHRpb25zKSk7XG5cbiAgICAgIF90aGlzNy5lbC5NX01vZGFsID0gX3RoaXM3O1xuXG4gICAgICAvKipcbiAgICAgICAqIE9wdGlvbnMgZm9yIHRoZSBtb2RhbFxuICAgICAgICogQG1lbWJlciBNb2RhbCNvcHRpb25zXG4gICAgICAgKiBAcHJvcCB7TnVtYmVyfSBbb3BhY2l0eT0wLjVdIC0gT3BhY2l0eSBvZiB0aGUgbW9kYWwgb3ZlcmxheVxuICAgICAgICogQHByb3Age051bWJlcn0gW2luRHVyYXRpb249MjUwXSAtIExlbmd0aCBpbiBtcyBvZiBlbnRlciB0cmFuc2l0aW9uXG4gICAgICAgKiBAcHJvcCB7TnVtYmVyfSBbb3V0RHVyYXRpb249MjUwXSAtIExlbmd0aCBpbiBtcyBvZiBleGl0IHRyYW5zaXRpb25cbiAgICAgICAqIEBwcm9wIHtGdW5jdGlvbn0gb25PcGVuU3RhcnQgLSBDYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgYmVmb3JlIG1vZGFsIGlzIG9wZW5lZFxuICAgICAgICogQHByb3Age0Z1bmN0aW9ufSBvbk9wZW5FbmQgLSBDYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgYWZ0ZXIgbW9kYWwgaXMgb3BlbmVkXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uQ2xvc2VTdGFydCAtIENhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCBiZWZvcmUgbW9kYWwgaXMgY2xvc2VkXG4gICAgICAgKiBAcHJvcCB7RnVuY3Rpb259IG9uQ2xvc2VFbmQgLSBDYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgYWZ0ZXIgbW9kYWwgaXMgY2xvc2VkXG4gICAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gW2Rpc21pc3NpYmxlPXRydWVdIC0gQWxsb3cgbW9kYWwgdG8gYmUgZGlzbWlzc2VkIGJ5IGtleWJvYXJkIG9yIG92ZXJsYXkgY2xpY2tcbiAgICAgICAqIEBwcm9wIHtTdHJpbmd9IFtzdGFydGluZ1RvcD0nNCUnXSAtIHN0YXJ0aW5nVG9wXG4gICAgICAgKiBAcHJvcCB7U3RyaW5nfSBbZW5kaW5nVG9wPScxMCUnXSAtIGVuZGluZ1RvcFxuICAgICAgICovXG4gICAgICBfdGhpczcub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBNb2RhbC5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzY3JpYmVzIG9wZW4vY2xvc2Ugc3RhdGUgb2YgbW9kYWxcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBfdGhpczcuaXNPcGVuID0gZmFsc2U7XG5cbiAgICAgIF90aGlzNy5pZCA9IF90aGlzNy4kZWwuYXR0cignaWQnKTtcbiAgICAgIF90aGlzNy5fb3BlbmluZ1RyaWdnZXIgPSB1bmRlZmluZWQ7XG4gICAgICBfdGhpczcuJG92ZXJsYXkgPSAkKCc8ZGl2IGNsYXNzPVwibW9kYWwtb3ZlcmxheVwiPjwvZGl2PicpO1xuICAgICAgX3RoaXM3LmVsLnRhYkluZGV4ID0gMDtcbiAgICAgIF90aGlzNy5fbnRoTW9kYWxPcGVuZWQgPSAwO1xuXG4gICAgICBNb2RhbC5fY291bnQrKztcbiAgICAgIF90aGlzNy5fc2V0dXBFdmVudEhhbmRsZXJzKCk7XG4gICAgICByZXR1cm4gX3RoaXM3O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhNb2RhbCwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBjb21wb25lbnRcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIE1vZGFsLl9jb3VudC0tO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICB0aGlzLiRvdmVybGF5LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmVsLk1fTW9kYWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVPdmVybGF5Q2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZU92ZXJsYXlDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVNb2RhbENsb3NlQ2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZU1vZGFsQ2xvc2VDbGljay5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGlmIChNb2RhbC5fY291bnQgPT09IDEpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlVHJpZ2dlckNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRvdmVybGF5WzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlT3ZlcmxheUNsaWNrQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlTW9kYWxDbG9zZUNsaWNrQm91bmQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgaWYgKE1vZGFsLl9jb3VudCA9PT0gMCkge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVUcmlnZ2VyQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJG92ZXJsYXlbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVPdmVybGF5Q2xpY2tCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVNb2RhbENsb3NlQ2xpY2tCb3VuZCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIFRyaWdnZXIgQ2xpY2tcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVUcmlnZ2VyQ2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVHJpZ2dlckNsaWNrKGUpIHtcbiAgICAgICAgdmFyICR0cmlnZ2VyID0gJChlLnRhcmdldCkuY2xvc2VzdCgnLm1vZGFsLXRyaWdnZXInKTtcbiAgICAgICAgaWYgKCR0cmlnZ2VyLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBtb2RhbElkID0gTS5nZXRJZEZyb21UcmlnZ2VyKCR0cmlnZ2VyWzBdKTtcbiAgICAgICAgICB2YXIgbW9kYWxJbnN0YW5jZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1vZGFsSWQpLk1fTW9kYWw7XG4gICAgICAgICAgaWYgKG1vZGFsSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIG1vZGFsSW5zdGFuY2Uub3BlbigkdHJpZ2dlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBPdmVybGF5IENsaWNrXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlT3ZlcmxheUNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU92ZXJsYXlDbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNtaXNzaWJsZSkge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBNb2RhbCBDbG9zZSBDbGlja1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZU1vZGFsQ2xvc2VDbGlja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVNb2RhbENsb3NlQ2xpY2soZSkge1xuICAgICAgICB2YXIgJGNsb3NlVHJpZ2dlciA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5tb2RhbC1jbG9zZScpO1xuICAgICAgICBpZiAoJGNsb3NlVHJpZ2dlci5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgS2V5ZG93blxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUtleWRvd25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlS2V5ZG93bihlKSB7XG4gICAgICAgIC8vIEVTQyBrZXlcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcgJiYgdGhpcy5vcHRpb25zLmRpc21pc3NpYmxlKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIEZvY3VzXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlRm9jdXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRm9jdXMoZSkge1xuICAgICAgICAvLyBPbmx5IHRyYXAgZm9jdXMgaWYgdGhpcyBtb2RhbCBpcyB0aGUgbGFzdCBtb2RlbCBvcGVuZWQgKHByZXZlbnRzIGxvb3BzIGluIG5lc3RlZCBtb2RhbHMpLlxuICAgICAgICBpZiAoIXRoaXMuZWwuY29udGFpbnMoZS50YXJnZXQpICYmIHRoaXMuX250aE1vZGFsT3BlbmVkID09PSBNb2RhbC5fbW9kYWxzT3Blbikge1xuICAgICAgICAgIHRoaXMuZWwuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFuaW1hdGUgaW4gbW9kYWxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hbmltYXRlSW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYW5pbWF0ZUluKCkge1xuICAgICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgICAvLyBTZXQgaW5pdGlhbCBzdHlsZXNcbiAgICAgICAgJC5leHRlbmQodGhpcy5lbC5zdHlsZSwge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KTtcbiAgICAgICAgJC5leHRlbmQodGhpcy4kb3ZlcmxheVswXS5zdHlsZSwge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBbmltYXRlIG92ZXJsYXlcbiAgICAgICAgYW5pbSh7XG4gICAgICAgICAgdGFyZ2V0czogdGhpcy4kb3ZlcmxheVswXSxcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLm9wdGlvbnMub3BhY2l0eSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmluRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERlZmluZSBtb2RhbCBhbmltYXRpb24gb3B0aW9uc1xuICAgICAgICB2YXIgZW50ZXJBbmltT3B0aW9ucyA9IHtcbiAgICAgICAgICB0YXJnZXRzOiB0aGlzLmVsLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMuaW5EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0Q3ViaWMnLFxuICAgICAgICAgIC8vIEhhbmRsZSBtb2RhbCBvbk9wZW5FbmQgY2FsbGJhY2tcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczgub3B0aW9ucy5vbk9wZW5FbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgX3RoaXM4Lm9wdGlvbnMub25PcGVuRW5kLmNhbGwoX3RoaXM4LCBfdGhpczguZWwsIF90aGlzOC5fb3BlbmluZ1RyaWdnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBCb3R0b20gc2hlZXQgYW5pbWF0aW9uXG4gICAgICAgIGlmICh0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucygnYm90dG9tLXNoZWV0JykpIHtcbiAgICAgICAgICAkLmV4dGVuZChlbnRlckFuaW1PcHRpb25zLCB7XG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYW5pbShlbnRlckFuaW1PcHRpb25zKTtcblxuICAgICAgICAgIC8vIE5vcm1hbCBtb2RhbCBhbmltYXRpb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkLmV4dGVuZChlbnRlckFuaW1PcHRpb25zLCB7XG4gICAgICAgICAgICB0b3A6IFt0aGlzLm9wdGlvbnMuc3RhcnRpbmdUb3AsIHRoaXMub3B0aW9ucy5lbmRpbmdUb3BdLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHNjYWxlWDogWzAuOCwgMV0sXG4gICAgICAgICAgICBzY2FsZVk6IFswLjgsIDFdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYW5pbShlbnRlckFuaW1PcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFuaW1hdGUgb3V0IG1vZGFsXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZU91dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlT3V0KCkge1xuICAgICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgICAvLyBBbmltYXRlIG92ZXJsYXlcbiAgICAgICAgYW5pbSh7XG4gICAgICAgICAgdGFyZ2V0czogdGhpcy4kb3ZlcmxheVswXSxcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMub3V0RHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0J1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEZWZpbmUgbW9kYWwgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICAgICAgdmFyIGV4aXRBbmltT3B0aW9ucyA9IHtcbiAgICAgICAgICB0YXJnZXRzOiB0aGlzLmVsLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMub3V0RHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAnZWFzZU91dEN1YmljJyxcbiAgICAgICAgICAvLyBIYW5kbGUgbW9kYWwgcmVhZHkgY2FsbGJhY2tcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM5LmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBfdGhpczkuJG92ZXJsYXkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vIENhbGwgb25DbG9zZUVuZCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczkub3B0aW9ucy5vbkNsb3NlRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIF90aGlzOS5vcHRpb25zLm9uQ2xvc2VFbmQuY2FsbChfdGhpczksIF90aGlzOS5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEJvdHRvbSBzaGVldCBhbmltYXRpb25cbiAgICAgICAgaWYgKHRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdib3R0b20tc2hlZXQnKSkge1xuICAgICAgICAgICQuZXh0ZW5kKGV4aXRBbmltT3B0aW9ucywge1xuICAgICAgICAgICAgYm90dG9tOiAnLTEwMCUnLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFuaW0oZXhpdEFuaW1PcHRpb25zKTtcblxuICAgICAgICAgIC8vIE5vcm1hbCBtb2RhbCBhbmltYXRpb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkLmV4dGVuZChleGl0QW5pbU9wdGlvbnMsIHtcbiAgICAgICAgICAgIHRvcDogW3RoaXMub3B0aW9ucy5lbmRpbmdUb3AsIHRoaXMub3B0aW9ucy5zdGFydGluZ1RvcF0sXG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgc2NhbGVYOiAwLjgsXG4gICAgICAgICAgICBzY2FsZVk6IDAuOFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFuaW0oZXhpdEFuaW1PcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE9wZW4gTW9kYWxcbiAgICAgICAqIEBwYXJhbSB7Y2FzaH0gWyR0cmlnZ2VyXVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib3BlblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oJHRyaWdnZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgICAgICBNb2RhbC5fbW9kYWxzT3BlbisrO1xuICAgICAgICB0aGlzLl9udGhNb2RhbE9wZW5lZCA9IE1vZGFsLl9tb2RhbHNPcGVuO1xuXG4gICAgICAgIC8vIFNldCBaLUluZGV4IGJhc2VkIG9uIG51bWJlciBvZiBjdXJyZW50bHkgb3BlbiBtb2RhbHNcbiAgICAgICAgdGhpcy4kb3ZlcmxheVswXS5zdHlsZS56SW5kZXggPSAxMDAwICsgTW9kYWwuX21vZGFsc09wZW4gKiAyO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnpJbmRleCA9IDEwMDAgKyBNb2RhbC5fbW9kYWxzT3BlbiAqIDIgKyAxO1xuXG4gICAgICAgIC8vIFNldCBvcGVuaW5nIHRyaWdnZXIsIHVuZGVmaW5lZCBpbmRpY2F0ZXMgbW9kYWwgd2FzIG9wZW5lZCBieSBqYXZhc2NyaXB0XG4gICAgICAgIHRoaXMuX29wZW5pbmdUcmlnZ2VyID0gISEkdHJpZ2dlciA/ICR0cmlnZ2VyWzBdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIG9uT3BlblN0YXJ0IGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uT3BlblN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9uT3BlblN0YXJ0LmNhbGwodGhpcywgdGhpcy5lbCwgdGhpcy5fb3BlbmluZ1RyaWdnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50U2Nyb2xsaW5nKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdvcGVuJyk7XG4gICAgICAgIHRoaXMuZWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIHRoaXMuJG92ZXJsYXlbMF0pO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzbWlzc2libGUpIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVLZXlkb3duQm91bmQgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRm9jdXNCb3VuZCA9IHRoaXMuX2hhbmRsZUZvY3VzLmJpbmQodGhpcyk7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUtleWRvd25Cb3VuZCk7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVGb2N1c0JvdW5kLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW0ucmVtb3ZlKHRoaXMuZWwpO1xuICAgICAgICBhbmltLnJlbW92ZSh0aGlzLiRvdmVybGF5WzBdKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZUluKCk7XG5cbiAgICAgICAgLy8gRm9jdXMgbW9kYWxcbiAgICAgICAgdGhpcy5lbC5mb2N1cygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsb3NlIE1vZGFsXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgTW9kYWwuX21vZGFsc09wZW4tLTtcbiAgICAgICAgdGhpcy5fbnRoTW9kYWxPcGVuZWQgPSAwO1xuXG4gICAgICAgIC8vIENhbGwgb25DbG9zZVN0YXJ0IGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uQ2xvc2VTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkNsb3NlU3RhcnQuY2FsbCh0aGlzLCB0aGlzLmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbicpO1xuXG4gICAgICAgIC8vIEVuYWJsZSBib2R5IHNjcm9sbGluZyBvbmx5IGlmIHRoZXJlIGFyZSBubyBtb3JlIG1vZGFscyBvcGVuLlxuICAgICAgICBpZiAoTW9kYWwuX21vZGFsc09wZW4gPT09IDApIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc21pc3NpYmxlKSB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUtleWRvd25Cb3VuZCk7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVGb2N1c0JvdW5kLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW0ucmVtb3ZlKHRoaXMuZWwpO1xuICAgICAgICBhbmltLnJlbW92ZSh0aGlzLiRvdmVybGF5WzBdKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZU91dCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoTW9kYWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNb2RhbCksIFwiaW5pdFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMsIGVscywgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IEluc3RhbmNlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRJbnN0YW5jZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluc3RhbmNlKGVsKSB7XG4gICAgICAgIHZhciBkb21FbGVtID0gISFlbC5qcXVlcnkgPyBlbFswXSA6IGVsO1xuICAgICAgICByZXR1cm4gZG9tRWxlbS5NX01vZGFsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE1vZGFsO1xuICB9KENvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIE1vZGFsXG4gICAqL1xuXG5cbiAgTW9kYWwuX21vZGFsc09wZW4gPSAwO1xuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBNb2RhbFxuICAgKi9cbiAgTW9kYWwuX2NvdW50ID0gMDtcblxuICBNLk1vZGFsID0gTW9kYWw7XG5cbiAgaWYgKE0ualF1ZXJ5TG9hZGVkKSB7XG4gICAgTS5pbml0aWFsaXplSnF1ZXJ5V3JhcHBlcihNb2RhbCwgJ21vZGFsJywgJ01fTW9kYWwnKTtcbiAgfVxufSkoY2FzaCwgTS5hbmltZSk7XG47KGZ1bmN0aW9uICgkKSB7XG4gIC8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBsYWJlbHMgb2YgdGV4dCBmaWVsZHNcbiAgTS51cGRhdGVUZXh0RmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnB1dF9zZWxlY3RvciA9ICdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPXBhc3N3b3JkXSwgaW5wdXRbdHlwZT1lbWFpbF0sIGlucHV0W3R5cGU9dXJsXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dFt0eXBlPW51bWJlcl0sIGlucHV0W3R5cGU9c2VhcmNoXSwgaW5wdXRbdHlwZT1kYXRlXSwgaW5wdXRbdHlwZT10aW1lXSwgdGV4dGFyZWEnO1xuICAgICQoaW5wdXRfc2VsZWN0b3IpLmVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgaWYgKGVsZW1lbnQudmFsdWUubGVuZ3RoID4gMCB8fCAkKGVsZW1lbnQpLmlzKCc6Zm9jdXMnKSB8fCBlbGVtZW50LmF1dG9mb2N1cyB8fCAkdGhpcy5hdHRyKCdwbGFjZWhvbGRlcicpICE9PSBudWxsKSB7XG4gICAgICAgICR0aGlzLnNpYmxpbmdzKCdsYWJlbCcpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC52YWxpZGl0eSkge1xuICAgICAgICAkdGhpcy5zaWJsaW5ncygnbGFiZWwnKS50b2dnbGVDbGFzcygnYWN0aXZlJywgZWxlbWVudC52YWxpZGl0eS5iYWRJbnB1dCA9PT0gdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkdGhpcy5zaWJsaW5ncygnbGFiZWwnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgTS52YWxpZGF0ZV9maWVsZCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgaGFzTGVuZ3RoID0gb2JqZWN0LmF0dHIoJ2RhdGEtbGVuZ3RoJykgIT09IG51bGw7XG4gICAgdmFyIGxlbkF0dHIgPSBwYXJzZUludChvYmplY3QuYXR0cignZGF0YS1sZW5ndGgnKSk7XG4gICAgdmFyIGxlbiA9IG9iamVjdFswXS52YWx1ZS5sZW5ndGg7XG5cbiAgICBpZiAobGVuID09PSAwICYmIG9iamVjdFswXS52YWxpZGl0eS5iYWRJbnB1dCA9PT0gZmFsc2UgJiYgIW9iamVjdC5pcygnOnJlcXVpcmVkJykpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzQ2xhc3MoJ3ZhbGlkYXRlJykpIHtcbiAgICAgICAgb2JqZWN0LnJlbW92ZUNsYXNzKCd2YWxpZCcpO1xuICAgICAgICBvYmplY3QucmVtb3ZlQ2xhc3MoJ2ludmFsaWQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9iamVjdC5oYXNDbGFzcygndmFsaWRhdGUnKSkge1xuICAgICAgICAvLyBDaGVjayBmb3IgY2hhcmFjdGVyIGNvdW50ZXIgYXR0cmlidXRlc1xuICAgICAgICBpZiAob2JqZWN0LmlzKCc6dmFsaWQnKSAmJiBoYXNMZW5ndGggJiYgbGVuIDw9IGxlbkF0dHIgfHwgb2JqZWN0LmlzKCc6dmFsaWQnKSAmJiAhaGFzTGVuZ3RoKSB7XG4gICAgICAgICAgb2JqZWN0LnJlbW92ZUNsYXNzKCdpbnZhbGlkJyk7XG4gICAgICAgICAgb2JqZWN0LmFkZENsYXNzKCd2YWxpZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iamVjdC5yZW1vdmVDbGFzcygndmFsaWQnKTtcbiAgICAgICAgICBvYmplY3QuYWRkQ2xhc3MoJ2ludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBNLnRleHRhcmVhQXV0b1Jlc2l6ZSA9IGZ1bmN0aW9uICgkdGV4dGFyZWEpIHtcbiAgICAvLyBXcmFwIGlmIG5hdGl2ZSBlbGVtZW50XG4gICAgaWYgKCR0ZXh0YXJlYSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICR0ZXh0YXJlYSA9ICQoJHRleHRhcmVhKTtcbiAgICB9XG5cbiAgICBpZiAoISR0ZXh0YXJlYS5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHRleHRhcmVhIGVsZW1lbnQgZm91bmQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUZXh0YXJlYSBBdXRvIFJlc2l6ZVxuICAgIHZhciBoaWRkZW5EaXYgPSAkKCcuaGlkZGVuZGl2JykuZmlyc3QoKTtcbiAgICBpZiAoIWhpZGRlbkRpdi5sZW5ndGgpIHtcbiAgICAgIGhpZGRlbkRpdiA9ICQoJzxkaXYgY2xhc3M9XCJoaWRkZW5kaXYgY29tbW9uXCI+PC9kaXY+Jyk7XG4gICAgICAkKCdib2R5JykuYXBwZW5kKGhpZGRlbkRpdik7XG4gICAgfVxuXG4gICAgLy8gU2V0IGZvbnQgcHJvcGVydGllcyBvZiBoaWRkZW5EaXZcbiAgICB2YXIgZm9udEZhbWlseSA9ICR0ZXh0YXJlYS5jc3MoJ2ZvbnQtZmFtaWx5Jyk7XG4gICAgdmFyIGZvbnRTaXplID0gJHRleHRhcmVhLmNzcygnZm9udC1zaXplJyk7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSAkdGV4dGFyZWEuY3NzKCdsaW5lLWhlaWdodCcpO1xuXG4gICAgLy8gRmlyZWZveCBjYW4ndCBoYW5kbGUgcGFkZGluZyBzaG9ydGhhbmQuXG4gICAgdmFyIHBhZGRpbmdUb3AgPSAkdGV4dGFyZWEuY3NzKCdwYWRkaW5nLXRvcCcpO1xuICAgIHZhciBwYWRkaW5nUmlnaHQgPSAkdGV4dGFyZWEuY3NzKCdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgdmFyIHBhZGRpbmdCb3R0b20gPSAkdGV4dGFyZWEuY3NzKCdwYWRkaW5nLWJvdHRvbScpO1xuICAgIHZhciBwYWRkaW5nTGVmdCA9ICR0ZXh0YXJlYS5jc3MoJ3BhZGRpbmctbGVmdCcpO1xuXG4gICAgaWYgKGZvbnRTaXplKSB7XG4gICAgICBoaWRkZW5EaXYuY3NzKCdmb250LXNpemUnLCBmb250U2l6ZSk7XG4gICAgfVxuICAgIGlmIChmb250RmFtaWx5KSB7XG4gICAgICBoaWRkZW5EaXYuY3NzKCdmb250LWZhbWlseScsIGZvbnRGYW1pbHkpO1xuICAgIH1cbiAgICBpZiAobGluZUhlaWdodCkge1xuICAgICAgaGlkZGVuRGl2LmNzcygnbGluZS1oZWlnaHQnLCBsaW5lSGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKHBhZGRpbmdUb3ApIHtcbiAgICAgIGhpZGRlbkRpdi5jc3MoJ3BhZGRpbmctdG9wJywgcGFkZGluZ1RvcCk7XG4gICAgfVxuICAgIGlmIChwYWRkaW5nUmlnaHQpIHtcbiAgICAgIGhpZGRlbkRpdi5jc3MoJ3BhZGRpbmctcmlnaHQnLCBwYWRkaW5nUmlnaHQpO1xuICAgIH1cbiAgICBpZiAocGFkZGluZ0JvdHRvbSkge1xuICAgICAgaGlkZGVuRGl2LmNzcygncGFkZGluZy1ib3R0b20nLCBwYWRkaW5nQm90dG9tKTtcbiAgICB9XG4gICAgaWYgKHBhZGRpbmdMZWZ0KSB7XG4gICAgICBoaWRkZW5EaXYuY3NzKCdwYWRkaW5nLWxlZnQnLCBwYWRkaW5nTGVmdCk7XG4gICAgfVxuXG4gICAgLy8gU2V0IG9yaWdpbmFsLWhlaWdodCwgaWYgbm9uZVxuICAgIGlmICghJHRleHRhcmVhLmRhdGEoJ29yaWdpbmFsLWhlaWdodCcpKSB7XG4gICAgICAkdGV4dGFyZWEuZGF0YSgnb3JpZ2luYWwtaGVpZ2h0JywgJHRleHRhcmVhLmhlaWdodCgpKTtcbiAgICB9XG5cbiAgICBpZiAoJHRleHRhcmVhLmF0dHIoJ3dyYXAnKSA9PT0gJ29mZicpIHtcbiAgICAgIGhpZGRlbkRpdi5jc3MoJ292ZXJmbG93LXdyYXAnLCAnbm9ybWFsJykuY3NzKCd3aGl0ZS1zcGFjZScsICdwcmUnKTtcbiAgICB9XG5cbiAgICBoaWRkZW5EaXYudGV4dCgkdGV4dGFyZWFbMF0udmFsdWUgKyAnXFxuJyk7XG4gICAgdmFyIGNvbnRlbnQgPSBoaWRkZW5EaXYuaHRtbCgpLnJlcGxhY2UoL1xcbi9nLCAnPGJyPicpO1xuICAgIGhpZGRlbkRpdi5odG1sKGNvbnRlbnQpO1xuXG4gICAgLy8gV2hlbiB0ZXh0YXJlYSBpcyBoaWRkZW4sIHdpZHRoIGdvZXMgY3JhenkuXG4gICAgLy8gQXBwcm94aW1hdGUgd2l0aCBoYWxmIG9mIHdpbmRvdyBzaXplXG5cbiAgICBpZiAoJHRleHRhcmVhWzBdLm9mZnNldFdpZHRoID4gMCAmJiAkdGV4dGFyZWFbMF0ub2Zmc2V0SGVpZ2h0ID4gMCkge1xuICAgICAgaGlkZGVuRGl2LmNzcygnd2lkdGgnLCAkdGV4dGFyZWEud2lkdGgoKSArICdweCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWRkZW5EaXYuY3NzKCd3aWR0aCcsIHdpbmRvdy5pbm5lcldpZHRoIC8gMiArICdweCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBpZiB0aGUgbmV3IGhlaWdodCBpcyBncmVhdGVyIHRoYW4gdGhlXG4gICAgICogb3JpZ2luYWwgaGVpZ2h0IG9mIHRoZSB0ZXh0YXJlYVxuICAgICAqL1xuICAgIGlmICgkdGV4dGFyZWEuZGF0YSgnb3JpZ2luYWwtaGVpZ2h0JykgPD0gaGlkZGVuRGl2LmlubmVySGVpZ2h0KCkpIHtcbiAgICAgICR0ZXh0YXJlYS5jc3MoJ2hlaWdodCcsIGhpZGRlbkRpdi5pbm5lckhlaWdodCgpICsgJ3B4Jyk7XG4gICAgfSBlbHNlIGlmICgkdGV4dGFyZWFbMF0udmFsdWUubGVuZ3RoIDwgJHRleHRhcmVhLmRhdGEoJ3ByZXZpb3VzLWxlbmd0aCcpKSB7XG4gICAgICAvKipcbiAgICAgICAqIEluIGNhc2UgdGhlIG5ldyBoZWlnaHQgaXMgbGVzcyB0aGFuIG9yaWdpbmFsIGhlaWdodCwgaXRcbiAgICAgICAqIG1lYW5zIHRoZSB0ZXh0YXJlYSBoYXMgbGVzcyB0ZXh0IHRoYW4gYmVmb3JlXG4gICAgICAgKiBTbyB3ZSBzZXQgdGhlIGhlaWdodCB0byB0aGUgb3JpZ2luYWwgb25lXG4gICAgICAgKi9cbiAgICAgICR0ZXh0YXJlYS5jc3MoJ2hlaWdodCcsICR0ZXh0YXJlYS5kYXRhKCdvcmlnaW5hbC1oZWlnaHQnKSArICdweCcpO1xuICAgIH1cbiAgICAkdGV4dGFyZWEuZGF0YSgncHJldmlvdXMtbGVuZ3RoJywgJHRleHRhcmVhWzBdLnZhbHVlLmxlbmd0aCk7XG4gIH07XG5cbiAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIC8vIFRleHQgYmFzZWQgaW5wdXRzXG4gICAgdmFyIGlucHV0X3NlbGVjdG9yID0gJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9cGFzc3dvcmRdLCBpbnB1dFt0eXBlPWVtYWlsXSwgaW5wdXRbdHlwZT11cmxdLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0W3R5cGU9bnVtYmVyXSwgaW5wdXRbdHlwZT1zZWFyY2hdLCBpbnB1dFt0eXBlPWRhdGVdLCBpbnB1dFt0eXBlPXRpbWVdLCB0ZXh0YXJlYSc7XG5cbiAgICAvLyBBZGQgYWN0aXZlIGlmIGZvcm0gYXV0byBjb21wbGV0ZVxuICAgICQoZG9jdW1lbnQpLm9uKCdjaGFuZ2UnLCBpbnB1dF9zZWxlY3RvciwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoICE9PSAwIHx8ICQodGhpcykuYXR0cigncGxhY2Vob2xkZXInKSAhPT0gbnVsbCkge1xuICAgICAgICAkKHRoaXMpLnNpYmxpbmdzKCdsYWJlbCcpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICAgIE0udmFsaWRhdGVfZmllbGQoJCh0aGlzKSk7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYWN0aXZlIGlmIGlucHV0IGVsZW1lbnQgaGFzIGJlZW4gcHJlLXBvcHVsYXRlZCBvbiBkb2N1bWVudCByZWFkeVxuICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgIE0udXBkYXRlVGV4dEZpZWxkcygpO1xuICAgIH0pO1xuXG4gICAgLy8gSFRNTCBET00gRk9STSBSRVNFVCBoYW5kbGluZ1xuICAgICQoZG9jdW1lbnQpLm9uKCdyZXNldCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZm9ybVJlc2V0ID0gJChlLnRhcmdldCk7XG4gICAgICBpZiAoZm9ybVJlc2V0LmlzKCdmb3JtJykpIHtcbiAgICAgICAgZm9ybVJlc2V0LmZpbmQoaW5wdXRfc2VsZWN0b3IpLnJlbW92ZUNsYXNzKCd2YWxpZCcpLnJlbW92ZUNsYXNzKCdpbnZhbGlkJyk7XG4gICAgICAgIGZvcm1SZXNldC5maW5kKGlucHV0X3NlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAkKHRoaXMpLnNpYmxpbmdzKCdsYWJlbCcpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlc2V0IHNlbGVjdCAoYWZ0ZXIgbmF0aXZlIHJlc2V0KVxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3JtUmVzZXQuZmluZCgnc2VsZWN0JykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpbml0aWFsaXplZFxuICAgICAgICAgICAgaWYgKHRoaXMuTV9Gb3JtU2VsZWN0KSB7XG4gICAgICAgICAgICAgICQodGhpcykudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkIGFjdGl2ZSB3aGVuIGVsZW1lbnQgaGFzIGZvY3VzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyhpbnB1dF9zZWxlY3RvcikpIHtcbiAgICAgICAgJChlLnRhcmdldCkuc2libGluZ3MoJ2xhYmVsLCAucHJlZml4JykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFjdGl2ZSB3aGVuIGVsZW1lbnQgaXMgYmx1cnJlZFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciAkaW5wdXRFbGVtZW50ID0gJChlLnRhcmdldCk7XG4gICAgICBpZiAoJGlucHV0RWxlbWVudC5pcyhpbnB1dF9zZWxlY3RvcikpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gJy5wcmVmaXgnO1xuXG4gICAgICAgIGlmICgkaW5wdXRFbGVtZW50WzBdLnZhbHVlLmxlbmd0aCA9PT0gMCAmJiAkaW5wdXRFbGVtZW50WzBdLnZhbGlkaXR5LmJhZElucHV0ICE9PSB0cnVlICYmICRpbnB1dEVsZW1lbnQuYXR0cigncGxhY2Vob2xkZXInKSA9PT0gbnVsbCkge1xuICAgICAgICAgIHNlbGVjdG9yICs9ICcsIGxhYmVsJztcbiAgICAgICAgfVxuICAgICAgICAkaW5wdXRFbGVtZW50LnNpYmxpbmdzKHNlbGVjdG9yKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIE0udmFsaWRhdGVfZmllbGQoJGlucHV0RWxlbWVudCk7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICAvLyBSYWRpbyBhbmQgQ2hlY2tib3ggZm9jdXMgY2xhc3NcbiAgICB2YXIgcmFkaW9fY2hlY2tib3ggPSAnaW5wdXRbdHlwZT1yYWRpb10sIGlucHV0W3R5cGU9Y2hlY2tib3hdJztcbiAgICAkKGRvY3VtZW50KS5vbigna2V5dXAnLCByYWRpb19jaGVja2JveCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIFRBQiwgY2hlY2sgaWYgdGFiYmluZyB0byByYWRpbyBvciBjaGVja2JveC5cbiAgICAgIGlmIChlLndoaWNoID09PSBNLmtleXMuVEFCKSB7XG4gICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ3RhYmJlZCcpO1xuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAkdGhpcy5vbmUoJ2JsdXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ3RhYmJlZCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHRleHRfYXJlYV9zZWxlY3RvciA9ICcubWF0ZXJpYWxpemUtdGV4dGFyZWEnO1xuICAgICQodGV4dF9hcmVhX3NlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGV4dGFyZWEgPSAkKHRoaXMpO1xuICAgICAgLyoqXG4gICAgICAgKiBSZXNpemUgdGV4dGFyZWEgb24gZG9jdW1lbnQgbG9hZCBhZnRlciBzdG9yaW5nXG4gICAgICAgKiB0aGUgb3JpZ2luYWwgaGVpZ2h0IGFuZCB0aGUgb3JpZ2luYWwgbGVuZ3RoXG4gICAgICAgKi9cbiAgICAgICR0ZXh0YXJlYS5kYXRhKCdvcmlnaW5hbC1oZWlnaHQnLCAkdGV4dGFyZWEuaGVpZ2h0KCkpO1xuICAgICAgJHRleHRhcmVhLmRhdGEoJ3ByZXZpb3VzLWxlbmd0aCcsIHRoaXMudmFsdWUubGVuZ3RoKTtcbiAgICAgIE0udGV4dGFyZWFBdXRvUmVzaXplKCR0ZXh0YXJlYSk7XG4gICAgfSk7XG5cbiAgICAkKGRvY3VtZW50KS5vbigna2V5dXAnLCB0ZXh0X2FyZWFfc2VsZWN0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIE0udGV4dGFyZWFBdXRvUmVzaXplKCQodGhpcykpO1xuICAgIH0pO1xuICAgICQoZG9jdW1lbnQpLm9uKCdrZXlkb3duJywgdGV4dF9hcmVhX3NlbGVjdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICBNLnRleHRhcmVhQXV0b1Jlc2l6ZSgkKHRoaXMpKTtcbiAgICB9KTtcblxuICAgIC8vIEZpbGUgSW5wdXQgUGF0aFxuICAgICQoZG9jdW1lbnQpLm9uKCdjaGFuZ2UnLCAnLmZpbGUtZmllbGQgaW5wdXRbdHlwZT1cImZpbGVcIl0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmlsZV9maWVsZCA9ICQodGhpcykuY2xvc2VzdCgnLmZpbGUtZmllbGQnKTtcbiAgICAgIHZhciBwYXRoX2lucHV0ID0gZmlsZV9maWVsZC5maW5kKCdpbnB1dC5maWxlLXBhdGgnKTtcbiAgICAgIHZhciBmaWxlcyA9ICQodGhpcylbMF0uZmlsZXM7XG4gICAgICB2YXIgZmlsZV9uYW1lcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmaWxlX25hbWVzLnB1c2goZmlsZXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgICBwYXRoX2lucHV0WzBdLnZhbHVlID0gZmlsZV9uYW1lcy5qb2luKCcsICcpO1xuICAgICAgcGF0aF9pbnB1dC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9KTtcbiAgfSk7IC8vIEVuZCBvZiAkKGRvY3VtZW50KS5yZWFkeVxufSkoY2FzaCk7XG47KGZ1bmN0aW9uICgkLCBhbmltKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2RlZmF1bHRzID0ge1xuICAgIGRpcmVjdGlvbjogJ3RvcCcsXG4gICAgaG92ZXJFbmFibGVkOiB0cnVlLFxuICAgIHRvb2xiYXJFbmFibGVkOiBmYWxzZVxuICB9O1xuXG4gICQuZm4ucmV2ZXJzZSA9IFtdLnJldmVyc2U7XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKi9cblxuICB2YXIgRmxvYXRpbmdBY3Rpb25CdXR0b24gPSBmdW5jdGlvbiAoX0NvbXBvbmVudDMpIHtcbiAgICBfaW5oZXJpdHMoRmxvYXRpbmdBY3Rpb25CdXR0b24sIF9Db21wb25lbnQzKTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBGbG9hdGluZ0FjdGlvbkJ1dHRvbiBpbnN0YW5jZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZsb2F0aW5nQWN0aW9uQnV0dG9uKGVsLCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmxvYXRpbmdBY3Rpb25CdXR0b24pO1xuXG4gICAgICB2YXIgX3RoaXMxMCA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGbG9hdGluZ0FjdGlvbkJ1dHRvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZsb2F0aW5nQWN0aW9uQnV0dG9uKSkuY2FsbCh0aGlzLCBGbG9hdGluZ0FjdGlvbkJ1dHRvbiwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgX3RoaXMxMC5lbC5NX0Zsb2F0aW5nQWN0aW9uQnV0dG9uID0gX3RoaXMxMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25zIGZvciB0aGUgZmFiXG4gICAgICAgKiBAbWVtYmVyIEZsb2F0aW5nQWN0aW9uQnV0dG9uI29wdGlvbnNcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBbZGlyZWN0aW9uXSAtIERpcmVjdGlvbiBmYWIgbWVudSBvcGVuc1xuICAgICAgICogQHByb3Age0Jvb2xlYW59IFtob3ZlckVuYWJsZWQ9dHJ1ZV0gLSBFbmFibGUgaG92ZXIgdnMgY2xpY2tcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBbdG9vbGJhckVuYWJsZWQ9ZmFsc2VdIC0gRW5hYmxlIHRvb2xiYXIgdHJhbnNpdGlvblxuICAgICAgICovXG4gICAgICBfdGhpczEwLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRmxvYXRpbmdBY3Rpb25CdXR0b24uZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICBfdGhpczEwLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgX3RoaXMxMC4kYW5jaG9yID0gX3RoaXMxMC4kZWwuY2hpbGRyZW4oJ2EnKS5maXJzdCgpO1xuICAgICAgX3RoaXMxMC4kbWVudSA9IF90aGlzMTAuJGVsLmNoaWxkcmVuKCd1bCcpLmZpcnN0KCk7XG4gICAgICBfdGhpczEwLiRmbG9hdGluZ0J0bnMgPSBfdGhpczEwLiRlbC5maW5kKCd1bCAuYnRuLWZsb2F0aW5nJyk7XG4gICAgICBfdGhpczEwLiRmbG9hdGluZ0J0bnNSZXZlcnNlID0gX3RoaXMxMC4kZWwuZmluZCgndWwgLmJ0bi1mbG9hdGluZycpLnJldmVyc2UoKTtcbiAgICAgIF90aGlzMTAub2Zmc2V0WSA9IDA7XG4gICAgICBfdGhpczEwLm9mZnNldFggPSAwO1xuXG4gICAgICBfdGhpczEwLiRlbC5hZGRDbGFzcyhcImRpcmVjdGlvbi1cIiArIF90aGlzMTAub3B0aW9ucy5kaXJlY3Rpb24pO1xuICAgICAgaWYgKF90aGlzMTAub3B0aW9ucy5kaXJlY3Rpb24gPT09ICd0b3AnKSB7XG4gICAgICAgIF90aGlzMTAub2Zmc2V0WSA9IDQwO1xuICAgICAgfSBlbHNlIGlmIChfdGhpczEwLm9wdGlvbnMuZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIF90aGlzMTAub2Zmc2V0WCA9IC00MDtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMxMC5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgX3RoaXMxMC5vZmZzZXRZID0gLTQwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMxMC5vZmZzZXRYID0gNDA7XG4gICAgICB9XG4gICAgICBfdGhpczEwLl9zZXR1cEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIHJldHVybiBfdGhpczEwO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhGbG9hdGluZ0FjdGlvbkJ1dHRvbiwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUZWFyZG93biBjb21wb25lbnRcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5lbC5NX0Zsb2F0aW5nQWN0aW9uQnV0dG9uID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHVwIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlRkFCQ2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZUZBQkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZU9wZW5Cb3VuZCA9IHRoaXMub3Blbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVDbG9zZUJvdW5kID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXJFbmFibGVkICYmICF0aGlzLm9wdGlvbnMudG9vbGJhckVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9oYW5kbGVPcGVuQm91bmQpO1xuICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX2hhbmRsZUNsb3NlQm91bmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVGQUJDbGlja0JvdW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3ZlckVuYWJsZWQgJiYgIXRoaXMub3B0aW9ucy50b29sYmFyRW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMuX2hhbmRsZU9wZW5Cb3VuZCk7XG4gICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5faGFuZGxlQ2xvc2VCb3VuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUZBQkNsaWNrQm91bmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIEZBQiBDbGlja1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUZBQkNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUZBQkNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgRG9jdW1lbnQgQ2xpY2tcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVEb2N1bWVudENsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZURvY3VtZW50Q2xpY2soZSkge1xuICAgICAgICBpZiAoISQoZS50YXJnZXQpLmNsb3Nlc3QodGhpcy4kbWVudSkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbiBGQUJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm9wZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvb2xiYXJFbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZUluVG9vbGJhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGVJbkZBQigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZSBGQUJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvb2xiYXJFbmFibGVkKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2hhbmRsZUNsb3NlQm91bmQsIHRydWUpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrQm91bmQsIHRydWUpO1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGVPdXRUb29sYmFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZU91dEZBQigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xhc3NpYyBGQUIgTWVudSBvcGVuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYW5pbWF0ZUluRkFCXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVJbkZBQigpIHtcbiAgICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdhY3RpdmUnKTtcblxuICAgICAgICB2YXIgdGltZSA9IDA7XG4gICAgICAgIHRoaXMuJGZsb2F0aW5nQnRuc1JldmVyc2UuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBhbmltKHtcbiAgICAgICAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHNjYWxlOiBbMC40LCAxXSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IFtfdGhpczExLm9mZnNldFksIDBdLFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogW190aGlzMTEub2Zmc2V0WCwgMF0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMjc1LFxuICAgICAgICAgICAgZGVsYXk6IHRpbWUsXG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlSW5PdXRRdWFkJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRpbWUgKz0gNDA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsYXNzaWMgRkFCIE1lbnUgY2xvc2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hbmltYXRlT3V0RkFCXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVPdXRGQUIoKSB7XG4gICAgICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgICAgICB0aGlzLiRmbG9hdGluZ0J0bnNSZXZlcnNlLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgYW5pbS5yZW1vdmUoZWwpO1xuICAgICAgICAgIGFuaW0oe1xuICAgICAgICAgICAgdGFyZ2V0czogZWwsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgc2NhbGU6IDAuNCxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IF90aGlzMTIub2Zmc2V0WSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IF90aGlzMTIub2Zmc2V0WCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxNzUsXG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhZCcsXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczEyLiRlbC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRvb2xiYXIgdHJhbnNpdGlvbiBNZW51IG9wZW5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hbmltYXRlSW5Ub29sYmFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVJblRvb2xiYXIoKSB7XG4gICAgICAgIHZhciBfdGhpczEzID0gdGhpcztcblxuICAgICAgICB2YXIgc2NhbGVGYWN0b3IgPSB2b2lkIDA7XG4gICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB2YXIgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICB2YXIgYnRuUmVjdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBiYWNrZHJvcCA9ICQoJzxkaXYgY2xhc3M9XCJmYWItYmFja2Ryb3BcIj48L2Rpdj4nKTtcbiAgICAgICAgdmFyIGZhYkNvbG9yID0gdGhpcy4kYW5jaG9yLmNzcygnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICB0aGlzLiRhbmNob3IuYXBwZW5kKGJhY2tkcm9wKTtcblxuICAgICAgICB0aGlzLm9mZnNldFggPSBidG5SZWN0LmxlZnQgLSB3aW5kb3dXaWR0aCAvIDIgKyBidG5SZWN0LndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy5vZmZzZXRZID0gd2luZG93SGVpZ2h0IC0gYnRuUmVjdC5ib3R0b207XG4gICAgICAgIHNjYWxlRmFjdG9yID0gd2luZG93V2lkdGggLyBiYWNrZHJvcFswXS5jbGllbnRXaWR0aDtcbiAgICAgICAgdGhpcy5idG5Cb3R0b20gPSBidG5SZWN0LmJvdHRvbTtcbiAgICAgICAgdGhpcy5idG5MZWZ0ID0gYnRuUmVjdC5sZWZ0O1xuICAgICAgICB0aGlzLmJ0bldpZHRoID0gYnRuUmVjdC53aWR0aDtcblxuICAgICAgICAvLyBTZXQgaW5pdGlhbCBzdGF0ZVxuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIHRoaXMuJGVsLmNzcyh7XG4gICAgICAgICAgJ3RleHQtYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoJyArIHRoaXMub2Zmc2V0WCArICdweCknLFxuICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kYW5jaG9yLmNzcyh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgnICsgLXRoaXMub2Zmc2V0WSArICdweCknLFxuICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xuICAgICAgICB9KTtcbiAgICAgICAgYmFja2Ryb3AuY3NzKHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IGZhYkNvbG9yXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMTMuJGVsLmNzcyh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAuMnMgY3ViaWMtYmV6aWVyKDAuNTUwLCAwLjA4NSwgMC42ODAsIDAuNTMwKSwgYmFja2dyb3VuZC1jb2xvciAwcyBsaW5lYXIgLjJzJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzMTMuJGFuY2hvci5jc3Moe1xuICAgICAgICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJycsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIC4ycydcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMxMy4kZWwuY3NzKHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IGZhYkNvbG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJhY2tkcm9wLmNzcyh7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKCcgKyBzY2FsZUZhY3RvciArICcpJyxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAuMnMgY3ViaWMtYmV6aWVyKDAuNTUwLCAwLjA1NSwgMC42NzUsIDAuMTkwKSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMxMy4kbWVudS5jaGlsZHJlbignbGknKS5jaGlsZHJlbignYScpLmNzcyh7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTY3JvbGwgdG8gY2xvc2UuXG4gICAgICAgICAgICBfdGhpczEzLl9oYW5kbGVEb2N1bWVudENsaWNrQm91bmQgPSBfdGhpczEzLl9oYW5kbGVEb2N1bWVudENsaWNrLmJpbmQoX3RoaXMxMyk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMxMy5faGFuZGxlQ2xvc2VCb3VuZCwgdHJ1ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMxMy5faGFuZGxlRG9jdW1lbnRDbGlja0JvdW5kLCB0cnVlKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUb29sYmFyIHRyYW5zaXRpb24gTWVudSBjbG9zZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FuaW1hdGVPdXRUb29sYmFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVPdXRUb29sYmFyKCkge1xuICAgICAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHZhciBiYWNrZHJvcCA9IHRoaXMuJGVsLmZpbmQoJy5mYWItYmFja2Ryb3AnKTtcbiAgICAgICAgdmFyIGZhYkNvbG9yID0gdGhpcy4kYW5jaG9yLmNzcygnYmFja2dyb3VuZC1jb2xvcicpO1xuXG4gICAgICAgIHRoaXMub2Zmc2V0WCA9IHRoaXMuYnRuTGVmdCAtIHdpbmRvd1dpZHRoIC8gMiArIHRoaXMuYnRuV2lkdGggLyAyO1xuICAgICAgICB0aGlzLm9mZnNldFkgPSB3aW5kb3dIZWlnaHQgLSB0aGlzLmJ0bkJvdHRvbTtcblxuICAgICAgICAvLyBIaWRlIGJhY2tkcm9wXG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy4kZWwuY3NzKHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRhbmNob3IuY3NzKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZSdcbiAgICAgICAgfSk7XG4gICAgICAgIGJhY2tkcm9wLmNzcyh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogZmFiQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJG1lbnUuY2hpbGRyZW4oJ2xpJykuY2hpbGRyZW4oJ2EnKS5jc3Moe1xuICAgICAgICAgIG9wYWNpdHk6ICcnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGJhY2tkcm9wLnJlbW92ZSgpO1xuXG4gICAgICAgICAgLy8gU2V0IGluaXRpYWwgc3RhdGUuXG4gICAgICAgICAgX3RoaXMxNC4kZWwuY3NzKHtcbiAgICAgICAgICAgICd0ZXh0LWFsaWduJzogJycsXG4gICAgICAgICAgICB3aWR0aDogJycsXG4gICAgICAgICAgICBib3R0b206ICcnLFxuICAgICAgICAgICAgbGVmdDogJycsXG4gICAgICAgICAgICBvdmVyZmxvdzogJycsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcnLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIC1fdGhpczE0Lm9mZnNldFggKyAncHgsMCwwKSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfdGhpczE0LiRhbmNob3IuY3NzKHtcbiAgICAgICAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsJyArIF90aGlzMTQub2Zmc2V0WSArICdweCwwKSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMxNC4kZWwuY3NzKHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwwLDApJyxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAuMnMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzMTQuJGFuY2hvci5jc3Moe1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLDAsMCknLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIC4ycyBjdWJpYy1iZXppZXIoMC41NTAsIDAuMDU1LCAwLjY3NSwgMC4xOTApJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMjApO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGVscywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX2dldChGbG9hdGluZ0FjdGlvbkJ1dHRvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZsb2F0aW5nQWN0aW9uQnV0dG9uKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fRmxvYXRpbmdBY3Rpb25CdXR0b247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlZmF1bHRzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRmxvYXRpbmdBY3Rpb25CdXR0b247XG4gIH0oQ29tcG9uZW50KTtcblxuICBNLkZsb2F0aW5nQWN0aW9uQnV0dG9uID0gRmxvYXRpbmdBY3Rpb25CdXR0b247XG5cbiAgaWYgKE0ualF1ZXJ5TG9hZGVkKSB7XG4gICAgTS5pbml0aWFsaXplSnF1ZXJ5V3JhcHBlcihGbG9hdGluZ0FjdGlvbkJ1dHRvbiwgJ2Zsb2F0aW5nQWN0aW9uQnV0dG9uJywgJ01fRmxvYXRpbmdBY3Rpb25CdXR0b24nKTtcbiAgfVxufSkoY2FzaCwgTS5hbmltZSk7XG47KGZ1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2RlZmF1bHRzID0ge1xuICAgIC8vIENsb3NlIHdoZW4gZGF0ZSBpcyBzZWxlY3RlZFxuICAgIGF1dG9DbG9zZTogZmFsc2UsXG5cbiAgICAvLyB0aGUgZGVmYXVsdCBvdXRwdXQgZm9ybWF0IGZvciB0aGUgaW5wdXQgZmllbGQgdmFsdWVcbiAgICBmb3JtYXQ6ICdtbW0gZGQsIHl5eXknLFxuXG4gICAgLy8gVXNlZCB0byBjcmVhdGUgZGF0ZSBvYmplY3QgZnJvbSBjdXJyZW50IGlucHV0IHN0cmluZ1xuICAgIHBhcnNlOiBudWxsLFxuXG4gICAgLy8gVGhlIGluaXRpYWwgZGF0ZSB0byB2aWV3IHdoZW4gZmlyc3Qgb3BlbmVkXG4gICAgZGVmYXVsdERhdGU6IG51bGwsXG5cbiAgICAvLyBNYWtlIHRoZSBgZGVmYXVsdERhdGVgIHRoZSBpbml0aWFsIHNlbGVjdGVkIHZhbHVlXG4gICAgc2V0RGVmYXVsdERhdGU6IGZhbHNlLFxuXG4gICAgZGlzYWJsZVdlZWtlbmRzOiBmYWxzZSxcblxuICAgIGRpc2FibGVEYXlGbjogbnVsbCxcblxuICAgIC8vIEZpcnN0IGRheSBvZiB3ZWVrICgwOiBTdW5kYXksIDE6IE1vbmRheSBldGMpXG4gICAgZmlyc3REYXk6IDAsXG5cbiAgICAvLyBUaGUgZWFybGllc3QgZGF0ZSB0aGF0IGNhbiBiZSBzZWxlY3RlZFxuICAgIG1pbkRhdGU6IG51bGwsXG4gICAgLy8gVGhlbGF0ZXN0IGRhdGUgdGhhdCBjYW4gYmUgc2VsZWN0ZWRcbiAgICBtYXhEYXRlOiBudWxsLFxuXG4gICAgLy8gTnVtYmVyIG9mIHllYXJzIGVpdGhlciBzaWRlLCBvciBhcnJheSBvZiB1cHBlci9sb3dlciByYW5nZVxuICAgIHllYXJSYW5nZTogMTAsXG5cbiAgICAvLyB1c2VkIGludGVybmFsbHkgKGRvbid0IGNvbmZpZyBvdXRzaWRlKVxuICAgIG1pblllYXI6IDAsXG4gICAgbWF4WWVhcjogOTk5OSxcbiAgICBtaW5Nb250aDogdW5kZWZpbmVkLFxuICAgIG1heE1vbnRoOiB1bmRlZmluZWQsXG5cbiAgICBzdGFydFJhbmdlOiBudWxsLFxuICAgIGVuZFJhbmdlOiBudWxsLFxuXG4gICAgaXNSVEw6IGZhbHNlLFxuXG4gICAgLy8gUmVuZGVyIHRoZSBtb250aCBhZnRlciB5ZWFyIGluIHRoZSBjYWxlbmRhciB0aXRsZVxuICAgIHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cbiAgICAvLyBSZW5kZXIgZGF5cyBvZiB0aGUgY2FsZW5kYXIgZ3JpZCB0aGF0IGZhbGwgaW4gdGhlIG5leHQgb3IgcHJldmlvdXMgbW9udGhcbiAgICBzaG93RGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzOiBmYWxzZSxcblxuICAgIC8vIFNwZWNpZnkgYSBET00gZWxlbWVudCB0byByZW5kZXIgdGhlIGNhbGVuZGFyIGluXG4gICAgY29udGFpbmVyOiBudWxsLFxuXG4gICAgLy8gU2hvdyBjbGVhciBidXR0b25cbiAgICBzaG93Q2xlYXJCdG46IGZhbHNlLFxuXG4gICAgLy8gaW50ZXJuYXRpb25hbGl6YXRpb25cbiAgICBpMThuOiB7XG4gICAgICBjYW5jZWw6ICdDYW5jZWwnLFxuICAgICAgY2xlYXI6ICdDbGVhcicsXG4gICAgICBkb25lOiAnT2snLFxuICAgICAgcHJldmlvdXNNb250aDogJ+KAuScsXG4gICAgICBuZXh0TW9udGg6ICfigLonLFxuICAgICAgbW9udGhzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcbiAgICAgIG1vbnRoc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gICAgICB3ZWVrZGF5czogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuICAgICAgd2Vla2RheXNTaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgICAgIHdlZWtkYXlzQWJicmV2OiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXVxuICAgIH0sXG5cbiAgICAvLyBldmVudHMgYXJyYXlcbiAgICBldmVudHM6IFtdLFxuXG4gICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICBvblNlbGVjdDogbnVsbCxcbiAgICBvbk9wZW46IG51bGwsXG4gICAgb25DbG9zZTogbnVsbCxcbiAgICBvbkRyYXc6IG51bGxcbiAgfTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqXG4gICAqL1xuXG4gIHZhciBEYXRlcGlja2VyID0gZnVuY3Rpb24gKF9Db21wb25lbnQ0KSB7XG4gICAgX2luaGVyaXRzKERhdGVwaWNrZXIsIF9Db21wb25lbnQ0KTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBEYXRlcGlja2VyIGluc3RhbmNlIGFuZCBzZXQgdXAgb3ZlcmxheVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGVwaWNrZXIoZWwsIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlcGlja2VyKTtcblxuICAgICAgdmFyIF90aGlzMTUgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRGF0ZXBpY2tlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERhdGVwaWNrZXIpKS5jYWxsKHRoaXMsIERhdGVwaWNrZXIsIGVsLCBvcHRpb25zKSk7XG5cbiAgICAgIF90aGlzMTUuZWwuTV9EYXRlcGlja2VyID0gX3RoaXMxNTtcblxuICAgICAgX3RoaXMxNS5vcHRpb25zID0gJC5leHRlbmQoe30sIERhdGVwaWNrZXIuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgaTE4biBkZWZhdWx0cyBhcmUgbm90IGxvc3Qgd2hlbiBvbmx5IGZldyBpMThuIG9wdGlvbiBwcm9wZXJ0aWVzIGFyZSBwYXNzZWRcbiAgICAgIGlmICghIW9wdGlvbnMgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnaTE4bicpICYmIHR5cGVvZiBvcHRpb25zLmkxOG4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIF90aGlzMTUub3B0aW9ucy5pMThuID0gJC5leHRlbmQoe30sIERhdGVwaWNrZXIuZGVmYXVsdHMuaTE4biwgb3B0aW9ucy5pMThuKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRpbWUgY29tcG9uZW50IGZyb20gbWluRGF0ZSBhbmQgbWF4RGF0ZSBvcHRpb25zXG4gICAgICBpZiAoX3RoaXMxNS5vcHRpb25zLm1pbkRhdGUpIF90aGlzMTUub3B0aW9ucy5taW5EYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgaWYgKF90aGlzMTUub3B0aW9ucy5tYXhEYXRlKSBfdGhpczE1Lm9wdGlvbnMubWF4RGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcblxuICAgICAgX3RoaXMxNS5pZCA9IE0uZ3VpZCgpO1xuXG4gICAgICBfdGhpczE1Ll9zZXR1cFZhcmlhYmxlcygpO1xuICAgICAgX3RoaXMxNS5faW5zZXJ0SFRNTEludG9ET00oKTtcbiAgICAgIF90aGlzMTUuX3NldHVwTW9kYWwoKTtcblxuICAgICAgX3RoaXMxNS5fc2V0dXBFdmVudEhhbmRsZXJzKCk7XG5cbiAgICAgIGlmICghX3RoaXMxNS5vcHRpb25zLmRlZmF1bHREYXRlKSB7XG4gICAgICAgIF90aGlzMTUub3B0aW9ucy5kZWZhdWx0RGF0ZSA9IG5ldyBEYXRlKERhdGUucGFyc2UoX3RoaXMxNS5lbC52YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmRGF0ZSA9IF90aGlzMTUub3B0aW9ucy5kZWZhdWx0RGF0ZTtcbiAgICAgIGlmIChEYXRlcGlja2VyLl9pc0RhdGUoZGVmRGF0ZSkpIHtcbiAgICAgICAgaWYgKF90aGlzMTUub3B0aW9ucy5zZXREZWZhdWx0RGF0ZSkge1xuICAgICAgICAgIF90aGlzMTUuc2V0RGF0ZShkZWZEYXRlLCB0cnVlKTtcbiAgICAgICAgICBfdGhpczE1LnNldElucHV0VmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczE1LmdvdG9EYXRlKGRlZkRhdGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpczE1LmdvdG9EYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc2NyaWJlcyBvcGVuL2Nsb3NlIHN0YXRlIG9mIGRhdGVwaWNrZXJcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBfdGhpczE1LmlzT3BlbiA9IGZhbHNlO1xuICAgICAgcmV0dXJuIF90aGlzMTU7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKERhdGVwaWNrZXIsIFt7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVGVhcmRvd24gY29tcG9uZW50XG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMubW9kYWwuZGVzdHJveSgpO1xuICAgICAgICAkKHRoaXMubW9kYWxFbCkucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveVNlbGVjdHMoKTtcbiAgICAgICAgdGhpcy5lbC5NX0RhdGVwaWNrZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlc3Ryb3lTZWxlY3RzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveVNlbGVjdHMoKSB7XG4gICAgICAgIHZhciBvbGRZZWFyU2VsZWN0ID0gdGhpcy5jYWxlbmRhckVsLnF1ZXJ5U2VsZWN0b3IoJy5vcmlnLXNlbGVjdC15ZWFyJyk7XG4gICAgICAgIGlmIChvbGRZZWFyU2VsZWN0KSB7XG4gICAgICAgICAgTS5Gb3JtU2VsZWN0LmdldEluc3RhbmNlKG9sZFllYXJTZWxlY3QpLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkTW9udGhTZWxlY3QgPSB0aGlzLmNhbGVuZGFyRWwucXVlcnlTZWxlY3RvcignLm9yaWctc2VsZWN0LW1vbnRoJyk7XG4gICAgICAgIGlmIChvbGRNb250aFNlbGVjdCkge1xuICAgICAgICAgIE0uRm9ybVNlbGVjdC5nZXRJbnN0YW5jZShvbGRNb250aFNlbGVjdCkuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9pbnNlcnRIVE1MSW50b0RPTVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnNlcnRIVE1MSW50b0RPTSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93Q2xlYXJCdG4pIHtcbiAgICAgICAgICAkKHRoaXMuY2xlYXJCdG4pLmNzcyh7IHZpc2liaWxpdHk6ICcnIH0pO1xuICAgICAgICAgIHRoaXMuY2xlYXJCdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLmkxOG4uY2xlYXI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvbmVCdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLmkxOG4uZG9uZTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLmkxOG4uY2FuY2VsO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGFpbmVyKSB7XG4gICAgICAgICAgdGhpcy4kbW9kYWxFbC5hcHBlbmRUbyh0aGlzLm9wdGlvbnMuY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRtb2RhbEVsLmluc2VydEJlZm9yZSh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBNb2RhbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cE1vZGFsKCkge1xuICAgICAgICB2YXIgX3RoaXMxNiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5tb2RhbEVsLmlkID0gJ21vZGFsLScgKyB0aGlzLmlkO1xuICAgICAgICB0aGlzLm1vZGFsID0gTS5Nb2RhbC5pbml0KHRoaXMubW9kYWxFbCwge1xuICAgICAgICAgIG9uQ2xvc2VFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMTYuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhmb3JtYXQpIHtcbiAgICAgICAgdmFyIF90aGlzMTcgPSB0aGlzO1xuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCB0aGlzLm9wdGlvbnMuZm9ybWF0O1xuICAgICAgICBpZiAoIURhdGVwaWNrZXIuX2lzRGF0ZSh0aGlzLmRhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvcm1hdEFycmF5ID0gZm9ybWF0LnNwbGl0KC8oZHsxLDR9fG17MSw0fXx5ezR9fHl5fCEuKS9nKTtcbiAgICAgICAgdmFyIGZvcm1hdHRlZERhdGUgPSBmb3JtYXRBcnJheS5tYXAoZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgICAgaWYgKF90aGlzMTcuZm9ybWF0c1tsYWJlbF0pIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczE3LmZvcm1hdHNbbGFiZWxdKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZERhdGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldERhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRlKGRhdGUsIHByZXZlbnRPblNlbGVjdCkge1xuICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICB0aGlzLmRhdGUgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX3JlbmRlckRhdGVEaXNwbGF5KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5wYXJzZShkYXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFEYXRlcGlja2VyLl9pc0RhdGUoZGF0ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluID0gdGhpcy5vcHRpb25zLm1pbkRhdGUsXG4gICAgICAgICAgICBtYXggPSB0aGlzLm9wdGlvbnMubWF4RGF0ZTtcblxuICAgICAgICBpZiAoRGF0ZXBpY2tlci5faXNEYXRlKG1pbikgJiYgZGF0ZSA8IG1pbikge1xuICAgICAgICAgIGRhdGUgPSBtaW47XG4gICAgICAgIH0gZWxzZSBpZiAoRGF0ZXBpY2tlci5faXNEYXRlKG1heCkgJiYgZGF0ZSA+IG1heCkge1xuICAgICAgICAgIGRhdGUgPSBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyRGF0ZURpc3BsYXkoKTtcblxuICAgICAgICBEYXRlcGlja2VyLl9zZXRUb1N0YXJ0T2ZEYXkodGhpcy5kYXRlKTtcbiAgICAgICAgdGhpcy5nb3RvRGF0ZSh0aGlzLmRhdGUpO1xuXG4gICAgICAgIGlmICghcHJldmVudE9uU2VsZWN0ICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMub25TZWxlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25TZWxlY3QuY2FsbCh0aGlzLCB0aGlzLmRhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldElucHV0VmFsdWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbnB1dFZhbHVlKCkge1xuICAgICAgICB0aGlzLmVsLnZhbHVlID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICB0aGlzLiRlbC50cmlnZ2VyKCdjaGFuZ2UnLCB7IGZpcmVkQnk6IHRoaXMgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW5kZXJEYXRlRGlzcGxheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJEYXRlRGlzcGxheSgpIHtcbiAgICAgICAgdmFyIGRpc3BsYXlEYXRlID0gRGF0ZXBpY2tlci5faXNEYXRlKHRoaXMuZGF0ZSkgPyB0aGlzLmRhdGUgOiBuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgaTE4biA9IHRoaXMub3B0aW9ucy5pMThuO1xuICAgICAgICB2YXIgZGF5ID0gaTE4bi53ZWVrZGF5c1Nob3J0W2Rpc3BsYXlEYXRlLmdldERheSgpXTtcbiAgICAgICAgdmFyIG1vbnRoID0gaTE4bi5tb250aHNTaG9ydFtkaXNwbGF5RGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgdmFyIGRhdGUgPSBkaXNwbGF5RGF0ZS5nZXREYXRlKCk7XG4gICAgICAgIHRoaXMueWVhclRleHRFbC5pbm5lckhUTUwgPSBkaXNwbGF5RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICB0aGlzLmRhdGVUZXh0RWwuaW5uZXJIVE1MID0gZGF5ICsgXCIsIFwiICsgbW9udGggKyBcIiBcIiArIGRhdGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY2hhbmdlIHZpZXcgdG8gYSBzcGVjaWZpYyBkYXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnb3RvRGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdvdG9EYXRlKGRhdGUpIHtcbiAgICAgICAgdmFyIG5ld0NhbGVuZGFyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIURhdGVwaWNrZXIuX2lzRGF0ZShkYXRlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNhbGVuZGFycykge1xuICAgICAgICAgIHZhciBmaXJzdFZpc2libGVEYXRlID0gbmV3IERhdGUodGhpcy5jYWxlbmRhcnNbMF0ueWVhciwgdGhpcy5jYWxlbmRhcnNbMF0ubW9udGgsIDEpLFxuICAgICAgICAgICAgICBsYXN0VmlzaWJsZURhdGUgPSBuZXcgRGF0ZSh0aGlzLmNhbGVuZGFyc1t0aGlzLmNhbGVuZGFycy5sZW5ndGggLSAxXS55ZWFyLCB0aGlzLmNhbGVuZGFyc1t0aGlzLmNhbGVuZGFycy5sZW5ndGggLSAxXS5tb250aCwgMSksXG4gICAgICAgICAgICAgIHZpc2libGVEYXRlID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgLy8gZ2V0IHRoZSBlbmQgb2YgdGhlIG1vbnRoXG4gICAgICAgICAgbGFzdFZpc2libGVEYXRlLnNldE1vbnRoKGxhc3RWaXNpYmxlRGF0ZS5nZXRNb250aCgpICsgMSk7XG4gICAgICAgICAgbGFzdFZpc2libGVEYXRlLnNldERhdGUobGFzdFZpc2libGVEYXRlLmdldERhdGUoKSAtIDEpO1xuICAgICAgICAgIG5ld0NhbGVuZGFyID0gdmlzaWJsZURhdGUgPCBmaXJzdFZpc2libGVEYXRlLmdldFRpbWUoKSB8fCBsYXN0VmlzaWJsZURhdGUuZ2V0VGltZSgpIDwgdmlzaWJsZURhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3Q2FsZW5kYXIpIHtcbiAgICAgICAgICB0aGlzLmNhbGVuZGFycyA9IFt7XG4gICAgICAgICAgICBtb250aDogZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgeWVhcjogZGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkanVzdENhbGVuZGFycygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGp1c3RDYWxlbmRhcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RDYWxlbmRhcnMoKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJzWzBdID0gdGhpcy5hZGp1c3RDYWxlbmRhcih0aGlzLmNhbGVuZGFyc1swXSk7XG4gICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGp1c3RDYWxlbmRhclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdENhbGVuZGFyKGNhbGVuZGFyKSB7XG4gICAgICAgIGlmIChjYWxlbmRhci5tb250aCA8IDApIHtcbiAgICAgICAgICBjYWxlbmRhci55ZWFyIC09IE1hdGguY2VpbChNYXRoLmFicyhjYWxlbmRhci5tb250aCkgLyAxMik7XG4gICAgICAgICAgY2FsZW5kYXIubW9udGggKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGVuZGFyLm1vbnRoID4gMTEpIHtcbiAgICAgICAgICBjYWxlbmRhci55ZWFyICs9IE1hdGguZmxvb3IoTWF0aC5hYnMoY2FsZW5kYXIubW9udGgpIC8gMTIpO1xuICAgICAgICAgIGNhbGVuZGFyLm1vbnRoIC09IDEyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxlbmRhcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibmV4dE1vbnRoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dE1vbnRoKCkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyc1swXS5tb250aCsrO1xuICAgICAgICB0aGlzLmFkanVzdENhbGVuZGFycygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcmV2TW9udGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmV2TW9udGgoKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJzWzBdLm1vbnRoLS07XG4gICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcih5ZWFyLCBtb250aCwgcmFuZElkKSB7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgbm93ID0gbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGRheXMgPSBEYXRlcGlja2VyLl9nZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCksXG4gICAgICAgICAgICBiZWZvcmUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSkuZ2V0RGF5KCksXG4gICAgICAgICAgICBkYXRhID0gW10sXG4gICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgRGF0ZXBpY2tlci5fc2V0VG9TdGFydE9mRGF5KG5vdyk7XG4gICAgICAgIGlmIChvcHRzLmZpcnN0RGF5ID4gMCkge1xuICAgICAgICAgIGJlZm9yZSAtPSBvcHRzLmZpcnN0RGF5O1xuICAgICAgICAgIGlmIChiZWZvcmUgPCAwKSB7XG4gICAgICAgICAgICBiZWZvcmUgKz0gNztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzTW9udGggPSBtb250aCA9PT0gMCA/IDExIDogbW9udGggLSAxLFxuICAgICAgICAgICAgbmV4dE1vbnRoID0gbW9udGggPT09IDExID8gMCA6IG1vbnRoICsgMSxcbiAgICAgICAgICAgIHllYXJPZlByZXZpb3VzTW9udGggPSBtb250aCA9PT0gMCA/IHllYXIgLSAxIDogeWVhcixcbiAgICAgICAgICAgIHllYXJPZk5leHRNb250aCA9IG1vbnRoID09PSAxMSA/IHllYXIgKyAxIDogeWVhcixcbiAgICAgICAgICAgIGRheXNJblByZXZpb3VzTW9udGggPSBEYXRlcGlja2VyLl9nZXREYXlzSW5Nb250aCh5ZWFyT2ZQcmV2aW91c01vbnRoLCBwcmV2aW91c01vbnRoKTtcbiAgICAgICAgdmFyIGNlbGxzID0gZGF5cyArIGJlZm9yZSxcbiAgICAgICAgICAgIGFmdGVyID0gY2VsbHM7XG4gICAgICAgIHdoaWxlIChhZnRlciA+IDcpIHtcbiAgICAgICAgICBhZnRlciAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIGNlbGxzICs9IDcgLSBhZnRlcjtcbiAgICAgICAgdmFyIGlzV2Vla1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCByID0gMDsgaSA8IGNlbGxzOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGF5ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDEgKyAoaSAtIGJlZm9yZSkpLFxuICAgICAgICAgICAgICBpc1NlbGVjdGVkID0gRGF0ZXBpY2tlci5faXNEYXRlKHRoaXMuZGF0ZSkgPyBEYXRlcGlja2VyLl9jb21wYXJlRGF0ZXMoZGF5LCB0aGlzLmRhdGUpIDogZmFsc2UsXG4gICAgICAgICAgICAgIGlzVG9kYXkgPSBEYXRlcGlja2VyLl9jb21wYXJlRGF0ZXMoZGF5LCBub3cpLFxuICAgICAgICAgICAgICBoYXNFdmVudCA9IG9wdHMuZXZlbnRzLmluZGV4T2YoZGF5LnRvRGF0ZVN0cmluZygpKSAhPT0gLTEgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgIGlzRW1wdHkgPSBpIDwgYmVmb3JlIHx8IGkgPj0gZGF5cyArIGJlZm9yZSxcbiAgICAgICAgICAgICAgZGF5TnVtYmVyID0gMSArIChpIC0gYmVmb3JlKSxcbiAgICAgICAgICAgICAgbW9udGhOdW1iZXIgPSBtb250aCxcbiAgICAgICAgICAgICAgeWVhck51bWJlciA9IHllYXIsXG4gICAgICAgICAgICAgIGlzU3RhcnRSYW5nZSA9IG9wdHMuc3RhcnRSYW5nZSAmJiBEYXRlcGlja2VyLl9jb21wYXJlRGF0ZXMob3B0cy5zdGFydFJhbmdlLCBkYXkpLFxuICAgICAgICAgICAgICBpc0VuZFJhbmdlID0gb3B0cy5lbmRSYW5nZSAmJiBEYXRlcGlja2VyLl9jb21wYXJlRGF0ZXMob3B0cy5lbmRSYW5nZSwgZGF5KSxcbiAgICAgICAgICAgICAgaXNJblJhbmdlID0gb3B0cy5zdGFydFJhbmdlICYmIG9wdHMuZW5kUmFuZ2UgJiYgb3B0cy5zdGFydFJhbmdlIDwgZGF5ICYmIGRheSA8IG9wdHMuZW5kUmFuZ2UsXG4gICAgICAgICAgICAgIGlzRGlzYWJsZWQgPSBvcHRzLm1pbkRhdGUgJiYgZGF5IDwgb3B0cy5taW5EYXRlIHx8IG9wdHMubWF4RGF0ZSAmJiBkYXkgPiBvcHRzLm1heERhdGUgfHwgb3B0cy5kaXNhYmxlV2Vla2VuZHMgJiYgRGF0ZXBpY2tlci5faXNXZWVrZW5kKGRheSkgfHwgb3B0cy5kaXNhYmxlRGF5Rm4gJiYgb3B0cy5kaXNhYmxlRGF5Rm4oZGF5KTtcblxuICAgICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgICBpZiAoaSA8IGJlZm9yZSkge1xuICAgICAgICAgICAgICBkYXlOdW1iZXIgPSBkYXlzSW5QcmV2aW91c01vbnRoICsgZGF5TnVtYmVyO1xuICAgICAgICAgICAgICBtb250aE51bWJlciA9IHByZXZpb3VzTW9udGg7XG4gICAgICAgICAgICAgIHllYXJOdW1iZXIgPSB5ZWFyT2ZQcmV2aW91c01vbnRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF5TnVtYmVyID0gZGF5TnVtYmVyIC0gZGF5cztcbiAgICAgICAgICAgICAgbW9udGhOdW1iZXIgPSBuZXh0TW9udGg7XG4gICAgICAgICAgICAgIHllYXJOdW1iZXIgPSB5ZWFyT2ZOZXh0TW9udGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRheUNvbmZpZyA9IHtcbiAgICAgICAgICAgIGRheTogZGF5TnVtYmVyLFxuICAgICAgICAgICAgbW9udGg6IG1vbnRoTnVtYmVyLFxuICAgICAgICAgICAgeWVhcjogeWVhck51bWJlcixcbiAgICAgICAgICAgIGhhc0V2ZW50OiBoYXNFdmVudCxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsXG4gICAgICAgICAgICBpc1RvZGF5OiBpc1RvZGF5LFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgICAgICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgICAgICAgICBpc1N0YXJ0UmFuZ2U6IGlzU3RhcnRSYW5nZSxcbiAgICAgICAgICAgIGlzRW5kUmFuZ2U6IGlzRW5kUmFuZ2UsXG4gICAgICAgICAgICBpc0luUmFuZ2U6IGlzSW5SYW5nZSxcbiAgICAgICAgICAgIHNob3dEYXlzSW5OZXh0QW5kUHJldmlvdXNNb250aHM6IG9wdHMuc2hvd0RheXNJbk5leHRBbmRQcmV2aW91c01vbnRoc1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByb3cucHVzaCh0aGlzLnJlbmRlckRheShkYXlDb25maWcpKTtcblxuICAgICAgICAgIGlmICgrK3IgPT09IDcpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh0aGlzLnJlbmRlclJvdyhyb3csIG9wdHMuaXNSVEwsIGlzV2Vla1NlbGVjdGVkKSk7XG4gICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgICAgIHIgPSAwO1xuICAgICAgICAgICAgaXNXZWVrU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVGFibGUob3B0cywgZGF0YSwgcmFuZElkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyRGF5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyRGF5KG9wdHMpIHtcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICB2YXIgYXJpYVNlbGVjdGVkID0gJ2ZhbHNlJztcbiAgICAgICAgaWYgKG9wdHMuaXNFbXB0eSkge1xuICAgICAgICAgIGlmIChvcHRzLnNob3dEYXlzSW5OZXh0QW5kUHJldmlvdXNNb250aHMpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCdpcy1vdXRzaWRlLWN1cnJlbnQtbW9udGgnKTtcbiAgICAgICAgICAgIGFyci5wdXNoKCdpcy1zZWxlY3Rpb24tZGlzYWJsZWQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJpcy1lbXB0eVwiPjwvdGQ+JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaXNEaXNhYmxlZCkge1xuICAgICAgICAgIGFyci5wdXNoKCdpcy1kaXNhYmxlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuaXNUb2RheSkge1xuICAgICAgICAgIGFyci5wdXNoKCdpcy10b2RheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICBhcnIucHVzaCgnaXMtc2VsZWN0ZWQnKTtcbiAgICAgICAgICBhcmlhU2VsZWN0ZWQgPSAndHJ1ZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaGFzRXZlbnQpIHtcbiAgICAgICAgICBhcnIucHVzaCgnaGFzLWV2ZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaXNJblJhbmdlKSB7XG4gICAgICAgICAgYXJyLnB1c2goJ2lzLWlucmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc1N0YXJ0UmFuZ2UpIHtcbiAgICAgICAgICBhcnIucHVzaCgnaXMtc3RhcnRyYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmlzRW5kUmFuZ2UpIHtcbiAgICAgICAgICBhcnIucHVzaCgnaXMtZW5kcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCI8dGQgZGF0YS1kYXk9XFxcIlwiICsgb3B0cy5kYXkgKyBcIlxcXCIgY2xhc3M9XFxcIlwiICsgYXJyLmpvaW4oJyAnKSArIFwiXFxcIiBhcmlhLXNlbGVjdGVkPVxcXCJcIiArIGFyaWFTZWxlY3RlZCArIFwiXFxcIj5cIiArIChcIjxidXR0b24gY2xhc3M9XFxcImRhdGVwaWNrZXItZGF5LWJ1dHRvblxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBkYXRhLXllYXI9XFxcIlwiICsgb3B0cy55ZWFyICsgXCJcXFwiIGRhdGEtbW9udGg9XFxcIlwiICsgb3B0cy5tb250aCArIFwiXFxcIiBkYXRhLWRheT1cXFwiXCIgKyBvcHRzLmRheSArIFwiXFxcIj5cIiArIG9wdHMuZGF5ICsgXCI8L2J1dHRvbj5cIikgKyAnPC90ZD4nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJSb3dcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJSb3coZGF5cywgaXNSVEwsIGlzUm93U2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuICc8dHIgY2xhc3M9XCJkYXRlcGlja2VyLXJvdycgKyAoaXNSb3dTZWxlY3RlZCA/ICcgaXMtc2VsZWN0ZWQnIDogJycpICsgJ1wiPicgKyAoaXNSVEwgPyBkYXlzLnJldmVyc2UoKSA6IGRheXMpLmpvaW4oJycpICsgJzwvdHI+JztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyVGFibGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUYWJsZShvcHRzLCBkYXRhLCByYW5kSWQpIHtcbiAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci10YWJsZS13cmFwcGVyXCI+PHRhYmxlIGNlbGxwYWRkaW5nPVwiMFwiIGNlbGxzcGFjaW5nPVwiMFwiIGNsYXNzPVwiZGF0ZXBpY2tlci10YWJsZVwiIHJvbGU9XCJncmlkXCIgYXJpYS1sYWJlbGxlZGJ5PVwiJyArIHJhbmRJZCArICdcIj4nICsgdGhpcy5yZW5kZXJIZWFkKG9wdHMpICsgdGhpcy5yZW5kZXJCb2R5KGRhdGEpICsgJzwvdGFibGU+PC9kaXY+JztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVySGVhZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckhlYWQob3B0cykge1xuICAgICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGFyciA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgYXJyLnB1c2goXCI8dGggc2NvcGU9XFxcImNvbFxcXCI+PGFiYnIgdGl0bGU9XFxcIlwiICsgdGhpcy5yZW5kZXJEYXlOYW1lKG9wdHMsIGkpICsgXCJcXFwiPlwiICsgdGhpcy5yZW5kZXJEYXlOYW1lKG9wdHMsIGksIHRydWUpICsgXCI8L2FiYnI+PC90aD5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc8dGhlYWQ+PHRyPicgKyAob3B0cy5pc1JUTCA/IGFyci5yZXZlcnNlKCkgOiBhcnIpLmpvaW4oJycpICsgJzwvdHI+PC90aGVhZD4nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJCb2R5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQm9keShyb3dzKSB7XG4gICAgICAgIHJldHVybiAnPHRib2R5PicgKyByb3dzLmpvaW4oJycpICsgJzwvdGJvZHk+JztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyVGl0bGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUaXRsZShpbnN0YW5jZSwgYywgeWVhciwgbW9udGgsIHJlZlllYXIsIHJhbmRJZCkge1xuICAgICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGogPSB2b2lkIDAsXG4gICAgICAgICAgICBhcnIgPSB2b2lkIDAsXG4gICAgICAgICAgICBvcHRzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgaXNNaW5ZZWFyID0geWVhciA9PT0gb3B0cy5taW5ZZWFyLFxuICAgICAgICAgICAgaXNNYXhZZWFyID0geWVhciA9PT0gb3B0cy5tYXhZZWFyLFxuICAgICAgICAgICAgaHRtbCA9ICc8ZGl2IGlkPVwiJyArIHJhbmRJZCArICdcIiBjbGFzcz1cImRhdGVwaWNrZXItY29udHJvbHNcIiByb2xlPVwiaGVhZGluZ1wiIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiPicsXG4gICAgICAgICAgICBtb250aEh0bWwgPSB2b2lkIDAsXG4gICAgICAgICAgICB5ZWFySHRtbCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHByZXYgPSB0cnVlLFxuICAgICAgICAgICAgbmV4dCA9IHRydWU7XG5cbiAgICAgICAgZm9yIChhcnIgPSBbXSwgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgYXJyLnB1c2goJzxvcHRpb24gdmFsdWU9XCInICsgKHllYXIgPT09IHJlZlllYXIgPyBpIC0gYyA6IDEyICsgaSAtIGMpICsgJ1wiJyArIChpID09PSBtb250aCA/ICcgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJyA6ICcnKSArIChpc01pblllYXIgJiYgaSA8IG9wdHMubWluTW9udGggfHwgaXNNYXhZZWFyICYmIGkgPiBvcHRzLm1heE1vbnRoID8gJ2Rpc2FibGVkPVwiZGlzYWJsZWRcIicgOiAnJykgKyAnPicgKyBvcHRzLmkxOG4ubW9udGhzW2ldICsgJzwvb3B0aW9uPicpO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9udGhIdG1sID0gJzxzZWxlY3QgY2xhc3M9XCJkYXRlcGlja2VyLXNlbGVjdCBvcmlnLXNlbGVjdC1tb250aFwiIHRhYmluZGV4PVwiLTFcIj4nICsgYXJyLmpvaW4oJycpICsgJzwvc2VsZWN0Pic7XG5cbiAgICAgICAgaWYgKCQuaXNBcnJheShvcHRzLnllYXJSYW5nZSkpIHtcbiAgICAgICAgICBpID0gb3B0cy55ZWFyUmFuZ2VbMF07XG4gICAgICAgICAgaiA9IG9wdHMueWVhclJhbmdlWzFdICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0geWVhciAtIG9wdHMueWVhclJhbmdlO1xuICAgICAgICAgIGogPSAxICsgeWVhciArIG9wdHMueWVhclJhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChhcnIgPSBbXTsgaSA8IGogJiYgaSA8PSBvcHRzLm1heFllYXI7IGkrKykge1xuICAgICAgICAgIGlmIChpID49IG9wdHMubWluWWVhcikge1xuICAgICAgICAgICAgYXJyLnB1c2goXCI8b3B0aW9uIHZhbHVlPVxcXCJcIiArIGkgKyBcIlxcXCIgXCIgKyAoaSA9PT0geWVhciA/ICdzZWxlY3RlZD1cInNlbGVjdGVkXCInIDogJycpICsgXCI+XCIgKyBpICsgXCI8L29wdGlvbj5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeWVhckh0bWwgPSBcIjxzZWxlY3QgY2xhc3M9XFxcImRhdGVwaWNrZXItc2VsZWN0IG9yaWctc2VsZWN0LXllYXJcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XCIgKyBhcnIuam9pbignJykgKyBcIjwvc2VsZWN0PlwiO1xuXG4gICAgICAgIHZhciBsZWZ0QXJyb3cgPSAnPHN2ZyBmaWxsPVwiIzAwMDAwMFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHdpZHRoPVwiMjRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0xNS40MSAxNi4wOWwtNC41OC00LjU5IDQuNTgtNC41OUwxNCA1LjVsLTYgNiA2IDZ6XCIvPjxwYXRoIGQ9XCJNMC0uNWgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPjwvc3ZnPic7XG4gICAgICAgIGh0bWwgKz0gXCI8YnV0dG9uIGNsYXNzPVxcXCJtb250aC1wcmV2XCIgKyAocHJldiA/ICcnIDogJyBpcy1kaXNhYmxlZCcpICsgXCJcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCI+XCIgKyBsZWZ0QXJyb3cgKyBcIjwvYnV0dG9uPlwiO1xuXG4gICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJzZWxlY3RzLWNvbnRhaW5lclwiPic7XG4gICAgICAgIGlmIChvcHRzLnNob3dNb250aEFmdGVyWWVhcikge1xuICAgICAgICAgIGh0bWwgKz0geWVhckh0bWwgKyBtb250aEh0bWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaHRtbCArPSBtb250aEh0bWwgKyB5ZWFySHRtbDtcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuXG4gICAgICAgIGlmIChpc01pblllYXIgJiYgKG1vbnRoID09PSAwIHx8IG9wdHMubWluTW9udGggPj0gbW9udGgpKSB7XG4gICAgICAgICAgcHJldiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTWF4WWVhciAmJiAobW9udGggPT09IDExIHx8IG9wdHMubWF4TW9udGggPD0gbW9udGgpKSB7XG4gICAgICAgICAgbmV4dCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJpZ2h0QXJyb3cgPSAnPHN2ZyBmaWxsPVwiIzAwMDAwMFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHdpZHRoPVwiMjRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk04LjU5IDE2LjM0bDQuNTgtNC41OS00LjU4LTQuNTlMMTAgNS43NWw2IDYtNiA2elwiLz48cGF0aCBkPVwiTTAtLjI1aDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+PC9zdmc+JztcbiAgICAgICAgaHRtbCArPSBcIjxidXR0b24gY2xhc3M9XFxcIm1vbnRoLW5leHRcIiArIChuZXh0ID8gJycgOiAnIGlzLWRpc2FibGVkJykgKyBcIlxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5cIiArIHJpZ2h0QXJyb3cgKyBcIjwvYnV0dG9uPlwiO1xuXG4gICAgICAgIHJldHVybiBodG1sICs9ICc8L2Rpdj4nO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJlZnJlc2ggdGhlIEhUTUxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGZvcmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4gJiYgIWZvcmNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgbWluWWVhciA9IG9wdHMubWluWWVhcixcbiAgICAgICAgICAgIG1heFllYXIgPSBvcHRzLm1heFllYXIsXG4gICAgICAgICAgICBtaW5Nb250aCA9IG9wdHMubWluTW9udGgsXG4gICAgICAgICAgICBtYXhNb250aCA9IG9wdHMubWF4TW9udGgsXG4gICAgICAgICAgICBodG1sID0gJycsXG4gICAgICAgICAgICByYW5kSWQgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHRoaXMuX3kgPD0gbWluWWVhcikge1xuICAgICAgICAgIHRoaXMuX3kgPSBtaW5ZZWFyO1xuICAgICAgICAgIGlmICghaXNOYU4obWluTW9udGgpICYmIHRoaXMuX20gPCBtaW5Nb250aCkge1xuICAgICAgICAgICAgdGhpcy5fbSA9IG1pbk1vbnRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5feSA+PSBtYXhZZWFyKSB7XG4gICAgICAgICAgdGhpcy5feSA9IG1heFllYXI7XG4gICAgICAgICAgaWYgKCFpc05hTihtYXhNb250aCkgJiYgdGhpcy5fbSA+IG1heE1vbnRoKSB7XG4gICAgICAgICAgICB0aGlzLl9tID0gbWF4TW9udGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmFuZElkID0gJ2RhdGVwaWNrZXItdGl0bGUtJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnJlcGxhY2UoL1teYS16XSsvZywgJycpLnN1YnN0cigwLCAyKTtcblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDE7IGMrKykge1xuICAgICAgICAgIHRoaXMuX3JlbmRlckRhdGVEaXNwbGF5KCk7XG4gICAgICAgICAgaHRtbCArPSB0aGlzLnJlbmRlclRpdGxlKHRoaXMsIGMsIHRoaXMuY2FsZW5kYXJzW2NdLnllYXIsIHRoaXMuY2FsZW5kYXJzW2NdLm1vbnRoLCB0aGlzLmNhbGVuZGFyc1swXS55ZWFyLCByYW5kSWQpICsgdGhpcy5yZW5kZXIodGhpcy5jYWxlbmRhcnNbY10ueWVhciwgdGhpcy5jYWxlbmRhcnNbY10ubW9udGgsIHJhbmRJZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlc3Ryb3lTZWxlY3RzKCk7XG5cbiAgICAgICAgdGhpcy5jYWxlbmRhckVsLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgLy8gSW5pdCBNYXRlcmlhbGl6ZSBTZWxlY3RcbiAgICAgICAgdmFyIHllYXJTZWxlY3QgPSB0aGlzLmNhbGVuZGFyRWwucXVlcnlTZWxlY3RvcignLm9yaWctc2VsZWN0LXllYXInKTtcbiAgICAgICAgdmFyIG1vbnRoU2VsZWN0ID0gdGhpcy5jYWxlbmRhckVsLnF1ZXJ5U2VsZWN0b3IoJy5vcmlnLXNlbGVjdC1tb250aCcpO1xuICAgICAgICBNLkZvcm1TZWxlY3QuaW5pdCh5ZWFyU2VsZWN0LCB7XG4gICAgICAgICAgY2xhc3NlczogJ3NlbGVjdC15ZWFyJyxcbiAgICAgICAgICBkcm9wZG93bk9wdGlvbnM6IHsgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LCBjb25zdHJhaW5XaWR0aDogZmFsc2UgfVxuICAgICAgICB9KTtcbiAgICAgICAgTS5Gb3JtU2VsZWN0LmluaXQobW9udGhTZWxlY3QsIHtcbiAgICAgICAgICBjbGFzc2VzOiAnc2VsZWN0LW1vbnRoJyxcbiAgICAgICAgICBkcm9wZG93bk9wdGlvbnM6IHsgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LCBjb25zdHJhaW5XaWR0aDogZmFsc2UgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgY2hhbmdlIGhhbmRsZXJzIGZvciBzZWxlY3RcbiAgICAgICAgeWVhclNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9oYW5kbGVZZWFyQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICBtb250aFNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9oYW5kbGVNb250aENoYW5nZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkRyYXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25EcmF3KHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVJbnB1dEtleWRvd25Cb3VuZCA9IHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVJbnB1dENsaWNrQm91bmQgPSB0aGlzLl9oYW5kbGVJbnB1dENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUlucHV0Q2hhbmdlQm91bmQgPSB0aGlzLl9oYW5kbGVJbnB1dENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVDYWxlbmRhckNsaWNrQm91bmQgPSB0aGlzLl9oYW5kbGVDYWxlbmRhckNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2ZpbmlzaFNlbGVjdGlvbkJvdW5kID0gdGhpcy5fZmluaXNoU2VsZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZU1vbnRoQ2hhbmdlID0gdGhpcy5faGFuZGxlTW9udGhDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fY2xvc2VCb3VuZCA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlSW5wdXRDbGlja0JvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlSW5wdXRLZXlkb3duQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2hhbmRsZUlucHV0Q2hhbmdlQm91bmQpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVDYWxlbmRhckNsaWNrQm91bmQpO1xuICAgICAgICB0aGlzLmRvbmVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9maW5pc2hTZWxlY3Rpb25Cb3VuZCk7XG4gICAgICAgIHRoaXMuY2FuY2VsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xvc2VCb3VuZCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93Q2xlYXJCdG4pIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVDbGVhckNsaWNrQm91bmQgPSB0aGlzLl9oYW5kbGVDbGVhckNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgICAgdGhpcy5jbGVhckJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUNsZWFyQ2xpY2tCb3VuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwVmFyaWFibGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwVmFyaWFibGVzKCkge1xuICAgICAgICB2YXIgX3RoaXMxOCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy4kbW9kYWxFbCA9ICQoRGF0ZXBpY2tlci5fdGVtcGxhdGUpO1xuICAgICAgICB0aGlzLm1vZGFsRWwgPSB0aGlzLiRtb2RhbEVsWzBdO1xuXG4gICAgICAgIHRoaXMuY2FsZW5kYXJFbCA9IHRoaXMubW9kYWxFbC5xdWVyeVNlbGVjdG9yKCcuZGF0ZXBpY2tlci1jYWxlbmRhcicpO1xuXG4gICAgICAgIHRoaXMueWVhclRleHRFbCA9IHRoaXMubW9kYWxFbC5xdWVyeVNlbGVjdG9yKCcueWVhci10ZXh0Jyk7XG4gICAgICAgIHRoaXMuZGF0ZVRleHRFbCA9IHRoaXMubW9kYWxFbC5xdWVyeVNlbGVjdG9yKCcuZGF0ZS10ZXh0Jyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0NsZWFyQnRuKSB7XG4gICAgICAgICAgdGhpcy5jbGVhckJ0biA9IHRoaXMubW9kYWxFbC5xdWVyeVNlbGVjdG9yKCcuZGF0ZXBpY2tlci1jbGVhcicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9uZUJ0biA9IHRoaXMubW9kYWxFbC5xdWVyeVNlbGVjdG9yKCcuZGF0ZXBpY2tlci1kb25lJyk7XG4gICAgICAgIHRoaXMuY2FuY2VsQnRuID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy5kYXRlcGlja2VyLWNhbmNlbCcpO1xuXG4gICAgICAgIHRoaXMuZm9ybWF0cyA9IHtcbiAgICAgICAgICBkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMxOC5kYXRlLmdldERhdGUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZCA9IF90aGlzMTguZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gKGQgPCAxMCA/ICcwJyA6ICcnKSArIGQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczE4Lm9wdGlvbnMuaTE4bi53ZWVrZGF5c1Nob3J0W190aGlzMTguZGF0ZS5nZXREYXkoKV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZGRkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMxOC5vcHRpb25zLmkxOG4ud2Vla2RheXNbX3RoaXMxOC5kYXRlLmdldERheSgpXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczE4LmRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtbTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBfdGhpczE4LmRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gKG0gPCAxMCA/ICcwJyA6ICcnKSArIG07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtbW06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczE4Lm9wdGlvbnMuaTE4bi5tb250aHNTaG9ydFtfdGhpczE4LmRhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtbW1tOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMxOC5vcHRpb25zLmkxOG4ubW9udGhzW190aGlzMTguZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHl5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCcnICsgX3RoaXMxOC5kYXRlLmdldEZ1bGxZZWFyKCkpLnNsaWNlKDIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeXl5eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMTguZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVJbnB1dENsaWNrQm91bmQpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVJbnB1dEtleWRvd25Cb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5faGFuZGxlSW5wdXRDaGFuZ2VCb3VuZCk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUNhbGVuZGFyQ2xpY2tCb3VuZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVJbnB1dENsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUlucHV0Q2xpY2soKSB7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlSW5wdXRLZXlkb3duXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUlucHV0S2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChlLndoaWNoID09PSBNLmtleXMuRU5URVIpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUNhbGVuZGFyQ2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2FsZW5kYXJDbGljayhlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgJHRhcmdldCA9ICQoZS50YXJnZXQpO1xuICAgICAgICBpZiAoISR0YXJnZXQuaGFzQ2xhc3MoJ2lzLWRpc2FibGVkJykpIHtcbiAgICAgICAgICBpZiAoJHRhcmdldC5oYXNDbGFzcygnZGF0ZXBpY2tlci1kYXktYnV0dG9uJykgJiYgISR0YXJnZXQuaGFzQ2xhc3MoJ2lzLWVtcHR5JykgJiYgISR0YXJnZXQucGFyZW50KCkuaGFzQ2xhc3MoJ2lzLWRpc2FibGVkJykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0ZShuZXcgRGF0ZShlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEteWVhcicpLCBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9udGgnKSwgZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWRheScpKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgICB0aGlzLl9maW5pc2hTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCR0YXJnZXQuY2xvc2VzdCgnLm1vbnRoLXByZXYnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJldk1vbnRoKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICgkdGFyZ2V0LmNsb3Nlc3QoJy5tb250aC1uZXh0JykubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRNb250aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlQ2xlYXJDbGlja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDbGVhckNsaWNrKCkge1xuICAgICAgICB0aGlzLmRhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnNldElucHV0VmFsdWUoKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlTW9udGhDaGFuZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTW9udGhDaGFuZ2UoZSkge1xuICAgICAgICB0aGlzLmdvdG9Nb250aChlLnRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVZZWFyQ2hhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVllYXJDaGFuZ2UoZSkge1xuICAgICAgICB0aGlzLmdvdG9ZZWFyKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjaGFuZ2UgdmlldyB0byBhIHNwZWNpZmljIG1vbnRoICh6ZXJvLWluZGV4LCBlLmcuIDA6IEphbnVhcnkpXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnb3RvTW9udGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnb3RvTW9udGgobW9udGgpIHtcbiAgICAgICAgaWYgKCFpc05hTihtb250aCkpIHtcbiAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXS5tb250aCA9IHBhcnNlSW50KG1vbnRoLCAxMCk7XG4gICAgICAgICAgdGhpcy5hZGp1c3RDYWxlbmRhcnMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNoYW5nZSB2aWV3IHRvIGEgc3BlY2lmaWMgZnVsbCB5ZWFyIChlLmcuIFwiMjAxMlwiKVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ290b1llYXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnb3RvWWVhcih5ZWFyKSB7XG4gICAgICAgIGlmICghaXNOYU4oeWVhcikpIHtcbiAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXS55ZWFyID0gcGFyc2VJbnQoeWVhciwgMTApO1xuICAgICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUlucHV0Q2hhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUlucHV0Q2hhbmdlKGUpIHtcbiAgICAgICAgdmFyIGRhdGUgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gUHJldmVudCBjaGFuZ2UgZXZlbnQgZnJvbSBiZWluZyBmaXJlZCB3aGVuIHRyaWdnZXJlZCBieSB0aGUgcGx1Z2luXG4gICAgICAgIGlmIChlLmZpcmVkQnkgPT09IHRoaXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJzZSkge1xuICAgICAgICAgIGRhdGUgPSB0aGlzLm9wdGlvbnMucGFyc2UodGhpcy5lbC52YWx1ZSwgdGhpcy5vcHRpb25zLmZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUucGFyc2UodGhpcy5lbC52YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKERhdGVwaWNrZXIuX2lzRGF0ZShkYXRlKSkge1xuICAgICAgICAgIHRoaXMuc2V0RGF0ZShkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJEYXlOYW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyRGF5TmFtZShvcHRzLCBkYXksIGFiYnIpIHtcbiAgICAgICAgZGF5ICs9IG9wdHMuZmlyc3REYXk7XG4gICAgICAgIHdoaWxlIChkYXkgPj0gNykge1xuICAgICAgICAgIGRheSAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYmJyID8gb3B0cy5pMThuLndlZWtkYXlzQWJicmV2W2RheV0gOiBvcHRzLmkxOG4ud2Vla2RheXNbZGF5XTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgaW5wdXQgdmFsdWUgdG8gdGhlIHNlbGVjdGVkIGRhdGUgYW5kIGNsb3NlIERhdGVwaWNrZXJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9maW5pc2hTZWxlY3Rpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluaXNoU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldElucHV0VmFsdWUoKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE9wZW4gRGF0ZXBpY2tlclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib3BlblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25PcGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9uT3Blbi5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICB0aGlzLm1vZGFsLm9wZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc2UgRGF0ZXBpY2tlclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25DbG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kYWwuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KERhdGVwaWNrZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEYXRlcGlja2VyKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2lzRGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0RhdGUob2JqKSB7XG4gICAgICAgIHJldHVybiAoL0RhdGUvLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpICYmICFpc05hTihvYmouZ2V0VGltZSgpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaXNXZWVrZW5kXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzV2Vla2VuZChkYXRlKSB7XG4gICAgICAgIHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICByZXR1cm4gZGF5ID09PSAwIHx8IGRheSA9PT0gNjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldFRvU3RhcnRPZkRheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRUb1N0YXJ0T2ZEYXkoZGF0ZSkge1xuICAgICAgICBpZiAoRGF0ZXBpY2tlci5faXNEYXRlKGRhdGUpKSBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0RGF5c0luTW9udGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIFszMSwgRGF0ZXBpY2tlci5faXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb250aF07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9pc0xlYXBZZWFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzTGVhcFllYXIoeWVhcikge1xuICAgICAgICAvLyBzb2x1dGlvbiBieSBNYXR0aSBWaXJra3VuZW46IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ4ODE5NTFcbiAgICAgICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2NvbXBhcmVEYXRlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21wYXJlRGF0ZXMoYSwgYikge1xuICAgICAgICAvLyB3ZWFrIGRhdGUgY29tcGFyaXNvbiAodXNlIHNldFRvU3RhcnRPZkRheShkYXRlKSB0byBlbnN1cmUgY29ycmVjdCByZXN1bHQpXG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXRUb1N0YXJ0T2ZEYXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VG9TdGFydE9mRGF5KGRhdGUpIHtcbiAgICAgICAgaWYgKERhdGVwaWNrZXIuX2lzRGF0ZShkYXRlKSkgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fRGF0ZXBpY2tlcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEYXRlcGlja2VyO1xuICB9KENvbXBvbmVudCk7XG5cbiAgRGF0ZXBpY2tlci5fdGVtcGxhdGUgPSBbJzxkaXYgY2xhc3M9IFwibW9kYWwgZGF0ZXBpY2tlci1tb2RhbFwiPicsICc8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudCBkYXRlcGlja2VyLWNvbnRhaW5lclwiPicsICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1kYXRlLWRpc3BsYXlcIj4nLCAnPHNwYW4gY2xhc3M9XCJ5ZWFyLXRleHRcIj48L3NwYW4+JywgJzxzcGFuIGNsYXNzPVwiZGF0ZS10ZXh0XCI+PC9zcGFuPicsICc8L2Rpdj4nLCAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItY2FsZW5kYXItY29udGFpbmVyXCI+JywgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWNhbGVuZGFyXCI+PC9kaXY+JywgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWZvb3RlclwiPicsICc8YnV0dG9uIGNsYXNzPVwiYnRuLWZsYXQgZGF0ZXBpY2tlci1jbGVhciB3YXZlcy1lZmZlY3RcIiBzdHlsZT1cInZpc2liaWxpdHk6IGhpZGRlbjtcIiB0eXBlPVwiYnV0dG9uXCI+PC9idXR0b24+JywgJzxkaXYgY2xhc3M9XCJjb25maXJtYXRpb24tYnRuc1wiPicsICc8YnV0dG9uIGNsYXNzPVwiYnRuLWZsYXQgZGF0ZXBpY2tlci1jYW5jZWwgd2F2ZXMtZWZmZWN0XCIgdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPicsICc8YnV0dG9uIGNsYXNzPVwiYnRuLWZsYXQgZGF0ZXBpY2tlci1kb25lIHdhdmVzLWVmZmVjdFwiIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj4nLCAnPC9kaXY+JywgJzwvZGl2PicsICc8L2Rpdj4nLCAnPC9kaXY+JywgJzwvZGl2PiddLmpvaW4oJycpO1xuXG4gIE0uRGF0ZXBpY2tlciA9IERhdGVwaWNrZXI7XG5cbiAgaWYgKE0ualF1ZXJ5TG9hZGVkKSB7XG4gICAgTS5pbml0aWFsaXplSnF1ZXJ5V3JhcHBlcihEYXRlcGlja2VyLCAnZGF0ZXBpY2tlcicsICdNX0RhdGVwaWNrZXInKTtcbiAgfVxufSkoY2FzaCk7XG47KGZ1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2RlZmF1bHRzID0ge1xuICAgIGRpYWxSYWRpdXM6IDEzNSxcbiAgICBvdXRlclJhZGl1czogMTA1LFxuICAgIGlubmVyUmFkaXVzOiA3MCxcbiAgICB0aWNrUmFkaXVzOiAyMCxcbiAgICBkdXJhdGlvbjogMzUwLFxuICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICBkZWZhdWx0VGltZTogJ25vdycsIC8vIGRlZmF1bHQgdGltZSwgJ25vdycgb3IgJzEzOjE0JyBlLmcuXG4gICAgZnJvbU5vdzogMCwgLy8gTWlsbGlzZWNvbmQgb2Zmc2V0IGZyb20gdGhlIGRlZmF1bHRUaW1lXG4gICAgc2hvd0NsZWFyQnRuOiBmYWxzZSxcblxuICAgIC8vIGludGVybmF0aW9uYWxpemF0aW9uXG4gICAgaTE4bjoge1xuICAgICAgY2FuY2VsOiAnQ2FuY2VsJyxcbiAgICAgIGNsZWFyOiAnQ2xlYXInLFxuICAgICAgZG9uZTogJ09rJ1xuICAgIH0sXG5cbiAgICBhdXRvQ2xvc2U6IGZhbHNlLCAvLyBhdXRvIGNsb3NlIHdoZW4gbWludXRlIGlzIHNlbGVjdGVkXG4gICAgdHdlbHZlSG91cjogdHJ1ZSwgLy8gY2hhbmdlIHRvIDEyIGhvdXIgQU0vUE0gY2xvY2sgZnJvbSAyNCBob3VyXG4gICAgdmlicmF0ZTogdHJ1ZSwgLy8gdmlicmF0ZSB0aGUgZGV2aWNlIHdoZW4gZHJhZ2dpbmcgY2xvY2sgaGFuZFxuXG4gICAgLy8gQ2FsbGJhY2tzXG4gICAgb25PcGVuU3RhcnQ6IG51bGwsXG4gICAgb25PcGVuRW5kOiBudWxsLFxuICAgIG9uQ2xvc2VTdGFydDogbnVsbCxcbiAgICBvbkNsb3NlRW5kOiBudWxsLFxuICAgIG9uU2VsZWN0OiBudWxsXG4gIH07XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKi9cblxuICB2YXIgVGltZXBpY2tlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50NSkge1xuICAgIF9pbmhlcml0cyhUaW1lcGlja2VyLCBfQ29tcG9uZW50NSk7XG5cbiAgICBmdW5jdGlvbiBUaW1lcGlja2VyKGVsLCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZXBpY2tlcik7XG5cbiAgICAgIHZhciBfdGhpczE5ID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRpbWVwaWNrZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lcGlja2VyKSkuY2FsbCh0aGlzLCBUaW1lcGlja2VyLCBlbCwgb3B0aW9ucykpO1xuXG4gICAgICBfdGhpczE5LmVsLk1fVGltZXBpY2tlciA9IF90aGlzMTk7XG5cbiAgICAgIF90aGlzMTkub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBUaW1lcGlja2VyLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgX3RoaXMxOS5pZCA9IE0uZ3VpZCgpO1xuICAgICAgX3RoaXMxOS5faW5zZXJ0SFRNTEludG9ET00oKTtcbiAgICAgIF90aGlzMTkuX3NldHVwTW9kYWwoKTtcbiAgICAgIF90aGlzMTkuX3NldHVwVmFyaWFibGVzKCk7XG4gICAgICBfdGhpczE5Ll9zZXR1cEV2ZW50SGFuZGxlcnMoKTtcblxuICAgICAgX3RoaXMxOS5fY2xvY2tTZXR1cCgpO1xuICAgICAgX3RoaXMxOS5fcGlja2VyU2V0dXAoKTtcbiAgICAgIHJldHVybiBfdGhpczE5O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhUaW1lcGlja2VyLCBbe1xuICAgICAga2V5OiBcImRlc3Ryb3lcIixcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRlYXJkb3duIGNvbXBvbmVudFxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLm1vZGFsLmRlc3Ryb3koKTtcbiAgICAgICAgJCh0aGlzLm1vZGFsRWwpLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmVsLk1fVGltZXBpY2tlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUlucHV0S2V5ZG93bkJvdW5kID0gdGhpcy5faGFuZGxlSW5wdXRLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUlucHV0Q2xpY2tCb3VuZCA9IHRoaXMuX2hhbmRsZUlucHV0Q2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlQ2xvY2tDbGlja1N0YXJ0Qm91bmQgPSB0aGlzLl9oYW5kbGVDbG9ja0NsaWNrU3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja01vdmVCb3VuZCA9IHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tFbmRCb3VuZCA9IHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tFbmQuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlSW5wdXRDbGlja0JvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlSW5wdXRLZXlkb3duQm91bmQpO1xuICAgICAgICB0aGlzLnBsYXRlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2hhbmRsZUNsb2NrQ2xpY2tTdGFydEJvdW5kKTtcbiAgICAgICAgdGhpcy5wbGF0ZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5faGFuZGxlQ2xvY2tDbGlja1N0YXJ0Qm91bmQpO1xuXG4gICAgICAgICQodGhpcy5zcGFuSG91cnMpLm9uKCdjbGljaycsIHRoaXMuc2hvd1ZpZXcuYmluZCh0aGlzLCAnaG91cnMnKSk7XG4gICAgICAgICQodGhpcy5zcGFuTWludXRlcykub24oJ2NsaWNrJywgdGhpcy5zaG93Vmlldy5iaW5kKHRoaXMsICdtaW51dGVzJykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlSW5wdXRDbGlja0JvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlSW5wdXRLZXlkb3duQm91bmQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlSW5wdXRDbGlja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVJbnB1dENsaWNrKCkge1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUlucHV0S2V5ZG93blwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVJbnB1dEtleWRvd24oZSkge1xuICAgICAgICBpZiAoZS53aGljaCA9PT0gTS5rZXlzLkVOVEVSKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVDbG9ja0NsaWNrU3RhcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2xvY2tDbGlja1N0YXJ0KGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgY2xvY2tQbGF0ZUJSID0gdGhpcy5wbGF0ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHsgeDogY2xvY2tQbGF0ZUJSLmxlZnQsIHk6IGNsb2NrUGxhdGVCUi50b3AgfTtcblxuICAgICAgICB0aGlzLngwID0gb2Zmc2V0LnggKyB0aGlzLm9wdGlvbnMuZGlhbFJhZGl1cztcbiAgICAgICAgdGhpcy55MCA9IG9mZnNldC55ICsgdGhpcy5vcHRpb25zLmRpYWxSYWRpdXM7XG4gICAgICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNsaWNrUG9zID0gVGltZXBpY2tlci5fUG9zKGUpO1xuICAgICAgICB0aGlzLmR4ID0gY2xpY2tQb3MueCAtIHRoaXMueDA7XG4gICAgICAgIHRoaXMuZHkgPSBjbGlja1Bvcy55IC0gdGhpcy55MDtcblxuICAgICAgICAvLyBTZXQgY2xvY2sgaGFuZHNcbiAgICAgICAgdGhpcy5zZXRIYW5kKHRoaXMuZHgsIHRoaXMuZHksIGZhbHNlKTtcblxuICAgICAgICAvLyBNb3VzZW1vdmUgb24gZG9jdW1lbnRcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja01vdmVCb3VuZCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tNb3ZlQm91bmQpO1xuXG4gICAgICAgIC8vIE1vdXNldXAgb24gZG9jdW1lbnRcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tFbmRCb3VuZCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja0VuZEJvdW5kKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZURvY3VtZW50Q2xpY2tNb3ZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZURvY3VtZW50Q2xpY2tNb3ZlKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgY2xpY2tQb3MgPSBUaW1lcGlja2VyLl9Qb3MoZSk7XG4gICAgICAgIHZhciB4ID0gY2xpY2tQb3MueCAtIHRoaXMueDA7XG4gICAgICAgIHZhciB5ID0gY2xpY2tQb3MueSAtIHRoaXMueTA7XG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldEhhbmQoeCwgeSwgZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlRG9jdW1lbnRDbGlja0VuZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVEb2N1bWVudENsaWNrRW5kKGUpIHtcbiAgICAgICAgdmFyIF90aGlzMjAgPSB0aGlzO1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tFbmRCb3VuZCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja0VuZEJvdW5kKTtcbiAgICAgICAgdmFyIGNsaWNrUG9zID0gVGltZXBpY2tlci5fUG9zKGUpO1xuICAgICAgICB2YXIgeCA9IGNsaWNrUG9zLnggLSB0aGlzLngwO1xuICAgICAgICB2YXIgeSA9IGNsaWNrUG9zLnkgLSB0aGlzLnkwO1xuICAgICAgICBpZiAodGhpcy5tb3ZlZCAmJiB4ID09PSB0aGlzLmR4ICYmIHkgPT09IHRoaXMuZHkpIHtcbiAgICAgICAgICB0aGlzLnNldEhhbmQoeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VmlldyA9PT0gJ2hvdXJzJykge1xuICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoJ21pbnV0ZXMnLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gLyAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XG4gICAgICAgICAgJCh0aGlzLm1pbnV0ZXNWaWV3KS5hZGRDbGFzcygndGltZXBpY2tlci1kaWFsLW91dCcpO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyMC5kb25lKCk7XG4gICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uIC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vblNlbGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vblNlbGVjdC5jYWxsKHRoaXMsIHRoaXMuaG91cnMsIHRoaXMubWludXRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmJpbmQgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tNb3ZlQm91bmQpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrTW92ZUJvdW5kKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2luc2VydEhUTUxJbnRvRE9NXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luc2VydEhUTUxJbnRvRE9NKCkge1xuICAgICAgICB0aGlzLiRtb2RhbEVsID0gJChUaW1lcGlja2VyLl90ZW1wbGF0ZSk7XG4gICAgICAgIHRoaXMubW9kYWxFbCA9IHRoaXMuJG1vZGFsRWxbMF07XG4gICAgICAgIHRoaXMubW9kYWxFbC5pZCA9ICdtb2RhbC0nICsgdGhpcy5pZDtcblxuICAgICAgICAvLyBBcHBlbmQgcG9wb3ZlciB0byBpbnB1dCBieSBkZWZhdWx0XG4gICAgICAgIHZhciBjb250YWluZXJFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLmNvbnRhaW5lcik7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGFpbmVyICYmICEhY29udGFpbmVyRWwpIHtcbiAgICAgICAgICB0aGlzLiRtb2RhbEVsLmFwcGVuZFRvKGNvbnRhaW5lckVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRtb2RhbEVsLmluc2VydEJlZm9yZSh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBNb2RhbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cE1vZGFsKCkge1xuICAgICAgICB2YXIgX3RoaXMyMSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5tb2RhbCA9IE0uTW9kYWwuaW5pdCh0aGlzLm1vZGFsRWwsIHtcbiAgICAgICAgICBvbk9wZW5TdGFydDogdGhpcy5vcHRpb25zLm9uT3BlblN0YXJ0LFxuICAgICAgICAgIG9uT3BlbkVuZDogdGhpcy5vcHRpb25zLm9uT3BlbkVuZCxcbiAgICAgICAgICBvbkNsb3NlU3RhcnQ6IHRoaXMub3B0aW9ucy5vbkNsb3NlU3RhcnQsXG4gICAgICAgICAgb25DbG9zZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczIxLm9wdGlvbnMub25DbG9zZUVuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBfdGhpczIxLm9wdGlvbnMub25DbG9zZUVuZC5jYWxsKF90aGlzMjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMyMS5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBWYXJpYWJsZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBWYXJpYWJsZXMoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXcgPSAnaG91cnMnO1xuICAgICAgICB0aGlzLnZpYnJhdGUgPSBuYXZpZ2F0b3IudmlicmF0ZSA/ICd2aWJyYXRlJyA6IG5hdmlnYXRvci53ZWJraXRWaWJyYXRlID8gJ3dlYmtpdFZpYnJhdGUnIDogbnVsbDtcblxuICAgICAgICB0aGlzLl9jYW52YXMgPSB0aGlzLm1vZGFsRWwucXVlcnlTZWxlY3RvcignLnRpbWVwaWNrZXItY2FudmFzJyk7XG4gICAgICAgIHRoaXMucGxhdGUgPSB0aGlzLm1vZGFsRWwucXVlcnlTZWxlY3RvcignLnRpbWVwaWNrZXItcGxhdGUnKTtcblxuICAgICAgICB0aGlzLmhvdXJzVmlldyA9IHRoaXMubW9kYWxFbC5xdWVyeVNlbGVjdG9yKCcudGltZXBpY2tlci1ob3VycycpO1xuICAgICAgICB0aGlzLm1pbnV0ZXNWaWV3ID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy50aW1lcGlja2VyLW1pbnV0ZXMnKTtcbiAgICAgICAgdGhpcy5zcGFuSG91cnMgPSB0aGlzLm1vZGFsRWwucXVlcnlTZWxlY3RvcignLnRpbWVwaWNrZXItc3Bhbi1ob3VycycpO1xuICAgICAgICB0aGlzLnNwYW5NaW51dGVzID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy50aW1lcGlja2VyLXNwYW4tbWludXRlcycpO1xuICAgICAgICB0aGlzLnNwYW5BbVBtID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy50aW1lcGlja2VyLXNwYW4tYW0tcG0nKTtcbiAgICAgICAgdGhpcy5mb290ZXIgPSB0aGlzLm1vZGFsRWwucXVlcnlTZWxlY3RvcignLnRpbWVwaWNrZXItZm9vdGVyJyk7XG4gICAgICAgIHRoaXMuYW1PclBtID0gJ1BNJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3BpY2tlclNldHVwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BpY2tlclNldHVwKCkge1xuICAgICAgICB2YXIgJGNsZWFyQnRuID0gJChcIjxidXR0b24gY2xhc3M9XFxcImJ0bi1mbGF0IHRpbWVwaWNrZXItY2xlYXIgd2F2ZXMtZWZmZWN0XFxcIiBzdHlsZT1cXFwidmlzaWJpbGl0eTogaGlkZGVuO1xcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiB0YWJpbmRleD1cXFwiXCIgKyAodGhpcy5vcHRpb25zLnR3ZWx2ZUhvdXIgPyAnMycgOiAnMScpICsgXCJcXFwiPlwiICsgdGhpcy5vcHRpb25zLmkxOG4uY2xlYXIgKyBcIjwvYnV0dG9uPlwiKS5hcHBlbmRUbyh0aGlzLmZvb3Rlcikub24oJ2NsaWNrJywgdGhpcy5jbGVhci5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93Q2xlYXJCdG4pIHtcbiAgICAgICAgICAkY2xlYXJCdG4uY3NzKHsgdmlzaWJpbGl0eTogJycgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29uZmlybWF0aW9uQnRuc0NvbnRhaW5lciA9ICQoJzxkaXYgY2xhc3M9XCJjb25maXJtYXRpb24tYnRuc1wiPjwvZGl2PicpO1xuICAgICAgICAkKCc8YnV0dG9uIGNsYXNzPVwiYnRuLWZsYXQgdGltZXBpY2tlci1jbG9zZSB3YXZlcy1lZmZlY3RcIiB0eXBlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCInICsgKHRoaXMub3B0aW9ucy50d2VsdmVIb3VyID8gJzMnIDogJzEnKSArICdcIj4nICsgdGhpcy5vcHRpb25zLmkxOG4uY2FuY2VsICsgJzwvYnV0dG9uPicpLmFwcGVuZFRvKGNvbmZpcm1hdGlvbkJ0bnNDb250YWluZXIpLm9uKCdjbGljaycsIHRoaXMuY2xvc2UuYmluZCh0aGlzKSk7XG4gICAgICAgICQoJzxidXR0b24gY2xhc3M9XCJidG4tZmxhdCB0aW1lcGlja2VyLWNsb3NlIHdhdmVzLWVmZmVjdFwiIHR5cGU9XCJidXR0b25cIiB0YWJpbmRleD1cIicgKyAodGhpcy5vcHRpb25zLnR3ZWx2ZUhvdXIgPyAnMycgOiAnMScpICsgJ1wiPicgKyB0aGlzLm9wdGlvbnMuaTE4bi5kb25lICsgJzwvYnV0dG9uPicpLmFwcGVuZFRvKGNvbmZpcm1hdGlvbkJ0bnNDb250YWluZXIpLm9uKCdjbGljaycsIHRoaXMuZG9uZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgY29uZmlybWF0aW9uQnRuc0NvbnRhaW5lci5hcHBlbmRUbyh0aGlzLmZvb3Rlcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9jbG9ja1NldHVwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Nsb2NrU2V0dXAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHdlbHZlSG91cikge1xuICAgICAgICAgIHRoaXMuJGFtQnRuID0gJCgnPGRpdiBjbGFzcz1cImFtLWJ0blwiPkFNPC9kaXY+Jyk7XG4gICAgICAgICAgdGhpcy4kcG1CdG4gPSAkKCc8ZGl2IGNsYXNzPVwicG0tYnRuXCI+UE08L2Rpdj4nKTtcbiAgICAgICAgICB0aGlzLiRhbUJ0bi5vbignY2xpY2snLCB0aGlzLl9oYW5kbGVBbVBtQ2xpY2suYmluZCh0aGlzKSkuYXBwZW5kVG8odGhpcy5zcGFuQW1QbSk7XG4gICAgICAgICAgdGhpcy4kcG1CdG4ub24oJ2NsaWNrJywgdGhpcy5faGFuZGxlQW1QbUNsaWNrLmJpbmQodGhpcykpLmFwcGVuZFRvKHRoaXMuc3BhbkFtUG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYnVpbGRIb3Vyc1ZpZXcoKTtcbiAgICAgICAgdGhpcy5fYnVpbGRNaW51dGVzVmlldygpO1xuICAgICAgICB0aGlzLl9idWlsZFNWR0Nsb2NrKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9idWlsZFNWR0Nsb2NrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2J1aWxkU1ZHQ2xvY2soKSB7XG4gICAgICAgIC8vIERyYXcgY2xvY2sgaGFuZHMgYW5kIG90aGVyc1xuICAgICAgICB2YXIgZGlhbFJhZGl1cyA9IHRoaXMub3B0aW9ucy5kaWFsUmFkaXVzO1xuICAgICAgICB2YXIgdGlja1JhZGl1cyA9IHRoaXMub3B0aW9ucy50aWNrUmFkaXVzO1xuICAgICAgICB2YXIgZGlhbWV0ZXIgPSBkaWFsUmFkaXVzICogMjtcblxuICAgICAgICB2YXIgc3ZnID0gVGltZXBpY2tlci5fY3JlYXRlU1ZHRWwoJ3N2ZycpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdjbGFzcycsICd0aW1lcGlja2VyLXN2ZycpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGRpYW1ldGVyKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgZGlhbWV0ZXIpO1xuICAgICAgICB2YXIgZyA9IFRpbWVwaWNrZXIuX2NyZWF0ZVNWR0VsKCdnJyk7XG4gICAgICAgIGcuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBkaWFsUmFkaXVzICsgJywnICsgZGlhbFJhZGl1cyArICcpJyk7XG4gICAgICAgIHZhciBiZWFyaW5nID0gVGltZXBpY2tlci5fY3JlYXRlU1ZHRWwoJ2NpcmNsZScpO1xuICAgICAgICBiZWFyaW5nLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAndGltZXBpY2tlci1jYW52YXMtYmVhcmluZycpO1xuICAgICAgICBiZWFyaW5nLnNldEF0dHJpYnV0ZSgnY3gnLCAwKTtcbiAgICAgICAgYmVhcmluZy5zZXRBdHRyaWJ1dGUoJ2N5JywgMCk7XG4gICAgICAgIGJlYXJpbmcuc2V0QXR0cmlidXRlKCdyJywgNCk7XG4gICAgICAgIHZhciBoYW5kID0gVGltZXBpY2tlci5fY3JlYXRlU1ZHRWwoJ2xpbmUnKTtcbiAgICAgICAgaGFuZC5zZXRBdHRyaWJ1dGUoJ3gxJywgMCk7XG4gICAgICAgIGhhbmQuc2V0QXR0cmlidXRlKCd5MScsIDApO1xuICAgICAgICB2YXIgYmcgPSBUaW1lcGlja2VyLl9jcmVhdGVTVkdFbCgnY2lyY2xlJyk7XG4gICAgICAgIGJnLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAndGltZXBpY2tlci1jYW52YXMtYmcnKTtcbiAgICAgICAgYmcuc2V0QXR0cmlidXRlKCdyJywgdGlja1JhZGl1cyk7XG4gICAgICAgIGcuYXBwZW5kQ2hpbGQoaGFuZCk7XG4gICAgICAgIGcuYXBwZW5kQ2hpbGQoYmcpO1xuICAgICAgICBnLmFwcGVuZENoaWxkKGJlYXJpbmcpO1xuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoZyk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hcHBlbmRDaGlsZChzdmcpO1xuXG4gICAgICAgIHRoaXMuaGFuZCA9IGhhbmQ7XG4gICAgICAgIHRoaXMuYmcgPSBiZztcbiAgICAgICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2J1aWxkSG91cnNWaWV3XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2J1aWxkSG91cnNWaWV3KCkge1xuICAgICAgICB2YXIgJHRpY2sgPSAkKCc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci10aWNrXCI+PC9kaXY+Jyk7XG4gICAgICAgIC8vIEhvdXJzIHZpZXdcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50d2VsdmVIb3VyKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxMzsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdGljayA9ICR0aWNrLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgcmFkaWFuID0gaSAvIDYgKiBNYXRoLlBJO1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMub3B0aW9ucy5vdXRlclJhZGl1cztcbiAgICAgICAgICAgIHRpY2suY3NzKHtcbiAgICAgICAgICAgICAgbGVmdDogdGhpcy5vcHRpb25zLmRpYWxSYWRpdXMgKyBNYXRoLnNpbihyYWRpYW4pICogcmFkaXVzIC0gdGhpcy5vcHRpb25zLnRpY2tSYWRpdXMgKyAncHgnLFxuICAgICAgICAgICAgICB0b3A6IHRoaXMub3B0aW9ucy5kaWFsUmFkaXVzIC0gTWF0aC5jb3MocmFkaWFuKSAqIHJhZGl1cyAtIHRoaXMub3B0aW9ucy50aWNrUmFkaXVzICsgJ3B4J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aWNrLmh0bWwoaSA9PT0gMCA/ICcwMCcgOiBpKTtcbiAgICAgICAgICAgIHRoaXMuaG91cnNWaWV3LmFwcGVuZENoaWxkKHRpY2tbMF0pO1xuICAgICAgICAgICAgLy8gdGljay5vbihtb3VzZWRvd25FdmVudCwgbW91c2Vkb3duKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDI0OyBfaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgX3RpY2sgPSAkdGljay5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIF9yYWRpYW4gPSBfaSAvIDYgKiBNYXRoLlBJO1xuICAgICAgICAgICAgdmFyIGlubmVyID0gX2kgPiAwICYmIF9pIDwgMTM7XG4gICAgICAgICAgICB2YXIgX3JhZGl1cyA9IGlubmVyID8gdGhpcy5vcHRpb25zLmlubmVyUmFkaXVzIDogdGhpcy5vcHRpb25zLm91dGVyUmFkaXVzO1xuICAgICAgICAgICAgX3RpY2suY3NzKHtcbiAgICAgICAgICAgICAgbGVmdDogdGhpcy5vcHRpb25zLmRpYWxSYWRpdXMgKyBNYXRoLnNpbihfcmFkaWFuKSAqIF9yYWRpdXMgLSB0aGlzLm9wdGlvbnMudGlja1JhZGl1cyArICdweCcsXG4gICAgICAgICAgICAgIHRvcDogdGhpcy5vcHRpb25zLmRpYWxSYWRpdXMgLSBNYXRoLmNvcyhfcmFkaWFuKSAqIF9yYWRpdXMgLSB0aGlzLm9wdGlvbnMudGlja1JhZGl1cyArICdweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RpY2suaHRtbChfaSA9PT0gMCA/ICcwMCcgOiBfaSk7XG4gICAgICAgICAgICB0aGlzLmhvdXJzVmlldy5hcHBlbmRDaGlsZChfdGlja1swXSk7XG4gICAgICAgICAgICAvLyB0aWNrLm9uKG1vdXNlZG93bkV2ZW50LCBtb3VzZWRvd24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYnVpbGRNaW51dGVzVmlld1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9idWlsZE1pbnV0ZXNWaWV3KCkge1xuICAgICAgICB2YXIgJHRpY2sgPSAkKCc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci10aWNrXCI+PC9kaXY+Jyk7XG4gICAgICAgIC8vIE1pbnV0ZXMgdmlld1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDYwOyBpICs9IDUpIHtcbiAgICAgICAgICB2YXIgdGljayA9ICR0aWNrLmNsb25lKCk7XG4gICAgICAgICAgdmFyIHJhZGlhbiA9IGkgLyAzMCAqIE1hdGguUEk7XG4gICAgICAgICAgdGljay5jc3Moe1xuICAgICAgICAgICAgbGVmdDogdGhpcy5vcHRpb25zLmRpYWxSYWRpdXMgKyBNYXRoLnNpbihyYWRpYW4pICogdGhpcy5vcHRpb25zLm91dGVyUmFkaXVzIC0gdGhpcy5vcHRpb25zLnRpY2tSYWRpdXMgKyAncHgnLFxuICAgICAgICAgICAgdG9wOiB0aGlzLm9wdGlvbnMuZGlhbFJhZGl1cyAtIE1hdGguY29zKHJhZGlhbikgKiB0aGlzLm9wdGlvbnMub3V0ZXJSYWRpdXMgLSB0aGlzLm9wdGlvbnMudGlja1JhZGl1cyArICdweCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aWNrLmh0bWwoVGltZXBpY2tlci5fYWRkTGVhZGluZ1plcm8oaSkpO1xuICAgICAgICAgIHRoaXMubWludXRlc1ZpZXcuYXBwZW5kQ2hpbGQodGlja1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUFtUG1DbGlja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVBbVBtQ2xpY2soZSkge1xuICAgICAgICB2YXIgJGJ0bkNsaWNrZWQgPSAkKGUudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5hbU9yUG0gPSAkYnRuQ2xpY2tlZC5oYXNDbGFzcygnYW0tYnRuJykgPyAnQU0nIDogJ1BNJztcbiAgICAgICAgdGhpcy5fdXBkYXRlQW1QbVZpZXcoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3VwZGF0ZUFtUG1WaWV3XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUFtUG1WaWV3KCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR3ZWx2ZUhvdXIpIHtcbiAgICAgICAgICB0aGlzLiRhbUJ0bi50b2dnbGVDbGFzcygndGV4dC1wcmltYXJ5JywgdGhpcy5hbU9yUG0gPT09ICdBTScpO1xuICAgICAgICAgIHRoaXMuJHBtQnRuLnRvZ2dsZUNsYXNzKCd0ZXh0LXByaW1hcnknLCB0aGlzLmFtT3JQbSA9PT0gJ1BNJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3VwZGF0ZVRpbWVGcm9tSW5wdXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlVGltZUZyb21JbnB1dCgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSB0aW1lXG4gICAgICAgIHZhciB2YWx1ZSA9ICgodGhpcy5lbC52YWx1ZSB8fCB0aGlzLm9wdGlvbnMuZGVmYXVsdFRpbWUgfHwgJycpICsgJycpLnNwbGl0KCc6Jyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHdlbHZlSG91ciAmJiAhKHR5cGVvZiB2YWx1ZVsxXSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlWzFdLnRvVXBwZXJDYXNlKCkuaW5kZXhPZignQU0nKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYW1PclBtID0gJ0FNJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbU9yUG0gPSAnUE0nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZVsxXSA9IHZhbHVlWzFdLnJlcGxhY2UoJ0FNJywgJycpLnJlcGxhY2UoJ1BNJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZVswXSA9PT0gJ25vdycpIHtcbiAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoK25ldyBEYXRlKCkgKyB0aGlzLm9wdGlvbnMuZnJvbU5vdyk7XG4gICAgICAgICAgdmFsdWUgPSBbbm93LmdldEhvdXJzKCksIG5vdy5nZXRNaW51dGVzKCldO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHdlbHZlSG91cikge1xuICAgICAgICAgICAgdGhpcy5hbU9yUG0gPSB2YWx1ZVswXSA+PSAxMiAmJiB2YWx1ZVswXSA8IDI0ID8gJ1BNJyA6ICdBTSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG91cnMgPSArdmFsdWVbMF0gfHwgMDtcbiAgICAgICAgdGhpcy5taW51dGVzID0gK3ZhbHVlWzFdIHx8IDA7XG4gICAgICAgIHRoaXMuc3BhbkhvdXJzLmlubmVySFRNTCA9IHRoaXMuaG91cnM7XG4gICAgICAgIHRoaXMuc3Bhbk1pbnV0ZXMuaW5uZXJIVE1MID0gVGltZXBpY2tlci5fYWRkTGVhZGluZ1plcm8odGhpcy5taW51dGVzKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVBbVBtVmlldygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzaG93Vmlld1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dWaWV3KHZpZXcsIGRlbGF5KSB7XG4gICAgICAgIGlmICh2aWV3ID09PSAnbWludXRlcycgJiYgJCh0aGlzLmhvdXJzVmlldykuY3NzKCd2aXNpYmlsaXR5JykgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAgIC8vIHJhaXNlQ2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUhvdXJTZWxlY3QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0hvdXJzID0gdmlldyA9PT0gJ2hvdXJzJyxcbiAgICAgICAgICAgIG5leHRWaWV3ID0gaXNIb3VycyA/IHRoaXMuaG91cnNWaWV3IDogdGhpcy5taW51dGVzVmlldyxcbiAgICAgICAgICAgIGhpZGVWaWV3ID0gaXNIb3VycyA/IHRoaXMubWludXRlc1ZpZXcgOiB0aGlzLmhvdXJzVmlldztcbiAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9IHZpZXc7XG5cbiAgICAgICAgJCh0aGlzLnNwYW5Ib3VycykudG9nZ2xlQ2xhc3MoJ3RleHQtcHJpbWFyeScsIGlzSG91cnMpO1xuICAgICAgICAkKHRoaXMuc3Bhbk1pbnV0ZXMpLnRvZ2dsZUNsYXNzKCd0ZXh0LXByaW1hcnknLCAhaXNIb3Vycyk7XG5cbiAgICAgICAgLy8gVHJhbnNpdGlvbiB2aWV3XG4gICAgICAgIGhpZGVWaWV3LmNsYXNzTGlzdC5hZGQoJ3RpbWVwaWNrZXItZGlhbC1vdXQnKTtcbiAgICAgICAgJChuZXh0VmlldykuY3NzKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKS5yZW1vdmVDbGFzcygndGltZXBpY2tlci1kaWFsLW91dCcpO1xuXG4gICAgICAgIC8vIFJlc2V0IGNsb2NrIGhhbmRcbiAgICAgICAgdGhpcy5yZXNldENsb2NrKGRlbGF5KTtcblxuICAgICAgICAvLyBBZnRlciB0cmFuc2l0aW9ucyBlbmRlZFxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b2dnbGVWaWV3VGltZXIpO1xuICAgICAgICB0aGlzLnRvZ2dsZVZpZXdUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQoaGlkZVZpZXcpLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVzZXRDbG9ja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0Q2xvY2soZGVsYXkpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmN1cnJlbnRWaWV3LFxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzW3ZpZXddLFxuICAgICAgICAgICAgaXNIb3VycyA9IHZpZXcgPT09ICdob3VycycsXG4gICAgICAgICAgICB1bml0ID0gTWF0aC5QSSAvIChpc0hvdXJzID8gNiA6IDMwKSxcbiAgICAgICAgICAgIHJhZGlhbiA9IHZhbHVlICogdW5pdCxcbiAgICAgICAgICAgIHJhZGl1cyA9IGlzSG91cnMgJiYgdmFsdWUgPiAwICYmIHZhbHVlIDwgMTMgPyB0aGlzLm9wdGlvbnMuaW5uZXJSYWRpdXMgOiB0aGlzLm9wdGlvbnMub3V0ZXJSYWRpdXMsXG4gICAgICAgICAgICB4ID0gTWF0aC5zaW4ocmFkaWFuKSAqIHJhZGl1cyxcbiAgICAgICAgICAgIHkgPSAtTWF0aC5jb3MocmFkaWFuKSAqIHJhZGl1cyxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICQodGhpcy5jYW52YXMpLmFkZENsYXNzKCd0aW1lcGlja2VyLWNhbnZhcy1vdXQnKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQoc2VsZi5jYW52YXMpLnJlbW92ZUNsYXNzKCd0aW1lcGlja2VyLWNhbnZhcy1vdXQnKTtcbiAgICAgICAgICAgIHNlbGYuc2V0SGFuZCh4LCB5KTtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRIYW5kKHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldEhhbmRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIYW5kKHgsIHksIHJvdW5kQnk1KSB7XG4gICAgICAgIHZhciBfdGhpczIyID0gdGhpcztcblxuICAgICAgICB2YXIgcmFkaWFuID0gTWF0aC5hdGFuMih4LCAteSksXG4gICAgICAgICAgICBpc0hvdXJzID0gdGhpcy5jdXJyZW50VmlldyA9PT0gJ2hvdXJzJyxcbiAgICAgICAgICAgIHVuaXQgPSBNYXRoLlBJIC8gKGlzSG91cnMgfHwgcm91bmRCeTUgPyA2IDogMzApLFxuICAgICAgICAgICAgeiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KSxcbiAgICAgICAgICAgIGlubmVyID0gaXNIb3VycyAmJiB6IDwgKHRoaXMub3B0aW9ucy5vdXRlclJhZGl1cyArIHRoaXMub3B0aW9ucy5pbm5lclJhZGl1cykgLyAyLFxuICAgICAgICAgICAgcmFkaXVzID0gaW5uZXIgPyB0aGlzLm9wdGlvbnMuaW5uZXJSYWRpdXMgOiB0aGlzLm9wdGlvbnMub3V0ZXJSYWRpdXM7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50d2VsdmVIb3VyKSB7XG4gICAgICAgICAgcmFkaXVzID0gdGhpcy5vcHRpb25zLm91dGVyUmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmFkaWFuIHNob3VsZCBpbiByYW5nZSBbMCwgMlBJXVxuICAgICAgICBpZiAocmFkaWFuIDwgMCkge1xuICAgICAgICAgIHJhZGlhbiA9IE1hdGguUEkgKiAyICsgcmFkaWFuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSByb3VuZCB2YWx1ZVxuICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLnJvdW5kKHJhZGlhbiAvIHVuaXQpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgcm91bmQgcmFkaWFuXG4gICAgICAgIHJhZGlhbiA9IHZhbHVlICogdW5pdDtcblxuICAgICAgICAvLyBDb3JyZWN0IHRoZSBob3VycyBvciBtaW51dGVzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHdlbHZlSG91cikge1xuICAgICAgICAgIGlmIChpc0hvdXJzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHZhbHVlID0gMTI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyb3VuZEJ5NSkgdmFsdWUgKj0gNTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gNjApIHZhbHVlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzSG91cnMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBpbm5lciA/IHZhbHVlID09PSAwID8gMTIgOiB2YWx1ZSA6IHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgMTI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyb3VuZEJ5NSkge1xuICAgICAgICAgICAgICB2YWx1ZSAqPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSA2MCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25jZSBob3VycyBvciBtaW51dGVzIGNoYW5nZWQsIHZpYnJhdGUgdGhlIGRldmljZVxuICAgICAgICBpZiAodGhpc1t0aGlzLmN1cnJlbnRWaWV3XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBpZiAodGhpcy52aWJyYXRlICYmIHRoaXMub3B0aW9ucy52aWJyYXRlKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgdmlicmF0ZSB0b28gZnJlcXVlbnRseVxuICAgICAgICAgICAgaWYgKCF0aGlzLnZpYnJhdGVUaW1lcikge1xuICAgICAgICAgICAgICBuYXZpZ2F0b3JbdGhpcy52aWJyYXRlXSgxMCk7XG4gICAgICAgICAgICAgIHRoaXMudmlicmF0ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyMi52aWJyYXRlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbdGhpcy5jdXJyZW50Vmlld10gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGlzSG91cnMpIHtcbiAgICAgICAgICB0aGlzWydzcGFuSG91cnMnXS5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzWydzcGFuTWludXRlcyddLmlubmVySFRNTCA9IFRpbWVwaWNrZXIuX2FkZExlYWRpbmdaZXJvKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBjbG9jayBoYW5kIGFuZCBvdGhlcnMnIHBvc2l0aW9uXG4gICAgICAgIHZhciBjeDEgPSBNYXRoLnNpbihyYWRpYW4pICogKHJhZGl1cyAtIHRoaXMub3B0aW9ucy50aWNrUmFkaXVzKSxcbiAgICAgICAgICAgIGN5MSA9IC1NYXRoLmNvcyhyYWRpYW4pICogKHJhZGl1cyAtIHRoaXMub3B0aW9ucy50aWNrUmFkaXVzKSxcbiAgICAgICAgICAgIGN4MiA9IE1hdGguc2luKHJhZGlhbikgKiByYWRpdXMsXG4gICAgICAgICAgICBjeTIgPSAtTWF0aC5jb3MocmFkaWFuKSAqIHJhZGl1cztcbiAgICAgICAgdGhpcy5oYW5kLnNldEF0dHJpYnV0ZSgneDInLCBjeDEpO1xuICAgICAgICB0aGlzLmhhbmQuc2V0QXR0cmlidXRlKCd5MicsIGN5MSk7XG4gICAgICAgIHRoaXMuYmcuc2V0QXR0cmlidXRlKCdjeCcsIGN4Mik7XG4gICAgICAgIHRoaXMuYmcuc2V0QXR0cmlidXRlKCdjeScsIGN5Mik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm9wZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRpbWVGcm9tSW5wdXQoKTtcbiAgICAgICAgdGhpcy5zaG93VmlldygnaG91cnMnKTtcblxuICAgICAgICB0aGlzLm1vZGFsLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW9kYWwuY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGaW5pc2ggdGltZXBpY2tlciBzZWxlY3Rpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkb25lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZG9uZShlLCBjbGVhclZhbHVlKSB7XG4gICAgICAgIC8vIFNldCBpbnB1dCB2YWx1ZVxuICAgICAgICB2YXIgbGFzdCA9IHRoaXMuZWwudmFsdWU7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNsZWFyVmFsdWUgPyAnJyA6IFRpbWVwaWNrZXIuX2FkZExlYWRpbmdaZXJvKHRoaXMuaG91cnMpICsgJzonICsgVGltZXBpY2tlci5fYWRkTGVhZGluZ1plcm8odGhpcy5taW51dGVzKTtcbiAgICAgICAgdGhpcy50aW1lID0gdmFsdWU7XG4gICAgICAgIGlmICghY2xlYXJWYWx1ZSAmJiB0aGlzLm9wdGlvbnMudHdlbHZlSG91cikge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyBcIiBcIiArIHRoaXMuYW1PclBtO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBUcmlnZ2VyIGNoYW5nZSBldmVudFxuICAgICAgICBpZiAodmFsdWUgIT09IGxhc3QpIHtcbiAgICAgICAgICB0aGlzLiRlbC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5lbC5mb2N1cygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmRvbmUobnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KFRpbWVwaWNrZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lcGlja2VyKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcywgZWxzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FkZExlYWRpbmdaZXJvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZExlYWRpbmdaZXJvKG51bSkge1xuICAgICAgICByZXR1cm4gKG51bSA8IDEwID8gJzAnIDogJycpICsgbnVtO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY3JlYXRlU1ZHRWxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlU1ZHRWwobmFtZSkge1xuICAgICAgICB2YXIgc3ZnTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQb2ludFxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIFggQ29vcmRpbmF0ZVxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIFkgQ29vcmRpbmF0ZVxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHggcG9zaXRpb24gb2YgbW91c2Ugb3IgdG91Y2ggZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqIEByZXR1cm4ge1BvaW50fSB4IGFuZCB5IGxvY2F0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfUG9zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX1BvcyhlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHsgeDogZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFgsIHk6IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW91c2UgZXZlbnRcbiAgICAgICAgcmV0dXJuIHsgeDogZS5jbGllbnRYLCB5OiBlLmNsaWVudFkgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgSW5zdGFuY2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoZWwpIHtcbiAgICAgICAgdmFyIGRvbUVsZW0gPSAhIWVsLmpxdWVyeSA/IGVsWzBdIDogZWw7XG4gICAgICAgIHJldHVybiBkb21FbGVtLk1fVGltZXBpY2tlcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUaW1lcGlja2VyO1xuICB9KENvbXBvbmVudCk7XG5cbiAgVGltZXBpY2tlci5fdGVtcGxhdGUgPSBbJzxkaXYgY2xhc3M9IFwibW9kYWwgdGltZXBpY2tlci1tb2RhbFwiPicsICc8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudCB0aW1lcGlja2VyLWNvbnRhaW5lclwiPicsICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1kaWdpdGFsLWRpc3BsYXlcIj4nLCAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItdGV4dC1jb250YWluZXJcIj4nLCAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItZGlzcGxheS1jb2x1bW5cIj4nLCAnPHNwYW4gY2xhc3M9XCJ0aW1lcGlja2VyLXNwYW4taG91cnMgdGV4dC1wcmltYXJ5XCI+PC9zcGFuPicsICc6JywgJzxzcGFuIGNsYXNzPVwidGltZXBpY2tlci1zcGFuLW1pbnV0ZXNcIj48L3NwYW4+JywgJzwvZGl2PicsICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1kaXNwbGF5LWNvbHVtbiB0aW1lcGlja2VyLWRpc3BsYXktYW0tcG1cIj4nLCAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItc3Bhbi1hbS1wbVwiPjwvZGl2PicsICc8L2Rpdj4nLCAnPC9kaXY+JywgJzwvZGl2PicsICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1hbmFsb2ctZGlzcGxheVwiPicsICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1wbGF0ZVwiPicsICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1jYW52YXNcIj48L2Rpdj4nLCAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItZGlhbCB0aW1lcGlja2VyLWhvdXJzXCI+PC9kaXY+JywgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLWRpYWwgdGltZXBpY2tlci1taW51dGVzIHRpbWVwaWNrZXItZGlhbC1vdXRcIj48L2Rpdj4nLCAnPC9kaXY+JywgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLWZvb3RlclwiPjwvZGl2PicsICc8L2Rpdj4nLCAnPC9kaXY+JywgJzwvZGl2PiddLmpvaW4oJycpO1xuXG4gIE0uVGltZXBpY2tlciA9IFRpbWVwaWNrZXI7XG5cbiAgaWYgKE0ualF1ZXJ5TG9hZGVkKSB7XG4gICAgTS5pbml0aWFsaXplSnF1ZXJ5V3JhcHBlcihUaW1lcGlja2VyLCAndGltZXBpY2tlcicsICdNX1RpbWVwaWNrZXInKTtcbiAgfVxufSkoY2FzaCk7XG47KGZ1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2RlZmF1bHRzID0ge1xuICAgIGNsYXNzZXM6ICcnLFxuICAgIGRyb3Bkb3duT3B0aW9uczoge31cbiAgfTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqXG4gICAqL1xuXG4gIHZhciBGb3JtU2VsZWN0ID0gZnVuY3Rpb24gKF9Db21wb25lbnQ2KSB7XG4gICAgX2luaGVyaXRzKEZvcm1TZWxlY3QsIF9Db21wb25lbnQ2KTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBGb3JtU2VsZWN0IGluc3RhbmNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gRm9ybVNlbGVjdChlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1TZWxlY3QpO1xuXG4gICAgICAvLyBEb24ndCBpbml0IGlmIGJyb3dzZXIgZGVmYXVsdCB2ZXJzaW9uXG4gICAgICB2YXIgX3RoaXMyMyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGb3JtU2VsZWN0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybVNlbGVjdCkpLmNhbGwodGhpcywgRm9ybVNlbGVjdCwgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgaWYgKF90aGlzMjMuJGVsLmhhc0NsYXNzKCdicm93c2VyLWRlZmF1bHQnKSkge1xuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMyMyk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzMjMuZWwuTV9Gb3JtU2VsZWN0ID0gX3RoaXMyMztcblxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25zIGZvciB0aGUgc2VsZWN0XG4gICAgICAgKiBAbWVtYmVyIEZvcm1TZWxlY3Qjb3B0aW9uc1xuICAgICAgICovXG4gICAgICBfdGhpczIzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRm9ybVNlbGVjdC5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIF90aGlzMjMuaXNNdWx0aXBsZSA9IF90aGlzMjMuJGVsLnByb3AoJ211bHRpcGxlJyk7XG5cbiAgICAgIC8vIFNldHVwXG4gICAgICBfdGhpczIzLmVsLnRhYkluZGV4ID0gLTE7XG4gICAgICBfdGhpczIzLl9rZXlzU2VsZWN0ZWQgPSB7fTtcbiAgICAgIF90aGlzMjMuX3ZhbHVlRGljdCA9IHt9OyAvLyBNYXBzIGtleSB0byBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIG9wdGlvbiBlbGVtZW50LlxuICAgICAgX3RoaXMyMy5fc2V0dXBEcm9wZG93bigpO1xuXG4gICAgICBfdGhpczIzLl9zZXR1cEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIHJldHVybiBfdGhpczIzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhGb3JtU2VsZWN0LCBbe1xuICAgICAga2V5OiBcImRlc3Ryb3lcIixcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRlYXJkb3duIGNvbXBvbmVudFxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLl9yZW1vdmVEcm9wZG93bigpO1xuICAgICAgICB0aGlzLmVsLk1fRm9ybVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczI0ID0gdGhpcztcblxuICAgICAgICB0aGlzLl9oYW5kbGVTZWxlY3RDaGFuZ2VCb3VuZCA9IHRoaXMuX2hhbmRsZVNlbGVjdENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVPcHRpb25DbGlja0JvdW5kID0gdGhpcy5faGFuZGxlT3B0aW9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlSW5wdXRDbGlja0JvdW5kID0gdGhpcy5faGFuZGxlSW5wdXRDbGljay5iaW5kKHRoaXMpO1xuXG4gICAgICAgICQodGhpcy5kcm9wZG93bk9wdGlvbnMpLmZpbmQoJ2xpOm5vdCgub3B0Z3JvdXApJykuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzMjQuX2hhbmRsZU9wdGlvbkNsaWNrQm91bmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9oYW5kbGVTZWxlY3RDaGFuZ2VCb3VuZCk7XG4gICAgICAgIHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVJbnB1dENsaWNrQm91bmQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBFdmVudCBIYW5kbGVyc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZUV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdmFyIF90aGlzMjUgPSB0aGlzO1xuXG4gICAgICAgICQodGhpcy5kcm9wZG93bk9wdGlvbnMpLmZpbmQoJ2xpOm5vdCgub3B0Z3JvdXApJykuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzMjUuX2hhbmRsZU9wdGlvbkNsaWNrQm91bmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9oYW5kbGVTZWxlY3RDaGFuZ2VCb3VuZCk7XG4gICAgICAgIHRoaXMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVJbnB1dENsaWNrQm91bmQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBTZWxlY3QgQ2hhbmdlXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlU2VsZWN0Q2hhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVNlbGVjdENoYW5nZShlKSB7XG4gICAgICAgIHRoaXMuX3NldFZhbHVlVG9JbnB1dCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBPcHRpb24gQ2xpY2tcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVPcHRpb25DbGlja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVPcHRpb25DbGljayhlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIG9wdGlvbiA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ2xpJylbMF07XG4gICAgICAgIHZhciBrZXkgPSBvcHRpb24uaWQ7XG4gICAgICAgIGlmICghJChvcHRpb24pLmhhc0NsYXNzKCdkaXNhYmxlZCcpICYmICEkKG9wdGlvbikuaGFzQ2xhc3MoJ29wdGdyb3VwJykgJiYga2V5Lmxlbmd0aCkge1xuICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc011bHRpcGxlKSB7XG4gICAgICAgICAgICAvLyBEZXNlbGVjdCBwbGFjZWhvbGRlciBvcHRpb24gaWYgc3RpbGwgc2VsZWN0ZWQuXG4gICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJPcHRpb24gPSAkKHRoaXMuZHJvcGRvd25PcHRpb25zKS5maW5kKCdsaS5kaXNhYmxlZC5zZWxlY3RlZCcpO1xuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyT3B0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICBwbGFjZWhvbGRlck9wdGlvbi5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXJPcHRpb24uZmluZCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRW50cnlGcm9tQXJyYXkocGxhY2Vob2xkZXJPcHRpb25bMF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLl90b2dnbGVFbnRyeUZyb21BcnJheShrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKHRoaXMuZHJvcGRvd25PcHRpb25zKS5maW5kKCdsaScpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgJChvcHRpb24pLnRvZ2dsZUNsYXNzKCdzZWxlY3RlZCcsIHNlbGVjdGVkKTtcbiAgICAgICAgICAgIHRoaXMuX2tleXNTZWxlY3RlZCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fa2V5c1NlbGVjdGVkW29wdGlvbi5pZF0gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCBzZWxlY3RlZCBvbiBvcmlnaW5hbCBzZWxlY3Qgb3B0aW9uXG4gICAgICAgICAgLy8gT25seSB0cmlnZ2VyIGlmIHNlbGVjdGVkIHN0YXRlIGNoYW5nZWRcbiAgICAgICAgICB2YXIgcHJldlNlbGVjdGVkID0gJCh0aGlzLl92YWx1ZURpY3Rba2V5XS5lbCkucHJvcCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICBpZiAocHJldlNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgJCh0aGlzLl92YWx1ZURpY3Rba2V5XS5lbCkucHJvcCgnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG4gICAgICAgICAgICB0aGlzLiRlbC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBJbnB1dCBDbGlja1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUlucHV0Q2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRDbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJvcGRvd24gJiYgdGhpcy5kcm9wZG93bi5pc09wZW4pIHtcbiAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVRvSW5wdXQoKTtcbiAgICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZFN0YXRlcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgZHJvcGRvd25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cERyb3Bkb3duXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwRHJvcGRvd24oKSB7XG4gICAgICAgIHZhciBfdGhpczI2ID0gdGhpcztcblxuICAgICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgJCh0aGlzLndyYXBwZXIpLmFkZENsYXNzKCdzZWxlY3Qtd3JhcHBlciAnICsgdGhpcy5vcHRpb25zLmNsYXNzZXMpO1xuICAgICAgICB0aGlzLiRlbC5iZWZvcmUoJCh0aGlzLndyYXBwZXIpKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuXG4gICAgICAgIGlmICh0aGlzLmVsLmRpc2FibGVkKSB7XG4gICAgICAgICAgdGhpcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgZHJvcGRvd25cbiAgICAgICAgdGhpcy4kc2VsZWN0T3B0aW9ucyA9IHRoaXMuJGVsLmNoaWxkcmVuKCdvcHRpb24sIG9wdGdyb3VwJyk7XG4gICAgICAgIHRoaXMuZHJvcGRvd25PcHRpb25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgdGhpcy5kcm9wZG93bk9wdGlvbnMuaWQgPSBcInNlbGVjdC1vcHRpb25zLVwiICsgTS5ndWlkKCk7XG4gICAgICAgICQodGhpcy5kcm9wZG93bk9wdGlvbnMpLmFkZENsYXNzKCdkcm9wZG93bi1jb250ZW50IHNlbGVjdC1kcm9wZG93biAnICsgKHRoaXMuaXNNdWx0aXBsZSA/ICdtdWx0aXBsZS1zZWxlY3QtZHJvcGRvd24nIDogJycpKTtcblxuICAgICAgICAvLyBDcmVhdGUgZHJvcGRvd24gc3RydWN0dXJlLlxuICAgICAgICBpZiAodGhpcy4kc2VsZWN0T3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLiRzZWxlY3RPcHRpb25zLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoJChlbCkuaXMoJ29wdGlvbicpKSB7XG4gICAgICAgICAgICAgIC8vIERpcmVjdCBkZXNjZW5kYW50IG9wdGlvbi5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbkVsID0gdm9pZCAwO1xuICAgICAgICAgICAgICBpZiAoX3RoaXMyNi5pc011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uRWwgPSBfdGhpczI2Ll9hcHBlbmRPcHRpb25XaXRoSWNvbihfdGhpczI2LiRlbCwgZWwsICdtdWx0aXBsZScpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbkVsID0gX3RoaXMyNi5fYXBwZW5kT3B0aW9uV2l0aEljb24oX3RoaXMyNi4kZWwsIGVsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzMjYuX2FkZE9wdGlvblRvVmFsdWVEaWN0KGVsLCBvcHRpb25FbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCQoZWwpLmlzKCdvcHRncm91cCcpKSB7XG4gICAgICAgICAgICAgIC8vIE9wdGdyb3VwLlxuICAgICAgICAgICAgICB2YXIgc2VsZWN0T3B0aW9ucyA9ICQoZWwpLmNoaWxkcmVuKCdvcHRpb24nKTtcbiAgICAgICAgICAgICAgJChfdGhpczI2LmRyb3Bkb3duT3B0aW9ucykuYXBwZW5kKCQoJzxsaSBjbGFzcz1cIm9wdGdyb3VwXCI+PHNwYW4+JyArIGVsLmdldEF0dHJpYnV0ZSgnbGFiZWwnKSArICc8L3NwYW4+PC9saT4nKVswXSk7XG5cbiAgICAgICAgICAgICAgc2VsZWN0T3B0aW9ucy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25FbCA9IF90aGlzMjYuX2FwcGVuZE9wdGlvbldpdGhJY29uKF90aGlzMjYuJGVsLCBlbCwgJ29wdGdyb3VwLW9wdGlvbicpO1xuICAgICAgICAgICAgICAgIF90aGlzMjYuX2FkZE9wdGlvblRvVmFsdWVEaWN0KGVsLCBvcHRpb25FbCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kZWwuYWZ0ZXIodGhpcy5kcm9wZG93bk9wdGlvbnMpO1xuXG4gICAgICAgIC8vIEFkZCBpbnB1dCBkcm9wZG93blxuICAgICAgICB0aGlzLmlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgJCh0aGlzLmlucHV0KS5hZGRDbGFzcygnc2VsZWN0LWRyb3Bkb3duIGRyb3Bkb3duLXRyaWdnZXInKTtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgICAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnLCB0aGlzLmRyb3Bkb3duT3B0aW9ucy5pZCk7XG4gICAgICAgIGlmICh0aGlzLmVsLmRpc2FibGVkKSB7XG4gICAgICAgICAgJCh0aGlzLmlucHV0KS5wcm9wKCdkaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbC5iZWZvcmUodGhpcy5pbnB1dCk7XG4gICAgICAgIHRoaXMuX3NldFZhbHVlVG9JbnB1dCgpO1xuXG4gICAgICAgIC8vIEFkZCBjYXJldFxuICAgICAgICB2YXIgZHJvcGRvd25JY29uID0gJCgnPHN2ZyBjbGFzcz1cImNhcmV0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTcgMTBsNSA1IDUtNXpcIi8+PHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz48L3N2Zz4nKTtcbiAgICAgICAgdGhpcy4kZWwuYmVmb3JlKGRyb3Bkb3duSWNvblswXSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBkcm9wZG93blxuICAgICAgICBpZiAoIXRoaXMuZWwuZGlzYWJsZWQpIHtcbiAgICAgICAgICB2YXIgZHJvcGRvd25PcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucy5kcm9wZG93bk9wdGlvbnMpO1xuXG4gICAgICAgICAgLy8gQWRkIGNhbGxiYWNrIGZvciBjZW50ZXJpbmcgc2VsZWN0ZWQgb3B0aW9uIHdoZW4gZHJvcGRvd24gY29udGVudCBpcyBzY3JvbGxhYmxlXG4gICAgICAgICAgZHJvcGRvd25PcHRpb25zLm9uT3BlbkVuZCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkT3B0aW9uID0gJChfdGhpczI2LmRyb3Bkb3duT3B0aW9ucykuZmluZCgnLnNlbGVjdGVkJykuZmlyc3QoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkT3B0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBGb2N1cyBzZWxlY3RlZCBvcHRpb24gaW4gZHJvcGRvd25cbiAgICAgICAgICAgICAgTS5rZXlEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX3RoaXMyNi5kcm9wZG93bi5mb2N1c2VkSW5kZXggPSBzZWxlY3RlZE9wdGlvbi5pbmRleCgpO1xuICAgICAgICAgICAgICBfdGhpczI2LmRyb3Bkb3duLl9mb2N1c0ZvY3VzZWRJdGVtKCk7XG4gICAgICAgICAgICAgIE0ua2V5RG93biA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBzY3JvbGxpbmcgdG8gc2VsZWN0ZWQgb3B0aW9uXG4gICAgICAgICAgICAgIGlmIChfdGhpczI2LmRyb3Bkb3duLmlzU2Nyb2xsYWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXQgPSBzZWxlY3RlZE9wdGlvblswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSBfdGhpczI2LmRyb3Bkb3duT3B0aW9ucy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7IC8vIHNjcm9sbCB0byBzZWxlY3RlZCBvcHRpb25cbiAgICAgICAgICAgICAgICBzY3JvbGxPZmZzZXQgLT0gX3RoaXMyNi5kcm9wZG93bk9wdGlvbnMuY2xpZW50SGVpZ2h0IC8gMjsgLy8gY2VudGVyIGluIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgX3RoaXMyNi5kcm9wZG93bk9wdGlvbnMuc2Nyb2xsVG9wID0gc2Nyb2xsT2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGRyb3Bkb3duT3B0aW9ucy5jbG9zZU9uQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kcm9wZG93biA9IE0uRHJvcGRvd24uaW5pdCh0aGlzLmlucHV0LCBkcm9wZG93bk9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGluaXRpYWwgc2VsZWN0aW9uc1xuICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZFN0YXRlcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBvcHRpb24gdG8gdmFsdWUgZGljdFxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCAgb3JpZ2luYWwgb3B0aW9uIGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gb3B0aW9uRWwgIGdlbmVyYXRlZCBvcHRpb24gZWxlbWVudFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FkZE9wdGlvblRvVmFsdWVEaWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZE9wdGlvblRvVmFsdWVEaWN0KGVsLCBvcHRpb25FbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBPYmplY3Qua2V5cyh0aGlzLl92YWx1ZURpY3QpLmxlbmd0aDtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuZHJvcGRvd25PcHRpb25zLmlkICsgaW5kZXg7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgb3B0aW9uRWwuaWQgPSBrZXk7XG5cbiAgICAgICAgb2JqLmVsID0gZWw7XG4gICAgICAgIG9iai5vcHRpb25FbCA9IG9wdGlvbkVsO1xuICAgICAgICB0aGlzLl92YWx1ZURpY3Rba2V5XSA9IG9iajtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgZHJvcGRvd25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVEcm9wZG93blwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVEcm9wZG93bigpIHtcbiAgICAgICAgJCh0aGlzLndyYXBwZXIpLmZpbmQoJy5jYXJldCcpLnJlbW92ZSgpO1xuICAgICAgICAkKHRoaXMuaW5wdXQpLnJlbW92ZSgpO1xuICAgICAgICAkKHRoaXMuZHJvcGRvd25PcHRpb25zKS5yZW1vdmUoKTtcbiAgICAgICAgJCh0aGlzLndyYXBwZXIpLmJlZm9yZSh0aGlzLiRlbCk7XG4gICAgICAgICQodGhpcy53cmFwcGVyKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBkcm9wZG93blxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBzZWxlY3QgIHNlbGVjdCBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG9wdGlvbiAgb3B0aW9uIGVsZW1lbnQgZnJvbSBzZWxlY3RcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSAgb3B0aW9uIGVsZW1lbnQgYWRkZWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hcHBlbmRPcHRpb25XaXRoSWNvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRPcHRpb25XaXRoSWNvbihzZWxlY3QsIG9wdGlvbiwgdHlwZSkge1xuICAgICAgICAvLyBBZGQgZGlzYWJsZWQgYXR0ciBpZiBkaXNhYmxlZFxuICAgICAgICB2YXIgZGlzYWJsZWRDbGFzcyA9IG9wdGlvbi5kaXNhYmxlZCA/ICdkaXNhYmxlZCAnIDogJyc7XG4gICAgICAgIHZhciBvcHRncm91cENsYXNzID0gdHlwZSA9PT0gJ29wdGdyb3VwLW9wdGlvbicgPyAnb3B0Z3JvdXAtb3B0aW9uICcgOiAnJztcbiAgICAgICAgdmFyIG11bHRpcGxlQ2hlY2tib3ggPSB0aGlzLmlzTXVsdGlwbGUgPyBcIjxsYWJlbD48aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiXCIgKyBkaXNhYmxlZENsYXNzICsgXCJcXFwiLz48c3Bhbj5cIiArIG9wdGlvbi5pbm5lckhUTUwgKyBcIjwvc3Bhbj48L2xhYmVsPlwiIDogb3B0aW9uLmlubmVySFRNTDtcbiAgICAgICAgdmFyIGxpRWwgPSAkKCc8bGk+PC9saT4nKTtcbiAgICAgICAgdmFyIHNwYW5FbCA9ICQoJzxzcGFuPjwvc3Bhbj4nKTtcbiAgICAgICAgc3BhbkVsLmh0bWwobXVsdGlwbGVDaGVja2JveCk7XG4gICAgICAgIGxpRWwuYWRkQ2xhc3MoZGlzYWJsZWRDbGFzcyArIFwiIFwiICsgb3B0Z3JvdXBDbGFzcyk7XG4gICAgICAgIGxpRWwuYXBwZW5kKHNwYW5FbCk7XG5cbiAgICAgICAgLy8gYWRkIGljb25zXG4gICAgICAgIHZhciBpY29uVXJsID0gb3B0aW9uLmdldEF0dHJpYnV0ZSgnZGF0YS1pY29uJyk7XG4gICAgICAgIGlmICghIWljb25VcmwpIHtcbiAgICAgICAgICB2YXIgaW1nRWwgPSAkKFwiPGltZyBhbHQ9XFxcIlxcXCIgc3JjPVxcXCJcIiArIGljb25VcmwgKyBcIlxcXCI+XCIpO1xuICAgICAgICAgIGxpRWwucHJlcGVuZChpbWdFbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgbXVsdGlwbGUgdHlwZS5cbiAgICAgICAgJCh0aGlzLmRyb3Bkb3duT3B0aW9ucykuYXBwZW5kKGxpRWxbMF0pO1xuICAgICAgICByZXR1cm4gbGlFbFswXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgZW50cnkgZnJvbSBvcHRpb25cbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgIE9wdGlvbiBrZXlcbiAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICBpZiBlbnRyeSB3YXMgYWRkZWQgb3IgcmVtb3ZlZFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3RvZ2dsZUVudHJ5RnJvbUFycmF5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvZ2dsZUVudHJ5RnJvbUFycmF5KGtleSkge1xuICAgICAgICB2YXIgbm90QWRkZWQgPSAhdGhpcy5fa2V5c1NlbGVjdGVkLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgIHZhciAkb3B0aW9uTGkgPSAkKHRoaXMuX3ZhbHVlRGljdFtrZXldLm9wdGlvbkVsKTtcblxuICAgICAgICBpZiAobm90QWRkZWQpIHtcbiAgICAgICAgICB0aGlzLl9rZXlzU2VsZWN0ZWRba2V5XSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2tleXNTZWxlY3RlZFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgJG9wdGlvbkxpLnRvZ2dsZUNsYXNzKCdzZWxlY3RlZCcsIG5vdEFkZGVkKTtcblxuICAgICAgICAvLyBTZXQgY2hlY2tib3ggY2hlY2tlZCB2YWx1ZVxuICAgICAgICAkb3B0aW9uTGkuZmluZCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJykucHJvcCgnY2hlY2tlZCcsIG5vdEFkZGVkKTtcblxuICAgICAgICAvLyB1c2Ugbm90QWRkZWQgaW5zdGVhZCBvZiB0cnVlICh0byBkZXRlY3QgaWYgdGhlIG9wdGlvbiBpcyBzZWxlY3RlZCBvciBub3QpXG4gICAgICAgICRvcHRpb25MaS5wcm9wKCdzZWxlY3RlZCcsIG5vdEFkZGVkKTtcblxuICAgICAgICByZXR1cm4gbm90QWRkZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRleHQgdmFsdWUgdG8gaW5wdXRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXRWYWx1ZVRvSW5wdXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VmFsdWVUb0lucHV0KCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy4kZWwuZmluZCgnb3B0aW9uJyk7XG5cbiAgICAgICAgb3B0aW9ucy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGlmICgkKGVsKS5wcm9wKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9ICQoZWwpLnRleHQoKTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGZpcnN0RGlzYWJsZWQgPSB0aGlzLiRlbC5maW5kKCdvcHRpb246ZGlzYWJsZWQnKS5lcSgwKTtcbiAgICAgICAgICBpZiAoZmlyc3REaXNhYmxlZC5sZW5ndGggJiYgZmlyc3REaXNhYmxlZFswXS52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGZpcnN0RGlzYWJsZWQudGV4dCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlucHV0LnZhbHVlID0gdmFsdWVzLmpvaW4oJywgJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHNlbGVjdGVkIHN0YXRlIG9mIGRyb3Bkb3duIHRvIG1hdGNoIGFjdHVhbCBzZWxlY3QgZWxlbWVudFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldFNlbGVjdGVkU3RhdGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNlbGVjdGVkU3RhdGVzKCkge1xuICAgICAgICB0aGlzLl9rZXlzU2VsZWN0ZWQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fdmFsdWVEaWN0KSB7XG4gICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMuX3ZhbHVlRGljdFtrZXldO1xuICAgICAgICAgIHZhciBvcHRpb25Jc1NlbGVjdGVkID0gJChvcHRpb24uZWwpLnByb3AoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgJChvcHRpb24ub3B0aW9uRWwpLmZpbmQoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpLnByb3AoJ2NoZWNrZWQnLCBvcHRpb25Jc1NlbGVjdGVkKTtcbiAgICAgICAgICBpZiAob3B0aW9uSXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVPcHRpb24oJCh0aGlzLmRyb3Bkb3duT3B0aW9ucyksICQob3B0aW9uLm9wdGlvbkVsKSk7XG4gICAgICAgICAgICB0aGlzLl9rZXlzU2VsZWN0ZWRba2V5XSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQob3B0aW9uLm9wdGlvbkVsKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNYWtlIG9wdGlvbiBhcyBzZWxlY3RlZCBhbmQgc2Nyb2xsIHRvIHNlbGVjdGVkIHBvc2l0aW9uXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gY29sbGVjdGlvbiAgU2VsZWN0IG9wdGlvbnMgalF1ZXJ5IGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbmV3T3B0aW9uICBlbGVtZW50IG9mIHRoZSBuZXcgb3B0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYWN0aXZhdGVPcHRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWN0aXZhdGVPcHRpb24oY29sbGVjdGlvbiwgbmV3T3B0aW9uKSB7XG4gICAgICAgIGlmIChuZXdPcHRpb24pIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aXBsZSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbi5maW5kKCdsaS5zZWxlY3RlZCcpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3B0aW9uID0gJChuZXdPcHRpb24pO1xuICAgICAgICAgIG9wdGlvbi5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBTZWxlY3RlZCBWYWx1ZXNcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSAgQXJyYXkgb2Ygc2VsZWN0ZWQgdmFsdWVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTZWxlY3RlZFZhbHVlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkVmFsdWVzKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2tleXNTZWxlY3RlZCkge1xuICAgICAgICAgIHNlbGVjdGVkVmFsdWVzLnB1c2godGhpcy5fdmFsdWVEaWN0W2tleV0uZWwudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFZhbHVlcztcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoRm9ybVNlbGVjdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvcm1TZWxlY3QpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLCBlbHMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShlbCkge1xuICAgICAgICB2YXIgZG9tRWxlbSA9ICEhZWwuanF1ZXJ5ID8gZWxbMF0gOiBlbDtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW0uTV9Gb3JtU2VsZWN0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEZvcm1TZWxlY3Q7XG4gIH0oQ29tcG9uZW50KTtcblxuICBNLkZvcm1TZWxlY3QgPSBGb3JtU2VsZWN0O1xuXG4gIGlmIChNLmpRdWVyeUxvYWRlZCkge1xuICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoRm9ybVNlbGVjdCwgJ2Zvcm1TZWxlY3QnLCAnTV9Gb3JtU2VsZWN0Jyk7XG4gIH1cbn0pKGNhc2gpO1xuOyhmdW5jdGlvbiAoJCwgYW5pbSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9kZWZhdWx0cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICovXG5cbiAgdmFyIFJhbmdlID0gZnVuY3Rpb24gKF9Db21wb25lbnQ3KSB7XG4gICAgX2luaGVyaXRzKFJhbmdlLCBfQ29tcG9uZW50Nyk7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgUmFuZ2UgaW5zdGFuY2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSYW5nZShlbCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlKTtcblxuICAgICAgdmFyIF90aGlzMjcgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUmFuZ2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSYW5nZSkpLmNhbGwodGhpcywgUmFuZ2UsIGVsLCBvcHRpb25zKSk7XG5cbiAgICAgIF90aGlzMjcuZWwuTV9SYW5nZSA9IF90aGlzMjc7XG5cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9ucyBmb3IgdGhlIHJhbmdlXG4gICAgICAgKiBAbWVtYmVyIFJhbmdlI29wdGlvbnNcbiAgICAgICAqL1xuICAgICAgX3RoaXMyNy5vcHRpb25zID0gJC5leHRlbmQoe30sIFJhbmdlLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgX3RoaXMyNy5fbW91c2Vkb3duID0gZmFsc2U7XG5cbiAgICAgIC8vIFNldHVwXG4gICAgICBfdGhpczI3Ll9zZXR1cFRodW1iKCk7XG5cbiAgICAgIF90aGlzMjcuX3NldHVwRXZlbnRIYW5kbGVycygpO1xuICAgICAgcmV0dXJuIF90aGlzMjc7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFJhbmdlLCBbe1xuICAgICAga2V5OiBcImRlc3Ryb3lcIixcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRlYXJkb3duIGNvbXBvbmVudFxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLl9yZW1vdmVUaHVtYigpO1xuICAgICAgICB0aGlzLmVsLk1fUmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0dXAgRXZlbnQgSGFuZGxlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVSYW5nZUNoYW5nZUJvdW5kID0gdGhpcy5faGFuZGxlUmFuZ2VDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlUmFuZ2VNb3VzZWRvd25Ub3VjaHN0YXJ0Qm91bmQgPSB0aGlzLl9oYW5kbGVSYW5nZU1vdXNlZG93blRvdWNoc3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlUmFuZ2VJbnB1dE1vdXNlbW92ZVRvdWNobW92ZUJvdW5kID0gdGhpcy5faGFuZGxlUmFuZ2VJbnB1dE1vdXNlbW92ZVRvdWNobW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVSYW5nZU1vdXNldXBUb3VjaGVuZEJvdW5kID0gdGhpcy5faGFuZGxlUmFuZ2VNb3VzZXVwVG91Y2hlbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlUmFuZ2VCbHVyTW91c2VvdXRUb3VjaGxlYXZlQm91bmQgPSB0aGlzLl9oYW5kbGVSYW5nZUJsdXJNb3VzZW91dFRvdWNobGVhdmUuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2hhbmRsZVJhbmdlQ2hhbmdlQm91bmQpO1xuXG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlUmFuZ2VNb3VzZWRvd25Ub3VjaHN0YXJ0Qm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVSYW5nZU1vdXNlZG93blRvdWNoc3RhcnRCb3VuZCk7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2hhbmRsZVJhbmdlSW5wdXRNb3VzZW1vdmVUb3VjaG1vdmVCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlUmFuZ2VJbnB1dE1vdXNlbW92ZVRvdWNobW92ZUJvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVSYW5nZUlucHV0TW91c2Vtb3ZlVG91Y2htb3ZlQm91bmQpO1xuXG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZVJhbmdlTW91c2V1cFRvdWNoZW5kQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlUmFuZ2VNb3VzZXVwVG91Y2hlbmRCb3VuZCk7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5faGFuZGxlUmFuZ2VCbHVyTW91c2VvdXRUb3VjaGxlYXZlQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlUmFuZ2VCbHVyTW91c2VvdXRUb3VjaGxlYXZlQm91bmQpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCB0aGlzLl9oYW5kbGVSYW5nZUJsdXJNb3VzZW91dFRvdWNobGVhdmVCb3VuZCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2hhbmRsZVJhbmdlQ2hhbmdlQm91bmQpO1xuXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlUmFuZ2VNb3VzZWRvd25Ub3VjaHN0YXJ0Qm91bmQpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVSYW5nZU1vdXNlZG93blRvdWNoc3RhcnRCb3VuZCk7XG5cbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2hhbmRsZVJhbmdlSW5wdXRNb3VzZW1vdmVUb3VjaG1vdmVCb3VuZCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlUmFuZ2VJbnB1dE1vdXNlbW92ZVRvdWNobW92ZUJvdW5kKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVSYW5nZUlucHV0TW91c2Vtb3ZlVG91Y2htb3ZlQm91bmQpO1xuXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZVJhbmdlTW91c2V1cFRvdWNoZW5kQm91bmQpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlUmFuZ2VNb3VzZXVwVG91Y2hlbmRCb3VuZCk7XG5cbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5faGFuZGxlUmFuZ2VCbHVyTW91c2VvdXRUb3VjaGxlYXZlQm91bmQpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlUmFuZ2VCbHVyTW91c2VvdXRUb3VjaGxlYXZlQm91bmQpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCB0aGlzLl9oYW5kbGVSYW5nZUJsdXJNb3VzZW91dFRvdWNobGVhdmVCb3VuZCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIFJhbmdlIENoYW5nZVxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZVJhbmdlQ2hhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVJhbmdlQ2hhbmdlKCkge1xuICAgICAgICAkKHRoaXMudmFsdWUpLmh0bWwodGhpcy4kZWwudmFsKCkpO1xuXG4gICAgICAgIGlmICghJCh0aGlzLnRodW1iKS5oYXNDbGFzcygnYWN0aXZlJykpIHtcbiAgICAgICAgICB0aGlzLl9zaG93UmFuZ2VCdWJibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gdGhpcy5fY2FsY1JhbmdlT2Zmc2V0KCk7XG4gICAgICAgICQodGhpcy50aHVtYikuYWRkQ2xhc3MoJ2FjdGl2ZScpLmNzcygnbGVmdCcsIG9mZnNldExlZnQgKyAncHgnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgUmFuZ2UgTW91c2Vkb3duIGFuZCBUb3VjaHN0YXJ0XG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlUmFuZ2VNb3VzZWRvd25Ub3VjaHN0YXJ0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVJhbmdlTW91c2Vkb3duVG91Y2hzdGFydChlKSB7XG4gICAgICAgIC8vIFNldCBpbmRpY2F0b3IgdmFsdWVcbiAgICAgICAgJCh0aGlzLnZhbHVlKS5odG1sKHRoaXMuJGVsLnZhbCgpKTtcblxuICAgICAgICB0aGlzLl9tb3VzZWRvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcygnYWN0aXZlJyk7XG5cbiAgICAgICAgaWYgKCEkKHRoaXMudGh1bWIpLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICAgIHRoaXMuX3Nob3dSYW5nZUJ1YmJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUudHlwZSAhPT0gJ2lucHV0Jykge1xuICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gdGhpcy5fY2FsY1JhbmdlT2Zmc2V0KCk7XG4gICAgICAgICAgJCh0aGlzLnRodW1iKS5hZGRDbGFzcygnYWN0aXZlJykuY3NzKCdsZWZ0Jywgb2Zmc2V0TGVmdCArICdweCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIFJhbmdlIElucHV0LCBNb3VzZW1vdmUgYW5kIFRvdWNobW92ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZVJhbmdlSW5wdXRNb3VzZW1vdmVUb3VjaG1vdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlUmFuZ2VJbnB1dE1vdXNlbW92ZVRvdWNobW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlZG93bikge1xuICAgICAgICAgIGlmICghJCh0aGlzLnRodW1iKS5oYXNDbGFzcygnYWN0aXZlJykpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dSYW5nZUJ1YmJsZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gdGhpcy5fY2FsY1JhbmdlT2Zmc2V0KCk7XG4gICAgICAgICAgJCh0aGlzLnRodW1iKS5hZGRDbGFzcygnYWN0aXZlJykuY3NzKCdsZWZ0Jywgb2Zmc2V0TGVmdCArICdweCcpO1xuICAgICAgICAgICQodGhpcy52YWx1ZSkuaHRtbCh0aGlzLiRlbC52YWwoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgUmFuZ2UgTW91c2V1cCBhbmQgVG91Y2hlbmRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVSYW5nZU1vdXNldXBUb3VjaGVuZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVSYW5nZU1vdXNldXBUb3VjaGVuZCgpIHtcbiAgICAgICAgdGhpcy5fbW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgUmFuZ2UgQmx1ciwgTW91c2VvdXQgYW5kIFRvdWNobGVhdmVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVSYW5nZUJsdXJNb3VzZW91dFRvdWNobGVhdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlUmFuZ2VCbHVyTW91c2VvdXRUb3VjaGxlYXZlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21vdXNlZG93bikge1xuICAgICAgICAgIHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlSW50KHRoaXMuJGVsLmNzcygncGFkZGluZy1sZWZ0JykpO1xuICAgICAgICAgIHZhciBtYXJnaW5MZWZ0ID0gNyArIHBhZGRpbmdMZWZ0ICsgJ3B4JztcblxuICAgICAgICAgIGlmICgkKHRoaXMudGh1bWIpLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgYW5pbS5yZW1vdmUodGhpcy50aHVtYik7XG4gICAgICAgICAgICBhbmltKHtcbiAgICAgICAgICAgICAgdGFyZ2V0czogdGhpcy50aHVtYixcbiAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgdG9wOiAxMCxcbiAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMTAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgJCh0aGlzLnRodW1iKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBkcm9wZG93blxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwVGh1bWJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBUaHVtYigpIHtcbiAgICAgICAgdGhpcy50aHVtYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgJCh0aGlzLnRodW1iKS5hZGRDbGFzcygndGh1bWInKTtcbiAgICAgICAgJCh0aGlzLnZhbHVlKS5hZGRDbGFzcygndmFsdWUnKTtcbiAgICAgICAgJCh0aGlzLnRodW1iKS5hcHBlbmQodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuJGVsLmFmdGVyKHRoaXMudGh1bWIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBkcm9wZG93blxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZVRodW1iXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZVRodW1iKCkge1xuICAgICAgICAkKHRoaXMudGh1bWIpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1vcnBoIHRodW1iIGludG8gYnViYmxlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2hvd1JhbmdlQnViYmxlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dSYW5nZUJ1YmJsZSgpIHtcbiAgICAgICAgdmFyIHBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQoJCh0aGlzLnRodW1iKS5wYXJlbnQoKS5jc3MoJ3BhZGRpbmctbGVmdCcpKTtcbiAgICAgICAgdmFyIG1hcmdpbkxlZnQgPSAtNyArIHBhZGRpbmdMZWZ0ICsgJ3B4JzsgLy8gVE9ETzogZml4IG1hZ2ljIG51bWJlcj9cbiAgICAgICAgYW5pbS5yZW1vdmUodGhpcy50aHVtYik7XG4gICAgICAgIGFuaW0oe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMudGh1bWIsXG4gICAgICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgICAgICB3aWR0aDogMzAsXG4gICAgICAgICAgdG9wOiAtMzAsXG4gICAgICAgICAgbWFyZ2luTGVmdDogbWFyZ2luTGVmdCxcbiAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWludCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlIHRoZSBvZmZzZXQgb2YgdGhlIHRodW1iXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICBvZmZzZXQgaW4gcGl4ZWxzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY2FsY1JhbmdlT2Zmc2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGNSYW5nZU9mZnNldCgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy4kZWwud2lkdGgoKSAtIDE1O1xuICAgICAgICB2YXIgbWF4ID0gcGFyc2VGbG9hdCh0aGlzLiRlbC5hdHRyKCdtYXgnKSkgfHwgMTAwOyAvLyBSYW5nZSBkZWZhdWx0IG1heFxuICAgICAgICB2YXIgbWluID0gcGFyc2VGbG9hdCh0aGlzLiRlbC5hdHRyKCdtaW4nKSkgfHwgMDsgLy8gUmFuZ2UgZGVmYXVsdCBtaW5cbiAgICAgICAgdmFyIHBlcmNlbnQgPSAocGFyc2VGbG9hdCh0aGlzLiRlbC52YWwoKSkgLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gICAgICAgIHJldHVybiBwZXJjZW50ICogd2lkdGg7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KFJhbmdlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmFuZ2UpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLCBlbHMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBJbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5zdGFuY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShlbCkge1xuICAgICAgICB2YXIgZG9tRWxlbSA9ICEhZWwuanF1ZXJ5ID8gZWxbMF0gOiBlbDtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW0uTV9SYW5nZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSYW5nZTtcbiAgfShDb21wb25lbnQpO1xuXG4gIE0uUmFuZ2UgPSBSYW5nZTtcblxuICBpZiAoTS5qUXVlcnlMb2FkZWQpIHtcbiAgICBNLmluaXRpYWxpemVKcXVlcnlXcmFwcGVyKFJhbmdlLCAncmFuZ2UnLCAnTV9SYW5nZScpO1xuICB9XG5cbiAgUmFuZ2UuaW5pdCgkKCdpbnB1dFt0eXBlPXJhbmdlXScpKTtcbn0pKGNhc2gsIE0uYW5pbWUpO1xuXG59Ly9lbmQgaWYgd2luZG93LmFuaW1lIl0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzR0E7QUE2R0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBN0NBO0FBQ0E7QUFnREE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUVBO0FBQ0E7QUFpRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFvQkE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUNBO0FBQ0E7QUE2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBNUZBO0FBZ0dBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBbkJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQXhIQTtBQTRIQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0EsV0FLQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQTNCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBckVBO0FBdUVBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU9BO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBckZBO0FBdUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBcUJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFoQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBOUJBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF6QkE7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF6QkE7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBM0RBO0FBNkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdERBO0FBd0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBbERBO0FBb0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFoQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQTFCQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF6QkE7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBekVBO0FBMkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQTNEQTtBQTZEQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBYUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzRUE7QUE4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQVhBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQ0E7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUEzQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBL0VBO0FBaUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQXJDQTtBQXVDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFqRUE7QUFtRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBOURBO0FBZ0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaENBO0FBa0NBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF6REE7QUEyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzQkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBeEJBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL0JBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFUQTtBQVdBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5DQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQWpDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBNEJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBNEJBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdEJBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhGQTtBQWtGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXhDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4R0E7QUEwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUJBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUE3QkE7QUErQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF0QkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUExQkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/elements_v3/common/materialize-1-dev/dist/js/materialize.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/libraries/opt_date_time_picker/dist/opt_date_time_picker_lib.css":
/*!************************************************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/libraries/opt_date_time_picker/dist/opt_date_time_picker_lib.css ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvbGlicmFyaWVzL29wdF9kYXRlX3RpbWVfcGlja2VyL2Rpc3Qvb3B0X2RhdGVfdGltZV9waWNrZXJfbGliLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3d3dy9qcy0zLjIuMi9vbnRyYXBvcnQvb3B0X2Fzc2V0cy9saWJyYXJpZXMvb3B0X2RhdGVfdGltZV9waWNrZXIvZGlzdC9vcHRfZGF0ZV90aW1lX3BpY2tlcl9saWIuY3NzPzk1OGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/libraries/opt_date_time_picker/dist/opt_date_time_picker_lib.css\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/libraries/opt_date_time_picker/dist/opt_date_time_picker_lib.js":
/*!***********************************************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/libraries/opt_date_time_picker/dist/opt_date_time_picker_lib.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function (e, t) {\n   true ? module.exports = t() : undefined;\n}(window, function () {\n  return function (e) {\n    var t = {};\n\n    function i(a) {\n      if (t[a]) return t[a].exports;\n      var n = t[a] = {\n        i: a,\n        l: !1,\n        exports: {}\n      };\n      return e[a].call(n.exports, n, n.exports, i), n.l = !0, n.exports;\n    }\n\n    return i.m = e, i.c = t, i.d = function (e, t, a) {\n      i.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: a\n      });\n    }, i.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, i.t = function (e, t) {\n      if (1 & t && (e = i(e)), 8 & t) return e;\n      if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n      var a = Object.create(null);\n      if (i.r(a), Object.defineProperty(a, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var n in e) i.d(a, n, function (t) {\n        return e[t];\n      }.bind(null, n));\n      return a;\n    }, i.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return i.d(t, \"a\", t), t;\n    }, i.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, i.p = \"/js-3.2.2/ontraport/\", i(i.s = 0);\n  }([function (e, t, i) {\n    i(1), e.exports = i(3).default;\n  }, function (e, t, i) {},, function (e, t, i) {\n    \"use strict\";\n\n    function a(e) {\n      return function (e) {\n        if (Array.isArray(e)) return n(e);\n      }(e) || function (e) {\n        if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);\n      }(e) || function (e, t) {\n        if (!e) return;\n        if (\"string\" == typeof e) return n(e, t);\n        var i = Object.prototype.toString.call(e).slice(8, -1);\n        \"Object\" === i && e.constructor && (i = e.constructor.name);\n        if (\"Map\" === i || \"Set\" === i) return Array.from(e);\n        if (\"Arguments\" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return n(e, t);\n      }(e) || function () {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n\n    function n(e, t) {\n      (null == t || t > e.length) && (t = e.length);\n\n      for (var i = 0, a = new Array(t); i < t; i++) a[i] = e[i];\n\n      return a;\n    }\n\n    function o(e, t) {\n      for (var i = 0; i < t.length; i++) {\n        var a = t[i];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n\n    i.r(t);\n\n    var r = function () {\n      function e(t, i) {\n        if (function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, e), this.inputEl = t, this.options = i || {\n          twelveHour: !0\n        }, i.isFormDate) {\n          var n = document.body;\n          n && !n.style.minHeight && (n.style.minHeight = \"450px\");\n        }\n\n        if (this.yearRange = 20, this.options.minimumYear = i.minimumYear || 1900, i.yearRange && (Array.isArray(i.yearRange) ? (this.yearRange = i.yearRange[1] - i.yearRange[0], this.options.minimumYear = i.yearRange[0], this.options.maximumYear = i.yearRange[1]) : this.yearRange = i.yearRange), this.timeZoneList = this.options.timeZoneList || window.op && window.op.timeZoneList, this._initializeInternalValues(), this.element = this._buildAndAppendPickerMarkup(), this.options.extraClasses) {\n          var o,\n              r = this.options.extraClasses.split(\" \");\n          (o = this.element.classList).add.apply(o, a(r));\n        }\n\n        if (this.guid = \"opt-dt-\" + this.generateGuid(), this.element.classList.add(this.guid), this.options.displayPickerInline ? this.element.classList.add(\"opt-date-time-picker--inline\") : this.positionPicker(), this.options.showTodayButton && this.element.classList.add(\"opt-date-time-picker--show-today\"), this.options.isDateOnly) this.element.classList.add(\"opt-date-time-picker--date-only\");else {\n          var c = this.element.querySelector('.opt-date-time-picker__picker-menu--time-zone .opt-date-time-picker__picker-menu-item[data-val=\"'.concat(this.getValProperty(\"time-zone\"), '\"]'));\n          c && c.classList.add(\"opt-date-time-picker__menu-item--active\");\n        }\n        this.options.twelveHour || this.element.classList.add(\"opt-date-time-picker--24-hour\"), \"china-date\" === this.options.dateFormat && this.centerSelectedDropdownMenuItem(\"year\"), this.datePicker = this._initDatePicker(), this.options.isDateOnly || (this.timePicker = this._initTimePicker(), Array.prototype.slice.call(this.element.querySelectorAll(\".timepicker-tick\")).forEach(function (e) {\n          var t = e.innerText;\n          1 === t.length && (t = \"0\" + t), e.setAttribute(\"data-time-value\", t);\n        }), this._setTimeActiveStates()), this.datePicker.open(), this.options.isDateOnly || this.timePicker.open(), this._bindPickerEvents();\n      }\n\n      var t, i, n;\n      return t = e, n = [{\n        key: \"convertTimeStampAndTimeZoneToDateTimeString\",\n        value: function (t, i, a, n) {\n          var o = new Date(t),\n              r = e.getDateObjectProperty(o, \"month\", !0),\n              c = e.getDateObjectProperty(o, \"day\", !0),\n              s = e.getDateObjectProperty(o, \"year\", !0),\n              l = \"\";\n\n          if (a && \"china-date\" === a.dateFormat ? l += \"\".concat(s, \"/\").concat(r, \"/\").concat(c, \" \") : a && \"euro-date\" === a.dateFormat ? l += \"\".concat(c, \"/\").concat(r, \"/\").concat(s, \" \") : l += \"\".concat(r, \"/\").concat(c, \"/\").concat(s, \" \"), !n) {\n            var d = e.getDateObjectProperty(o, \"hour\", !0, a && a.twelveHour),\n                p = e.getDateObjectProperty(o, \"minute\", !0);\n            l += \"\".concat(d, \":\").concat(p, \" \"), a && a.twelveHour && (l += e.getDateObjectProperty(o, \"time-period\", !0) + \" \"), l += i;\n          }\n\n          return l;\n        }\n      }, {\n        key: \"getDateObjectProperty\",\n        value: function (e, t, i, a) {\n          var n;\n\n          switch (t) {\n            case \"month\":\n              n = e.getMonth(), i && 1 === (n = \"\" + ++n).length && (n = \"0\" + n);\n              break;\n\n            case \"day\":\n              n = e.getDate(), i && 1 === (n = \"\" + n).length && (n = \"0\" + n);\n              break;\n\n            case \"year\":\n              n = e.getFullYear();\n              break;\n\n            case \"hour\":\n              n = e.getHours(), i && (a && (n > 12 ? n -= 12 : 0 === n && (n = 12)), 1 === (n = \"\" + n).length && (n = \"0\" + n));\n              break;\n\n            case \"minute\":\n              n = e.getMinutes(), i && 1 === (n = \"\" + n).length && (n = \"0\" + n);\n              break;\n\n            case \"time-period\":\n              n = e.getHours() < 12 ? \"am\" : \"pm\", i && (n = n.toUpperCase());\n          }\n\n          return n;\n        }\n      }, {\n        key: \"dateTimeFieldClickHandler\",\n        value: function (t) {\n          var i = t.currentTarget,\n              a = i.querySelector(\".opt-date-time-field\");\n\n          if (i.classList.contains(\"opt-date-time__picker--open\")) {\n            i.classList.remove(\"opt-date-time__picker--open\");\n            var n = i.querySelector(\".opt-date-time-field__hidden-field\"),\n                o = !1;\n            t.target.classList.contains(\"opt-date-time__icon--x\") && (a.value = \"\", a.setAttribute(\"data-timeZone\", \"\"), n.value = \"\", o = !0);\n            var r = a.dateTimePicker;\n\n            if (r) {\n              if (!o) {\n                var c = r.getSaveData();\n                a.value = c.dateTimeString, a.setAttribute(\"data-timeZone\", c.timeZone), n.value = c.timestamp / 1e3;\n              }\n\n              r.destroy(), a.dateTimePicker = null;\n            }\n\n            \"default\" === i.getAttribute(\"opt-input-style\") && \"\" === a.value && i.querySelector(\".opt-input__label\").classList.remove(\"active\");\n          } else {\n            var s = e.JSONParse(a.dataset.datepickeroptions),\n                l = i.querySelector(\".opt-date-time-field__hidden-field\").value,\n                d = {\n              dateFormat: \"usa-date\",\n              twelveHour: !0,\n              initialTimeZone: a.getAttribute(\"data-timeZone\") || Intl.DateTimeFormat().resolvedOptions().timeZone,\n              timeZoneList: window.op && window.op.timeZoneList,\n              isDateOnly: s && s.isDateOnly || !1,\n              isFormDate: s && s.isFormDate || !1\n            };\n            window.op && op.dateFormat && op.dateFormat.date_format && (d.dateFormat = op.dateFormat.date_format), window.op && op.dateFormat && op.dateFormat.time_format && \"24-hour\" === op.dateFormat.time_format && (d.twelveHour = !1), l && (d.initialValue = 1e3 * +l), a.dateTimePicker = new e(a, d), i.classList.add(\"opt-date-time__picker--open\"), \"default\" === i.getAttribute(\"opt-input-style\") && i.querySelector(\".opt-input__label\").classList.add(\"active\");\n          }\n        }\n      }, {\n        key: \"JSONParse\",\n        value: function (e) {\n          if (!(\"string\" == typeof e || e instanceof String)) return e;\n\n          try {\n            return JSON.parse(e);\n          } catch (t) {\n            return e;\n          }\n        }\n      }, {\n        key: \"dateTimeFieldSaveHandler\",\n        value: function (e) {\n          var t = e.detail || e.originalEvent.detail,\n              i = e.currentTarget,\n              a = i.querySelector(\".opt-date-time-field\");\n\n          if (i.classList.remove(\"opt-date-time__picker--open\"), /iPad|iPhone|iPod|Android/.test(window.navigator.userAgent) && a.setAttribute(\"type\", \"text\"), a.value = t.dateTimeString, t.timeZone && a.setAttribute(\"data-timeZone\", t.timeZone), t.timestamp) {\n            var n = e.target.dataset.datepickeroptions;\n            if (\"string\" == typeof n || n instanceof String) try {\n              n = JSON.parse(n);\n            } catch (e) {}\n\n            if (n && n.isDateOnly) {\n              var o = new Date(t.timestamp);\n              i.querySelector(\".opt-date-time-field__hidden-field\").value = o.setHours(12, 0, 0, 0) / 1e3;\n            } else i.querySelector(\".opt-date-time-field__hidden-field\").value = t.timestamp / 1e3;\n          }\n\n          a.dateTimePicker = null;\n        }\n      }, {\n        key: \"dateTimeFieldCancelHandler\",\n        value: function (e) {\n          var t = e.currentTarget,\n              i = t.querySelector(\".opt-date-time-field\");\n          t.classList.remove(\"opt-date-time__picker--open\"), i.dateTimePicker = null, \"default\" === t.getAttribute(\"opt-input-style\") && \"\" === i.value && t.querySelector(\".opt-input__label\").classList.remove(\"active\");\n        }\n      }], (i = [{\n        key: \"getDialog\",\n        value: function () {\n          return this.inputEl.closest(\"op-dialog\") || !1;\n        }\n      }, {\n        key: \"positionPicker\",\n        value: function () {\n          var e,\n              t = this.inputEl.getBoundingClientRect(),\n              i = this.element.getBoundingClientRect(),\n              a = this.getDialog();\n          e = a ? a.offsetHeight > document.documentElement.clientHeight ? a.offsetHeight : document.documentElement.clientHeight : document.body.offsetHeight > document.documentElement.clientHeight ? document.body.offsetHeight : document.documentElement.clientHeight;\n          var n = a ? 0 - a.getBoundingClientRect().top : window.scrollY,\n              o = t.top + n + t.height;\n          o + i.height > e && (o = t.top + n - i.height) < 0 && (o = 0);\n          var r = a ? 0 - a.getBoundingClientRect().left : window.scrollX,\n              c = t.left + r;\n          c + i.width > document.body.offsetWidth && (c = t.left + r + t.width - i.width) < 0 && (c = 0), this.element.style.top = o + \"px\", this.element.style.left = c + \"px\";\n        }\n      }, {\n        key: \"save\",\n        value: function () {\n          var t = this.getSaveData();\n          this.options.updateInput && (this.inputEl.value = t.dateTimeString), this.inputEl.dispatchEvent(new CustomEvent(e.SaveEventDispatch, {\n            detail: t,\n            bubbles: !0\n          })), this.destroy();\n        }\n      }, {\n        key: \"getSaveData\",\n        value: function () {\n          var e = this._val.getTime();\n\n          if (!this.options.isDateOnly) {\n            var t = this.getTimeZoneOffsetValue(Intl.DateTimeFormat().resolvedOptions().timeZone),\n                i = this.getTimeZoneOffsetValue(this._timeZone);\n            if (t !== i) e += 60 * (t - i) * 60 * 1e3;\n          }\n\n          var a = {\n            dateFormat: this.options.dateFormat,\n            twelveHour: this.options.twelveHour\n          },\n              n = \"\";\n          this.options.isDateOnly || (n = this.getValProperty(\"time-zone\", !0));\n          var o = {\n            dateTimeString: this.constructor.convertTimeStampAndTimeZoneToDateTimeString(this._val.getTime(), n, a, this.options.isDateOnly),\n            timestamp: e\n          };\n          return this.options.isDateOnly || (o.timeZone = this.getValProperty(\"time-zone\"), o.offset = this._val.getTimezoneOffset()), o;\n        }\n      }, {\n        key: \"destroy\",\n        value: function () {\n          this.element && (this.element.querySelector(\".opt-date-time-picker__control-bar\").removeEventListener(\"click\", this._boundControlBarEvent), this.element.removeEventListener(\"dateTimePickerSelect\", this._boundDateTimePickerEvent), this.element.querySelector(\".opt-date-time-picker__picker-menu--year\").removeEventListener(\"click\", this._boundYearClickEvent), this.element.querySelector(\".opt-date-time-picker__picker-menu--year\").removeEventListener(\"scroll\", this._boundYearScrollEvent), this.options.showTodayButton && this.element.querySelector(\".opt-date-time-picker__button--today\").removeEventListener(\"click\", this._boundTodayClickEvent), this.options.isDateOnly || (this.element.querySelector(\".opt-date-time-picker__picker-menu--time-zone\").removeEventListener(\"click\", this._boundTimeZoneEvent), this.element.querySelector(\".opt-date-time-picker__search-icon\").removeEventListener(\"click\", this._boundTimeZoneSearchClickEvent), this.element.querySelector(\".opt-date-time-picker__search-bar\").removeEventListener(\"input\", this._boundTimeZoneSearchInputEvent)), this.element.querySelector(\".opt-date-time-picker__button--save\").removeEventListener(\"click\", this._boundSaveEvent), this.element.querySelector(\".opt-date-time-picker__button--cancel\").removeEventListener(\"click\", this._boundCancelEvent), this.element.remove()), this.datePicker && this.datePicker.destroy(), this.timePicker && this.timePicker.destroy(), this.element = null, this.inputEl = null, this._val = null, this.options = null, this.timeZoneList = null, this.datePicker = null, this.timePicker = null, this._boundControlBarEvent = null, this._boundDateTimePickerEvent = null, this._boundYearClickEvent = null, this._boundTodayClickEvent = null, this._boundTimeZoneEvent = null, this._boundTimeZoneSearchClickEvent = null, this._boundTimeZoneSearchInputEvent = null, this._boundSaveEvent = null, this._boundCancelEvent = null, this._currentMonthYear = null;\n        }\n      }, {\n        key: \"updateControlBarDisplay\",\n        value: function () {\n          for (var e = this.element.querySelector(\".opt-date-time-picker__control-bar\").querySelectorAll(\".opt-date-time-picker__control\"), t = 0, i = e.length; t < i; t++) {\n            var a = e[t],\n                n = a.getAttribute(\"data-control-type\");\n\n            if (\"month-day\" === n) {\n              var o = a.classList.contains(\"opt-date-time-picker__control--day\") ? \"day\" : \"month\";\n              a.innerText = this.getValProperty(o, !0);\n            } else \"time-period\" === n ? a.setAttribute(\"data-current-time-period\", this.getValProperty(n)) : a.innerText = this.getValProperty(n, !0);\n          }\n        }\n      }, {\n        key: \"changeControl\",\n        value: function (e) {\n          if (\"time-zone\" === e || this.options.isDateOnly || this._clearTimeZoneSearch(), \"time-period\" === e) {\n            var t = this.element.querySelector('[data-control-type=\"time-period\"]'),\n                i = \"am\" === t.getAttribute(\"data-current-time-period\") ? \"pm\" : \"am\";\n            t.setAttribute(\"data-current-time-period\", i);\n\n            var a = this._val.getHours();\n\n            \"am\" === i ? a -= 12 : a += 12, this._val.setHours(a);\n          } else \"hour\" === e ? (this.timePicker.showView(\"hours\"), this.timePicker.resetClock()) : \"minute\" === e && (this.timePicker.showView(\"minutes\"), this.timePicker.resetClock()), this.element.setAttribute(\"data-active-control\", e), \"year\" !== e && \"time-zone\" !== e || this.centerSelectedDropdownMenuItem(e);\n        }\n      }, {\n        key: \"addYearMenuItems\",\n        value: function (e) {\n          var t,\n              i = this.element.querySelector(\".opt-date-time-picker__picker-menu--year\"),\n              a = \"\";\n          if ((t = e ? +i.firstElementChild.getAttribute(\"data-val\") : +i.lastElementChild.getAttribute(\"data-val\")) - this.yearRange < this.options.minimumYear) return {\n            minYear: !0\n          };\n          if (this.options.maximumYear && t + this.yearRange >= this.options.maximumYear) return {\n            maxYear: !0\n          };\n\n          for (var n = 1; n <= this.yearRange; n++) {\n            var o = void 0;\n            e ? a = '<div class=\"opt-date-time-picker__picker-menu-item\" data-val=\"'.concat(o = t + n, '\">').concat(o, \"</div>\\n                                    \").concat(a) : a += '<div class=\"opt-date-time-picker__picker-menu-item\" data-val=\"'.concat(o = t - n, '\">').concat(o, \"</div>\");\n          }\n\n          e ? i.insertAdjacentHTML(\"afterbegin\", a) : i.insertAdjacentHTML(\"beforeend\", a);\n        }\n      }, {\n        key: \"getValProperty\",\n        value: function (e, t) {\n          var i;\n\n          switch (e) {\n            case \"month\":\n            case \"day\":\n            case \"year\":\n            case \"hour\":\n            case \"minute\":\n            case \"time-period\":\n              i = this.constructor.getDateObjectProperty(this._val, e, t, this.options.twelveHour);\n              break;\n\n            case \"time-zone\":\n              i = this._timeZone, t && (i = this.getTimeZoneLabel(i, !0));\n          }\n\n          return i;\n        }\n      }, {\n        key: \"getTimeZoneLabel\",\n        value: function (e, t) {\n          for (var i = \"\", a = 0, n = this.timeZoneList.length; a < n; a++) if (this.timeZoneList[a].value === e) {\n            i = this.timeZoneList[a].label;\n            break;\n          }\n\n          if (i && t) {\n            var o = i.indexOf(\")\");\n            -1 !== o && (i = i.substring(o + 2));\n          }\n\n          return i;\n        }\n      }, {\n        key: \"getTimeZoneOffsetValue\",\n        value: function (e) {\n          for (var t = \"\", i = 0, a = this.timeZoneList.length; i < a; i++) if (this.timeZoneList[i].value === e) {\n            t = this.timeZoneList[i].offset;\n            break;\n          }\n\n          return t;\n        }\n      }, {\n        key: \"generateGuid\",\n        value: function () {\n          var e = function () {\n            return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);\n          };\n\n          return e() + e() + \"-\" + e() + \"-\" + e() + \"-\" + e() + \"-\" + e() + e() + e();\n        }\n      }, {\n        key: \"centerSelectedDropdownMenuItem\",\n        value: function (e) {\n          var t = this.element.querySelector(\".opt-date-time-picker__picker-menu--\".concat(e)),\n              i = t.querySelector(\".opt-date-time-picker__menu-item--active\");\n\n          if (i) {\n            var a = Array.prototype.slice.call(t.querySelectorAll(\".opt-date-time-picker__picker-menu-item\")).indexOf(i) * i.scrollHeight - (t.offsetHeight / 2 - i.scrollHeight / 2),\n                n = t.scrollHeight - t.offsetHeight;\n            t.scrollTop = a < 0 ? 0 : a > n ? n : a;\n          }\n        }\n      }, {\n        key: \"setCalendarDots\",\n        value: function (e, t) {\n          var i = this;\n\n          if (e) {\n            if (!this._currentMonthYear || this._currentMonthYear.month !== t.month || this._currentMonthYear.year !== t.year) return;\n            this._calendarDotDays = e;\n          }\n\n          this._calendarDotDays.forEach(function (e) {\n            var t = i.element.querySelector(\".opt-date-time-picker__picker--date\").querySelector('[data-day=\"'.concat(e, '\"]'));\n            t && t.classList.add(\"opt-date-time-picker__day--dot\");\n          });\n        }\n      }, {\n        key: \"updateCalendarDate\",\n        value: function (e) {\n          this.options.isDateOnly && e instanceof Date && (this._val.setFullYear(e.getFullYear()), this._val.setMonth(e.getMonth()), this._val.setDate(e.getDate()), this.updateControlBarDisplay(), this._silenceSelectionEvents = !0, this.datePicker.setDate(e), this._silenceSelectionEvents = !1);\n        }\n      }, {\n        key: \"_buildAndAppendPickerMarkup\",\n        value: function () {\n          var e = document.createElement(\"template\"),\n              t = this._generateDateControlMarkup(),\n              i = this._generateYearMarkup(),\n              a = \"china-date\" === this.options.dateFormat ? \"year\" : \"month-day\",\n              n = \"\",\n              o = \"\";\n\n          if (!this.options.isDateOnly) {\n            n = '<div class=\"opt-date-time-picker__control-section opt-date-time-picker__control-section--time\">\\n                <div class=\"opt-date-time-picker__control-group\" data-control-type=\"hour\">\\n                    <div class=\"opt-date-time-picker__control\" data-control-type=\"hour\">'.concat(this.getValProperty(\"hour\", !0), '</div>\\n                    <div class=\"opt-date-time-picker__control-divider\" data-control-type=\"hour\">:</div>\\n                </div>\\n                <div class=\"opt-date-time-picker__control\" data-control-type=\"minute\">').concat(this.getValProperty(\"minute\", !0), '</div>\\n                <div class=\"opt-date-time-picker__control\" data-control-type=\"time-period\" data-current-time-period=\"').concat(this.getValProperty(\"time-period\"), '\">\\n                    <span data-time-period-val=\"am\">AM</span><span data-time-period-val=\"pm\">PM</span>\\n                </div>\\n            </div>\\n            <div class=\"opt-date-time-picker__control-section opt-date-time-picker__control-section--time-zone\">\\n                <div class=\"opt-date-time-picker__control\" data-control-type=\"time-zone\">').concat(this.getValProperty(\"time-zone\", !0), \"</div>\\n            </div>\");\n\n            var r = this._generateTimeZoneMarkup();\n\n            o = '<div class=\"opt-date-time-picker__picker opt-date-time-picker__picker--time-zone\" data-picker-menu-type=\"time-zone\">\\n                <div class=\"opt-date-time-picker__picker-header-section\">\\n                    <div class=\"opt-date-time-picker__title\">TIME ZONE</div>\\n                    <div class=\"opt-date-time-picker__search\">\\n                        <div class=\"opt-date-time-picker__search-bar-animation-container\">\\n                            <div class=\"opt-date-time-picker__search-bar-container\">\\n                                <input type=\"text\" placeholder=\"Search timezone...\" class=\"browser-default opt-date-time-picker__search-bar\"/>\\n                                <img src=\"https://app.ontraport.com/images/close_x.png\" class=\"opt-date-time-picker__search-clear\"/>\\n                            </div>\\n                        </div>\\n                        <img src=\"https://app.ontraport.com/images/search_black.png\" class=\"opt-date-time-picker__search-icon opt-date-time-picker__search-icon--open\"/>\\n                        <img src=\"https://app.ontraport.com/images/search_grey.png\" class=\"opt-date-time-picker__search-icon opt-date-time-picker__search-icon--closed\"/>\\n                    </div>\\n                </div>\\n                <div class=\"opt-date-time-picker__picker-menu opt-date-time-picker__picker-menu--time-zone\">\\n                    '.concat(r, \"\\n                </div>\\n            </div>\");\n          }\n\n          var c = \"\";\n          this.options.showTodayButton && (c = '<button class=\"opt-date-time-picker__button--today\">Today</button>'), e.innerHTML = '<div class=\"opt-date-time-picker\" data-active-control=\"'.concat(a, '\">\\n            <div class=\"opt-date-time-picker__control-bar\">\\n                <div class=\"opt-date-time-picker__control-section opt-date-time-picker__control-section--date\">\\n                    ').concat(t, \"\\n                </div>\\n                \").concat(n, \"\\n                \").concat(c, '\\n            </div>\\n            <div class=\"opt-date-time-picker__picker-section\">\\n                <div class=\"opt-date-time-picker__materialize-section\">\\n                    <div class=\"opt-date-time-picker__title opt-date-time-picker__title--hour\">HOUR</div>\\n                    <div class=\"opt-date-time-picker__title opt-date-time-picker__title--minute\">MINUTE</div>\\n                    <div class=\"opt-date-time-picker__picker opt-date-time-picker__picker--date opt-materialize-namespace\"></div>\\n                    <div class=\"opt-date-time-picker__picker opt-date-time-picker__picker--time\"></div>\\n                    \\x3c!-- These inputs are hidden don\\'t actually do anything, they are just used to initialize the pickers --\\x3e\\n                    <input class=\"opt-date-time-picker__input--date\">\\n                    <input class=\"opt-date-time-picker__input--time\">\\n                </div>\\n                <div class=\"opt-date-time-picker__picker opt-date-time-picker__picker--year\" data-picker-menu-type=\"year\">\\n                    <div class=\"opt-date-time-picker__title\">YEAR</div>\\n                    <div class=\"opt-date-time-picker__picker-menu opt-date-time-picker__picker-menu--year\">\\n                        ').concat(i, \"\\n                    </div>\\n                </div>\\n                \").concat(o, '\\n            </div>\\n            <div class=\"opt-date-time-picker__buttons\">\\n                <div class=\"opt-date-time-picker__button opt-date-time-picker__button--cancel\">CANCEL</div>\\n                <div class=\"opt-date-time-picker__button opt-date-time-picker__button--save\">SAVE</div>\\n            </div>\\n        </div>');\n          var s = e.content.cloneNode(!0),\n              l = s.children[0];\n          if (this.options.displayPickerInline) this.inputEl.append(s);else {\n            var d = this.getDialog();\n            d ? d.querySelector(\".op-dialog__content\").append(s) : document.body.append(s);\n          }\n          return l;\n        }\n      }, {\n        key: \"_generateDateControlMarkup\",\n        value: function () {\n          var e = '<div class=\"opt-date-time-picker__control opt-date-time-picker__control--month\" data-control-type=\"month-day\">'.concat(this.getValProperty(\"month\", !0), \"</div>\"),\n              t = '<div class=\"opt-date-time-picker__control-divider\" data-control-type=\"month-day\">/</div>',\n              i = '<div class=\"opt-date-time-picker__control opt-date-time-picker__control--day\" data-control-type=\"month-day\">'.concat(this.getValProperty(\"day\", !0), \"</div>\"),\n              a = '<div class=\"opt-date-time-picker__control-divider\" data-control-type=\"year\">/</div>',\n              n = '<div class=\"opt-date-time-picker__control\" data-control-type=\"year\">'.concat(this.getValProperty(\"year\"), \"</div>\");\n          return \"euro-date\" === this.options.dateFormat ? '<div class=\"opt-date-time-picker__control-group\" data-control-type=\"month-day\">\\n                                        '.concat(i).concat(t).concat(e, '\\n                                    </div>\\n                                    <div class=\"opt-date-time-picker__control-group\" data-control-type=\"year\">\\n                                        ').concat(a).concat(n, \"\\n                                    </div>\") : \"china-date\" === this.options.dateFormat ? '<div class=\"opt-date-time-picker__control-group\" data-control-type=\"year\">\\n                                        '.concat(n).concat(a, '\\n                                    </div>\\n                                    <div class=\"opt-date-time-picker__control-group\" data-control-type=\"month-day\">\\n                                        ').concat(e).concat(t).concat(i, \"\\n                                    </div>\\n                                    \") : '<div class=\"opt-date-time-picker__control-group\" data-control-type=\"month-day\">\\n                                        '.concat(e).concat(t).concat(i, '\\n                                    </div>\\n                                    <div class=\"opt-date-time-picker__control-group\" data-control-type=\"year\">\\n                                        ').concat(a).concat(n, \"\\n                                    </div>\");\n        }\n      }, {\n        key: \"_generateYearMarkup\",\n        value: function () {\n          for (var e = this.getValProperty(\"year\"), t = '<div class=\"opt-date-time-picker__picker-menu-item opt-date-time-picker__menu-item--active\" data-val=\"'.concat(e, '\">').concat(e, \"</div>\"), i = 1; i <= this.yearRange; i++) t = '<div class=\"opt-date-time-picker__picker-menu-item\" data-val=\"'.concat(e + i, '\">').concat(e + i, \"</div>\\n                                \").concat(t, '\\n                                <div class=\"opt-date-time-picker__picker-menu-item\" data-val=\"').concat(e - i, '\">').concat(e - i, \"</div>\");\n\n          return t;\n        }\n      }, {\n        key: \"_generateTimeZoneMarkup\",\n        value: function () {\n          for (var e = \"\", t = 0, i = this.timeZoneList.length; t < i; t++) {\n            var a = this.timeZoneList[t];\n            e += '<div class=\"opt-date-time-picker__picker-menu-item\" data-val=\"'.concat(a.value, '\">').concat(a.label, \"</div>\");\n          }\n\n          return e;\n        }\n      }, {\n        key: \"_initDatePicker\",\n        value: function () {\n          this.options.addCalendarDots && (this._currentMonthYear = {\n            month: this._val.getMonth(),\n            year: this._val.getFullYear()\n          });\n          var e = Object.assign({\n            format: \"mm/dd/yyyy\",\n            defaultDate: this._val,\n            setDefaultDate: !0,\n            container: this.element.querySelector(\".opt-date-time-picker__picker--date\"),\n            i18n: {\n              done: \"Save\",\n              weekdaysAbbrev: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]\n            },\n            onOpen: function () {\n              this.modal.open = function () {}, this.modal.close = function () {}, this.modal.$el.css(\"display\", \"block\");\n            },\n            onClose: function () {\n              this.modal.$el.css(\"display\", \"\");\n            },\n            onDraw: function () {\n              if (this.options.addCalendarDots && this.datePicker && this._currentMonthYear) {\n                var e = this.datePicker.calendars[0];\n                this._currentMonthYear && e.month === this._currentMonthYear.month && e.year === this._currentMonthYear.year ? this._calendarDotDays && this.setCalendarDots() : (this._currentMonthYear = Object.assign({}, e), this.element.dispatchEvent(new CustomEvent(\"dateTimeMonthChanged\", {\n                  detail: this._currentMonthYear,\n                  bubbles: !0\n                })));\n              }\n            }.bind(this),\n            onSelect: function (e) {\n              this._silenceSelectionEvents || this.element.dispatchEvent(new CustomEvent(\"dateTimePickerSelect\", {\n                detail: {\n                  selectType: \"date\",\n                  date: e\n                },\n                bubbles: !0\n              }));\n            }.bind(this)\n          }, this.options);\n          return M.Datepicker.init(this.element.querySelector(\".opt-date-time-picker__input--date\"), e);\n        }\n      }, {\n        key: \"_initTimePicker\",\n        value: function () {\n          var e = Object.assign({\n            i18n: {\n              cancel: \"Cancel\",\n              done: \"Save\"\n            },\n            container: \".\".concat(this.guid, \" .opt-date-time-picker__picker--time\"),\n            twelveHour: !0,\n            defaultTime: this.getValProperty(\"hour\", !0) + \":\" + this.getValProperty(\"minute\", !0),\n            duration: 2,\n            onSelect: function (e, t) {\n              var i = this.el.closest(\".opt-date-time-picker\");\n              i && \"hour\" === i.getAttribute(\"data-active-control\") && i.setAttribute(\"data-active-control\", \"minute\"), i.dispatchEvent(new CustomEvent(\"dateTimePickerSelect\", {\n                detail: {\n                  selectType: \"time\",\n                  hour: e,\n                  minute: t\n                },\n                bubbles: !0\n              }));\n            }\n          }, this.options),\n              t = M.Timepicker.init(this.element.querySelector(\".opt-date-time-picker__input--time\"), e);\n          return t.modal.open = function () {}, t.modal.close = function () {}, t.modal.$el.css(\"display\", \"block\"), t;\n        }\n      }, {\n        key: \"_initializeInternalValues\",\n        value: function () {\n          if (this.options.initialTimeZone ? this._timeZone = this.options.initialTimeZone : this._timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone, this.options.initialValue) {\n            if (!this.options.isDateOnly) {\n              var e = this.getTimeZoneOffsetValue(Intl.DateTimeFormat().resolvedOptions().timeZone),\n                  t = this.getTimeZoneOffsetValue(this._timeZone);\n\n              if (e !== t) {\n                var i = t - e;\n                this.options.initialValue = this.options.initialValue + 60 * i * 60 * 1e3;\n              }\n            }\n\n            this._val = new Date(this.options.initialValue);\n          } else this._val = new Date();\n\n          this._val.setSeconds(0), this._val.setMilliseconds(0);\n        }\n      }, {\n        key: \"_clearTimeZoneSearch\",\n        value: function () {\n          var e = this.element.querySelector(\".opt-date-time-picker__search\");\n          e.classList.contains(\"opt-date-time-picker__search--open\") && (this.element.querySelector(\".opt-date-time-picker__search-bar\").value = \"\", e.classList.remove(\"opt-date-time-picker__search--open\"), Array.prototype.slice.call(this.element.querySelectorAll(\".opt-date-time-picker__picker-menu--time-zone .opt-date-time-picker__picker-menu-item.opt-date-time-picker__picker-menu-item--hidden\")).forEach(function (e) {\n            e.classList.remove(\"opt-date-time-picker__picker-menu-item--hidden\");\n          }));\n        }\n      }, {\n        key: \"_setTimeActiveStates\",\n        value: function () {\n          Array.prototype.slice.call(this.element.querySelectorAll(\".timepicker-tick.opt-time--active\")).forEach(function (e) {\n            e.classList.remove(\"opt-time--active\");\n          });\n          var e = this.getValProperty(\"hour\", !0),\n              t = this.getValProperty(\"minute\", !0),\n              i = this.element.querySelector('.timepicker-hours .timepicker-tick[data-time-value=\"'.concat(e, '\"]')),\n              a = this.element.querySelector('.timepicker-minutes .timepicker-tick[data-time-value=\"'.concat(t, '\"]'));\n          i && i.classList.add(\"opt-time--active\"), a && a.classList.add(\"opt-time--active\");\n        }\n      }, {\n        key: \"_updateSelectedYear\",\n        value: function (e) {\n          var t = this.element.querySelector(\".opt-date-time-picker__picker-menu--year\"),\n              i = t.querySelector(\".opt-date-time-picker__menu-item--active\");\n          i && i.classList.remove(\"opt-date-time-picker__menu-item--active\");\n          var a = t.querySelector('[data-val=\"' + e + '\"]');\n          a && a.classList.add(\"opt-date-time-picker__menu-item--active\");\n        }\n      }, {\n        key: \"_bindPickerEvents\",\n        value: function () {\n          this._boundControlBarEvent = this._controlBarClickHandler.bind(this), this._boundDateTimePickerEvent = this._dateTimePickerSelectHandler.bind(this), this._boundYearClickEvent = this._yearMenuClickHandler.bind(this), this._boundYearScrollEvent = this._yearMenuScrollHandler.bind(this), this.options.showTodayButton && (this._boundTodayClickEvent = this._todayClickHandler.bind(this)), this.options.isDateOnly || (this._boundTimeZoneEvent = this._timeZoneMenuClickHandler.bind(this), this._boundTimeZoneSearchClickEvent = this._timeZoneSearchClickHandler.bind(this), this._boundTimeZoneSearchInputEvent = this._timeZoneSearchInputHandler.bind(this)), this._boundSaveEvent = this._saveClickHandler.bind(this), this._boundCancelEvent = this._cancelClickHandler.bind(this), this.element.querySelector(\".opt-date-time-picker__control-bar\").addEventListener(\"click\", this._boundControlBarEvent), this.element.addEventListener(\"dateTimePickerSelect\", this._boundDateTimePickerEvent), this.element.querySelector(\".opt-date-time-picker__picker-menu--year\").addEventListener(\"click\", this._boundYearClickEvent), this.element.querySelector(\".opt-date-time-picker__picker-menu--year\").addEventListener(\"scroll\", this._boundYearScrollEvent), this.options.showTodayButton && this.element.querySelector(\".opt-date-time-picker__button--today\").addEventListener(\"click\", this._boundTodayClickEvent), this.options.isDateOnly || (this.element.querySelector(\".opt-date-time-picker__picker-menu--time-zone\").addEventListener(\"click\", this._boundTimeZoneEvent), this.element.querySelector(\".opt-date-time-picker__search\").addEventListener(\"click\", this._boundTimeZoneSearchClickEvent), this.element.querySelector(\".opt-date-time-picker__search-bar\").addEventListener(\"input\", this._boundTimeZoneSearchInputEvent)), this.element.querySelector(\".opt-date-time-picker__button--save\").addEventListener(\"click\", this._boundSaveEvent), this.element.querySelector(\".opt-date-time-picker__button--cancel\").addEventListener(\"click\", this._boundCancelEvent);\n        }\n      }, {\n        key: \"_controlBarClickHandler\",\n        value: function (e) {\n          e.target.hasAttribute(\"data-control-type\") && this.changeControl(e.target.getAttribute(\"data-control-type\"));\n        }\n      }, {\n        key: \"_dateTimePickerSelectHandler\",\n        value: function (e) {\n          var t = e.detail;\n\n          if (\"date\" === t.selectType) {\n            var i = t.date.getFullYear();\n            this._val.setFullYear(i), this._val.setDate(1), this._val.setMonth(t.date.getMonth()), this._val.setDate(t.date.getDate()), this._updateSelectedYear(i), this.options.disableAutoControlChange || (\"china-date\" !== this.options.dateFormat || this.options.isDateOnly ? \"china-date\" !== this.options.dateFormat && this.changeControl(\"year\") : this.changeControl(\"hour\"));\n          } else if (\"time\" === t.selectType) {\n            if (this.options.twelveHour) {\n              var a = this.getValProperty(\"time-period\");\n              \"am\" === a && 12 === t.hour ? t.hour = 0 : \"pm\" === a && 12 !== t.hour && (t.hour += 12);\n            }\n\n            this._val.setHours(t.hour, t.minute, 0, 0), this._setTimeActiveStates();\n          }\n\n          this.updateControlBarDisplay(), this.options.isDateOnly && \"china-date\" === this.options.dateFormat && this.save();\n        }\n      }, {\n        key: \"_yearMenuClickHandler\",\n        value: function (e) {\n          if (e.target.classList.contains(\"opt-date-time-picker__picker-menu-item\")) {\n            var t = +e.target.getAttribute(\"data-val\");\n            this._val.setFullYear(t), this._silenceSelectionEvents = !0, this.datePicker.setDate(this._val), this._silenceSelectionEvents = !1, this._updateSelectedYear(t), this.updateControlBarDisplay(), this.options.disableAutoControlChange || (\"china-date\" === this.options.dateFormat ? this.changeControl(\"month-day\") : this.options.isDateOnly || this.changeControl(\"hour\")), this.element.dispatchEvent(new CustomEvent(\"dateTimePickerYearSelect\", {\n              detail: {\n                selectType: \"year\",\n                date: this._val\n              },\n              bubbles: !0\n            })), this.options.isDateOnly && \"china-date\" !== this.options.dateFormat && this.save();\n          }\n        }\n      }, {\n        key: \"_yearMenuScrollHandler\",\n        value: function (e) {\n          if (0 === e.target.scrollTop) {\n            var t = this.addYearMenuItems(!0);\n            if (t && t.maxYear) return;\n            var i = e.target.firstElementChild.scrollHeight;\n            e.target.scrollTop = i * this.yearRange;\n          } else e.target.scrollTop + e.target.offsetHeight > e.target.scrollHeight - 5 && this.addYearMenuItems();\n        }\n      }, {\n        key: \"_todayClickHandler\",\n        value: function (e) {\n          var t = new Date(),\n              i = t.getFullYear();\n          this._val.setDate(t.getDate()), this._val.setMonth(t.getMonth()), this._val.setFullYear(i), this._updateSelectedYear(i), this.datePicker.setDate(this._val);\n        }\n      }, {\n        key: \"_timeZoneMenuClickHandler\",\n        value: function (e) {\n          if (e.target.classList.contains(\"opt-date-time-picker__picker-menu-item\")) {\n            this._timeZone = e.target.getAttribute(\"data-val\");\n            var t = e.target.closest(\".opt-date-time-picker__picker-menu--time-zone\").querySelector(\".opt-date-time-picker__menu-item--active\");\n            t && t.classList.remove(\"opt-date-time-picker__menu-item--active\"), e.target.classList.add(\"opt-date-time-picker__menu-item--active\"), this.updateControlBarDisplay();\n          }\n        }\n      }, {\n        key: \"_timeZoneSearchClickHandler\",\n        value: function (e) {\n          e.target.classList.contains(\"opt-date-time-picker__search-icon--closed\") ? (e.currentTarget.classList.add(\"opt-date-time-picker__search--open\"), e.currentTarget.querySelector(\".opt-date-time-picker__search-bar\").focus()) : e.target.classList.contains(\"opt-date-time-picker__search-clear\") && (this._clearTimeZoneSearch(), this.centerSelectedDropdownMenuItem(\"time-zone\"));\n        }\n      }, {\n        key: \"_timeZoneSearchInputHandler\",\n        value: function (e) {\n          var t = e.target.value;\n          Array.prototype.slice.call(this.element.querySelectorAll(\".opt-date-time-picker__picker-menu--time-zone .opt-date-time-picker__picker-menu-item\")).forEach(function (e) {\n            e.innerText.toLowerCase().includes(t.toLowerCase()) ? e.classList.remove(\"opt-date-time-picker__picker-menu-item--hidden\") : e.classList.add(\"opt-date-time-picker__picker-menu-item--hidden\");\n          });\n        }\n      }, {\n        key: \"_saveClickHandler\",\n        value: function (e) {\n          this.save();\n        }\n      }, {\n        key: \"_cancelClickHandler\",\n        value: function (t) {\n          this.inputEl.dispatchEvent(new CustomEvent(e.CancelEventDispatch, {\n            bubbles: !0\n          })), this.destroy();\n        }\n      }]) && o(t.prototype, i), n && o(t, n), e;\n    }();\n\n    r.SaveEventDispatch = \"dateTimePickerSave\", r.CancelEventDispatch = \"dateTimePickerCancel\", t.default = r;\n  }]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvbGlicmFyaWVzL29wdF9kYXRlX3RpbWVfcGlja2VyL2Rpc3Qvb3B0X2RhdGVfdGltZV9waWNrZXJfbGliLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vd3d3L2pzLTMuMi4yL29udHJhcG9ydC9vcHRfYXNzZXRzL2xpYnJhcmllcy9vcHRfZGF0ZV90aW1lX3BpY2tlci9kaXN0L29wdF9kYXRlX3RpbWVfcGlja2VyX2xpYi5qcz9mNzBiIl0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuT3B0RGF0ZVRpbWVQaWNrZXI9dCgpOmUuT3B0RGF0ZVRpbWVQaWNrZXI9dCgpfSh3aW5kb3csZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gaShhKXtpZih0W2FdKXJldHVybiB0W2FdLmV4cG9ydHM7dmFyIG49dFthXT17aTphLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbYV0uY2FsbChuLmV4cG9ydHMsbixuLmV4cG9ydHMsaSksbi5sPSEwLG4uZXhwb3J0c31yZXR1cm4gaS5tPWUsaS5jPXQsaS5kPWZ1bmN0aW9uKGUsdCxhKXtpLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6YX0pfSxpLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0saS50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1pKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBhPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoaS5yKGEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgbiBpbiBlKWkuZChhLG4sZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxuKSk7cmV0dXJuIGF9LGkubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gaS5kKHQsXCJhXCIsdCksdH0saS5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxpLnA9XCIvanMtMy4yLjIvb250cmFwb3J0L1wiLGkoaS5zPTApfShbZnVuY3Rpb24oZSx0LGkpe2koMSksZS5leHBvcnRzPWkoMykuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LGkpe30sLGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBhKGUpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBuKGUpfShlKXx8ZnVuY3Rpb24oZSl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSlyZXR1cm4gQXJyYXkuZnJvbShlKX0oZSl8fGZ1bmN0aW9uKGUsdCl7aWYoIWUpcmV0dXJuO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBuKGUsdCk7dmFyIGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO1wiT2JqZWN0XCI9PT1pJiZlLmNvbnN0cnVjdG9yJiYoaT1lLmNvbnN0cnVjdG9yLm5hbWUpO2lmKFwiTWFwXCI9PT1pfHxcIlNldFwiPT09aSlyZXR1cm4gQXJyYXkuZnJvbShlKTtpZihcIkFyZ3VtZW50c1wiPT09aXx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QoaSkpcmV0dXJuIG4oZSx0KX0oZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9ZnVuY3Rpb24gbihlLHQpeyhudWxsPT10fHx0PmUubGVuZ3RoKSYmKHQ9ZS5sZW5ndGgpO2Zvcih2YXIgaT0wLGE9bmV3IEFycmF5KHQpO2k8dDtpKyspYVtpXT1lW2ldO3JldHVybiBhfWZ1bmN0aW9uIG8oZSx0KXtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKyl7dmFyIGE9dFtpXTthLmVudW1lcmFibGU9YS5lbnVtZXJhYmxlfHwhMSxhLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBhJiYoYS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYS5rZXksYSl9fWkucih0KTt2YXIgcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxpKXtpZihmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5pbnB1dEVsPXQsdGhpcy5vcHRpb25zPWl8fHt0d2VsdmVIb3VyOiEwfSxpLmlzRm9ybURhdGUpe3ZhciBuPWRvY3VtZW50LmJvZHk7biYmIW4uc3R5bGUubWluSGVpZ2h0JiYobi5zdHlsZS5taW5IZWlnaHQ9XCI0NTBweFwiKX1pZih0aGlzLnllYXJSYW5nZT0yMCx0aGlzLm9wdGlvbnMubWluaW11bVllYXI9aS5taW5pbXVtWWVhcnx8MTkwMCxpLnllYXJSYW5nZSYmKEFycmF5LmlzQXJyYXkoaS55ZWFyUmFuZ2UpPyh0aGlzLnllYXJSYW5nZT1pLnllYXJSYW5nZVsxXS1pLnllYXJSYW5nZVswXSx0aGlzLm9wdGlvbnMubWluaW11bVllYXI9aS55ZWFyUmFuZ2VbMF0sdGhpcy5vcHRpb25zLm1heGltdW1ZZWFyPWkueWVhclJhbmdlWzFdKTp0aGlzLnllYXJSYW5nZT1pLnllYXJSYW5nZSksdGhpcy50aW1lWm9uZUxpc3Q9dGhpcy5vcHRpb25zLnRpbWVab25lTGlzdHx8d2luZG93Lm9wJiZ3aW5kb3cub3AudGltZVpvbmVMaXN0LHRoaXMuX2luaXRpYWxpemVJbnRlcm5hbFZhbHVlcygpLHRoaXMuZWxlbWVudD10aGlzLl9idWlsZEFuZEFwcGVuZFBpY2tlck1hcmt1cCgpLHRoaXMub3B0aW9ucy5leHRyYUNsYXNzZXMpe3ZhciBvLHI9dGhpcy5vcHRpb25zLmV4dHJhQ2xhc3Nlcy5zcGxpdChcIiBcIik7KG89dGhpcy5lbGVtZW50LmNsYXNzTGlzdCkuYWRkLmFwcGx5KG8sYShyKSl9aWYodGhpcy5ndWlkPVwib3B0LWR0LVwiK3RoaXMuZ2VuZXJhdGVHdWlkKCksdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5ndWlkKSx0aGlzLm9wdGlvbnMuZGlzcGxheVBpY2tlcklubGluZT90aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm9wdC1kYXRlLXRpbWUtcGlja2VyLS1pbmxpbmVcIik6dGhpcy5wb3NpdGlvblBpY2tlcigpLHRoaXMub3B0aW9ucy5zaG93VG9kYXlCdXR0b24mJnRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwib3B0LWRhdGUtdGltZS1waWNrZXItLXNob3ctdG9kYXlcIiksdGhpcy5vcHRpb25zLmlzRGF0ZU9ubHkpdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJvcHQtZGF0ZS10aW1lLXBpY2tlci0tZGF0ZS1vbmx5XCIpO2Vsc2V7dmFyIGM9dGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLW1lbnUtLXRpbWUtem9uZSAub3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LWl0ZW1bZGF0YS12YWw9XCInLmNvbmNhdCh0aGlzLmdldFZhbFByb3BlcnR5KFwidGltZS16b25lXCIpLCdcIl0nKSk7YyYmYy5jbGFzc0xpc3QuYWRkKFwib3B0LWRhdGUtdGltZS1waWNrZXJfX21lbnUtaXRlbS0tYWN0aXZlXCIpfXRoaXMub3B0aW9ucy50d2VsdmVIb3VyfHx0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm9wdC1kYXRlLXRpbWUtcGlja2VyLS0yNC1ob3VyXCIpLFwiY2hpbmEtZGF0ZVwiPT09dGhpcy5vcHRpb25zLmRhdGVGb3JtYXQmJnRoaXMuY2VudGVyU2VsZWN0ZWREcm9wZG93bk1lbnVJdGVtKFwieWVhclwiKSx0aGlzLmRhdGVQaWNrZXI9dGhpcy5faW5pdERhdGVQaWNrZXIoKSx0aGlzLm9wdGlvbnMuaXNEYXRlT25seXx8KHRoaXMudGltZVBpY2tlcj10aGlzLl9pbml0VGltZVBpY2tlcigpLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRpbWVwaWNrZXItdGlja1wiKSkuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1lLmlubmVyVGV4dDsxPT09dC5sZW5ndGgmJih0PVwiMFwiK3QpLGUuc2V0QXR0cmlidXRlKFwiZGF0YS10aW1lLXZhbHVlXCIsdCl9KSx0aGlzLl9zZXRUaW1lQWN0aXZlU3RhdGVzKCkpLHRoaXMuZGF0ZVBpY2tlci5vcGVuKCksdGhpcy5vcHRpb25zLmlzRGF0ZU9ubHl8fHRoaXMudGltZVBpY2tlci5vcGVuKCksdGhpcy5fYmluZFBpY2tlckV2ZW50cygpfXZhciB0LGksbjtyZXR1cm4gdD1lLG49W3trZXk6XCJjb252ZXJ0VGltZVN0YW1wQW5kVGltZVpvbmVUb0RhdGVUaW1lU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24odCxpLGEsbil7dmFyIG89bmV3IERhdGUodCkscj1lLmdldERhdGVPYmplY3RQcm9wZXJ0eShvLFwibW9udGhcIiwhMCksYz1lLmdldERhdGVPYmplY3RQcm9wZXJ0eShvLFwiZGF5XCIsITApLHM9ZS5nZXREYXRlT2JqZWN0UHJvcGVydHkobyxcInllYXJcIiwhMCksbD1cIlwiO2lmKGEmJlwiY2hpbmEtZGF0ZVwiPT09YS5kYXRlRm9ybWF0P2wrPVwiXCIuY29uY2F0KHMsXCIvXCIpLmNvbmNhdChyLFwiL1wiKS5jb25jYXQoYyxcIiBcIik6YSYmXCJldXJvLWRhdGVcIj09PWEuZGF0ZUZvcm1hdD9sKz1cIlwiLmNvbmNhdChjLFwiL1wiKS5jb25jYXQocixcIi9cIikuY29uY2F0KHMsXCIgXCIpOmwrPVwiXCIuY29uY2F0KHIsXCIvXCIpLmNvbmNhdChjLFwiL1wiKS5jb25jYXQocyxcIiBcIiksIW4pe3ZhciBkPWUuZ2V0RGF0ZU9iamVjdFByb3BlcnR5KG8sXCJob3VyXCIsITAsYSYmYS50d2VsdmVIb3VyKSxwPWUuZ2V0RGF0ZU9iamVjdFByb3BlcnR5KG8sXCJtaW51dGVcIiwhMCk7bCs9XCJcIi5jb25jYXQoZCxcIjpcIikuY29uY2F0KHAsXCIgXCIpLGEmJmEudHdlbHZlSG91ciYmKGwrPWUuZ2V0RGF0ZU9iamVjdFByb3BlcnR5KG8sXCJ0aW1lLXBlcmlvZFwiLCEwKStcIiBcIiksbCs9aX1yZXR1cm4gbH19LHtrZXk6XCJnZXREYXRlT2JqZWN0UHJvcGVydHlcIix2YWx1ZTpmdW5jdGlvbihlLHQsaSxhKXt2YXIgbjtzd2l0Y2godCl7Y2FzZVwibW9udGhcIjpuPWUuZ2V0TW9udGgoKSxpJiYxPT09KG49XCJcIisgKytuKS5sZW5ndGgmJihuPVwiMFwiK24pO2JyZWFrO2Nhc2VcImRheVwiOm49ZS5nZXREYXRlKCksaSYmMT09PShuPVwiXCIrbikubGVuZ3RoJiYobj1cIjBcIituKTticmVhaztjYXNlXCJ5ZWFyXCI6bj1lLmdldEZ1bGxZZWFyKCk7YnJlYWs7Y2FzZVwiaG91clwiOm49ZS5nZXRIb3VycygpLGkmJihhJiYobj4xMj9uLT0xMjowPT09biYmKG49MTIpKSwxPT09KG49XCJcIituKS5sZW5ndGgmJihuPVwiMFwiK24pKTticmVhaztjYXNlXCJtaW51dGVcIjpuPWUuZ2V0TWludXRlcygpLGkmJjE9PT0obj1cIlwiK24pLmxlbmd0aCYmKG49XCIwXCIrbik7YnJlYWs7Y2FzZVwidGltZS1wZXJpb2RcIjpuPWUuZ2V0SG91cnMoKTwxMj9cImFtXCI6XCJwbVwiLGkmJihuPW4udG9VcHBlckNhc2UoKSl9cmV0dXJuIG59fSx7a2V5OlwiZGF0ZVRpbWVGaWVsZENsaWNrSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBpPXQuY3VycmVudFRhcmdldCxhPWkucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLWZpZWxkXCIpO2lmKGkuY2xhc3NMaXN0LmNvbnRhaW5zKFwib3B0LWRhdGUtdGltZV9fcGlja2VyLS1vcGVuXCIpKXtpLmNsYXNzTGlzdC5yZW1vdmUoXCJvcHQtZGF0ZS10aW1lX19waWNrZXItLW9wZW5cIik7dmFyIG49aS5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtZmllbGRfX2hpZGRlbi1maWVsZFwiKSxvPSExO3QudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcIm9wdC1kYXRlLXRpbWVfX2ljb24tLXhcIikmJihhLnZhbHVlPVwiXCIsYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRpbWVab25lXCIsXCJcIiksbi52YWx1ZT1cIlwiLG89ITApO3ZhciByPWEuZGF0ZVRpbWVQaWNrZXI7aWYocil7aWYoIW8pe3ZhciBjPXIuZ2V0U2F2ZURhdGEoKTthLnZhbHVlPWMuZGF0ZVRpbWVTdHJpbmcsYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRpbWVab25lXCIsYy50aW1lWm9uZSksbi52YWx1ZT1jLnRpbWVzdGFtcC8xZTN9ci5kZXN0cm95KCksYS5kYXRlVGltZVBpY2tlcj1udWxsfVwiZGVmYXVsdFwiPT09aS5nZXRBdHRyaWJ1dGUoXCJvcHQtaW5wdXQtc3R5bGVcIikmJlwiXCI9PT1hLnZhbHVlJiZpLnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWlucHV0X19sYWJlbFwiKS5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpfWVsc2V7dmFyIHM9ZS5KU09OUGFyc2UoYS5kYXRhc2V0LmRhdGVwaWNrZXJvcHRpb25zKSxsPWkucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLWZpZWxkX19oaWRkZW4tZmllbGRcIikudmFsdWUsZD17ZGF0ZUZvcm1hdDpcInVzYS1kYXRlXCIsdHdlbHZlSG91cjohMCxpbml0aWFsVGltZVpvbmU6YS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRpbWVab25lXCIpfHxJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmUsdGltZVpvbmVMaXN0OndpbmRvdy5vcCYmd2luZG93Lm9wLnRpbWVab25lTGlzdCxpc0RhdGVPbmx5OnMmJnMuaXNEYXRlT25seXx8ITEsaXNGb3JtRGF0ZTpzJiZzLmlzRm9ybURhdGV8fCExfTt3aW5kb3cub3AmJm9wLmRhdGVGb3JtYXQmJm9wLmRhdGVGb3JtYXQuZGF0ZV9mb3JtYXQmJihkLmRhdGVGb3JtYXQ9b3AuZGF0ZUZvcm1hdC5kYXRlX2Zvcm1hdCksd2luZG93Lm9wJiZvcC5kYXRlRm9ybWF0JiZvcC5kYXRlRm9ybWF0LnRpbWVfZm9ybWF0JiZcIjI0LWhvdXJcIj09PW9wLmRhdGVGb3JtYXQudGltZV9mb3JtYXQmJihkLnR3ZWx2ZUhvdXI9ITEpLGwmJihkLmluaXRpYWxWYWx1ZT0xZTMqK2wpLGEuZGF0ZVRpbWVQaWNrZXI9bmV3IGUoYSxkKSxpLmNsYXNzTGlzdC5hZGQoXCJvcHQtZGF0ZS10aW1lX19waWNrZXItLW9wZW5cIiksXCJkZWZhdWx0XCI9PT1pLmdldEF0dHJpYnV0ZShcIm9wdC1pbnB1dC1zdHlsZVwiKSYmaS5xdWVyeVNlbGVjdG9yKFwiLm9wdC1pbnB1dF9fbGFiZWxcIikuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKX19fSx7a2V5OlwiSlNPTlBhcnNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoIShcInN0cmluZ1wiPT10eXBlb2YgZXx8ZSBpbnN0YW5jZW9mIFN0cmluZykpcmV0dXJuIGU7dHJ5e3JldHVybiBKU09OLnBhcnNlKGUpfWNhdGNoKHQpe3JldHVybiBlfX19LHtrZXk6XCJkYXRlVGltZUZpZWxkU2F2ZUhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLmRldGFpbHx8ZS5vcmlnaW5hbEV2ZW50LmRldGFpbCxpPWUuY3VycmVudFRhcmdldCxhPWkucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLWZpZWxkXCIpO2lmKGkuY2xhc3NMaXN0LnJlbW92ZShcIm9wdC1kYXRlLXRpbWVfX3BpY2tlci0tb3BlblwiKSwvaVBhZHxpUGhvbmV8aVBvZHxBbmRyb2lkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSYmYS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJ0ZXh0XCIpLGEudmFsdWU9dC5kYXRlVGltZVN0cmluZyx0LnRpbWVab25lJiZhLnNldEF0dHJpYnV0ZShcImRhdGEtdGltZVpvbmVcIix0LnRpbWVab25lKSx0LnRpbWVzdGFtcCl7dmFyIG49ZS50YXJnZXQuZGF0YXNldC5kYXRlcGlja2Vyb3B0aW9ucztpZihcInN0cmluZ1wiPT10eXBlb2Ygbnx8biBpbnN0YW5jZW9mIFN0cmluZyl0cnl7bj1KU09OLnBhcnNlKG4pfWNhdGNoKGUpe31pZihuJiZuLmlzRGF0ZU9ubHkpe3ZhciBvPW5ldyBEYXRlKHQudGltZXN0YW1wKTtpLnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWRhdGUtdGltZS1maWVsZF9faGlkZGVuLWZpZWxkXCIpLnZhbHVlPW8uc2V0SG91cnMoMTIsMCwwLDApLzFlM31lbHNlIGkucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLWZpZWxkX19oaWRkZW4tZmllbGRcIikudmFsdWU9dC50aW1lc3RhbXAvMWUzfWEuZGF0ZVRpbWVQaWNrZXI9bnVsbH19LHtrZXk6XCJkYXRlVGltZUZpZWxkQ2FuY2VsSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUuY3VycmVudFRhcmdldCxpPXQucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLWZpZWxkXCIpO3QuY2xhc3NMaXN0LnJlbW92ZShcIm9wdC1kYXRlLXRpbWVfX3BpY2tlci0tb3BlblwiKSxpLmRhdGVUaW1lUGlja2VyPW51bGwsXCJkZWZhdWx0XCI9PT10LmdldEF0dHJpYnV0ZShcIm9wdC1pbnB1dC1zdHlsZVwiKSYmXCJcIj09PWkudmFsdWUmJnQucXVlcnlTZWxlY3RvcihcIi5vcHQtaW5wdXRfX2xhYmVsXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIil9fV0sKGk9W3trZXk6XCJnZXREaWFsb2dcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlucHV0RWwuY2xvc2VzdChcIm9wLWRpYWxvZ1wiKXx8ITF9fSx7a2V5OlwicG9zaXRpb25QaWNrZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlLHQ9dGhpcy5pbnB1dEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGk9dGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGE9dGhpcy5nZXREaWFsb2coKTtlPWE/YS5vZmZzZXRIZWlnaHQ+ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodD9hLm9mZnNldEhlaWdodDpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0OmRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0PmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ/ZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDt2YXIgbj1hPzAtYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A6d2luZG93LnNjcm9sbFksbz10LnRvcCtuK3QuaGVpZ2h0O28raS5oZWlnaHQ+ZSYmKG89dC50b3Arbi1pLmhlaWdodCk8MCYmKG89MCk7dmFyIHI9YT8wLWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDp3aW5kb3cuc2Nyb2xsWCxjPXQubGVmdCtyO2MraS53aWR0aD5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoJiYoYz10LmxlZnQrcit0LndpZHRoLWkud2lkdGgpPDAmJihjPTApLHRoaXMuZWxlbWVudC5zdHlsZS50b3A9bytcInB4XCIsdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQ9YytcInB4XCJ9fSx7a2V5Olwic2F2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRTYXZlRGF0YSgpO3RoaXMub3B0aW9ucy51cGRhdGVJbnB1dCYmKHRoaXMuaW5wdXRFbC52YWx1ZT10LmRhdGVUaW1lU3RyaW5nKSx0aGlzLmlucHV0RWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZS5TYXZlRXZlbnREaXNwYXRjaCx7ZGV0YWlsOnQsYnViYmxlczohMH0pKSx0aGlzLmRlc3Ryb3koKX19LHtrZXk6XCJnZXRTYXZlRGF0YVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fdmFsLmdldFRpbWUoKTtpZighdGhpcy5vcHRpb25zLmlzRGF0ZU9ubHkpe3ZhciB0PXRoaXMuZ2V0VGltZVpvbmVPZmZzZXRWYWx1ZShJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmUpLGk9dGhpcy5nZXRUaW1lWm9uZU9mZnNldFZhbHVlKHRoaXMuX3RpbWVab25lKTtpZih0IT09aSllKz02MCoodC1pKSo2MCoxZTN9dmFyIGE9e2RhdGVGb3JtYXQ6dGhpcy5vcHRpb25zLmRhdGVGb3JtYXQsdHdlbHZlSG91cjp0aGlzLm9wdGlvbnMudHdlbHZlSG91cn0sbj1cIlwiO3RoaXMub3B0aW9ucy5pc0RhdGVPbmx5fHwobj10aGlzLmdldFZhbFByb3BlcnR5KFwidGltZS16b25lXCIsITApKTt2YXIgbz17ZGF0ZVRpbWVTdHJpbmc6dGhpcy5jb25zdHJ1Y3Rvci5jb252ZXJ0VGltZVN0YW1wQW5kVGltZVpvbmVUb0RhdGVUaW1lU3RyaW5nKHRoaXMuX3ZhbC5nZXRUaW1lKCksbixhLHRoaXMub3B0aW9ucy5pc0RhdGVPbmx5KSx0aW1lc3RhbXA6ZX07cmV0dXJuIHRoaXMub3B0aW9ucy5pc0RhdGVPbmx5fHwoby50aW1lWm9uZT10aGlzLmdldFZhbFByb3BlcnR5KFwidGltZS16b25lXCIpLG8ub2Zmc2V0PXRoaXMuX3ZhbC5nZXRUaW1lem9uZU9mZnNldCgpKSxvfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZWxlbWVudCYmKHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sLWJhclwiKS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9ib3VuZENvbnRyb2xCYXJFdmVudCksdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkYXRlVGltZVBpY2tlclNlbGVjdFwiLHRoaXMuX2JvdW5kRGF0ZVRpbWVQaWNrZXJFdmVudCksdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LS15ZWFyXCIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2JvdW5kWWVhckNsaWNrRXZlbnQpLHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS0teWVhclwiKS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5fYm91bmRZZWFyU2Nyb2xsRXZlbnQpLHRoaXMub3B0aW9ucy5zaG93VG9kYXlCdXR0b24mJnRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19idXR0b24tLXRvZGF5XCIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2JvdW5kVG9kYXlDbGlja0V2ZW50KSx0aGlzLm9wdGlvbnMuaXNEYXRlT25seXx8KHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS0tdGltZS16b25lXCIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2JvdW5kVGltZVpvbmVFdmVudCksdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX3NlYXJjaC1pY29uXCIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2JvdW5kVGltZVpvbmVTZWFyY2hDbGlja0V2ZW50KSx0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLXBpY2tlcl9fc2VhcmNoLWJhclwiKS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIix0aGlzLl9ib3VuZFRpbWVab25lU2VhcmNoSW5wdXRFdmVudCkpLHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19idXR0b24tLXNhdmVcIikucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fYm91bmRTYXZlRXZlbnQpLHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19idXR0b24tLWNhbmNlbFwiKS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9ib3VuZENhbmNlbEV2ZW50KSx0aGlzLmVsZW1lbnQucmVtb3ZlKCkpLHRoaXMuZGF0ZVBpY2tlciYmdGhpcy5kYXRlUGlja2VyLmRlc3Ryb3koKSx0aGlzLnRpbWVQaWNrZXImJnRoaXMudGltZVBpY2tlci5kZXN0cm95KCksdGhpcy5lbGVtZW50PW51bGwsdGhpcy5pbnB1dEVsPW51bGwsdGhpcy5fdmFsPW51bGwsdGhpcy5vcHRpb25zPW51bGwsdGhpcy50aW1lWm9uZUxpc3Q9bnVsbCx0aGlzLmRhdGVQaWNrZXI9bnVsbCx0aGlzLnRpbWVQaWNrZXI9bnVsbCx0aGlzLl9ib3VuZENvbnRyb2xCYXJFdmVudD1udWxsLHRoaXMuX2JvdW5kRGF0ZVRpbWVQaWNrZXJFdmVudD1udWxsLHRoaXMuX2JvdW5kWWVhckNsaWNrRXZlbnQ9bnVsbCx0aGlzLl9ib3VuZFRvZGF5Q2xpY2tFdmVudD1udWxsLHRoaXMuX2JvdW5kVGltZVpvbmVFdmVudD1udWxsLHRoaXMuX2JvdW5kVGltZVpvbmVTZWFyY2hDbGlja0V2ZW50PW51bGwsdGhpcy5fYm91bmRUaW1lWm9uZVNlYXJjaElucHV0RXZlbnQ9bnVsbCx0aGlzLl9ib3VuZFNhdmVFdmVudD1udWxsLHRoaXMuX2JvdW5kQ2FuY2VsRXZlbnQ9bnVsbCx0aGlzLl9jdXJyZW50TW9udGhZZWFyPW51bGx9fSx7a2V5OlwidXBkYXRlQ29udHJvbEJhckRpc3BsYXlcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbC1iYXJcIikucXVlcnlTZWxlY3RvckFsbChcIi5vcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbFwiKSx0PTAsaT1lLmxlbmd0aDt0PGk7dCsrKXt2YXIgYT1lW3RdLG49YS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbnRyb2wtdHlwZVwiKTtpZihcIm1vbnRoLWRheVwiPT09bil7dmFyIG89YS5jbGFzc0xpc3QuY29udGFpbnMoXCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbC0tZGF5XCIpP1wiZGF5XCI6XCJtb250aFwiO2EuaW5uZXJUZXh0PXRoaXMuZ2V0VmFsUHJvcGVydHkobywhMCl9ZWxzZVwidGltZS1wZXJpb2RcIj09PW4/YS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWN1cnJlbnQtdGltZS1wZXJpb2RcIix0aGlzLmdldFZhbFByb3BlcnR5KG4pKTphLmlubmVyVGV4dD10aGlzLmdldFZhbFByb3BlcnR5KG4sITApfX19LHtrZXk6XCJjaGFuZ2VDb250cm9sXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoXCJ0aW1lLXpvbmVcIj09PWV8fHRoaXMub3B0aW9ucy5pc0RhdGVPbmx5fHx0aGlzLl9jbGVhclRpbWVab25lU2VhcmNoKCksXCJ0aW1lLXBlcmlvZFwiPT09ZSl7dmFyIHQ9dGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWNvbnRyb2wtdHlwZT1cInRpbWUtcGVyaW9kXCJdJyksaT1cImFtXCI9PT10LmdldEF0dHJpYnV0ZShcImRhdGEtY3VycmVudC10aW1lLXBlcmlvZFwiKT9cInBtXCI6XCJhbVwiO3Quc2V0QXR0cmlidXRlKFwiZGF0YS1jdXJyZW50LXRpbWUtcGVyaW9kXCIsaSk7dmFyIGE9dGhpcy5fdmFsLmdldEhvdXJzKCk7XCJhbVwiPT09aT9hLT0xMjphKz0xMix0aGlzLl92YWwuc2V0SG91cnMoYSl9ZWxzZVwiaG91clwiPT09ZT8odGhpcy50aW1lUGlja2VyLnNob3dWaWV3KFwiaG91cnNcIiksdGhpcy50aW1lUGlja2VyLnJlc2V0Q2xvY2soKSk6XCJtaW51dGVcIj09PWUmJih0aGlzLnRpbWVQaWNrZXIuc2hvd1ZpZXcoXCJtaW51dGVzXCIpLHRoaXMudGltZVBpY2tlci5yZXNldENsb2NrKCkpLHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFjdGl2ZS1jb250cm9sXCIsZSksXCJ5ZWFyXCIhPT1lJiZcInRpbWUtem9uZVwiIT09ZXx8dGhpcy5jZW50ZXJTZWxlY3RlZERyb3Bkb3duTWVudUl0ZW0oZSl9fSx7a2V5OlwiYWRkWWVhck1lbnVJdGVtc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0LGk9dGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LS15ZWFyXCIpLGE9XCJcIjtpZigodD1lPytpLmZpcnN0RWxlbWVudENoaWxkLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsXCIpOitpLmxhc3RFbGVtZW50Q2hpbGQuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWxcIikpLXRoaXMueWVhclJhbmdlPHRoaXMub3B0aW9ucy5taW5pbXVtWWVhcilyZXR1cm57bWluWWVhcjohMH07aWYodGhpcy5vcHRpb25zLm1heGltdW1ZZWFyJiZ0K3RoaXMueWVhclJhbmdlPj10aGlzLm9wdGlvbnMubWF4aW11bVllYXIpcmV0dXJue21heFllYXI6ITB9O2Zvcih2YXIgbj0xO248PXRoaXMueWVhclJhbmdlO24rKyl7dmFyIG89dm9pZCAwO2U/YT0nPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS1pdGVtXCIgZGF0YS12YWw9XCInLmNvbmNhdChvPXQrbiwnXCI+JykuY29uY2F0KG8sXCI8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIikuY29uY2F0KGEpOmErPSc8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LWl0ZW1cIiBkYXRhLXZhbD1cIicuY29uY2F0KG89dC1uLCdcIj4nKS5jb25jYXQobyxcIjwvZGl2PlwiKX1lP2kuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYWZ0ZXJiZWdpblwiLGEpOmkuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsYSl9fSx7a2V5OlwiZ2V0VmFsUHJvcGVydHlcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBpO3N3aXRjaChlKXtjYXNlXCJtb250aFwiOmNhc2VcImRheVwiOmNhc2VcInllYXJcIjpjYXNlXCJob3VyXCI6Y2FzZVwibWludXRlXCI6Y2FzZVwidGltZS1wZXJpb2RcIjppPXRoaXMuY29uc3RydWN0b3IuZ2V0RGF0ZU9iamVjdFByb3BlcnR5KHRoaXMuX3ZhbCxlLHQsdGhpcy5vcHRpb25zLnR3ZWx2ZUhvdXIpO2JyZWFrO2Nhc2VcInRpbWUtem9uZVwiOmk9dGhpcy5fdGltZVpvbmUsdCYmKGk9dGhpcy5nZXRUaW1lWm9uZUxhYmVsKGksITApKX1yZXR1cm4gaX19LHtrZXk6XCJnZXRUaW1lWm9uZUxhYmVsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIGk9XCJcIixhPTAsbj10aGlzLnRpbWVab25lTGlzdC5sZW5ndGg7YTxuO2ErKylpZih0aGlzLnRpbWVab25lTGlzdFthXS52YWx1ZT09PWUpe2k9dGhpcy50aW1lWm9uZUxpc3RbYV0ubGFiZWw7YnJlYWt9aWYoaSYmdCl7dmFyIG89aS5pbmRleE9mKFwiKVwiKTstMSE9PW8mJihpPWkuc3Vic3RyaW5nKG8rMikpfXJldHVybiBpfX0se2tleTpcImdldFRpbWVab25lT2Zmc2V0VmFsdWVcIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9XCJcIixpPTAsYT10aGlzLnRpbWVab25lTGlzdC5sZW5ndGg7aTxhO2krKylpZih0aGlzLnRpbWVab25lTGlzdFtpXS52YWx1ZT09PWUpe3Q9dGhpcy50aW1lWm9uZUxpc3RbaV0ub2Zmc2V0O2JyZWFrfXJldHVybiB0fX0se2tleTpcImdlbmVyYXRlR3VpZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5mbG9vcig2NTUzNiooMStNYXRoLnJhbmRvbSgpKSkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKX07cmV0dXJuIGUoKStlKCkrXCItXCIrZSgpK1wiLVwiK2UoKStcIi1cIitlKCkrXCItXCIrZSgpK2UoKStlKCl9fSx7a2V5OlwiY2VudGVyU2VsZWN0ZWREcm9wZG93bk1lbnVJdGVtXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LS1cIi5jb25jYXQoZSkpLGk9dC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19tZW51LWl0ZW0tLWFjdGl2ZVwiKTtpZihpKXt2YXIgYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LnF1ZXJ5U2VsZWN0b3JBbGwoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LWl0ZW1cIikpLmluZGV4T2YoaSkqaS5zY3JvbGxIZWlnaHQtKHQub2Zmc2V0SGVpZ2h0LzItaS5zY3JvbGxIZWlnaHQvMiksbj10LnNjcm9sbEhlaWdodC10Lm9mZnNldEhlaWdodDt0LnNjcm9sbFRvcD1hPDA/MDphPm4/bjphfX19LHtrZXk6XCJzZXRDYWxlbmRhckRvdHNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBpPXRoaXM7aWYoZSl7aWYoIXRoaXMuX2N1cnJlbnRNb250aFllYXJ8fHRoaXMuX2N1cnJlbnRNb250aFllYXIubW9udGghPT10Lm1vbnRofHx0aGlzLl9jdXJyZW50TW9udGhZZWFyLnllYXIhPT10LnllYXIpcmV0dXJuO3RoaXMuX2NhbGVuZGFyRG90RGF5cz1lfXRoaXMuX2NhbGVuZGFyRG90RGF5cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWkuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItLWRhdGVcIikucXVlcnlTZWxlY3RvcignW2RhdGEtZGF5PVwiJy5jb25jYXQoZSwnXCJdJykpO3QmJnQuY2xhc3NMaXN0LmFkZChcIm9wdC1kYXRlLXRpbWUtcGlja2VyX19kYXktLWRvdFwiKX0pfX0se2tleTpcInVwZGF0ZUNhbGVuZGFyRGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMub3B0aW9ucy5pc0RhdGVPbmx5JiZlIGluc3RhbmNlb2YgRGF0ZSYmKHRoaXMuX3ZhbC5zZXRGdWxsWWVhcihlLmdldEZ1bGxZZWFyKCkpLHRoaXMuX3ZhbC5zZXRNb250aChlLmdldE1vbnRoKCkpLHRoaXMuX3ZhbC5zZXREYXRlKGUuZ2V0RGF0ZSgpKSx0aGlzLnVwZGF0ZUNvbnRyb2xCYXJEaXNwbGF5KCksdGhpcy5fc2lsZW5jZVNlbGVjdGlvbkV2ZW50cz0hMCx0aGlzLmRhdGVQaWNrZXIuc2V0RGF0ZShlKSx0aGlzLl9zaWxlbmNlU2VsZWN0aW9uRXZlbnRzPSExKX19LHtrZXk6XCJfYnVpbGRBbmRBcHBlbmRQaWNrZXJNYXJrdXBcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKSx0PXRoaXMuX2dlbmVyYXRlRGF0ZUNvbnRyb2xNYXJrdXAoKSxpPXRoaXMuX2dlbmVyYXRlWWVhck1hcmt1cCgpLGE9XCJjaGluYS1kYXRlXCI9PT10aGlzLm9wdGlvbnMuZGF0ZUZvcm1hdD9cInllYXJcIjpcIm1vbnRoLWRheVwiLG49XCJcIixvPVwiXCI7aWYoIXRoaXMub3B0aW9ucy5pc0RhdGVPbmx5KXtuPSc8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX2NvbnRyb2wtc2VjdGlvbiBvcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbC1zZWN0aW9uLS10aW1lXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbC1ncm91cFwiIGRhdGEtY29udHJvbC10eXBlPVwiaG91clwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sXCIgZGF0YS1jb250cm9sLXR5cGU9XCJob3VyXCI+Jy5jb25jYXQodGhpcy5nZXRWYWxQcm9wZXJ0eShcImhvdXJcIiwhMCksJzwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sLWRpdmlkZXJcIiBkYXRhLWNvbnRyb2wtdHlwZT1cImhvdXJcIj46PC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX2NvbnRyb2xcIiBkYXRhLWNvbnRyb2wtdHlwZT1cIm1pbnV0ZVwiPicpLmNvbmNhdCh0aGlzLmdldFZhbFByb3BlcnR5KFwibWludXRlXCIsITApLCc8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sXCIgZGF0YS1jb250cm9sLXR5cGU9XCJ0aW1lLXBlcmlvZFwiIGRhdGEtY3VycmVudC10aW1lLXBlcmlvZD1cIicpLmNvbmNhdCh0aGlzLmdldFZhbFByb3BlcnR5KFwidGltZS1wZXJpb2RcIiksJ1wiPlxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gZGF0YS10aW1lLXBlcmlvZC12YWw9XCJhbVwiPkFNPC9zcGFuPjxzcGFuIGRhdGEtdGltZS1wZXJpb2QtdmFsPVwicG1cIj5QTTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sLXNlY3Rpb24gb3B0LWRhdGUtdGltZS1waWNrZXJfX2NvbnRyb2wtc2VjdGlvbi0tdGltZS16b25lXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbFwiIGRhdGEtY29udHJvbC10eXBlPVwidGltZS16b25lXCI+JykuY29uY2F0KHRoaXMuZ2V0VmFsUHJvcGVydHkoXCJ0aW1lLXpvbmVcIiwhMCksXCI8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cIik7dmFyIHI9dGhpcy5fZ2VuZXJhdGVUaW1lWm9uZU1hcmt1cCgpO289JzxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyIG9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItLXRpbWUtem9uZVwiIGRhdGEtcGlja2VyLW1lbnUtdHlwZT1cInRpbWUtem9uZVwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1oZWFkZXItc2VjdGlvblwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX190aXRsZVwiPlRJTUUgWk9ORTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19zZWFyY2hcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX3NlYXJjaC1iYXItYW5pbWF0aW9uLWNvbnRhaW5lclwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX3NlYXJjaC1iYXItY29udGFpbmVyXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIlNlYXJjaCB0aW1lem9uZS4uLlwiIGNsYXNzPVwiYnJvd3Nlci1kZWZhdWx0IG9wdC1kYXRlLXRpbWUtcGlja2VyX19zZWFyY2gtYmFyXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL2FwcC5vbnRyYXBvcnQuY29tL2ltYWdlcy9jbG9zZV94LnBuZ1wiIGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX3NlYXJjaC1jbGVhclwiLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL2FwcC5vbnRyYXBvcnQuY29tL2ltYWdlcy9zZWFyY2hfYmxhY2sucG5nXCIgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fc2VhcmNoLWljb24gb3B0LWRhdGUtdGltZS1waWNrZXJfX3NlYXJjaC1pY29uLS1vcGVuXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9hcHAub250cmFwb3J0LmNvbS9pbWFnZXMvc2VhcmNoX2dyZXkucG5nXCIgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fc2VhcmNoLWljb24gb3B0LWRhdGUtdGltZS1waWNrZXJfX3NlYXJjaC1pY29uLS1jbG9zZWRcIi8+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLW1lbnUgb3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LS10aW1lLXpvbmVcIj5cXG4gICAgICAgICAgICAgICAgICAgICcuY29uY2F0KHIsXCJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XCIpfXZhciBjPVwiXCI7dGhpcy5vcHRpb25zLnNob3dUb2RheUJ1dHRvbiYmKGM9JzxidXR0b24gY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fYnV0dG9uLS10b2RheVwiPlRvZGF5PC9idXR0b24+JyksZS5pbm5lckhUTUw9JzxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlclwiIGRhdGEtYWN0aXZlLWNvbnRyb2w9XCInLmNvbmNhdChhLCdcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX2NvbnRyb2wtYmFyXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbC1zZWN0aW9uIG9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sLXNlY3Rpb24tLWRhdGVcIj5cXG4gICAgICAgICAgICAgICAgICAgICcpLmNvbmNhdCh0LFwiXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICBcIikuY29uY2F0KG4sXCJcXG4gICAgICAgICAgICAgICAgXCIpLmNvbmNhdChjLCdcXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1zZWN0aW9uXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fbWF0ZXJpYWxpemUtc2VjdGlvblwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX190aXRsZSBvcHQtZGF0ZS10aW1lLXBpY2tlcl9fdGl0bGUtLWhvdXJcIj5IT1VSPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX3RpdGxlIG9wdC1kYXRlLXRpbWUtcGlja2VyX190aXRsZS0tbWludXRlXCI+TUlOVVRFPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlciBvcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLS1kYXRlIG9wdC1tYXRlcmlhbGl6ZS1uYW1lc3BhY2VcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyIG9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItLXRpbWVcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIFxceDNjIS0tIFRoZXNlIGlucHV0cyBhcmUgaGlkZGVuIGRvblxcJ3QgYWN0dWFsbHkgZG8gYW55dGhpbmcsIHRoZXkgYXJlIGp1c3QgdXNlZCB0byBpbml0aWFsaXplIHRoZSBwaWNrZXJzIC0tXFx4M2VcXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19pbnB1dC0tZGF0ZVwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX2lucHV0LS10aW1lXCI+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlciBvcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLS15ZWFyXCIgZGF0YS1waWNrZXItbWVudS10eXBlPVwieWVhclwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX190aXRsZVwiPllFQVI8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLW1lbnUgb3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LS15ZWFyXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgJykuY29uY2F0KGksXCJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgXCIpLmNvbmNhdChvLCdcXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX2J1dHRvbnNcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19idXR0b24gb3B0LWRhdGUtdGltZS1waWNrZXJfX2J1dHRvbi0tY2FuY2VsXCI+Q0FOQ0VMPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fYnV0dG9uIG9wdC1kYXRlLXRpbWUtcGlja2VyX19idXR0b24tLXNhdmVcIj5TQVZFPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj4nKTt2YXIgcz1lLmNvbnRlbnQuY2xvbmVOb2RlKCEwKSxsPXMuY2hpbGRyZW5bMF07aWYodGhpcy5vcHRpb25zLmRpc3BsYXlQaWNrZXJJbmxpbmUpdGhpcy5pbnB1dEVsLmFwcGVuZChzKTtlbHNle3ZhciBkPXRoaXMuZ2V0RGlhbG9nKCk7ZD9kLnF1ZXJ5U2VsZWN0b3IoXCIub3AtZGlhbG9nX19jb250ZW50XCIpLmFwcGVuZChzKTpkb2N1bWVudC5ib2R5LmFwcGVuZChzKX1yZXR1cm4gbH19LHtrZXk6XCJfZ2VuZXJhdGVEYXRlQ29udHJvbE1hcmt1cFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9JzxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbCBvcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbC0tbW9udGhcIiBkYXRhLWNvbnRyb2wtdHlwZT1cIm1vbnRoLWRheVwiPicuY29uY2F0KHRoaXMuZ2V0VmFsUHJvcGVydHkoXCJtb250aFwiLCEwKSxcIjwvZGl2PlwiKSx0PSc8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX2NvbnRyb2wtZGl2aWRlclwiIGRhdGEtY29udHJvbC10eXBlPVwibW9udGgtZGF5XCI+LzwvZGl2PicsaT0nPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sIG9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sLS1kYXlcIiBkYXRhLWNvbnRyb2wtdHlwZT1cIm1vbnRoLWRheVwiPicuY29uY2F0KHRoaXMuZ2V0VmFsUHJvcGVydHkoXCJkYXlcIiwhMCksXCI8L2Rpdj5cIiksYT0nPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sLWRpdmlkZXJcIiBkYXRhLWNvbnRyb2wtdHlwZT1cInllYXJcIj4vPC9kaXY+JyxuPSc8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX2NvbnRyb2xcIiBkYXRhLWNvbnRyb2wtdHlwZT1cInllYXJcIj4nLmNvbmNhdCh0aGlzLmdldFZhbFByb3BlcnR5KFwieWVhclwiKSxcIjwvZGl2PlwiKTtyZXR1cm5cImV1cm8tZGF0ZVwiPT09dGhpcy5vcHRpb25zLmRhdGVGb3JtYXQ/JzxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbC1ncm91cFwiIGRhdGEtY29udHJvbC10eXBlPVwibW9udGgtZGF5XCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuY29uY2F0KGkpLmNvbmNhdCh0KS5jb25jYXQoZSwnXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sLWdyb3VwXCIgZGF0YS1jb250cm9sLXR5cGU9XCJ5ZWFyXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcpLmNvbmNhdChhKS5jb25jYXQobixcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlwiKTpcImNoaW5hLWRhdGVcIj09PXRoaXMub3B0aW9ucy5kYXRlRm9ybWF0Pyc8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX2NvbnRyb2wtZ3JvdXBcIiBkYXRhLWNvbnRyb2wtdHlwZT1cInllYXJcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy5jb25jYXQobikuY29uY2F0KGEsJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbC1ncm91cFwiIGRhdGEtY29udHJvbC10eXBlPVwibW9udGgtZGF5XCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcpLmNvbmNhdChlKS5jb25jYXQodCkuY29uY2F0KGksXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIik6JzxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fY29udHJvbC1ncm91cFwiIGRhdGEtY29udHJvbC10eXBlPVwibW9udGgtZGF5XCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuY29uY2F0KGUpLmNvbmNhdCh0KS5jb25jYXQoaSwnXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sLWdyb3VwXCIgZGF0YS1jb250cm9sLXR5cGU9XCJ5ZWFyXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcpLmNvbmNhdChhKS5jb25jYXQobixcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlwiKX19LHtrZXk6XCJfZ2VuZXJhdGVZZWFyTWFya3VwXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5nZXRWYWxQcm9wZXJ0eShcInllYXJcIiksdD0nPGRpdiBjbGFzcz1cIm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS1pdGVtIG9wdC1kYXRlLXRpbWUtcGlja2VyX19tZW51LWl0ZW0tLWFjdGl2ZVwiIGRhdGEtdmFsPVwiJy5jb25jYXQoZSwnXCI+JykuY29uY2F0KGUsXCI8L2Rpdj5cIiksaT0xO2k8PXRoaXMueWVhclJhbmdlO2krKyl0PSc8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LWl0ZW1cIiBkYXRhLXZhbD1cIicuY29uY2F0KGUraSwnXCI+JykuY29uY2F0KGUraSxcIjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIpLmNvbmNhdCh0LCdcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLW1lbnUtaXRlbVwiIGRhdGEtdmFsPVwiJykuY29uY2F0KGUtaSwnXCI+JykuY29uY2F0KGUtaSxcIjwvZGl2PlwiKTtyZXR1cm4gdH19LHtrZXk6XCJfZ2VuZXJhdGVUaW1lWm9uZU1hcmt1cFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPVwiXCIsdD0wLGk9dGhpcy50aW1lWm9uZUxpc3QubGVuZ3RoO3Q8aTt0Kyspe3ZhciBhPXRoaXMudGltZVpvbmVMaXN0W3RdO2UrPSc8ZGl2IGNsYXNzPVwib3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LWl0ZW1cIiBkYXRhLXZhbD1cIicuY29uY2F0KGEudmFsdWUsJ1wiPicpLmNvbmNhdChhLmxhYmVsLFwiPC9kaXY+XCIpfXJldHVybiBlfX0se2tleTpcIl9pbml0RGF0ZVBpY2tlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLmFkZENhbGVuZGFyRG90cyYmKHRoaXMuX2N1cnJlbnRNb250aFllYXI9e21vbnRoOnRoaXMuX3ZhbC5nZXRNb250aCgpLHllYXI6dGhpcy5fdmFsLmdldEZ1bGxZZWFyKCl9KTt2YXIgZT1PYmplY3QuYXNzaWduKHtmb3JtYXQ6XCJtbS9kZC95eXl5XCIsZGVmYXVsdERhdGU6dGhpcy5fdmFsLHNldERlZmF1bHREYXRlOiEwLGNvbnRhaW5lcjp0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLS1kYXRlXCIpLGkxOG46e2RvbmU6XCJTYXZlXCIsd2Vla2RheXNBYmJyZXY6W1wiU3VcIixcIk1vXCIsXCJUdVwiLFwiV2VcIixcIlRoXCIsXCJGclwiLFwiU2FcIl19LG9uT3BlbjpmdW5jdGlvbigpe3RoaXMubW9kYWwub3Blbj1mdW5jdGlvbigpe30sdGhpcy5tb2RhbC5jbG9zZT1mdW5jdGlvbigpe30sdGhpcy5tb2RhbC4kZWwuY3NzKFwiZGlzcGxheVwiLFwiYmxvY2tcIil9LG9uQ2xvc2U6ZnVuY3Rpb24oKXt0aGlzLm1vZGFsLiRlbC5jc3MoXCJkaXNwbGF5XCIsXCJcIil9LG9uRHJhdzpmdW5jdGlvbigpe2lmKHRoaXMub3B0aW9ucy5hZGRDYWxlbmRhckRvdHMmJnRoaXMuZGF0ZVBpY2tlciYmdGhpcy5fY3VycmVudE1vbnRoWWVhcil7dmFyIGU9dGhpcy5kYXRlUGlja2VyLmNhbGVuZGFyc1swXTt0aGlzLl9jdXJyZW50TW9udGhZZWFyJiZlLm1vbnRoPT09dGhpcy5fY3VycmVudE1vbnRoWWVhci5tb250aCYmZS55ZWFyPT09dGhpcy5fY3VycmVudE1vbnRoWWVhci55ZWFyP3RoaXMuX2NhbGVuZGFyRG90RGF5cyYmdGhpcy5zZXRDYWxlbmRhckRvdHMoKToodGhpcy5fY3VycmVudE1vbnRoWWVhcj1PYmplY3QuYXNzaWduKHt9LGUpLHRoaXMuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImRhdGVUaW1lTW9udGhDaGFuZ2VkXCIse2RldGFpbDp0aGlzLl9jdXJyZW50TW9udGhZZWFyLGJ1YmJsZXM6ITB9KSkpfX0uYmluZCh0aGlzKSxvblNlbGVjdDpmdW5jdGlvbihlKXt0aGlzLl9zaWxlbmNlU2VsZWN0aW9uRXZlbnRzfHx0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJkYXRlVGltZVBpY2tlclNlbGVjdFwiLHtkZXRhaWw6e3NlbGVjdFR5cGU6XCJkYXRlXCIsZGF0ZTplfSxidWJibGVzOiEwfSkpfS5iaW5kKHRoaXMpfSx0aGlzLm9wdGlvbnMpO3JldHVybiBNLkRhdGVwaWNrZXIuaW5pdCh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLXBpY2tlcl9faW5wdXQtLWRhdGVcIiksZSl9fSx7a2V5OlwiX2luaXRUaW1lUGlja2VyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1PYmplY3QuYXNzaWduKHtpMThuOntjYW5jZWw6XCJDYW5jZWxcIixkb25lOlwiU2F2ZVwifSxjb250YWluZXI6XCIuXCIuY29uY2F0KHRoaXMuZ3VpZCxcIiAub3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci0tdGltZVwiKSx0d2VsdmVIb3VyOiEwLGRlZmF1bHRUaW1lOnRoaXMuZ2V0VmFsUHJvcGVydHkoXCJob3VyXCIsITApK1wiOlwiK3RoaXMuZ2V0VmFsUHJvcGVydHkoXCJtaW51dGVcIiwhMCksZHVyYXRpb246MixvblNlbGVjdDpmdW5jdGlvbihlLHQpe3ZhciBpPXRoaXMuZWwuY2xvc2VzdChcIi5vcHQtZGF0ZS10aW1lLXBpY2tlclwiKTtpJiZcImhvdXJcIj09PWkuZ2V0QXR0cmlidXRlKFwiZGF0YS1hY3RpdmUtY29udHJvbFwiKSYmaS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFjdGl2ZS1jb250cm9sXCIsXCJtaW51dGVcIiksaS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImRhdGVUaW1lUGlja2VyU2VsZWN0XCIse2RldGFpbDp7c2VsZWN0VHlwZTpcInRpbWVcIixob3VyOmUsbWludXRlOnR9LGJ1YmJsZXM6ITB9KSl9fSx0aGlzLm9wdGlvbnMpLHQ9TS5UaW1lcGlja2VyLmluaXQodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX2lucHV0LS10aW1lXCIpLGUpO3JldHVybiB0Lm1vZGFsLm9wZW49ZnVuY3Rpb24oKXt9LHQubW9kYWwuY2xvc2U9ZnVuY3Rpb24oKXt9LHQubW9kYWwuJGVsLmNzcyhcImRpc3BsYXlcIixcImJsb2NrXCIpLHR9fSx7a2V5OlwiX2luaXRpYWxpemVJbnRlcm5hbFZhbHVlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5vcHRpb25zLmluaXRpYWxUaW1lWm9uZT90aGlzLl90aW1lWm9uZT10aGlzLm9wdGlvbnMuaW5pdGlhbFRpbWVab25lOnRoaXMuX3RpbWVab25lPUludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZSx0aGlzLm9wdGlvbnMuaW5pdGlhbFZhbHVlKXtpZighdGhpcy5vcHRpb25zLmlzRGF0ZU9ubHkpe3ZhciBlPXRoaXMuZ2V0VGltZVpvbmVPZmZzZXRWYWx1ZShJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmUpLHQ9dGhpcy5nZXRUaW1lWm9uZU9mZnNldFZhbHVlKHRoaXMuX3RpbWVab25lKTtpZihlIT09dCl7dmFyIGk9dC1lO3RoaXMub3B0aW9ucy5pbml0aWFsVmFsdWU9dGhpcy5vcHRpb25zLmluaXRpYWxWYWx1ZSs2MCppKjYwKjFlM319dGhpcy5fdmFsPW5ldyBEYXRlKHRoaXMub3B0aW9ucy5pbml0aWFsVmFsdWUpfWVsc2UgdGhpcy5fdmFsPW5ldyBEYXRlO3RoaXMuX3ZhbC5zZXRTZWNvbmRzKDApLHRoaXMuX3ZhbC5zZXRNaWxsaXNlY29uZHMoMCl9fSx7a2V5OlwiX2NsZWFyVGltZVpvbmVTZWFyY2hcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19zZWFyY2hcIik7ZS5jbGFzc0xpc3QuY29udGFpbnMoXCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fc2VhcmNoLS1vcGVuXCIpJiYodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX3NlYXJjaC1iYXJcIikudmFsdWU9XCJcIixlLmNsYXNzTGlzdC5yZW1vdmUoXCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fc2VhcmNoLS1vcGVuXCIpLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS0tdGltZS16b25lIC5vcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLW1lbnUtaXRlbS5vcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLW1lbnUtaXRlbS0taGlkZGVuXCIpKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuY2xhc3NMaXN0LnJlbW92ZShcIm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS1pdGVtLS1oaWRkZW5cIil9KSl9fSx7a2V5OlwiX3NldFRpbWVBY3RpdmVTdGF0ZXNcIix2YWx1ZTpmdW5jdGlvbigpe0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRpbWVwaWNrZXItdGljay5vcHQtdGltZS0tYWN0aXZlXCIpKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuY2xhc3NMaXN0LnJlbW92ZShcIm9wdC10aW1lLS1hY3RpdmVcIil9KTt2YXIgZT10aGlzLmdldFZhbFByb3BlcnR5KFwiaG91clwiLCEwKSx0PXRoaXMuZ2V0VmFsUHJvcGVydHkoXCJtaW51dGVcIiwhMCksaT10aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcignLnRpbWVwaWNrZXItaG91cnMgLnRpbWVwaWNrZXItdGlja1tkYXRhLXRpbWUtdmFsdWU9XCInLmNvbmNhdChlLCdcIl0nKSksYT10aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcignLnRpbWVwaWNrZXItbWludXRlcyAudGltZXBpY2tlci10aWNrW2RhdGEtdGltZS12YWx1ZT1cIicuY29uY2F0KHQsJ1wiXScpKTtpJiZpLmNsYXNzTGlzdC5hZGQoXCJvcHQtdGltZS0tYWN0aXZlXCIpLGEmJmEuY2xhc3NMaXN0LmFkZChcIm9wdC10aW1lLS1hY3RpdmVcIil9fSx7a2V5OlwiX3VwZGF0ZVNlbGVjdGVkWWVhclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS0teWVhclwiKSxpPXQucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLXBpY2tlcl9fbWVudS1pdGVtLS1hY3RpdmVcIik7aSYmaS5jbGFzc0xpc3QucmVtb3ZlKFwib3B0LWRhdGUtdGltZS1waWNrZXJfX21lbnUtaXRlbS0tYWN0aXZlXCIpO3ZhciBhPXQucXVlcnlTZWxlY3RvcignW2RhdGEtdmFsPVwiJytlKydcIl0nKTthJiZhLmNsYXNzTGlzdC5hZGQoXCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fbWVudS1pdGVtLS1hY3RpdmVcIil9fSx7a2V5OlwiX2JpbmRQaWNrZXJFdmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2JvdW5kQ29udHJvbEJhckV2ZW50PXRoaXMuX2NvbnRyb2xCYXJDbGlja0hhbmRsZXIuYmluZCh0aGlzKSx0aGlzLl9ib3VuZERhdGVUaW1lUGlja2VyRXZlbnQ9dGhpcy5fZGF0ZVRpbWVQaWNrZXJTZWxlY3RIYW5kbGVyLmJpbmQodGhpcyksdGhpcy5fYm91bmRZZWFyQ2xpY2tFdmVudD10aGlzLl95ZWFyTWVudUNsaWNrSGFuZGxlci5iaW5kKHRoaXMpLHRoaXMuX2JvdW5kWWVhclNjcm9sbEV2ZW50PXRoaXMuX3llYXJNZW51U2Nyb2xsSGFuZGxlci5iaW5kKHRoaXMpLHRoaXMub3B0aW9ucy5zaG93VG9kYXlCdXR0b24mJih0aGlzLl9ib3VuZFRvZGF5Q2xpY2tFdmVudD10aGlzLl90b2RheUNsaWNrSGFuZGxlci5iaW5kKHRoaXMpKSx0aGlzLm9wdGlvbnMuaXNEYXRlT25seXx8KHRoaXMuX2JvdW5kVGltZVpvbmVFdmVudD10aGlzLl90aW1lWm9uZU1lbnVDbGlja0hhbmRsZXIuYmluZCh0aGlzKSx0aGlzLl9ib3VuZFRpbWVab25lU2VhcmNoQ2xpY2tFdmVudD10aGlzLl90aW1lWm9uZVNlYXJjaENsaWNrSGFuZGxlci5iaW5kKHRoaXMpLHRoaXMuX2JvdW5kVGltZVpvbmVTZWFyY2hJbnB1dEV2ZW50PXRoaXMuX3RpbWVab25lU2VhcmNoSW5wdXRIYW5kbGVyLmJpbmQodGhpcykpLHRoaXMuX2JvdW5kU2F2ZUV2ZW50PXRoaXMuX3NhdmVDbGlja0hhbmRsZXIuYmluZCh0aGlzKSx0aGlzLl9ib3VuZENhbmNlbEV2ZW50PXRoaXMuX2NhbmNlbENsaWNrSGFuZGxlci5iaW5kKHRoaXMpLHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19jb250cm9sLWJhclwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9ib3VuZENvbnRyb2xCYXJFdmVudCksdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkYXRlVGltZVBpY2tlclNlbGVjdFwiLHRoaXMuX2JvdW5kRGF0ZVRpbWVQaWNrZXJFdmVudCksdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LS15ZWFyXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2JvdW5kWWVhckNsaWNrRXZlbnQpLHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS0teWVhclwiKS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5fYm91bmRZZWFyU2Nyb2xsRXZlbnQpLHRoaXMub3B0aW9ucy5zaG93VG9kYXlCdXR0b24mJnRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19idXR0b24tLXRvZGF5XCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2JvdW5kVG9kYXlDbGlja0V2ZW50KSx0aGlzLm9wdGlvbnMuaXNEYXRlT25seXx8KHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS0tdGltZS16b25lXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2JvdW5kVGltZVpvbmVFdmVudCksdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX3NlYXJjaFwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9ib3VuZFRpbWVab25lU2VhcmNoQ2xpY2tFdmVudCksdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX3NlYXJjaC1iYXJcIikuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsdGhpcy5fYm91bmRUaW1lWm9uZVNlYXJjaElucHV0RXZlbnQpKSx0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLXBpY2tlcl9fYnV0dG9uLS1zYXZlXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2JvdW5kU2F2ZUV2ZW50KSx0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5vcHQtZGF0ZS10aW1lLXBpY2tlcl9fYnV0dG9uLS1jYW5jZWxcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fYm91bmRDYW5jZWxFdmVudCl9fSx7a2V5OlwiX2NvbnRyb2xCYXJDbGlja0hhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbihlKXtlLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLWNvbnRyb2wtdHlwZVwiKSYmdGhpcy5jaGFuZ2VDb250cm9sKGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29udHJvbC10eXBlXCIpKX19LHtrZXk6XCJfZGF0ZVRpbWVQaWNrZXJTZWxlY3RIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5kZXRhaWw7aWYoXCJkYXRlXCI9PT10LnNlbGVjdFR5cGUpe3ZhciBpPXQuZGF0ZS5nZXRGdWxsWWVhcigpO3RoaXMuX3ZhbC5zZXRGdWxsWWVhcihpKSx0aGlzLl92YWwuc2V0RGF0ZSgxKSx0aGlzLl92YWwuc2V0TW9udGgodC5kYXRlLmdldE1vbnRoKCkpLHRoaXMuX3ZhbC5zZXREYXRlKHQuZGF0ZS5nZXREYXRlKCkpLHRoaXMuX3VwZGF0ZVNlbGVjdGVkWWVhcihpKSx0aGlzLm9wdGlvbnMuZGlzYWJsZUF1dG9Db250cm9sQ2hhbmdlfHwoXCJjaGluYS1kYXRlXCIhPT10aGlzLm9wdGlvbnMuZGF0ZUZvcm1hdHx8dGhpcy5vcHRpb25zLmlzRGF0ZU9ubHk/XCJjaGluYS1kYXRlXCIhPT10aGlzLm9wdGlvbnMuZGF0ZUZvcm1hdCYmdGhpcy5jaGFuZ2VDb250cm9sKFwieWVhclwiKTp0aGlzLmNoYW5nZUNvbnRyb2woXCJob3VyXCIpKX1lbHNlIGlmKFwidGltZVwiPT09dC5zZWxlY3RUeXBlKXtpZih0aGlzLm9wdGlvbnMudHdlbHZlSG91cil7dmFyIGE9dGhpcy5nZXRWYWxQcm9wZXJ0eShcInRpbWUtcGVyaW9kXCIpO1wiYW1cIj09PWEmJjEyPT09dC5ob3VyP3QuaG91cj0wOlwicG1cIj09PWEmJjEyIT09dC5ob3VyJiYodC5ob3VyKz0xMil9dGhpcy5fdmFsLnNldEhvdXJzKHQuaG91cix0Lm1pbnV0ZSwwLDApLHRoaXMuX3NldFRpbWVBY3RpdmVTdGF0ZXMoKX10aGlzLnVwZGF0ZUNvbnRyb2xCYXJEaXNwbGF5KCksdGhpcy5vcHRpb25zLmlzRGF0ZU9ubHkmJlwiY2hpbmEtZGF0ZVwiPT09dGhpcy5vcHRpb25zLmRhdGVGb3JtYXQmJnRoaXMuc2F2ZSgpfX0se2tleTpcIl95ZWFyTWVudUNsaWNrSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcIm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS1pdGVtXCIpKXt2YXIgdD0rZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWxcIik7dGhpcy5fdmFsLnNldEZ1bGxZZWFyKHQpLHRoaXMuX3NpbGVuY2VTZWxlY3Rpb25FdmVudHM9ITAsdGhpcy5kYXRlUGlja2VyLnNldERhdGUodGhpcy5fdmFsKSx0aGlzLl9zaWxlbmNlU2VsZWN0aW9uRXZlbnRzPSExLHRoaXMuX3VwZGF0ZVNlbGVjdGVkWWVhcih0KSx0aGlzLnVwZGF0ZUNvbnRyb2xCYXJEaXNwbGF5KCksdGhpcy5vcHRpb25zLmRpc2FibGVBdXRvQ29udHJvbENoYW5nZXx8KFwiY2hpbmEtZGF0ZVwiPT09dGhpcy5vcHRpb25zLmRhdGVGb3JtYXQ/dGhpcy5jaGFuZ2VDb250cm9sKFwibW9udGgtZGF5XCIpOnRoaXMub3B0aW9ucy5pc0RhdGVPbmx5fHx0aGlzLmNoYW5nZUNvbnRyb2woXCJob3VyXCIpKSx0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJkYXRlVGltZVBpY2tlclllYXJTZWxlY3RcIix7ZGV0YWlsOntzZWxlY3RUeXBlOlwieWVhclwiLGRhdGU6dGhpcy5fdmFsfSxidWJibGVzOiEwfSkpLHRoaXMub3B0aW9ucy5pc0RhdGVPbmx5JiZcImNoaW5hLWRhdGVcIiE9PXRoaXMub3B0aW9ucy5kYXRlRm9ybWF0JiZ0aGlzLnNhdmUoKX19fSx7a2V5OlwiX3llYXJNZW51U2Nyb2xsSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKDA9PT1lLnRhcmdldC5zY3JvbGxUb3Ape3ZhciB0PXRoaXMuYWRkWWVhck1lbnVJdGVtcyghMCk7aWYodCYmdC5tYXhZZWFyKXJldHVybjt2YXIgaT1lLnRhcmdldC5maXJzdEVsZW1lbnRDaGlsZC5zY3JvbGxIZWlnaHQ7ZS50YXJnZXQuc2Nyb2xsVG9wPWkqdGhpcy55ZWFyUmFuZ2V9ZWxzZSBlLnRhcmdldC5zY3JvbGxUb3ArZS50YXJnZXQub2Zmc2V0SGVpZ2h0PmUudGFyZ2V0LnNjcm9sbEhlaWdodC01JiZ0aGlzLmFkZFllYXJNZW51SXRlbXMoKX19LHtrZXk6XCJfdG9kYXlDbGlja0hhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1uZXcgRGF0ZSxpPXQuZ2V0RnVsbFllYXIoKTt0aGlzLl92YWwuc2V0RGF0ZSh0LmdldERhdGUoKSksdGhpcy5fdmFsLnNldE1vbnRoKHQuZ2V0TW9udGgoKSksdGhpcy5fdmFsLnNldEZ1bGxZZWFyKGkpLHRoaXMuX3VwZGF0ZVNlbGVjdGVkWWVhcihpKSx0aGlzLmRhdGVQaWNrZXIuc2V0RGF0ZSh0aGlzLl92YWwpfX0se2tleTpcIl90aW1lWm9uZU1lbnVDbGlja0hhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbihlKXtpZihlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLW1lbnUtaXRlbVwiKSl7dGhpcy5fdGltZVpvbmU9ZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWxcIik7dmFyIHQ9ZS50YXJnZXQuY2xvc2VzdChcIi5vcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLW1lbnUtLXRpbWUtem9uZVwiKS5xdWVyeVNlbGVjdG9yKFwiLm9wdC1kYXRlLXRpbWUtcGlja2VyX19tZW51LWl0ZW0tLWFjdGl2ZVwiKTt0JiZ0LmNsYXNzTGlzdC5yZW1vdmUoXCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fbWVudS1pdGVtLS1hY3RpdmVcIiksZS50YXJnZXQuY2xhc3NMaXN0LmFkZChcIm9wdC1kYXRlLXRpbWUtcGlja2VyX19tZW51LWl0ZW0tLWFjdGl2ZVwiKSx0aGlzLnVwZGF0ZUNvbnRyb2xCYXJEaXNwbGF5KCl9fX0se2tleTpcIl90aW1lWm9uZVNlYXJjaENsaWNrSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe2UudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcIm9wdC1kYXRlLXRpbWUtcGlja2VyX19zZWFyY2gtaWNvbi0tY2xvc2VkXCIpPyhlLmN1cnJlbnRUYXJnZXQuY2xhc3NMaXN0LmFkZChcIm9wdC1kYXRlLXRpbWUtcGlja2VyX19zZWFyY2gtLW9wZW5cIiksZS5jdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX3NlYXJjaC1iYXJcIikuZm9jdXMoKSk6ZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwib3B0LWRhdGUtdGltZS1waWNrZXJfX3NlYXJjaC1jbGVhclwiKSYmKHRoaXMuX2NsZWFyVGltZVpvbmVTZWFyY2goKSx0aGlzLmNlbnRlclNlbGVjdGVkRHJvcGRvd25NZW51SXRlbShcInRpbWUtem9uZVwiKSl9fSx7a2V5OlwiX3RpbWVab25lU2VhcmNoSW5wdXRIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50YXJnZXQudmFsdWU7QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIub3B0LWRhdGUtdGltZS1waWNrZXJfX3BpY2tlci1tZW51LS10aW1lLXpvbmUgLm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS1pdGVtXCIpKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuaW5uZXJUZXh0LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModC50b0xvd2VyQ2FzZSgpKT9lLmNsYXNzTGlzdC5yZW1vdmUoXCJvcHQtZGF0ZS10aW1lLXBpY2tlcl9fcGlja2VyLW1lbnUtaXRlbS0taGlkZGVuXCIpOmUuY2xhc3NMaXN0LmFkZChcIm9wdC1kYXRlLXRpbWUtcGlja2VyX19waWNrZXItbWVudS1pdGVtLS1oaWRkZW5cIil9KX19LHtrZXk6XCJfc2F2ZUNsaWNrSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuc2F2ZSgpfX0se2tleTpcIl9jYW5jZWxDbGlja0hhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmlucHV0RWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZS5DYW5jZWxFdmVudERpc3BhdGNoLHtidWJibGVzOiEwfSkpLHRoaXMuZGVzdHJveSgpfX1dKSYmbyh0LnByb3RvdHlwZSxpKSxuJiZvKHQsbiksZX0oKTtyLlNhdmVFdmVudERpc3BhdGNoPVwiZGF0ZVRpbWVQaWNrZXJTYXZlXCIsci5DYW5jZWxFdmVudERpc3BhdGNoPVwiZGF0ZVRpbWVQaWNrZXJDYW5jZWxcIix0LmRlZmF1bHQ9cn1dKX0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/libraries/opt_date_time_picker/dist/opt_date_time_picker_lib.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt-assets.webpack.js":
/*!*****************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt-assets.webpack.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("if (window.OptDateTimePicker === undefined) {\n  //optassets.js\n  //These are all the files that get built into optassets.js. Note we are pulling  materialize.js in here and defining it as global objects.\n  //We moved anime.js out of materialize.js to get materialize.js fields working on mobile ios chrome.\n  //leaving jquery out for the time being moonrayform.paymentplandisplay.js depends on jQuery but must be included before ontraport-order-summary.js so until we move\n  //the paymentplan js into the webpack build jquery stays out. Dont forget to update the externaljquery option in webpack.opt-assets.config.js\n  //$ = jQuery = window.$ = window.jQuery = require( './opt_boilerplates/v3/jquery-3.2.1.js' );\n  //IE 11 polyfills, the babel poly fill is way bigger so we maintain our own polyfills.\n  __webpack_require__(/*! ./opt_boilerplates/v3/polyfills.js */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/polyfills.js\"); // Opt assets JavaScript\n\n\n  __webpack_require__(/*! ./opt_boilerplates/v3/jQueryUiWidget.js */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/jQueryUiWidget.js\"); // Form conditions live in a legacy folder but are hosted at forms.ontraport.com, @todo move these to central location so we can include in the opages build. This gets reference by opt.materialize.js so it must come first\n\n\n  __webpack_require__(/*! ../../../../legacy/include/formEditor/jquery.jb.formconditions.js */ \"./legacy/include/formEditor/jquery.jb.formconditions.js\"); //anime.js This gets included outside the build because it breaks ios chrome and IE 11\n  //anime = window.anime =  require( './elements_v3/common/materialize-1-dev/js/anime.js');\n\n\n  const OptDateTimePicker = __webpack_require__(/*! ./libraries/opt_date_time_picker/dist/opt_date_time_picker_lib.js */ \"./www/js-3.2.2/ontraport/opt_assets/libraries/opt_date_time_picker/dist/opt_date_time_picker_lib.js\");\n\n  __webpack_require__(/*! ./libraries/opt_date_time_picker/dist/opt_date_time_picker_lib.css */ \"./www/js-3.2.2/ontraport/opt_assets/libraries/opt_date_time_picker/dist/opt_date_time_picker_lib.css\");\n\n  if (!window.M) {\n    // This is a modified build. See mateialize-1-dev/Gruntfile.js to see whats included. Also not that we had to make some custom changes to materialize-1-dev/js/global.js to accomodate moving anime js\n    M = window.M = __webpack_require__(/*! ./elements_v3/common/materialize-1-dev/dist/js/materialize.js */ \"./www/js-3.2.2/ontraport/opt_assets/elements_v3/common/materialize-1-dev/dist/js/materialize.js\");\n  } // This is only required if there's a slideshow present\n\n\n  __webpack_require__(/*! ./opt_boilerplates/v3/opt.materialize.slideshowdependancies.js */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.materialize.slideshowdependancies.js\"); // Js encryption for spam blocking\n\n\n  desExport = window.desExport = __webpack_require__(/*! ./opt_boilerplates/v3/des.js */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/des.js\");\n  des = window.des = window.desExport.des;\n  des_createKeys = window.des_createKeys = window.desExport.des_createKeys;\n  stringToHex = window.stringToHex = window.desExport.stringToHex;\n  hexToString = window.hexToString = window.desExport.hexToString;\n  XD = window.XD = __webpack_require__(/*! ./opt_boilerplates/v3/postmessage.js */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/postmessage.js\"); // Opt enhancements to materialize\n\n  __webpack_require__(/*! ./opt_boilerplates/v3/opt.materialize.js */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.materialize.js\"); // Common functionality\n\n\n  __webpack_require__(/*! ./opt_boilerplates/v3/opt.common.js */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.common.js\"); // Page initialization via js, we need this so we can build global block gradients in the wild.\n\n\n  __webpack_require__(/*! ./opt_boilerplates/v3/opt.init.js */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.init.js\"); // Helpers\n\n\n  __webpack_require__(/*! ./blocks/common/jQueryCloneVal/jquery-cloneVal.js */ \"./www/js-3.2.2/ontraport/opt_assets/blocks/common/jQueryCloneVal/jquery-cloneVal.js\"); // UiLocker to lock the page during form submission\n\n\n  __webpack_require__(/*! ./opt_boilerplates/v3/uiLocker.js */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/uiLocker.js\"); // Form validation, this is for preview.\n\n\n  __webpack_require__(/*! ./opt_boilerplates/v3/validator.js */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/validator.js\"); // Globalize god knows what\n\n\n  __webpack_require__(/*! ../../globalize/globalize.js */ \"./www/js-3.2.2/globalize/globalize.js\");\n\n  window.OptDateTimePicker = OptDateTimePicker;\n  module.exports.OptDateTimePicker = OptDateTimePicker;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0LWFzc2V0cy53ZWJwYWNrLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vd3d3L2pzLTMuMi4yL29udHJhcG9ydC9vcHRfYXNzZXRzL29wdC1hc3NldHMud2VicGFjay5qcz83Njk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vb3B0YXNzZXRzLmpzXG4vL1RoZXNlIGFyZSBhbGwgdGhlIGZpbGVzIHRoYXQgZ2V0IGJ1aWx0IGludG8gb3B0YXNzZXRzLmpzLiBOb3RlIHdlIGFyZSBwdWxsaW5nICBtYXRlcmlhbGl6ZS5qcyBpbiBoZXJlIGFuZCBkZWZpbmluZyBpdCBhcyBnbG9iYWwgb2JqZWN0cy5cbi8vV2UgbW92ZWQgYW5pbWUuanMgb3V0IG9mIG1hdGVyaWFsaXplLmpzIHRvIGdldCBtYXRlcmlhbGl6ZS5qcyBmaWVsZHMgd29ya2luZyBvbiBtb2JpbGUgaW9zIGNocm9tZS5cblxuLy9sZWF2aW5nIGpxdWVyeSBvdXQgZm9yIHRoZSB0aW1lIGJlaW5nIG1vb25yYXlmb3JtLnBheW1lbnRwbGFuZGlzcGxheS5qcyBkZXBlbmRzIG9uIGpRdWVyeSBidXQgbXVzdCBiZSBpbmNsdWRlZCBiZWZvcmUgb250cmFwb3J0LW9yZGVyLXN1bW1hcnkuanMgc28gdW50aWwgd2UgbW92ZVxuLy90aGUgcGF5bWVudHBsYW4ganMgaW50byB0aGUgd2VicGFjayBidWlsZCBqcXVlcnkgc3RheXMgb3V0LiBEb250IGZvcmdldCB0byB1cGRhdGUgdGhlIGV4dGVybmFsanF1ZXJ5IG9wdGlvbiBpbiB3ZWJwYWNrLm9wdC1hc3NldHMuY29uZmlnLmpzXG4vLyQgPSBqUXVlcnkgPSB3aW5kb3cuJCA9IHdpbmRvdy5qUXVlcnkgPSByZXF1aXJlKCAnLi9vcHRfYm9pbGVycGxhdGVzL3YzL2pxdWVyeS0zLjIuMS5qcycgKTtcblxuLy9JRSAxMSBwb2x5ZmlsbHMsIHRoZSBiYWJlbCBwb2x5IGZpbGwgaXMgd2F5IGJpZ2dlciBzbyB3ZSBtYWludGFpbiBvdXIgb3duIHBvbHlmaWxscy5cbnJlcXVpcmUoICcuL29wdF9ib2lsZXJwbGF0ZXMvdjMvcG9seWZpbGxzLmpzJyApO1xuXG4vLyBPcHQgYXNzZXRzIEphdmFTY3JpcHRcblxucmVxdWlyZSggJy4vb3B0X2JvaWxlcnBsYXRlcy92My9qUXVlcnlVaVdpZGdldC5qcycgKTtcblxuLy8gRm9ybSBjb25kaXRpb25zIGxpdmUgaW4gYSBsZWdhY3kgZm9sZGVyIGJ1dCBhcmUgaG9zdGVkIGF0IGZvcm1zLm9udHJhcG9ydC5jb20sIEB0b2RvIG1vdmUgdGhlc2UgdG8gY2VudHJhbCBsb2NhdGlvbiBzbyB3ZSBjYW4gaW5jbHVkZSBpbiB0aGUgb3BhZ2VzIGJ1aWxkLiBUaGlzIGdldHMgcmVmZXJlbmNlIGJ5IG9wdC5tYXRlcmlhbGl6ZS5qcyBzbyBpdCBtdXN0IGNvbWUgZmlyc3RcbnJlcXVpcmUoICcuLi8uLi8uLi8uLi9sZWdhY3kvaW5jbHVkZS9mb3JtRWRpdG9yL2pxdWVyeS5qYi5mb3JtY29uZGl0aW9ucy5qcycgKTtcblxuLy9hbmltZS5qcyBUaGlzIGdldHMgaW5jbHVkZWQgb3V0c2lkZSB0aGUgYnVpbGQgYmVjYXVzZSBpdCBicmVha3MgaW9zIGNocm9tZSBhbmQgSUUgMTFcbi8vYW5pbWUgPSB3aW5kb3cuYW5pbWUgPSAgcmVxdWlyZSggJy4vZWxlbWVudHNfdjMvY29tbW9uL21hdGVyaWFsaXplLTEtZGV2L2pzL2FuaW1lLmpzJyk7XG5cbmNvbnN0IE9wdERhdGVUaW1lUGlja2VyID0gcmVxdWlyZSgnLi9saWJyYXJpZXMvb3B0X2RhdGVfdGltZV9waWNrZXIvZGlzdC9vcHRfZGF0ZV90aW1lX3BpY2tlcl9saWIuanMnKTtcblxucmVxdWlyZSgnLi9saWJyYXJpZXMvb3B0X2RhdGVfdGltZV9waWNrZXIvZGlzdC9vcHRfZGF0ZV90aW1lX3BpY2tlcl9saWIuY3NzJyk7XG5cbmlmKCAhd2luZG93Lk0gKXtcbi8vIFRoaXMgaXMgYSBtb2RpZmllZCBidWlsZC4gU2VlIG1hdGVpYWxpemUtMS1kZXYvR3J1bnRmaWxlLmpzIHRvIHNlZSB3aGF0cyBpbmNsdWRlZC4gQWxzbyBub3QgdGhhdCB3ZSBoYWQgdG8gbWFrZSBzb21lIGN1c3RvbSBjaGFuZ2VzIHRvIG1hdGVyaWFsaXplLTEtZGV2L2pzL2dsb2JhbC5qcyB0byBhY2NvbW9kYXRlIG1vdmluZyBhbmltZSBqc1xuTSA9IHdpbmRvdy5NID0gcmVxdWlyZSggJy4vZWxlbWVudHNfdjMvY29tbW9uL21hdGVyaWFsaXplLTEtZGV2L2Rpc3QvanMvbWF0ZXJpYWxpemUuanMnICk7XG59XG5cbi8vIFRoaXMgaXMgb25seSByZXF1aXJlZCBpZiB0aGVyZSdzIGEgc2xpZGVzaG93IHByZXNlbnRcbnJlcXVpcmUoICcuL29wdF9ib2lsZXJwbGF0ZXMvdjMvb3B0Lm1hdGVyaWFsaXplLnNsaWRlc2hvd2RlcGVuZGFuY2llcy5qcycgKTtcblxuLy8gSnMgZW5jcnlwdGlvbiBmb3Igc3BhbSBibG9ja2luZ1xuZGVzRXhwb3J0ID0gd2luZG93LmRlc0V4cG9ydCA9IHJlcXVpcmUgKCAnLi9vcHRfYm9pbGVycGxhdGVzL3YzL2Rlcy5qcycgKTtcbmRlcyA9IHdpbmRvdy5kZXMgPSB3aW5kb3cuZGVzRXhwb3J0LmRlcztcbmRlc19jcmVhdGVLZXlzID0gd2luZG93LmRlc19jcmVhdGVLZXlzID0gd2luZG93LmRlc0V4cG9ydC5kZXNfY3JlYXRlS2V5cztcbnN0cmluZ1RvSGV4ID0gd2luZG93LnN0cmluZ1RvSGV4ID0gd2luZG93LmRlc0V4cG9ydC5zdHJpbmdUb0hleDtcbmhleFRvU3RyaW5nID13aW5kb3cuaGV4VG9TdHJpbmcgPSB3aW5kb3cuZGVzRXhwb3J0LmhleFRvU3RyaW5nO1xuXG5YRCA9IHdpbmRvdy5YRCA9IHJlcXVpcmUgKCAnLi9vcHRfYm9pbGVycGxhdGVzL3YzL3Bvc3RtZXNzYWdlLmpzJyApO1xuXG4vLyBPcHQgZW5oYW5jZW1lbnRzIHRvIG1hdGVyaWFsaXplXG5cbnJlcXVpcmUoICcuL29wdF9ib2lsZXJwbGF0ZXMvdjMvb3B0Lm1hdGVyaWFsaXplLmpzJyApO1xuXG4vLyBDb21tb24gZnVuY3Rpb25hbGl0eVxucmVxdWlyZSggJy4vb3B0X2JvaWxlcnBsYXRlcy92My9vcHQuY29tbW9uLmpzJyApO1xuXG4vLyBQYWdlIGluaXRpYWxpemF0aW9uIHZpYSBqcywgd2UgbmVlZCB0aGlzIHNvIHdlIGNhbiBidWlsZCBnbG9iYWwgYmxvY2sgZ3JhZGllbnRzIGluIHRoZSB3aWxkLlxucmVxdWlyZSggJy4vb3B0X2JvaWxlcnBsYXRlcy92My9vcHQuaW5pdC5qcycgKTtcblxuLy8gSGVscGVyc1xucmVxdWlyZSggJy4vYmxvY2tzL2NvbW1vbi9qUXVlcnlDbG9uZVZhbC9qcXVlcnktY2xvbmVWYWwuanMnICk7XG5cbi8vIFVpTG9ja2VyIHRvIGxvY2sgdGhlIHBhZ2UgZHVyaW5nIGZvcm0gc3VibWlzc2lvblxucmVxdWlyZSggJy4vb3B0X2JvaWxlcnBsYXRlcy92My91aUxvY2tlci5qcycgKTtcblxuLy8gRm9ybSB2YWxpZGF0aW9uLCB0aGlzIGlzIGZvciBwcmV2aWV3LlxucmVxdWlyZSggJy4vb3B0X2JvaWxlcnBsYXRlcy92My92YWxpZGF0b3IuanMnICk7XG5cbi8vIEdsb2JhbGl6ZSBnb2Qga25vd3Mgd2hhdFxucmVxdWlyZSggJy4uLy4uL2dsb2JhbGl6ZS9nbG9iYWxpemUuanMnICk7XG5cbiJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt-assets.webpack.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/des.js":
/*!**********************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/des.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // Paul Tero, July 2001\n// http://www.tero.co.uk/des/\n//\n// Optimised for performance with large blocks by Michael Hayworth, November 2001\n// http://www.netdealing.com\n//\n// THIS SOFTWARE IS PROVIDED \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n// SUCH DAMAGE.\n\n(() => {\n  // Des\n  // This takes the key, the message, and whether to encrypt or decrypt\n  function des(key, message, encrypt, mode, iv, padding) {\n    // Declaring this locally speeds things up a bit\n    var spfunction1 = new Array(0x1010400, 0, 0x10000, 0x1010404, 0x1010004, 0x10404, 0x4, 0x10000, 0x400, 0x1010400, 0x1010404, 0x400, 0x1000404, 0x1010004, 0x1000000, 0x4, 0x404, 0x1000400, 0x1000400, 0x10400, 0x10400, 0x1010000, 0x1010000, 0x1000404, 0x10004, 0x1000004, 0x1000004, 0x10004, 0, 0x404, 0x10404, 0x1000000, 0x10000, 0x1010404, 0x4, 0x1010000, 0x1010400, 0x1000000, 0x1000000, 0x400, 0x1010004, 0x10000, 0x10400, 0x1000004, 0x400, 0x4, 0x1000404, 0x10404, 0x1010404, 0x10004, 0x1010000, 0x1000404, 0x1000004, 0x404, 0x10404, 0x1010400, 0x404, 0x1000400, 0x1000400, 0, 0x10004, 0x10400, 0, 0x1010004);\n    var spfunction2 = new Array(-0x7fef7fe0, -0x7fff8000, 0x8000, 0x108020, 0x100000, 0x20, -0x7fefffe0, -0x7fff7fe0, -0x7fffffe0, -0x7fef7fe0, -0x7fef8000, -0x80000000, -0x7fff8000, 0x100000, 0x20, -0x7fefffe0, 0x108000, 0x100020, -0x7fff7fe0, 0, -0x80000000, 0x8000, 0x108020, -0x7ff00000, 0x100020, -0x7fffffe0, 0, 0x108000, 0x8020, -0x7fef8000, -0x7ff00000, 0x8020, 0, 0x108020, -0x7fefffe0, 0x100000, -0x7fff7fe0, -0x7ff00000, -0x7fef8000, 0x8000, -0x7ff00000, -0x7fff8000, 0x20, -0x7fef7fe0, 0x108020, 0x20, 0x8000, -0x80000000, 0x8020, -0x7fef8000, 0x100000, -0x7fffffe0, 0x100020, -0x7fff7fe0, -0x7fffffe0, 0x100020, 0x108000, 0, -0x7fff8000, 0x8020, -0x80000000, -0x7fefffe0, -0x7fef7fe0, 0x108000);\n    var spfunction3 = new Array(0x208, 0x8020200, 0, 0x8020008, 0x8000200, 0, 0x20208, 0x8000200, 0x20008, 0x8000008, 0x8000008, 0x20000, 0x8020208, 0x20008, 0x8020000, 0x208, 0x8000000, 0x8, 0x8020200, 0x200, 0x20200, 0x8020000, 0x8020008, 0x20208, 0x8000208, 0x20200, 0x20000, 0x8000208, 0x8, 0x8020208, 0x200, 0x8000000, 0x8020200, 0x8000000, 0x20008, 0x208, 0x20000, 0x8020200, 0x8000200, 0, 0x200, 0x20008, 0x8020208, 0x8000200, 0x8000008, 0x200, 0, 0x8020008, 0x8000208, 0x20000, 0x8000000, 0x8020208, 0x8, 0x20208, 0x20200, 0x8000008, 0x8020000, 0x8000208, 0x208, 0x8020000, 0x20208, 0x8, 0x8020008, 0x20200);\n    var spfunction4 = new Array(0x802001, 0x2081, 0x2081, 0x80, 0x802080, 0x800081, 0x800001, 0x2001, 0, 0x802000, 0x802000, 0x802081, 0x81, 0, 0x800080, 0x800001, 0x1, 0x2000, 0x800000, 0x802001, 0x80, 0x800000, 0x2001, 0x2080, 0x800081, 0x1, 0x2080, 0x800080, 0x2000, 0x802080, 0x802081, 0x81, 0x800080, 0x800001, 0x802000, 0x802081, 0x81, 0, 0, 0x802000, 0x2080, 0x800080, 0x800081, 0x1, 0x802001, 0x2081, 0x2081, 0x80, 0x802081, 0x81, 0x1, 0x2000, 0x800001, 0x2001, 0x802080, 0x800081, 0x2001, 0x2080, 0x800000, 0x802001, 0x80, 0x800000, 0x2000, 0x802080);\n    var spfunction5 = new Array(0x100, 0x2080100, 0x2080000, 0x42000100, 0x80000, 0x100, 0x40000000, 0x2080000, 0x40080100, 0x80000, 0x2000100, 0x40080100, 0x42000100, 0x42080000, 0x80100, 0x40000000, 0x2000000, 0x40080000, 0x40080000, 0, 0x40000100, 0x42080100, 0x42080100, 0x2000100, 0x42080000, 0x40000100, 0, 0x42000000, 0x2080100, 0x2000000, 0x42000000, 0x80100, 0x80000, 0x42000100, 0x100, 0x2000000, 0x40000000, 0x2080000, 0x42000100, 0x40080100, 0x2000100, 0x40000000, 0x42080000, 0x2080100, 0x40080100, 0x100, 0x2000000, 0x42080000, 0x42080100, 0x80100, 0x42000000, 0x42080100, 0x2080000, 0, 0x40080000, 0x42000000, 0x80100, 0x2000100, 0x40000100, 0x80000, 0, 0x40080000, 0x2080100, 0x40000100);\n    var spfunction6 = new Array(0x20000010, 0x20400000, 0x4000, 0x20404010, 0x20400000, 0x10, 0x20404010, 0x400000, 0x20004000, 0x404010, 0x400000, 0x20000010, 0x400010, 0x20004000, 0x20000000, 0x4010, 0, 0x400010, 0x20004010, 0x4000, 0x404000, 0x20004010, 0x10, 0x20400010, 0x20400010, 0, 0x404010, 0x20404000, 0x4010, 0x404000, 0x20404000, 0x20000000, 0x20004000, 0x10, 0x20400010, 0x404000, 0x20404010, 0x400000, 0x4010, 0x20000010, 0x400000, 0x20004000, 0x20000000, 0x4010, 0x20000010, 0x20404010, 0x404000, 0x20400000, 0x404010, 0x20404000, 0, 0x20400010, 0x10, 0x4000, 0x20400000, 0x404010, 0x4000, 0x400010, 0x20004010, 0, 0x20404000, 0x20000000, 0x400010, 0x20004010);\n    var spfunction7 = new Array(0x200000, 0x4200002, 0x4000802, 0, 0x800, 0x4000802, 0x200802, 0x4200800, 0x4200802, 0x200000, 0, 0x4000002, 0x2, 0x4000000, 0x4200002, 0x802, 0x4000800, 0x200802, 0x200002, 0x4000800, 0x4000002, 0x4200000, 0x4200800, 0x200002, 0x4200000, 0x800, 0x802, 0x4200802, 0x200800, 0x2, 0x4000000, 0x200800, 0x4000000, 0x200800, 0x200000, 0x4000802, 0x4000802, 0x4200002, 0x4200002, 0x2, 0x200002, 0x4000000, 0x4000800, 0x200000, 0x4200800, 0x802, 0x200802, 0x4200800, 0x802, 0x4000002, 0x4200802, 0x4200000, 0x200800, 0, 0x2, 0x4200802, 0, 0x200802, 0x4200000, 0x800, 0x4000002, 0x4000800, 0x800, 0x200002);\n    var spfunction8 = new Array(0x10001040, 0x1000, 0x40000, 0x10041040, 0x10000000, 0x10001040, 0x40, 0x10000000, 0x40040, 0x10040000, 0x10041040, 0x41000, 0x10041000, 0x41040, 0x1000, 0x40, 0x10040000, 0x10000040, 0x10001000, 0x1040, 0x41000, 0x40040, 0x10040040, 0x10041000, 0x1040, 0, 0, 0x10040040, 0x10000040, 0x10001000, 0x41040, 0x40000, 0x41040, 0x40000, 0x10041000, 0x1000, 0x40, 0x10040040, 0x1000, 0x41040, 0x10001000, 0x40, 0x10000040, 0x10040000, 0x10040040, 0x10000000, 0x40000, 0x10001040, 0, 0x10041040, 0x40040, 0x10000040, 0x10040000, 0x10001000, 0x10001040, 0, 0x10041040, 0x41000, 0x41000, 0x1040, 0x1040, 0x40040, 0x10000000, 0x10041000); // Create the 16 or 48 subkeys we will need\n\n    var keys = des_createKeys(key);\n    var m = 0,\n        i,\n        j,\n        temp,\n        temp2,\n        right1,\n        right2,\n        left,\n        right,\n        looping;\n    var cbcleft, cbcleft2, cbcright, cbcright2;\n    var endloop, loopinc;\n    var len = message.length;\n    var chunk = 0; // Set up the loops for single and triple des\n\n    var iterations = keys.length == 32 ? 3 : 9; // Single or triple des\n\n    if (iterations == 3) {\n      looping = encrypt ? new Array(0, 32, 2) : new Array(30, -2, -2);\n    } else {\n      looping = encrypt ? new Array(0, 32, 2, 62, 30, -2, 64, 96, 2) : new Array(94, 62, -2, 32, 64, 2, 30, -2, -2);\n    } // Pad the message depending on the padding parameter\n\n\n    if (padding == 2) {\n      message += '        ';\n    } // Pad the message with spaces\n    else if (padding == 1) {\n        temp = 8 - len % 8;\n        message += String.fromCharCode(temp, temp, temp, temp, temp, temp, temp, temp);\n\n        if (temp == 8) {\n          len += 8;\n        }\n      } // PKCS7 padding\n      else if (!padding) {\n          message += '\\0\\0\\0\\0\\0\\0\\0\\0';\n        } // Pad the message out with null bytes\n    // Store the result here\n\n\n    var result = '';\n    var tempresult = '';\n\n    if (mode == 1) {\n      // CBC mode\n      cbcleft = iv.charCodeAt(m++) << 24 | iv.charCodeAt(m++) << 16 | iv.charCodeAt(m++) << 8 | iv.charCodeAt(m++);\n      cbcright = iv.charCodeAt(m++) << 24 | iv.charCodeAt(m++) << 16 | iv.charCodeAt(m++) << 8 | iv.charCodeAt(m++);\n      m = 0;\n    } // Loop through each 64 bit chunk of the message\n\n\n    while (m < len) {\n      left = message.charCodeAt(m++) << 24 | message.charCodeAt(m++) << 16 | message.charCodeAt(m++) << 8 | message.charCodeAt(m++);\n      right = message.charCodeAt(m++) << 24 | message.charCodeAt(m++) << 16 | message.charCodeAt(m++) << 8 | message.charCodeAt(m++); // For Cipher Block Chaining mode, xor the message with the previous result\n\n      if (mode == 1) {\n        if (encrypt) {\n          left ^= cbcleft;\n          right ^= cbcright;\n        } else {\n          cbcleft2 = cbcleft;\n          cbcright2 = cbcright;\n          cbcleft = left;\n          cbcright = right;\n        }\n      } // First each 64 but chunk of the message must be permuted according to IP\n\n\n      temp = (left >>> 4 ^ right) & 0x0f0f0f0f;\n      right ^= temp;\n      left ^= temp << 4;\n      temp = (left >>> 16 ^ right) & 0x0000ffff;\n      right ^= temp;\n      left ^= temp << 16;\n      temp = (right >>> 2 ^ left) & 0x33333333;\n      left ^= temp;\n      right ^= temp << 2;\n      temp = (right >>> 8 ^ left) & 0x00ff00ff;\n      left ^= temp;\n      right ^= temp << 8;\n      temp = (left >>> 1 ^ right) & 0x55555555;\n      right ^= temp;\n      left ^= temp << 1;\n      left = left << 1 | left >>> 31;\n      right = right << 1 | right >>> 31; // Do this either 1 or 3 times for each chunk of the message\n\n      for (j = 0; j < iterations; j += 3) {\n        endloop = looping[j + 1];\n        loopinc = looping[j + 2]; // Now go through and perform the encryption or decryption\n\n        for (i = looping[j]; i != endloop; i += loopinc) {\n          // For efficiency\n          right1 = right ^ keys[i];\n          right2 = (right >>> 4 | right << 28) ^ keys[i + 1]; // The result is attained by passing these bytes through the S selection functions\n\n          temp = left;\n          left = right;\n          right = temp ^ (spfunction2[right1 >>> 24 & 0x3f] | spfunction4[right1 >>> 16 & 0x3f] | spfunction6[right1 >>> 8 & 0x3f] | spfunction8[right1 & 0x3f] | spfunction1[right2 >>> 24 & 0x3f] | spfunction3[right2 >>> 16 & 0x3f] | spfunction5[right2 >>> 8 & 0x3f] | spfunction7[right2 & 0x3f]);\n        }\n\n        temp = left;\n        left = right;\n        right = temp; // Unreverse left and right\n      } // For either 1 or 3 iterations\n      // Move then each one bit to the right\n\n\n      left = left >>> 1 | left << 31;\n      right = right >>> 1 | right << 31; // Now perform IP-1, which is IP in the opposite direction\n\n      temp = (left >>> 1 ^ right) & 0x55555555;\n      right ^= temp;\n      left ^= temp << 1;\n      temp = (right >>> 8 ^ left) & 0x00ff00ff;\n      left ^= temp;\n      right ^= temp << 8;\n      temp = (right >>> 2 ^ left) & 0x33333333;\n      left ^= temp;\n      right ^= temp << 2;\n      temp = (left >>> 16 ^ right) & 0x0000ffff;\n      right ^= temp;\n      left ^= temp << 16;\n      temp = (left >>> 4 ^ right) & 0x0f0f0f0f;\n      right ^= temp;\n      left ^= temp << 4; // For Cipher Block Chaining mode, xor the message with the previous result\n\n      if (mode == 1) {\n        if (encrypt) {\n          cbcleft = left;\n          cbcright = right;\n        } else {\n          left ^= cbcleft2;\n          right ^= cbcright2;\n        }\n      }\n\n      tempresult += String.fromCharCode(left >>> 24, left >>> 16 & 0xff, left >>> 8 & 0xff, left & 0xff, right >>> 24, right >>> 16 & 0xff, right >>> 8 & 0xff, right & 0xff);\n      chunk += 8;\n\n      if (chunk == 512) {\n        result += tempresult;\n        tempresult = '';\n        chunk = 0;\n      }\n    } // For every 8 characters, or 64 bits in the message\n    // Return the result as an array\n\n\n    return result + tempresult;\n  } // End of des\n  // Des_createKeys\n  // This takes as input a 64 bit key (even though only 56 bits are used)\n  // As an array of 2 integers, and returns 16 48 bit keys\n\n\n  function des_createKeys(key) {\n    // Declaring this locally speeds things up a bit - Oh the irony\n    var left,\n        right,\n        pc2bytes0 = new Array(0, 0x4, 0x20000000, 0x20000004, 0x10000, 0x10004, 0x20010000, 0x20010004, 0x200, 0x204, 0x20000200, 0x20000204, 0x10200, 0x10204, 0x20010200, 0x20010204),\n        pc2bytes1 = new Array(0, 0x1, 0x100000, 0x100001, 0x4000000, 0x4000001, 0x4100000, 0x4100001, 0x100, 0x101, 0x100100, 0x100101, 0x4000100, 0x4000101, 0x4100100, 0x4100101),\n        pc2bytes2 = new Array(0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808, 0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808),\n        pc2bytes3 = new Array(0, 0x200000, 0x8000000, 0x8200000, 0x2000, 0x202000, 0x8002000, 0x8202000, 0x20000, 0x220000, 0x8020000, 0x8220000, 0x22000, 0x222000, 0x8022000, 0x8222000),\n        pc2bytes4 = new Array(0, 0x40000, 0x10, 0x40010, 0, 0x40000, 0x10, 0x40010, 0x1000, 0x41000, 0x1010, 0x41010, 0x1000, 0x41000, 0x1010, 0x41010),\n        pc2bytes5 = new Array(0, 0x400, 0x20, 0x420, 0, 0x400, 0x20, 0x420, 0x2000000, 0x2000400, 0x2000020, 0x2000420, 0x2000000, 0x2000400, 0x2000020, 0x2000420),\n        pc2bytes6 = new Array(0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002, 0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002),\n        pc2bytes7 = new Array(0, 0x10000, 0x800, 0x10800, 0x20000000, 0x20010000, 0x20000800, 0x20010800, 0x20000, 0x30000, 0x20800, 0x30800, 0x20020000, 0x20030000, 0x20020800, 0x20030800),\n        pc2bytes8 = new Array(0, 0x40000, 0, 0x40000, 0x2, 0x40002, 0x2, 0x40002, 0x2000000, 0x2040000, 0x2000000, 0x2040000, 0x2000002, 0x2040002, 0x2000002, 0x2040002),\n        pc2bytes9 = new Array(0, 0x10000000, 0x8, 0x10000008, 0, 0x10000000, 0x8, 0x10000008, 0x400, 0x10000400, 0x408, 0x10000408, 0x400, 0x10000400, 0x408, 0x10000408),\n        pc2bytes10 = new Array(0, 0x20, 0, 0x20, 0x100000, 0x100020, 0x100000, 0x100020, 0x2000, 0x2020, 0x2000, 0x2020, 0x102000, 0x102020, 0x102000, 0x102020),\n        pc2bytes11 = new Array(0, 0x1000000, 0x200, 0x1000200, 0x200000, 0x1200000, 0x200200, 0x1200200, 0x4000000, 0x5000000, 0x4000200, 0x5000200, 0x4200000, 0x5200000, 0x4200200, 0x5200200),\n        pc2bytes12 = new Array(0, 0x1000, 0x8000000, 0x8001000, 0x80000, 0x81000, 0x8080000, 0x8081000, 0x10, 0x1010, 0x8000010, 0x8001010, 0x80010, 0x81010, 0x8080010, 0x8081010),\n        pc2bytes13 = new Array(0, 0x4, 0x100, 0x104, 0, 0x4, 0x100, 0x104, 0x1, 0x5, 0x101, 0x105, 0x1, 0x5, 0x101, 0x105); // How many iterations (1 for des, 3 for triple des)\n\n    var iterations = key.length > 8 ? 3 : 1; // Changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys\n    // Stores the return keys\n\n    var keys = new Array(32 * iterations); // Now define the left shifts which need to be done\n\n    var shifts = new Array(0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0); // Other variables\n\n    var lefttemp,\n        righttemp,\n        m = 0,\n        n = 0,\n        temp;\n\n    for (var j = 0; j < iterations; j++) {\n      // Either 1 or 3 iterations\n      left = key.charCodeAt(m++) << 24 | key.charCodeAt(m++) << 16 | key.charCodeAt(m++) << 8 | key.charCodeAt(m++);\n      right = key.charCodeAt(m++) << 24 | key.charCodeAt(m++) << 16 | key.charCodeAt(m++) << 8 | key.charCodeAt(m++);\n      temp = (left >>> 4 ^ right) & 0x0f0f0f0f;\n      right ^= temp;\n      left ^= temp << 4;\n      temp = (right >>> -16 ^ left) & 0x0000ffff;\n      left ^= temp;\n      right ^= temp << -16;\n      temp = (left >>> 2 ^ right) & 0x33333333;\n      right ^= temp;\n      left ^= temp << 2;\n      temp = (right >>> -16 ^ left) & 0x0000ffff;\n      left ^= temp;\n      right ^= temp << -16;\n      temp = (left >>> 1 ^ right) & 0x55555555;\n      right ^= temp;\n      left ^= temp << 1;\n      temp = (right >>> 8 ^ left) & 0x00ff00ff;\n      left ^= temp;\n      right ^= temp << 8;\n      temp = (left >>> 1 ^ right) & 0x55555555;\n      right ^= temp;\n      left ^= temp << 1; // The right side needs to be shifted and to get the last four bits of the left side\n\n      temp = left << 8 | right >>> 20 & 0x000000f0; // Left needs to be put upside down\n\n      left = right << 24 | right << 8 & 0xff0000 | right >>> 8 & 0xff00 | right >>> 24 & 0xf0;\n      right = temp; // Now go through and perform these shifts on the left and right keys\n\n      for (var i = 0; i < shifts.length; i++) {\n        // Shift the keys either one or two bits to the left\n        if (shifts[i]) {\n          left = left << 2 | left >>> 26;\n          right = right << 2 | right >>> 26;\n        } else {\n          left = left << 1 | left >>> 27;\n          right = right << 1 | right >>> 27;\n        }\n\n        left &= -0xf;\n        right &= -0xf; // Now apply PC-2, in such a way that E is easier when encrypting or decrypting\n        // This conversion will look like PC-2 except only the last 6 bits of each byte are used\n        // Rather than 48 consecutive bits and the order of lines will be according to\n        // How the S selection functions will be applied: S2, S4, S6, S8, S1, S3, S5, S7\n\n        lefttemp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 0xf] | pc2bytes2[left >>> 20 & 0xf] | pc2bytes3[left >>> 16 & 0xf] | pc2bytes4[left >>> 12 & 0xf] | pc2bytes5[left >>> 8 & 0xf] | pc2bytes6[left >>> 4 & 0xf];\n        righttemp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 0xf] | pc2bytes9[right >>> 20 & 0xf] | pc2bytes10[right >>> 16 & 0xf] | pc2bytes11[right >>> 12 & 0xf] | pc2bytes12[right >>> 8 & 0xf] | pc2bytes13[right >>> 4 & 0xf];\n        temp = (righttemp >>> 16 ^ lefttemp) & 0x0000ffff;\n        keys[n++] = lefttemp ^ temp;\n        keys[n++] = righttemp ^ temp << 16;\n      }\n    } // For each iterations\n    // Return the keys we've created\n\n\n    return keys;\n  } // End of des_createKeys\n  // //////////////////////////// TEST //////////////////////////////\n\n\n  function stringToHex(s) {\n    var r = '0x';\n    var hexes = new Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');\n\n    for (var i = 0; i < s.length; i++) {\n      r += hexes[s.charCodeAt(i) >> 4] + hexes[s.charCodeAt(i) & 0xf];\n    }\n\n    return r;\n  }\n\n  function hexToString(h) {\n    var r = '';\n\n    for (var i = h.substr(0, 2) == '0x' ? 2 : 0; i < h.length; i += 2) {\n      r += String.fromCharCode(parseInt(h.substr(i, 2), 16));\n    }\n\n    return r;\n  } // Var key = \"this is a 24 byte key !!\";\n  // Var message = \"This is a test message\";\n  // Var ciphertext = des (key, message, 1, 0);\n  // Document.writeln (\"DES Test: \" + stringToHex (ciphertext));\n  // export common js / node else browser\n\n\n  if ( true && typeof module.exports !== 'undefined') {\n    var desExport = {\n      des: des,\n      des_createKeys: des_createKeys,\n      stringToHex: stringToHex,\n      hexToString: hexToString\n    };\n    module.exports = desExport;\n  } else {\n    window.des = des;\n    window.des_createKeys = des_createKeys;\n    window.stringToHex = stringToHex;\n    window.hexToString = hexToString;\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9kZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9kZXMuanM/MDM0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBQYXVsIFRlcm8sIEp1bHkgMjAwMVxuLy8gaHR0cDovL3d3dy50ZXJvLmNvLnVrL2Rlcy9cbi8vXG4vLyBPcHRpbWlzZWQgZm9yIHBlcmZvcm1hbmNlIHdpdGggbGFyZ2UgYmxvY2tzIGJ5IE1pY2hhZWwgSGF5d29ydGgsIE5vdmVtYmVyIDIwMDFcbi8vIGh0dHA6Ly93d3cubmV0ZGVhbGluZy5jb21cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkRcbi8vIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuLy8gSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0Vcbi8vIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4vLyBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuLy8gREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbi8vIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuLy8gSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1Rcbi8vIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVlcbi8vIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0Zcbi8vIFNVQ0ggREFNQUdFLlxuKCAoKSA9PiB7XG4gICAgLy8gRGVzXG4gICAgLy8gVGhpcyB0YWtlcyB0aGUga2V5LCB0aGUgbWVzc2FnZSwgYW5kIHdoZXRoZXIgdG8gZW5jcnlwdCBvciBkZWNyeXB0XG4gICAgZnVuY3Rpb24gZGVzKCBrZXksIG1lc3NhZ2UsIGVuY3J5cHQsIG1vZGUsIGl2LCBwYWRkaW5nICkge1xuICAgICAgICAvLyBEZWNsYXJpbmcgdGhpcyBsb2NhbGx5IHNwZWVkcyB0aGluZ3MgdXAgYSBiaXRcbiAgICAgICAgdmFyIHNwZnVuY3Rpb24xID0gbmV3IEFycmF5ICggMHgxMDEwNDAwLDAsMHgxMDAwMCwweDEwMTA0MDQsMHgxMDEwMDA0LDB4MTA0MDQsMHg0LDB4MTAwMDAsMHg0MDAsMHgxMDEwNDAwLDB4MTAxMDQwNCwweDQwMCwweDEwMDA0MDQsMHgxMDEwMDA0LDB4MTAwMDAwMCwweDQsMHg0MDQsMHgxMDAwNDAwLDB4MTAwMDQwMCwweDEwNDAwLDB4MTA0MDAsMHgxMDEwMDAwLDB4MTAxMDAwMCwweDEwMDA0MDQsMHgxMDAwNCwweDEwMDAwMDQsMHgxMDAwMDA0LDB4MTAwMDQsMCwweDQwNCwweDEwNDA0LDB4MTAwMDAwMCwweDEwMDAwLDB4MTAxMDQwNCwweDQsMHgxMDEwMDAwLDB4MTAxMDQwMCwweDEwMDAwMDAsMHgxMDAwMDAwLDB4NDAwLDB4MTAxMDAwNCwweDEwMDAwLDB4MTA0MDAsMHgxMDAwMDA0LDB4NDAwLDB4NCwweDEwMDA0MDQsMHgxMDQwNCwweDEwMTA0MDQsMHgxMDAwNCwweDEwMTAwMDAsMHgxMDAwNDA0LDB4MTAwMDAwNCwweDQwNCwweDEwNDA0LDB4MTAxMDQwMCwweDQwNCwweDEwMDA0MDAsMHgxMDAwNDAwLDAsMHgxMDAwNCwweDEwNDAwLDAsMHgxMDEwMDA0ICk7XG4gICAgICAgIHZhciBzcGZ1bmN0aW9uMiA9IG5ldyBBcnJheSAoIC0weDdmZWY3ZmUwLC0weDdmZmY4MDAwLDB4ODAwMCwweDEwODAyMCwweDEwMDAwMCwweDIwLC0weDdmZWZmZmUwLC0weDdmZmY3ZmUwLC0weDdmZmZmZmUwLC0weDdmZWY3ZmUwLC0weDdmZWY4MDAwLC0weDgwMDAwMDAwLC0weDdmZmY4MDAwLDB4MTAwMDAwLDB4MjAsLTB4N2ZlZmZmZTAsMHgxMDgwMDAsMHgxMDAwMjAsLTB4N2ZmZjdmZTAsMCwtMHg4MDAwMDAwMCwweDgwMDAsMHgxMDgwMjAsLTB4N2ZmMDAwMDAsMHgxMDAwMjAsLTB4N2ZmZmZmZTAsMCwweDEwODAwMCwweDgwMjAsLTB4N2ZlZjgwMDAsLTB4N2ZmMDAwMDAsMHg4MDIwLDAsMHgxMDgwMjAsLTB4N2ZlZmZmZTAsMHgxMDAwMDAsLTB4N2ZmZjdmZTAsLTB4N2ZmMDAwMDAsLTB4N2ZlZjgwMDAsMHg4MDAwLC0weDdmZjAwMDAwLC0weDdmZmY4MDAwLDB4MjAsLTB4N2ZlZjdmZTAsMHgxMDgwMjAsMHgyMCwweDgwMDAsLTB4ODAwMDAwMDAsMHg4MDIwLC0weDdmZWY4MDAwLDB4MTAwMDAwLC0weDdmZmZmZmUwLDB4MTAwMDIwLC0weDdmZmY3ZmUwLC0weDdmZmZmZmUwLDB4MTAwMDIwLDB4MTA4MDAwLDAsLTB4N2ZmZjgwMDAsMHg4MDIwLC0weDgwMDAwMDAwLC0weDdmZWZmZmUwLC0weDdmZWY3ZmUwLDB4MTA4MDAwICk7XG4gICAgICAgIHZhciBzcGZ1bmN0aW9uMyA9IG5ldyBBcnJheSAoIDB4MjA4LDB4ODAyMDIwMCwwLDB4ODAyMDAwOCwweDgwMDAyMDAsMCwweDIwMjA4LDB4ODAwMDIwMCwweDIwMDA4LDB4ODAwMDAwOCwweDgwMDAwMDgsMHgyMDAwMCwweDgwMjAyMDgsMHgyMDAwOCwweDgwMjAwMDAsMHgyMDgsMHg4MDAwMDAwLDB4OCwweDgwMjAyMDAsMHgyMDAsMHgyMDIwMCwweDgwMjAwMDAsMHg4MDIwMDA4LDB4MjAyMDgsMHg4MDAwMjA4LDB4MjAyMDAsMHgyMDAwMCwweDgwMDAyMDgsMHg4LDB4ODAyMDIwOCwweDIwMCwweDgwMDAwMDAsMHg4MDIwMjAwLDB4ODAwMDAwMCwweDIwMDA4LDB4MjA4LDB4MjAwMDAsMHg4MDIwMjAwLDB4ODAwMDIwMCwwLDB4MjAwLDB4MjAwMDgsMHg4MDIwMjA4LDB4ODAwMDIwMCwweDgwMDAwMDgsMHgyMDAsMCwweDgwMjAwMDgsMHg4MDAwMjA4LDB4MjAwMDAsMHg4MDAwMDAwLDB4ODAyMDIwOCwweDgsMHgyMDIwOCwweDIwMjAwLDB4ODAwMDAwOCwweDgwMjAwMDAsMHg4MDAwMjA4LDB4MjA4LDB4ODAyMDAwMCwweDIwMjA4LDB4OCwweDgwMjAwMDgsMHgyMDIwMCApO1xuICAgICAgICB2YXIgc3BmdW5jdGlvbjQgPSBuZXcgQXJyYXkgKCAweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODAsMHg4MDAwODEsMHg4MDAwMDEsMHgyMDAxLDAsMHg4MDIwMDAsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDB4ODAwMDgwLDB4ODAwMDAxLDB4MSwweDIwMDAsMHg4MDAwMDAsMHg4MDIwMDEsMHg4MCwweDgwMDAwMCwweDIwMDEsMHgyMDgwLDB4ODAwMDgxLDB4MSwweDIwODAsMHg4MDAwODAsMHgyMDAwLDB4ODAyMDgwLDB4ODAyMDgxLDB4ODEsMHg4MDAwODAsMHg4MDAwMDEsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDAsMHg4MDIwMDAsMHgyMDgwLDB4ODAwMDgwLDB4ODAwMDgxLDB4MSwweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODEsMHg4MSwweDEsMHgyMDAwLDB4ODAwMDAxLDB4MjAwMSwweDgwMjA4MCwweDgwMDA4MSwweDIwMDEsMHgyMDgwLDB4ODAwMDAwLDB4ODAyMDAxLDB4ODAsMHg4MDAwMDAsMHgyMDAwLDB4ODAyMDgwICk7XG4gICAgICAgIHZhciBzcGZ1bmN0aW9uNSA9IG5ldyBBcnJheSAoIDB4MTAwLDB4MjA4MDEwMCwweDIwODAwMDAsMHg0MjAwMDEwMCwweDgwMDAwLDB4MTAwLDB4NDAwMDAwMDAsMHgyMDgwMDAwLDB4NDAwODAxMDAsMHg4MDAwMCwweDIwMDAxMDAsMHg0MDA4MDEwMCwweDQyMDAwMTAwLDB4NDIwODAwMDAsMHg4MDEwMCwweDQwMDAwMDAwLDB4MjAwMDAwMCwweDQwMDgwMDAwLDB4NDAwODAwMDAsMCwweDQwMDAwMTAwLDB4NDIwODAxMDAsMHg0MjA4MDEwMCwweDIwMDAxMDAsMHg0MjA4MDAwMCwweDQwMDAwMTAwLDAsMHg0MjAwMDAwMCwweDIwODAxMDAsMHgyMDAwMDAwLDB4NDIwMDAwMDAsMHg4MDEwMCwweDgwMDAwLDB4NDIwMDAxMDAsMHgxMDAsMHgyMDAwMDAwLDB4NDAwMDAwMDAsMHgyMDgwMDAwLDB4NDIwMDAxMDAsMHg0MDA4MDEwMCwweDIwMDAxMDAsMHg0MDAwMDAwMCwweDQyMDgwMDAwLDB4MjA4MDEwMCwweDQwMDgwMTAwLDB4MTAwLDB4MjAwMDAwMCwweDQyMDgwMDAwLDB4NDIwODAxMDAsMHg4MDEwMCwweDQyMDAwMDAwLDB4NDIwODAxMDAsMHgyMDgwMDAwLDAsMHg0MDA4MDAwMCwweDQyMDAwMDAwLDB4ODAxMDAsMHgyMDAwMTAwLDB4NDAwMDAxMDAsMHg4MDAwMCwwLDB4NDAwODAwMDAsMHgyMDgwMTAwLDB4NDAwMDAxMDAgKTtcbiAgICAgICAgdmFyIHNwZnVuY3Rpb242ID0gbmV3IEFycmF5ICggMHgyMDAwMDAxMCwweDIwNDAwMDAwLDB4NDAwMCwweDIwNDA0MDEwLDB4MjA0MDAwMDAsMHgxMCwweDIwNDA0MDEwLDB4NDAwMDAwLDB4MjAwMDQwMDAsMHg0MDQwMTAsMHg0MDAwMDAsMHgyMDAwMDAxMCwweDQwMDAxMCwweDIwMDA0MDAwLDB4MjAwMDAwMDAsMHg0MDEwLDAsMHg0MDAwMTAsMHgyMDAwNDAxMCwweDQwMDAsMHg0MDQwMDAsMHgyMDAwNDAxMCwweDEwLDB4MjA0MDAwMTAsMHgyMDQwMDAxMCwwLDB4NDA0MDEwLDB4MjA0MDQwMDAsMHg0MDEwLDB4NDA0MDAwLDB4MjA0MDQwMDAsMHgyMDAwMDAwMCwweDIwMDA0MDAwLDB4MTAsMHgyMDQwMDAxMCwweDQwNDAwMCwweDIwNDA0MDEwLDB4NDAwMDAwLDB4NDAxMCwweDIwMDAwMDEwLDB4NDAwMDAwLDB4MjAwMDQwMDAsMHgyMDAwMDAwMCwweDQwMTAsMHgyMDAwMDAxMCwweDIwNDA0MDEwLDB4NDA0MDAwLDB4MjA0MDAwMDAsMHg0MDQwMTAsMHgyMDQwNDAwMCwwLDB4MjA0MDAwMTAsMHgxMCwweDQwMDAsMHgyMDQwMDAwMCwweDQwNDAxMCwweDQwMDAsMHg0MDAwMTAsMHgyMDAwNDAxMCwwLDB4MjA0MDQwMDAsMHgyMDAwMDAwMCwweDQwMDAxMCwweDIwMDA0MDEwICk7XG4gICAgICAgIHZhciBzcGZ1bmN0aW9uNyA9IG5ldyBBcnJheSAoIDB4MjAwMDAwLDB4NDIwMDAwMiwweDQwMDA4MDIsMCwweDgwMCwweDQwMDA4MDIsMHgyMDA4MDIsMHg0MjAwODAwLDB4NDIwMDgwMiwweDIwMDAwMCwwLDB4NDAwMDAwMiwweDIsMHg0MDAwMDAwLDB4NDIwMDAwMiwweDgwMiwweDQwMDA4MDAsMHgyMDA4MDIsMHgyMDAwMDIsMHg0MDAwODAwLDB4NDAwMDAwMiwweDQyMDAwMDAsMHg0MjAwODAwLDB4MjAwMDAyLDB4NDIwMDAwMCwweDgwMCwweDgwMiwweDQyMDA4MDIsMHgyMDA4MDAsMHgyLDB4NDAwMDAwMCwweDIwMDgwMCwweDQwMDAwMDAsMHgyMDA4MDAsMHgyMDAwMDAsMHg0MDAwODAyLDB4NDAwMDgwMiwweDQyMDAwMDIsMHg0MjAwMDAyLDB4MiwweDIwMDAwMiwweDQwMDAwMDAsMHg0MDAwODAwLDB4MjAwMDAwLDB4NDIwMDgwMCwweDgwMiwweDIwMDgwMiwweDQyMDA4MDAsMHg4MDIsMHg0MDAwMDAyLDB4NDIwMDgwMiwweDQyMDAwMDAsMHgyMDA4MDAsMCwweDIsMHg0MjAwODAyLDAsMHgyMDA4MDIsMHg0MjAwMDAwLDB4ODAwLDB4NDAwMDAwMiwweDQwMDA4MDAsMHg4MDAsMHgyMDAwMDIgKTtcbiAgICAgICAgdmFyIHNwZnVuY3Rpb244ID0gbmV3IEFycmF5ICggMHgxMDAwMTA0MCwweDEwMDAsMHg0MDAwMCwweDEwMDQxMDQwLDB4MTAwMDAwMDAsMHgxMDAwMTA0MCwweDQwLDB4MTAwMDAwMDAsMHg0MDA0MCwweDEwMDQwMDAwLDB4MTAwNDEwNDAsMHg0MTAwMCwweDEwMDQxMDAwLDB4NDEwNDAsMHgxMDAwLDB4NDAsMHgxMDA0MDAwMCwweDEwMDAwMDQwLDB4MTAwMDEwMDAsMHgxMDQwLDB4NDEwMDAsMHg0MDA0MCwweDEwMDQwMDQwLDB4MTAwNDEwMDAsMHgxMDQwLDAsMCwweDEwMDQwMDQwLDB4MTAwMDAwNDAsMHgxMDAwMTAwMCwweDQxMDQwLDB4NDAwMDAsMHg0MTA0MCwweDQwMDAwLDB4MTAwNDEwMDAsMHgxMDAwLDB4NDAsMHgxMDA0MDA0MCwweDEwMDAsMHg0MTA0MCwweDEwMDAxMDAwLDB4NDAsMHgxMDAwMDA0MCwweDEwMDQwMDAwLDB4MTAwNDAwNDAsMHgxMDAwMDAwMCwweDQwMDAwLDB4MTAwMDEwNDAsMCwweDEwMDQxMDQwLDB4NDAwNDAsMHgxMDAwMDA0MCwweDEwMDQwMDAwLDB4MTAwMDEwMDAsMHgxMDAwMTA0MCwwLDB4MTAwNDEwNDAsMHg0MTAwMCwweDQxMDAwLDB4MTA0MCwweDEwNDAsMHg0MDA0MCwweDEwMDAwMDAwLDB4MTAwNDEwMDAgKTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIDE2IG9yIDQ4IHN1YmtleXMgd2Ugd2lsbCBuZWVkXG4gICAgICAgIHZhciBrZXlzID0gZGVzX2NyZWF0ZUtleXMgKCBrZXkgKTtcbiAgICAgICAgdmFyIG09MCwgaSwgaiwgdGVtcCwgdGVtcDIsIHJpZ2h0MSwgcmlnaHQyLCBsZWZ0LCByaWdodCwgbG9vcGluZztcbiAgICAgICAgdmFyIGNiY2xlZnQsIGNiY2xlZnQyLCBjYmNyaWdodCwgY2JjcmlnaHQyO1xuICAgICAgICB2YXIgZW5kbG9vcCwgbG9vcGluYztcbiAgICAgICAgdmFyIGxlbiA9IG1lc3NhZ2UubGVuZ3RoO1xuICAgICAgICB2YXIgY2h1bmsgPSAwO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIGxvb3BzIGZvciBzaW5nbGUgYW5kIHRyaXBsZSBkZXNcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBrZXlzLmxlbmd0aCA9PSAzMiA/IDMgOiA5OyAvLyBTaW5nbGUgb3IgdHJpcGxlIGRlc1xuICAgICAgICBpZiAoIGl0ZXJhdGlvbnMgPT0gMyApIHtcbiAgICAgICAgICAgIGxvb3BpbmcgPSBlbmNyeXB0ID8gbmV3IEFycmF5ICggMCwgMzIsIDIgKSA6IG5ldyBBcnJheSAoIDMwLCAtMiwgLTIgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvb3BpbmcgPSBlbmNyeXB0ID8gbmV3IEFycmF5ICggMCwgMzIsIDIsIDYyLCAzMCwgLTIsIDY0LCA5NiwgMiApIDogbmV3IEFycmF5ICggOTQsIDYyLCAtMiwgMzIsIDY0LCAyLCAzMCwgLTIsIC0yICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYWQgdGhlIG1lc3NhZ2UgZGVwZW5kaW5nIG9uIHRoZSBwYWRkaW5nIHBhcmFtZXRlclxuICAgICAgICBpZiAoIHBhZGRpbmcgPT0gMiApIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gJyAgICAgICAgJztcbiAgICAgICAgfSAvLyBQYWQgdGhlIG1lc3NhZ2Ugd2l0aCBzcGFjZXNcbiAgICAgICAgZWxzZSBpZiAoIHBhZGRpbmcgPT0gMSApIHtcbiAgICAgICAgICAgIHRlbXAgPSA4LSggbGVuJTggKTsgbWVzc2FnZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlICggdGVtcCx0ZW1wLHRlbXAsdGVtcCx0ZW1wLHRlbXAsdGVtcCx0ZW1wICk7IGlmICggdGVtcD09OCApIHtcbiAgICAgICAgICAgICAgICBsZW4rPTg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gUEtDUzcgcGFkZGluZ1xuICAgICAgICBlbHNlIGlmICggIXBhZGRpbmcgKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9ICdcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDAnO1xuICAgICAgICB9IC8vIFBhZCB0aGUgbWVzc2FnZSBvdXQgd2l0aCBudWxsIGJ5dGVzXG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIHJlc3VsdCBoZXJlXG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIHRlbXByZXN1bHQgPSAnJztcblxuICAgICAgICBpZiAoIG1vZGUgPT0gMSApIHsgLy8gQ0JDIG1vZGVcbiAgICAgICAgICAgIGNiY2xlZnQgPSAoIGl2LmNoYXJDb2RlQXQoIG0rKyApIDw8IDI0ICkgfCAoIGl2LmNoYXJDb2RlQXQoIG0rKyApIDw8IDE2ICkgfCAoIGl2LmNoYXJDb2RlQXQoIG0rKyApIDw8IDggKSB8IGl2LmNoYXJDb2RlQXQoIG0rKyApO1xuICAgICAgICAgICAgY2JjcmlnaHQgPSAoIGl2LmNoYXJDb2RlQXQoIG0rKyApIDw8IDI0ICkgfCAoIGl2LmNoYXJDb2RlQXQoIG0rKyApIDw8IDE2ICkgfCAoIGl2LmNoYXJDb2RlQXQoIG0rKyApIDw8IDggKSB8IGl2LmNoYXJDb2RlQXQoIG0rKyApO1xuICAgICAgICAgICAgbT0wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggNjQgYml0IGNodW5rIG9mIHRoZSBtZXNzYWdlXG4gICAgICAgIHdoaWxlICggbSA8IGxlbiApIHtcbiAgICAgICAgICAgIGxlZnQgPSAoIG1lc3NhZ2UuY2hhckNvZGVBdCggbSsrICkgPDwgMjQgKSB8ICggbWVzc2FnZS5jaGFyQ29kZUF0KCBtKysgKSA8PCAxNiApIHwgKCBtZXNzYWdlLmNoYXJDb2RlQXQoIG0rKyApIDw8IDggKSB8IG1lc3NhZ2UuY2hhckNvZGVBdCggbSsrICk7XG4gICAgICAgICAgICByaWdodCA9ICggbWVzc2FnZS5jaGFyQ29kZUF0KCBtKysgKSA8PCAyNCApIHwgKCBtZXNzYWdlLmNoYXJDb2RlQXQoIG0rKyApIDw8IDE2ICkgfCAoIG1lc3NhZ2UuY2hhckNvZGVBdCggbSsrICkgPDwgOCApIHwgbWVzc2FnZS5jaGFyQ29kZUF0KCBtKysgKTtcblxuICAgICAgICAgICAgLy8gRm9yIENpcGhlciBCbG9jayBDaGFpbmluZyBtb2RlLCB4b3IgdGhlIG1lc3NhZ2Ugd2l0aCB0aGUgcHJldmlvdXMgcmVzdWx0XG4gICAgICAgICAgICBpZiAoIG1vZGUgPT0gMSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGVuY3J5cHQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgXj0gY2JjbGVmdDsgcmlnaHQgXj0gY2JjcmlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2JjbGVmdDIgPSBjYmNsZWZ0OyBjYmNyaWdodDIgPSBjYmNyaWdodDsgY2JjbGVmdCA9IGxlZnQ7IGNiY3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJzdCBlYWNoIDY0IGJ1dCBjaHVuayBvZiB0aGUgbWVzc2FnZSBtdXN0IGJlIHBlcm11dGVkIGFjY29yZGluZyB0byBJUFxuICAgICAgICAgICAgdGVtcCA9ICggKCBsZWZ0ID4+PiA0ICkgXiByaWdodCApICYgMHgwZjBmMGYwZjsgcmlnaHQgXj0gdGVtcDsgbGVmdCBePSAoIHRlbXAgPDwgNCApO1xuICAgICAgICAgICAgdGVtcCA9ICggKCBsZWZ0ID4+PiAxNiApIF4gcmlnaHQgKSAmIDB4MDAwMGZmZmY7IHJpZ2h0IF49IHRlbXA7IGxlZnQgXj0gKCB0ZW1wIDw8IDE2ICk7XG4gICAgICAgICAgICB0ZW1wID0gKCAoIHJpZ2h0ID4+PiAyICkgXiBsZWZ0ICkgJiAweDMzMzMzMzMzOyBsZWZ0IF49IHRlbXA7IHJpZ2h0IF49ICggdGVtcCA8PCAyICk7XG4gICAgICAgICAgICB0ZW1wID0gKCAoIHJpZ2h0ID4+PiA4ICkgXiBsZWZ0ICkgJiAweDAwZmYwMGZmOyBsZWZ0IF49IHRlbXA7IHJpZ2h0IF49ICggdGVtcCA8PCA4ICk7XG4gICAgICAgICAgICB0ZW1wID0gKCAoIGxlZnQgPj4+IDEgKSBeIHJpZ2h0ICkgJiAweDU1NTU1NTU1OyByaWdodCBePSB0ZW1wOyBsZWZ0IF49ICggdGVtcCA8PCAxICk7XG5cbiAgICAgICAgICAgIGxlZnQgPSAoICggbGVmdCA8PCAxICkgfCAoIGxlZnQgPj4+IDMxICkgKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gKCAoIHJpZ2h0IDw8IDEgKSB8ICggcmlnaHQgPj4+IDMxICkgKTtcblxuICAgICAgICAgICAgLy8gRG8gdGhpcyBlaXRoZXIgMSBvciAzIHRpbWVzIGZvciBlYWNoIGNodW5rIG9mIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICBmb3IgKCBqPTA7IGo8aXRlcmF0aW9uczsgais9MyApIHtcbiAgICAgICAgICAgICAgICBlbmRsb29wID0gbG9vcGluZ1sgaisxIF07XG4gICAgICAgICAgICAgICAgbG9vcGluYyA9IGxvb3BpbmdbIGorMiBdO1xuICAgICAgICAgICAgICAgIC8vIE5vdyBnbyB0aHJvdWdoIGFuZCBwZXJmb3JtIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb25cbiAgICAgICAgICAgICAgICBmb3IgKCBpPWxvb3BpbmdbIGogXTsgaSE9ZW5kbG9vcDsgaSs9bG9vcGluYyApIHsgLy8gRm9yIGVmZmljaWVuY3lcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQxID0gcmlnaHQgXiBrZXlzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0MiA9ICggKCByaWdodCA+Pj4gNCApIHwgKCByaWdodCA8PCAyOCApICkgXiBrZXlzWyBpKzEgXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBhdHRhaW5lZCBieSBwYXNzaW5nIHRoZXNlIGJ5dGVzIHRocm91Z2ggdGhlIFMgc2VsZWN0aW9uIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRlbXAgXiAoIHNwZnVuY3Rpb24yWyAoIHJpZ2h0MSA+Pj4gMjQgKSAmIDB4M2YgXSB8IHNwZnVuY3Rpb240WyAoIHJpZ2h0MSA+Pj4gMTYgKSAmIDB4M2YgXSB8XG4gICAgICAgICAgICAgICAgICBzcGZ1bmN0aW9uNlsgKCByaWdodDEgPj4+IDggKSAmIDB4M2YgXSB8IHNwZnVuY3Rpb244WyByaWdodDEgJiAweDNmIF0gfFxuICAgICAgICAgICAgICAgICAgc3BmdW5jdGlvbjFbICggcmlnaHQyID4+PiAyNCApICYgMHgzZiBdIHwgc3BmdW5jdGlvbjNbICggcmlnaHQyID4+PiAxNiApICYgMHgzZiBdIHxcbiAgICAgICAgICAgICAgICAgIHNwZnVuY3Rpb241WyAoIHJpZ2h0MiA+Pj4gOCApICYgMHgzZiBdIHwgc3BmdW5jdGlvbjdbIHJpZ2h0MiAmIDB4M2YgXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wID0gbGVmdDsgbGVmdCA9IHJpZ2h0OyByaWdodCA9IHRlbXA7IC8vIFVucmV2ZXJzZSBsZWZ0IGFuZCByaWdodFxuICAgICAgICAgICAgfSAvLyBGb3IgZWl0aGVyIDEgb3IgMyBpdGVyYXRpb25zXG5cbiAgICAgICAgICAgIC8vIE1vdmUgdGhlbiBlYWNoIG9uZSBiaXQgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICBsZWZ0ID0gKCAoIGxlZnQgPj4+IDEgKSB8ICggbGVmdCA8PCAzMSApICk7XG4gICAgICAgICAgICByaWdodCA9ICggKCByaWdodCA+Pj4gMSApIHwgKCByaWdodCA8PCAzMSApICk7XG5cbiAgICAgICAgICAgIC8vIE5vdyBwZXJmb3JtIElQLTEsIHdoaWNoIGlzIElQIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIHRlbXAgPSAoICggbGVmdCA+Pj4gMSApIF4gcmlnaHQgKSAmIDB4NTU1NTU1NTU7IHJpZ2h0IF49IHRlbXA7IGxlZnQgXj0gKCB0ZW1wIDw8IDEgKTtcbiAgICAgICAgICAgIHRlbXAgPSAoICggcmlnaHQgPj4+IDggKSBeIGxlZnQgKSAmIDB4MDBmZjAwZmY7IGxlZnQgXj0gdGVtcDsgcmlnaHQgXj0gKCB0ZW1wIDw8IDggKTtcbiAgICAgICAgICAgIHRlbXAgPSAoICggcmlnaHQgPj4+IDIgKSBeIGxlZnQgKSAmIDB4MzMzMzMzMzM7IGxlZnQgXj0gdGVtcDsgcmlnaHQgXj0gKCB0ZW1wIDw8IDIgKTtcbiAgICAgICAgICAgIHRlbXAgPSAoICggbGVmdCA+Pj4gMTYgKSBeIHJpZ2h0ICkgJiAweDAwMDBmZmZmOyByaWdodCBePSB0ZW1wOyBsZWZ0IF49ICggdGVtcCA8PCAxNiApO1xuICAgICAgICAgICAgdGVtcCA9ICggKCBsZWZ0ID4+PiA0ICkgXiByaWdodCApICYgMHgwZjBmMGYwZjsgcmlnaHQgXj0gdGVtcDsgbGVmdCBePSAoIHRlbXAgPDwgNCApO1xuXG4gICAgICAgICAgICAvLyBGb3IgQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUsIHhvciB0aGUgbWVzc2FnZSB3aXRoIHRoZSBwcmV2aW91cyByZXN1bHRcbiAgICAgICAgICAgIGlmICggbW9kZSA9PSAxICkge1xuICAgICAgICAgICAgICAgIGlmICggZW5jcnlwdCApIHtcbiAgICAgICAgICAgICAgICAgICAgY2JjbGVmdCA9IGxlZnQ7IGNiY3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCBePSBjYmNsZWZ0MjsgcmlnaHQgXj0gY2JjcmlnaHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoICggbGVmdD4+PjI0ICksICggKCBsZWZ0Pj4+MTYgKSAmIDB4ZmYgKSwgKCAoIGxlZnQ+Pj44ICkgJiAweGZmICksICggbGVmdCAmIDB4ZmYgKSwgKCByaWdodD4+PjI0ICksICggKCByaWdodD4+PjE2ICkgJiAweGZmICksICggKCByaWdodD4+PjggKSAmIDB4ZmYgKSwgKCByaWdodCAmIDB4ZmYgKSApO1xuXG4gICAgICAgICAgICBjaHVuayArPSA4O1xuICAgICAgICAgICAgaWYgKCBjaHVuayA9PSA1MTIgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRlbXByZXN1bHQ7IHRlbXByZXN1bHQgPSAnJzsgY2h1bmsgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIEZvciBldmVyeSA4IGNoYXJhY3RlcnMsIG9yIDY0IGJpdHMgaW4gdGhlIG1lc3NhZ2VcblxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBhcyBhbiBhcnJheVxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgdGVtcHJlc3VsdDtcbiAgICB9IC8vIEVuZCBvZiBkZXNcblxuXG4gICAgLy8gRGVzX2NyZWF0ZUtleXNcbiAgICAvLyBUaGlzIHRha2VzIGFzIGlucHV0IGEgNjQgYml0IGtleSAoZXZlbiB0aG91Z2ggb25seSA1NiBiaXRzIGFyZSB1c2VkKVxuICAgIC8vIEFzIGFuIGFycmF5IG9mIDIgaW50ZWdlcnMsIGFuZCByZXR1cm5zIDE2IDQ4IGJpdCBrZXlzXG4gICAgZnVuY3Rpb24gZGVzX2NyZWF0ZUtleXMoIGtleSApIHtcbiAgICAgICAgLy8gRGVjbGFyaW5nIHRoaXMgbG9jYWxseSBzcGVlZHMgdGhpbmdzIHVwIGEgYml0IC0gT2ggdGhlIGlyb255XG4gICAgICAgIHZhciBsZWZ0LCByaWdodCxcbiAgICAgICAgICAgIHBjMmJ5dGVzMCA9IG5ldyBBcnJheSAoIDAsMHg0LDB4MjAwMDAwMDAsMHgyMDAwMDAwNCwweDEwMDAwLDB4MTAwMDQsMHgyMDAxMDAwMCwweDIwMDEwMDA0LDB4MjAwLDB4MjA0LDB4MjAwMDAyMDAsMHgyMDAwMDIwNCwweDEwMjAwLDB4MTAyMDQsMHgyMDAxMDIwMCwweDIwMDEwMjA0ICksXG4gICAgICAgICAgICBwYzJieXRlczEgPSBuZXcgQXJyYXkgKCAwLDB4MSwweDEwMDAwMCwweDEwMDAwMSwweDQwMDAwMDAsMHg0MDAwMDAxLDB4NDEwMDAwMCwweDQxMDAwMDEsMHgxMDAsMHgxMDEsMHgxMDAxMDAsMHgxMDAxMDEsMHg0MDAwMTAwLDB4NDAwMDEwMSwweDQxMDAxMDAsMHg0MTAwMTAxICksXG4gICAgICAgICAgICBwYzJieXRlczIgPSBuZXcgQXJyYXkgKCAwLDB4OCwweDgwMCwweDgwOCwweDEwMDAwMDAsMHgxMDAwMDA4LDB4MTAwMDgwMCwweDEwMDA4MDgsMCwweDgsMHg4MDAsMHg4MDgsMHgxMDAwMDAwLDB4MTAwMDAwOCwweDEwMDA4MDAsMHgxMDAwODA4ICksXG4gICAgICAgICAgICBwYzJieXRlczMgPSBuZXcgQXJyYXkgKCAwLDB4MjAwMDAwLDB4ODAwMDAwMCwweDgyMDAwMDAsMHgyMDAwLDB4MjAyMDAwLDB4ODAwMjAwMCwweDgyMDIwMDAsMHgyMDAwMCwweDIyMDAwMCwweDgwMjAwMDAsMHg4MjIwMDAwLDB4MjIwMDAsMHgyMjIwMDAsMHg4MDIyMDAwLDB4ODIyMjAwMCApLFxuICAgICAgICAgICAgcGMyYnl0ZXM0ID0gbmV3IEFycmF5ICggMCwweDQwMDAwLDB4MTAsMHg0MDAxMCwwLDB4NDAwMDAsMHgxMCwweDQwMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwICksXG4gICAgICAgICAgICBwYzJieXRlczUgPSBuZXcgQXJyYXkgKCAwLDB4NDAwLDB4MjAsMHg0MjAsMCwweDQwMCwweDIwLDB4NDIwLDB4MjAwMDAwMCwweDIwMDA0MDAsMHgyMDAwMDIwLDB4MjAwMDQyMCwweDIwMDAwMDAsMHgyMDAwNDAwLDB4MjAwMDAyMCwweDIwMDA0MjAgKSxcbiAgICAgICAgICAgIHBjMmJ5dGVzNiA9IG5ldyBBcnJheSAoIDAsMHgxMDAwMDAwMCwweDgwMDAwLDB4MTAwODAwMDAsMHgyLDB4MTAwMDAwMDIsMHg4MDAwMiwweDEwMDgwMDAyLDAsMHgxMDAwMDAwMCwweDgwMDAwLDB4MTAwODAwMDAsMHgyLDB4MTAwMDAwMDIsMHg4MDAwMiwweDEwMDgwMDAyICksXG4gICAgICAgICAgICBwYzJieXRlczcgPSBuZXcgQXJyYXkgKCAwLDB4MTAwMDAsMHg4MDAsMHgxMDgwMCwweDIwMDAwMDAwLDB4MjAwMTAwMDAsMHgyMDAwMDgwMCwweDIwMDEwODAwLDB4MjAwMDAsMHgzMDAwMCwweDIwODAwLDB4MzA4MDAsMHgyMDAyMDAwMCwweDIwMDMwMDAwLDB4MjAwMjA4MDAsMHgyMDAzMDgwMCApLFxuICAgICAgICAgICAgcGMyYnl0ZXM4ID0gbmV3IEFycmF5ICggMCwweDQwMDAwLDAsMHg0MDAwMCwweDIsMHg0MDAwMiwweDIsMHg0MDAwMiwweDIwMDAwMDAsMHgyMDQwMDAwLDB4MjAwMDAwMCwweDIwNDAwMDAsMHgyMDAwMDAyLDB4MjA0MDAwMiwweDIwMDAwMDIsMHgyMDQwMDAyICksXG4gICAgICAgICAgICBwYzJieXRlczkgPSBuZXcgQXJyYXkgKCAwLDB4MTAwMDAwMDAsMHg4LDB4MTAwMDAwMDgsMCwweDEwMDAwMDAwLDB4OCwweDEwMDAwMDA4LDB4NDAwLDB4MTAwMDA0MDAsMHg0MDgsMHgxMDAwMDQwOCwweDQwMCwweDEwMDAwNDAwLDB4NDA4LDB4MTAwMDA0MDggKSxcbiAgICAgICAgICAgIHBjMmJ5dGVzMTAgPSBuZXcgQXJyYXkgKCAwLDB4MjAsMCwweDIwLDB4MTAwMDAwLDB4MTAwMDIwLDB4MTAwMDAwLDB4MTAwMDIwLDB4MjAwMCwweDIwMjAsMHgyMDAwLDB4MjAyMCwweDEwMjAwMCwweDEwMjAyMCwweDEwMjAwMCwweDEwMjAyMCApLFxuICAgICAgICAgICAgcGMyYnl0ZXMxMSA9IG5ldyBBcnJheSAoIDAsMHgxMDAwMDAwLDB4MjAwLDB4MTAwMDIwMCwweDIwMDAwMCwweDEyMDAwMDAsMHgyMDAyMDAsMHgxMjAwMjAwLDB4NDAwMDAwMCwweDUwMDAwMDAsMHg0MDAwMjAwLDB4NTAwMDIwMCwweDQyMDAwMDAsMHg1MjAwMDAwLDB4NDIwMDIwMCwweDUyMDAyMDAgKSxcbiAgICAgICAgICAgIHBjMmJ5dGVzMTIgPSBuZXcgQXJyYXkgKCAwLDB4MTAwMCwweDgwMDAwMDAsMHg4MDAxMDAwLDB4ODAwMDAsMHg4MTAwMCwweDgwODAwMDAsMHg4MDgxMDAwLDB4MTAsMHgxMDEwLDB4ODAwMDAxMCwweDgwMDEwMTAsMHg4MDAxMCwweDgxMDEwLDB4ODA4MDAxMCwweDgwODEwMTAgKSxcbiAgICAgICAgICAgIHBjMmJ5dGVzMTMgPSBuZXcgQXJyYXkgKCAwLDB4NCwweDEwMCwweDEwNCwwLDB4NCwweDEwMCwweDEwNCwweDEsMHg1LDB4MTAxLDB4MTA1LDB4MSwweDUsMHgxMDEsMHgxMDUgKTtcblxuICAgICAgICAvLyBIb3cgbWFueSBpdGVyYXRpb25zICgxIGZvciBkZXMsIDMgZm9yIHRyaXBsZSBkZXMpXG4gICAgICAgIHZhciBpdGVyYXRpb25zID0ga2V5Lmxlbmd0aCA+IDggPyAzIDogMTsgLy8gQ2hhbmdlZCBieSBQYXVsIDE2LzYvMjAwNyB0byB1c2UgVHJpcGxlIERFUyBmb3IgOSsgYnl0ZSBrZXlzXG4gICAgICAgIC8vIFN0b3JlcyB0aGUgcmV0dXJuIGtleXNcbiAgICAgICAgdmFyIGtleXMgPSBuZXcgQXJyYXkgKCAzMiAqIGl0ZXJhdGlvbnMgKTtcbiAgICAgICAgLy8gTm93IGRlZmluZSB0aGUgbGVmdCBzaGlmdHMgd2hpY2ggbmVlZCB0byBiZSBkb25lXG4gICAgICAgIHZhciBzaGlmdHMgPSBuZXcgQXJyYXkgKCAwLCAwLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAxLCAwICk7XG4gICAgICAgIC8vIE90aGVyIHZhcmlhYmxlc1xuICAgICAgICB2YXIgbGVmdHRlbXAsIHJpZ2h0dGVtcCwgbT0wLCBuPTAsIHRlbXA7XG5cbiAgICAgICAgZm9yICggdmFyIGo9MDsgajxpdGVyYXRpb25zOyBqKysgKSB7IC8vIEVpdGhlciAxIG9yIDMgaXRlcmF0aW9uc1xuICAgICAgICAgICAgbGVmdCA9ICgga2V5LmNoYXJDb2RlQXQoIG0rKyApIDw8IDI0ICkgfCAoIGtleS5jaGFyQ29kZUF0KCBtKysgKSA8PCAxNiApIHwgKCBrZXkuY2hhckNvZGVBdCggbSsrICkgPDwgOCApIHwga2V5LmNoYXJDb2RlQXQoIG0rKyApO1xuICAgICAgICAgICAgcmlnaHQgPSAoIGtleS5jaGFyQ29kZUF0KCBtKysgKSA8PCAyNCApIHwgKCBrZXkuY2hhckNvZGVBdCggbSsrICkgPDwgMTYgKSB8ICgga2V5LmNoYXJDb2RlQXQoIG0rKyApIDw8IDggKSB8IGtleS5jaGFyQ29kZUF0KCBtKysgKTtcblxuICAgICAgICAgICAgdGVtcCA9ICggKCBsZWZ0ID4+PiA0ICkgXiByaWdodCApICYgMHgwZjBmMGYwZjsgcmlnaHQgXj0gdGVtcDsgbGVmdCBePSAoIHRlbXAgPDwgNCApO1xuICAgICAgICAgICAgdGVtcCA9ICggKCByaWdodCA+Pj4gLTE2ICkgXiBsZWZ0ICkgJiAweDAwMDBmZmZmOyBsZWZ0IF49IHRlbXA7IHJpZ2h0IF49ICggdGVtcCA8PCAtMTYgKTtcbiAgICAgICAgICAgIHRlbXAgPSAoICggbGVmdCA+Pj4gMiApIF4gcmlnaHQgKSAmIDB4MzMzMzMzMzM7IHJpZ2h0IF49IHRlbXA7IGxlZnQgXj0gKCB0ZW1wIDw8IDIgKTtcbiAgICAgICAgICAgIHRlbXAgPSAoICggcmlnaHQgPj4+IC0xNiApIF4gbGVmdCApICYgMHgwMDAwZmZmZjsgbGVmdCBePSB0ZW1wOyByaWdodCBePSAoIHRlbXAgPDwgLTE2ICk7XG4gICAgICAgICAgICB0ZW1wID0gKCAoIGxlZnQgPj4+IDEgKSBeIHJpZ2h0ICkgJiAweDU1NTU1NTU1OyByaWdodCBePSB0ZW1wOyBsZWZ0IF49ICggdGVtcCA8PCAxICk7XG4gICAgICAgICAgICB0ZW1wID0gKCAoIHJpZ2h0ID4+PiA4ICkgXiBsZWZ0ICkgJiAweDAwZmYwMGZmOyBsZWZ0IF49IHRlbXA7IHJpZ2h0IF49ICggdGVtcCA8PCA4ICk7XG4gICAgICAgICAgICB0ZW1wID0gKCAoIGxlZnQgPj4+IDEgKSBeIHJpZ2h0ICkgJiAweDU1NTU1NTU1OyByaWdodCBePSB0ZW1wOyBsZWZ0IF49ICggdGVtcCA8PCAxICk7XG5cbiAgICAgICAgICAgIC8vIFRoZSByaWdodCBzaWRlIG5lZWRzIHRvIGJlIHNoaWZ0ZWQgYW5kIHRvIGdldCB0aGUgbGFzdCBmb3VyIGJpdHMgb2YgdGhlIGxlZnQgc2lkZVxuICAgICAgICAgICAgdGVtcCA9ICggbGVmdCA8PCA4ICkgfCAoICggcmlnaHQgPj4+IDIwICkgJiAweDAwMDAwMGYwICk7XG4gICAgICAgICAgICAvLyBMZWZ0IG5lZWRzIHRvIGJlIHB1dCB1cHNpZGUgZG93blxuICAgICAgICAgICAgbGVmdCA9ICggcmlnaHQgPDwgMjQgKSB8ICggKCByaWdodCA8PCA4ICkgJiAweGZmMDAwMCApIHwgKCAoIHJpZ2h0ID4+PiA4ICkgJiAweGZmMDAgKSB8ICggKCByaWdodCA+Pj4gMjQgKSAmIDB4ZjAgKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGVtcDtcblxuICAgICAgICAgICAgLy8gTm93IGdvIHRocm91Z2ggYW5kIHBlcmZvcm0gdGhlc2Ugc2hpZnRzIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBrZXlzXG4gICAgICAgICAgICBmb3IgKCB2YXIgaT0wOyBpIDwgc2hpZnRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSBrZXlzIGVpdGhlciBvbmUgb3IgdHdvIGJpdHMgdG8gdGhlIGxlZnRcbiAgICAgICAgICAgICAgICBpZiAoIHNoaWZ0c1sgaSBdICkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKCBsZWZ0IDw8IDIgKSB8ICggbGVmdCA+Pj4gMjYgKTsgcmlnaHQgPSAoIHJpZ2h0IDw8IDIgKSB8ICggcmlnaHQgPj4+IDI2ICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9ICggbGVmdCA8PCAxICkgfCAoIGxlZnQgPj4+IDI3ICk7IHJpZ2h0ID0gKCByaWdodCA8PCAxICkgfCAoIHJpZ2h0ID4+PiAyNyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZWZ0ICY9IC0weGY7IHJpZ2h0ICY9IC0weGY7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3cgYXBwbHkgUEMtMiwgaW4gc3VjaCBhIHdheSB0aGF0IEUgaXMgZWFzaWVyIHdoZW4gZW5jcnlwdGluZyBvciBkZWNyeXB0aW5nXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb252ZXJzaW9uIHdpbGwgbG9vayBsaWtlIFBDLTIgZXhjZXB0IG9ubHkgdGhlIGxhc3QgNiBiaXRzIG9mIGVhY2ggYnl0ZSBhcmUgdXNlZFxuICAgICAgICAgICAgICAgIC8vIFJhdGhlciB0aGFuIDQ4IGNvbnNlY3V0aXZlIGJpdHMgYW5kIHRoZSBvcmRlciBvZiBsaW5lcyB3aWxsIGJlIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgICAgIC8vIEhvdyB0aGUgUyBzZWxlY3Rpb24gZnVuY3Rpb25zIHdpbGwgYmUgYXBwbGllZDogUzIsIFM0LCBTNiwgUzgsIFMxLCBTMywgUzUsIFM3XG4gICAgICAgICAgICAgICAgbGVmdHRlbXAgPSBwYzJieXRlczBbIGxlZnQgPj4+IDI4IF0gfCBwYzJieXRlczFbICggbGVmdCA+Pj4gMjQgKSAmIDB4ZiBdIHxcbiAgICAgICAgICAgICAgICAgIHBjMmJ5dGVzMlsgKCBsZWZ0ID4+PiAyMCApICYgMHhmIF0gfCBwYzJieXRlczNbICggbGVmdCA+Pj4gMTYgKSAmIDB4ZiBdIHxcbiAgICAgICAgICAgICAgICAgIHBjMmJ5dGVzNFsgKCBsZWZ0ID4+PiAxMiApICYgMHhmIF0gfCBwYzJieXRlczVbICggbGVmdCA+Pj4gOCApICYgMHhmIF0gfFxuICAgICAgICAgICAgICAgICAgcGMyYnl0ZXM2WyAoIGxlZnQgPj4+IDQgKSAmIDB4ZiBdO1xuICAgICAgICAgICAgICAgIHJpZ2h0dGVtcCA9IHBjMmJ5dGVzN1sgcmlnaHQgPj4+IDI4IF0gfCBwYzJieXRlczhbICggcmlnaHQgPj4+IDI0ICkgJiAweGYgXSB8XG4gICAgICAgICAgICAgICAgICAgIHBjMmJ5dGVzOVsgKCByaWdodCA+Pj4gMjAgKSAmIDB4ZiBdIHwgcGMyYnl0ZXMxMFsgKCByaWdodCA+Pj4gMTYgKSAmIDB4ZiBdIHxcbiAgICAgICAgICAgICAgICAgICAgcGMyYnl0ZXMxMVsgKCByaWdodCA+Pj4gMTIgKSAmIDB4ZiBdIHwgcGMyYnl0ZXMxMlsgKCByaWdodCA+Pj4gOCApICYgMHhmIF0gfFxuICAgICAgICAgICAgICAgICAgICBwYzJieXRlczEzWyAoIHJpZ2h0ID4+PiA0ICkgJiAweGYgXTtcbiAgICAgICAgICAgICAgICB0ZW1wID0gKCAoIHJpZ2h0dGVtcCA+Pj4gMTYgKSBeIGxlZnR0ZW1wICkgJiAweDAwMDBmZmZmO1xuICAgICAgICAgICAgICAgIGtleXNbIG4rKyBdID0gbGVmdHRlbXAgXiB0ZW1wOyBrZXlzWyBuKysgXSA9IHJpZ2h0dGVtcCBeICggdGVtcCA8PCAxNiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIEZvciBlYWNoIGl0ZXJhdGlvbnNcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBrZXlzIHdlJ3ZlIGNyZWF0ZWRcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSAvLyBFbmQgb2YgZGVzX2NyZWF0ZUtleXNcblxuXG4gICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBURVNUIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGZ1bmN0aW9uIHN0cmluZ1RvSGV4KCBzICkge1xuICAgICAgICB2YXIgciA9ICcweCc7XG4gICAgICAgIHZhciBoZXhlcyA9IG5ldyBBcnJheSAoICcwJywnMScsJzInLCczJywnNCcsJzUnLCc2JywnNycsJzgnLCc5JywnYScsJ2InLCdjJywnZCcsJ2UnLCdmJyApO1xuICAgICAgICBmb3IgKCB2YXIgaT0wOyBpPHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICByICs9IGhleGVzWyBzLmNoYXJDb2RlQXQoIGkgKSA+PiA0IF0gKyBoZXhlc1sgcy5jaGFyQ29kZUF0KCBpICkgJiAweGYgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoZXhUb1N0cmluZyggaCApIHtcbiAgICAgICAgdmFyIHIgPSAnJztcbiAgICAgICAgZm9yICggdmFyIGk9ICggaC5zdWJzdHIoIDAsIDIgKT09JzB4JyApPzI6MDsgaTxoLmxlbmd0aDsgaSs9MiApIHtcbiAgICAgICAgICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoIHBhcnNlSW50ICggaC5zdWJzdHIgKCBpLCAyICksIDE2ICkgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyBWYXIga2V5ID0gXCJ0aGlzIGlzIGEgMjQgYnl0ZSBrZXkgISFcIjtcbiAgICAvLyBWYXIgbWVzc2FnZSA9IFwiVGhpcyBpcyBhIHRlc3QgbWVzc2FnZVwiO1xuICAgIC8vIFZhciBjaXBoZXJ0ZXh0ID0gZGVzIChrZXksIG1lc3NhZ2UsIDEsIDApO1xuICAgIC8vIERvY3VtZW50LndyaXRlbG4gKFwiREVTIFRlc3Q6IFwiICsgc3RyaW5nVG9IZXggKGNpcGhlcnRleHQpKTtcblxuICAgIC8vIGV4cG9ydCBjb21tb24ganMgLyBub2RlIGVsc2UgYnJvd3NlclxuICAgIGlmICggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgdmFyIGRlc0V4cG9ydCA9IHtcbiAgICAgICAgICAgIGRlczogZGVzLFxuICAgICAgICAgICAgZGVzX2NyZWF0ZUtleXM6IGRlc19jcmVhdGVLZXlzLFxuICAgICAgICAgICAgc3RyaW5nVG9IZXg6IHN0cmluZ1RvSGV4LFxuICAgICAgICAgICAgaGV4VG9TdHJpbmc6IGhleFRvU3RyaW5nXG4gICAgICAgIH07XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVzRXhwb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5kZXMgPSBkZXM7XG4gICAgICAgIHdpbmRvdy5kZXNfY3JlYXRlS2V5cyA9IGRlc19jcmVhdGVLZXlzO1xuICAgICAgICB3aW5kb3cuc3RyaW5nVG9IZXggPSBzdHJpbmdUb0hleDtcbiAgICAgICAgd2luZG93LmhleFRvU3RyaW5nID0gaGV4VG9TdHJpbmc7XG4gICAgfVxufSApKCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/des.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/jQueryUiWidget.js":
/*!*********************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/jQueryUiWidget.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\r\n* This is being included becaue form conditions is a jQuery ui dependent if we get rid of that dependancy we can get rid of this. \r\n*jQuery UI - v1.12.1 - 2018-07-17\r\n* http://jqueryui.com\r\n* Includes: widget.js\r\n* Copyright jQuery Foundation and other contributors; Licensed MIT */\n(function (factory) {\n  // Commented out the if/else for our webpack build since these dependencies are right here in the file\n  // And do not need to be loaded as external dependencies\n  //\tif ( typeof define === \"function\" && define.amd ) {\n  //\n  //\t\t// AMD. Register as an anonymous module.\n  //\t\tdefine([ \"jquery\" ], factory );\n  //\t} else {\n  //\n  //\t\t// Browser globals\n  //\t\tfactory( jQuery );\n  //\t}\n  // Browser globals\n  factory(jQuery);\n})(function ($) {\n  $.ui = $.ui || {};\n  var version = $.ui.version = \"1.12.1\";\n  /*!\r\n   * jQuery UI Widget 1.12.1\r\n   * http://jqueryui.com\r\n   *\r\n   * Copyright jQuery Foundation and other contributors\r\n   * Released under the MIT license.\r\n   * http://jquery.org/license\r\n   */\n  //>>label: Widget\n  //>>group: Core\n  //>>description: Provides a factory for creating stateful widgets with a common API.\n  //>>docs: http://api.jqueryui.com/jQuery.widget/\n  //>>demos: http://jqueryui.com/widget/\n\n  var widgetUuid = 0;\n  var widgetSlice = Array.prototype.slice;\n\n  $.cleanData = function (orig) {\n    return function (elems) {\n      var events, elem, i;\n\n      for (i = 0; (elem = elems[i]) != null; i++) {\n        try {\n          // Only trigger remove when necessary to save time\n          events = $._data(elem, \"events\");\n\n          if (events && events.remove) {\n            $(elem).triggerHandler(\"remove\");\n          } // Http://bugs.jquery.com/ticket/8235\n\n        } catch (e) {}\n      }\n\n      orig(elems);\n    };\n  }($.cleanData);\n\n  $.widget = function (name, base, prototype) {\n    var existingConstructor, constructor, basePrototype; // ProxiedPrototype allows the provided prototype to remain unmodified\n    // so that it can be used as a mixin for multiple widgets (#8876)\n\n    var proxiedPrototype = {};\n    var namespace = name.split(\".\")[0];\n    name = name.split(\".\")[1];\n    var fullName = namespace + \"-\" + name;\n\n    if (!prototype) {\n      prototype = base;\n      base = $.Widget;\n    }\n\n    if ($.isArray(prototype)) {\n      prototype = $.extend.apply(null, [{}].concat(prototype));\n    } // Create selector for plugin\n\n\n    $.expr[\":\"][fullName.toLowerCase()] = function (elem) {\n      return !!$.data(elem, fullName);\n    };\n\n    $[namespace] = $[namespace] || {};\n    existingConstructor = $[namespace][name];\n\n    constructor = $[namespace][name] = function (options, element) {\n      // Allow instantiation without \"new\" keyword\n      if (!this._createWidget) {\n        return new constructor(options, element);\n      } // Allow instantiation without initializing for simple inheritance\n      // must use \"new\" keyword (the code above always passes args)\n\n\n      if (arguments.length) {\n        this._createWidget(options, element);\n      }\n    }; // Extend with the existing constructor to carry over any static properties\n\n\n    $.extend(constructor, existingConstructor, {\n      version: prototype.version,\n      // Copy the object used to create the prototype in case we need to\n      // redefine the widget later\n      _proto: $.extend({}, prototype),\n      // Track widgets that inherit from this widget in case this widget is\n      // redefined after a widget inherits from it\n      _childConstructors: []\n    });\n    basePrototype = new base(); // We need to make the options hash a property directly on the new instance\n    // otherwise we'll modify the options hash on the prototype that we're\n    // inheriting from\n\n    basePrototype.options = $.widget.extend({}, basePrototype.options);\n    $.each(prototype, function (prop, value) {\n      if (!$.isFunction(value)) {\n        proxiedPrototype[prop] = value;\n        return;\n      }\n\n      proxiedPrototype[prop] = function () {\n        function _super() {\n          return base.prototype[prop].apply(this, arguments);\n        }\n\n        function _superApply(args) {\n          return base.prototype[prop].apply(this, args);\n        }\n\n        return function () {\n          var __super = this._super;\n          var __superApply = this._superApply;\n          var returnValue;\n          this._super = _super;\n          this._superApply = _superApply;\n          returnValue = value.apply(this, arguments);\n          this._super = __super;\n          this._superApply = __superApply;\n          return returnValue;\n        };\n      }();\n    });\n    constructor.prototype = $.widget.extend(basePrototype, {\n      // TODO: remove support for widgetEventPrefix\n      // always use the name + a colon as the prefix, e.g., draggable:start\n      // don't prefix for widgets that aren't DOM-based\n      widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name\n    }, proxiedPrototype, {\n      constructor: constructor,\n      namespace: namespace,\n      widgetName: name,\n      widgetFullName: fullName\n    }); // If this widget is being redefined then we need to find all widgets that\n    // are inheriting from it and redefine all of them so that they inherit from\n    // the new version of this widget. We're essentially trying to replace one\n    // level in the prototype chain.\n\n    if (existingConstructor) {\n      $.each(existingConstructor._childConstructors, function (i, child) {\n        var childPrototype = child.prototype; // Redefine the child widget using the same prototype that was\n        // originally used, but inherit from the new version of the base\n\n        $.widget(childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto);\n      }); // Remove the list of existing child constructors from the old constructor\n      // so the old child constructors can be garbage collected\n\n      delete existingConstructor._childConstructors;\n    } else {\n      base._childConstructors.push(constructor);\n    }\n\n    $.widget.bridge(name, constructor);\n    return constructor;\n  };\n\n  $.widget.extend = function (target) {\n    var input = widgetSlice.call(arguments, 1);\n    var inputIndex = 0;\n    var inputLength = input.length;\n    var key;\n    var value;\n\n    for (; inputIndex < inputLength; inputIndex++) {\n      for (key in input[inputIndex]) {\n        value = input[inputIndex][key];\n\n        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {\n          // Clone objects\n          if ($.isPlainObject(value)) {\n            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : // Don't extend strings, arrays, etc. with objects\n            $.widget.extend({}, value); // Copy everything else by reference\n          } else {\n            target[key] = value;\n          }\n        }\n      }\n    }\n\n    return target;\n  };\n\n  $.widget.bridge = function (name, object) {\n    var fullName = object.prototype.widgetFullName || name;\n\n    $.fn[name] = function (options) {\n      var isMethodCall = typeof options === \"string\";\n      var args = widgetSlice.call(arguments, 1);\n      var returnValue = this;\n\n      if (isMethodCall) {\n        // If this is an empty collection, we need to have the instance method\n        // return undefined instead of the jQuery instance\n        if (!this.length && options === \"instance\") {\n          returnValue = undefined;\n        } else {\n          this.each(function () {\n            var methodValue;\n            var instance = $.data(this, fullName);\n\n            if (options === \"instance\") {\n              returnValue = instance;\n              return false;\n            }\n\n            if (!instance) {\n              return $.error(\"cannot call methods on \" + name + \" prior to initialization; \" + \"attempted to call method '\" + options + \"'\");\n            }\n\n            if (!$.isFunction(instance[options]) || options.charAt(0) === \"_\") {\n              return $.error(\"no such method '\" + options + \"' for \" + name + \" widget instance\");\n            }\n\n            methodValue = instance[options].apply(instance, args);\n\n            if (methodValue !== instance && methodValue !== undefined) {\n              returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;\n              return false;\n            }\n          });\n        }\n      } else {\n        // Allow multiple hashes to be passed on init\n        if (args.length) {\n          options = $.widget.extend.apply(null, [options].concat(args));\n        }\n\n        this.each(function () {\n          var instance = $.data(this, fullName);\n\n          if (instance) {\n            instance.option(options || {});\n\n            if (instance._init) {\n              instance._init();\n            }\n          } else {\n            $.data(this, fullName, new object(options, this));\n          }\n        });\n      }\n\n      return returnValue;\n    };\n  };\n\n  $.Widget = function ()\n  /* options, element */\n  {};\n\n  $.Widget._childConstructors = [];\n  $.Widget.prototype = {\n    widgetName: \"widget\",\n    widgetEventPrefix: \"\",\n    defaultElement: \"<div>\",\n    options: {\n      classes: {},\n      disabled: false,\n      // Callbacks\n      create: null\n    },\n    _createWidget: function (options, element) {\n      element = $(element || this.defaultElement || this)[0];\n      this.element = $(element);\n      this.uuid = widgetUuid++;\n      this.eventNamespace = \".\" + this.widgetName + this.uuid;\n      this.bindings = $();\n      this.hoverable = $();\n      this.focusable = $();\n      this.classesElementLookup = {};\n\n      if (element !== this) {\n        $.data(element, this.widgetFullName, this);\n\n        this._on(true, this.element, {\n          remove: function (event) {\n            if (event.target === element) {\n              this.destroy();\n            }\n          }\n        });\n\n        this.document = $(element.style ? // Element within the document\n        element.ownerDocument : // Element is window or document\n        element.document || element);\n        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);\n      }\n\n      this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);\n\n      this._create();\n\n      if (this.options.disabled) {\n        this._setOptionDisabled(this.options.disabled);\n      }\n\n      this._trigger(\"create\", null, this._getCreateEventData());\n\n      this._init();\n    },\n    _getCreateOptions: function () {\n      return {};\n    },\n    _getCreateEventData: $.noop,\n    _create: $.noop,\n    _init: $.noop,\n    destroy: function () {\n      var that = this;\n\n      this._destroy();\n\n      $.each(this.classesElementLookup, function (key, value) {\n        that._removeClass(value, key);\n      }); // We can probably remove the unbind calls in 2.0\n      // all event bindings should go through this._on()\n\n      this.element.off(this.eventNamespace).removeData(this.widgetFullName);\n      this.widget().off(this.eventNamespace).removeAttr(\"aria-disabled\"); // Clean up events and states\n\n      this.bindings.off(this.eventNamespace);\n    },\n    _destroy: $.noop,\n    widget: function () {\n      return this.element;\n    },\n    option: function (key, value) {\n      var options = key;\n      var parts;\n      var curOption;\n      var i;\n\n      if (arguments.length === 0) {\n        // Don't return a reference to the internal hash\n        return $.widget.extend({}, this.options);\n      }\n\n      if (typeof key === \"string\") {\n        // Handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\n        options = {};\n        parts = key.split(\".\");\n        key = parts.shift();\n\n        if (parts.length) {\n          curOption = options[key] = $.widget.extend({}, this.options[key]);\n\n          for (i = 0; i < parts.length - 1; i++) {\n            curOption[parts[i]] = curOption[parts[i]] || {};\n            curOption = curOption[parts[i]];\n          }\n\n          key = parts.pop();\n\n          if (arguments.length === 1) {\n            return curOption[key] === undefined ? null : curOption[key];\n          }\n\n          curOption[key] = value;\n        } else {\n          if (arguments.length === 1) {\n            return this.options[key] === undefined ? null : this.options[key];\n          }\n\n          options[key] = value;\n        }\n      }\n\n      this._setOptions(options);\n\n      return this;\n    },\n    _setOptions: function (options) {\n      var key;\n\n      for (key in options) {\n        this._setOption(key, options[key]);\n      }\n\n      return this;\n    },\n    _setOption: function (key, value) {\n      if (key === \"classes\") {\n        this._setOptionClasses(value);\n      }\n\n      this.options[key] = value;\n\n      if (key === \"disabled\") {\n        this._setOptionDisabled(value);\n      }\n\n      return this;\n    },\n    _setOptionClasses: function (value) {\n      var classKey, elements, currentElements;\n\n      for (classKey in value) {\n        currentElements = this.classesElementLookup[classKey];\n\n        if (value[classKey] === this.options.classes[classKey] || !currentElements || !currentElements.length) {\n          continue;\n        } // We are doing this to create a new jQuery object because the _removeClass() call\n        // on the next line is going to destroy the reference to the current elements being\n        // tracked. We need to save a copy of this collection so that we can add the new classes\n        // below.\n\n\n        elements = $(currentElements.get());\n\n        this._removeClass(currentElements, classKey); // We don't use _addClass() here, because that uses this.options.classes\n        // for generating the string of classes. We want to use the value passed in from\n        // _setOption(), this is the new value of the classes option which was passed to\n        // _setOption(). We pass this value directly to _classes().\n\n\n        elements.addClass(this._classes({\n          element: elements,\n          keys: classKey,\n          classes: value,\n          add: true\n        }));\n      }\n    },\n    _setOptionDisabled: function (value) {\n      this._toggleClass(this.widget(), this.widgetFullName + \"-disabled\", null, !!value); // If the widget is becoming disabled, then nothing is interactive\n\n\n      if (value) {\n        this._removeClass(this.hoverable, null, \"ui-state-hover\");\n\n        this._removeClass(this.focusable, null, \"ui-state-focus\");\n      }\n    },\n    enable: function () {\n      return this._setOptions({\n        disabled: false\n      });\n    },\n    disable: function () {\n      return this._setOptions({\n        disabled: true\n      });\n    },\n    _classes: function (options) {\n      var full = [];\n      var that = this;\n      options = $.extend({\n        element: this.element,\n        classes: this.options.classes || {}\n      }, options);\n\n      function processClassString(classes, checkOption) {\n        var current, i;\n\n        for (i = 0; i < classes.length; i++) {\n          current = that.classesElementLookup[classes[i]] || $();\n\n          if (options.add) {\n            current = $($.unique(current.get().concat(options.element.get())));\n          } else {\n            current = $(current.not(options.element).get());\n          }\n\n          that.classesElementLookup[classes[i]] = current;\n          full.push(classes[i]);\n\n          if (checkOption && options.classes[classes[i]]) {\n            full.push(options.classes[classes[i]]);\n          }\n        }\n      }\n\n      this._on(options.element, {\n        \"remove\": \"_untrackClassesElement\"\n      });\n\n      if (options.keys) {\n        processClassString(options.keys.match(/\\S+/g) || [], true);\n      }\n\n      if (options.extra) {\n        processClassString(options.extra.match(/\\S+/g) || []);\n      }\n\n      return full.join(\" \");\n    },\n    _untrackClassesElement: function (event) {\n      var that = this;\n      $.each(that.classesElementLookup, function (key, value) {\n        if ($.inArray(event.target, value) !== -1) {\n          that.classesElementLookup[key] = $(value.not(event.target).get());\n        }\n      });\n    },\n    _removeClass: function (element, keys, extra) {\n      return this._toggleClass(element, keys, extra, false);\n    },\n    _addClass: function (element, keys, extra) {\n      return this._toggleClass(element, keys, extra, true);\n    },\n    _toggleClass: function (element, keys, extra, add) {\n      add = typeof add === \"boolean\" ? add : extra;\n      var shift = typeof element === \"string\" || element === null,\n          options = {\n        extra: shift ? keys : extra,\n        keys: shift ? element : keys,\n        element: shift ? this.element : element,\n        add: add\n      };\n      options.element.toggleClass(this._classes(options), add);\n      return this;\n    },\n    _on: function (suppressDisabledCheck, element, handlers) {\n      var delegateElement;\n      var instance = this; // No suppressDisabledCheck flag, shuffle arguments\n\n      if (typeof suppressDisabledCheck !== \"boolean\") {\n        handlers = element;\n        element = suppressDisabledCheck;\n        suppressDisabledCheck = false;\n      } // No element argument, shuffle and use this.element\n\n\n      if (!handlers) {\n        handlers = element;\n        element = this.element;\n        delegateElement = this.widget();\n      } else {\n        element = delegateElement = $(element);\n        this.bindings = this.bindings.add(element);\n      }\n\n      $.each(handlers, function (event, handler) {\n        function handlerProxy() {\n          // Allow widgets to customize the disabled handling\n          // - disabled as an array instead of boolean\n          // - disabled class as method for disabling individual parts\n          if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass(\"ui-state-disabled\"))) {\n            return;\n          }\n\n          return (typeof handler === \"string\" ? instance[handler] : handler).apply(instance, arguments);\n        } // Copy the guid so direct unbinding works\n\n\n        if (typeof handler !== \"string\") {\n          handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;\n        }\n\n        var match = event.match(/^([\\w:-]*)\\s*(.*)$/);\n        var eventName = match[1] + instance.eventNamespace;\n        var selector = match[2];\n\n        if (selector) {\n          delegateElement.on(eventName, selector, handlerProxy);\n        } else {\n          element.on(eventName, handlerProxy);\n        }\n      });\n    },\n    _off: function (element, eventName) {\n      eventName = (eventName || \"\").split(\" \").join(this.eventNamespace + \" \") + this.eventNamespace;\n      element.off(eventName).off(eventName); // Clear the stack to avoid memory leaks (#10056)\n\n      this.bindings = $(this.bindings.not(element).get());\n      this.focusable = $(this.focusable.not(element).get());\n      this.hoverable = $(this.hoverable.not(element).get());\n    },\n    _delay: function (handler, delay) {\n      function handlerProxy() {\n        return (typeof handler === \"string\" ? instance[handler] : handler).apply(instance, arguments);\n      }\n\n      var instance = this;\n      return setTimeout(handlerProxy, delay || 0);\n    },\n    _hoverable: function (element) {\n      this.hoverable = this.hoverable.add(element);\n\n      this._on(element, {\n        mouseenter: function (event) {\n          this._addClass($(event.currentTarget), null, \"ui-state-hover\");\n        },\n        mouseleave: function (event) {\n          this._removeClass($(event.currentTarget), null, \"ui-state-hover\");\n        }\n      });\n    },\n    _focusable: function (element) {\n      this.focusable = this.focusable.add(element);\n\n      this._on(element, {\n        focusin: function (event) {\n          this._addClass($(event.currentTarget), null, \"ui-state-focus\");\n        },\n        focusout: function (event) {\n          this._removeClass($(event.currentTarget), null, \"ui-state-focus\");\n        }\n      });\n    },\n    _trigger: function (type, event, data) {\n      var prop, orig;\n      var callback = this.options[type];\n      data = data || {};\n      event = $.Event(event);\n      event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(); // The original event may come from any element\n      // so we need to reset the target on the new event\n\n      event.target = this.element[0]; // Copy original event properties over to the new event\n\n      orig = event.originalEvent;\n\n      if (orig) {\n        for (prop in orig) {\n          if (!(prop in event)) {\n            event[prop] = orig[prop];\n          }\n        }\n      }\n\n      this.element.trigger(event, data);\n      return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());\n    }\n  };\n  $.each({\n    show: \"fadeIn\",\n    hide: \"fadeOut\"\n  }, function (method, defaultEffect) {\n    $.Widget.prototype[\"_\" + method] = function (element, options, callback) {\n      if (typeof options === \"string\") {\n        options = {\n          effect: options\n        };\n      }\n\n      var hasOptions;\n      var effectName = !options ? method : options === true || typeof options === \"number\" ? defaultEffect : options.effect || defaultEffect;\n      options = options || {};\n\n      if (typeof options === \"number\") {\n        options = {\n          duration: options\n        };\n      }\n\n      hasOptions = !$.isEmptyObject(options);\n      options.complete = callback;\n\n      if (options.delay) {\n        element.delay(options.delay);\n      }\n\n      if (hasOptions && $.effects && $.effects.effect[effectName]) {\n        element[method](options);\n      } else if (effectName !== method && element[effectName]) {\n        element[effectName](options.duration, options.easing, callback);\n      } else {\n        element.queue(function (next) {\n          $(this)[method]();\n\n          if (callback) {\n            callback.call(element[0]);\n          }\n\n          next();\n        });\n      }\n    };\n  });\n  var widget = $.widget;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9qUXVlcnlVaVdpZGdldC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3d3dy9qcy0zLjIuMi9vbnRyYXBvcnQvb3B0X2Fzc2V0cy9vcHRfYm9pbGVycGxhdGVzL3YzL2pRdWVyeVVpV2lkZ2V0LmpzPzdkZjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiogVGhpcyBpcyBiZWluZyBpbmNsdWRlZCBiZWNhdWUgZm9ybSBjb25kaXRpb25zIGlzIGEgalF1ZXJ5IHVpIGRlcGVuZGVudCBpZiB3ZSBnZXQgcmlkIG9mIHRoYXQgZGVwZW5kYW5jeSB3ZSBjYW4gZ2V0IHJpZCBvZiB0aGlzLiBcclxuKmpRdWVyeSBVSSAtIHYxLjEyLjEgLSAyMDE4LTA3LTE3XHJcbiogaHR0cDovL2pxdWVyeXVpLmNvbVxyXG4qIEluY2x1ZGVzOiB3aWRnZXQuanNcclxuKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yczsgTGljZW5zZWQgTUlUICovXHJcblxyXG4oZnVuY3Rpb24oIGZhY3RvcnkgKSB7XHJcbiAgICAvLyBDb21tZW50ZWQgb3V0IHRoZSBpZi9lbHNlIGZvciBvdXIgd2VicGFjayBidWlsZCBzaW5jZSB0aGVzZSBkZXBlbmRlbmNpZXMgYXJlIHJpZ2h0IGhlcmUgaW4gdGhlIGZpbGVcclxuICAgIC8vIEFuZCBkbyBub3QgbmVlZCB0byBiZSBsb2FkZWQgYXMgZXh0ZXJuYWwgZGVwZW5kZW5jaWVzXHJcbi8vXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xyXG4vL1xyXG4vL1x0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcbi8vXHRcdGRlZmluZShbIFwianF1ZXJ5XCIgXSwgZmFjdG9yeSApO1xyXG4vL1x0fSBlbHNlIHtcclxuLy9cclxuLy9cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXHJcbi8vXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xyXG4vL1x0fVxyXG5cclxuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xyXG4gICAgZmFjdG9yeSggalF1ZXJ5ICk7XHJcbn0oZnVuY3Rpb24oICQgKSB7XHJcblxyXG4kLnVpID0gJC51aSB8fCB7fTtcclxuXHJcbnZhciB2ZXJzaW9uID0gJC51aS52ZXJzaW9uID0gXCIxLjEyLjFcIjtcclxuXHJcblxyXG4vKiFcclxuICogalF1ZXJ5IFVJIFdpZGdldCAxLjEyLjFcclxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICovXHJcblxyXG4vLz4+bGFiZWw6IFdpZGdldFxyXG4vLz4+Z3JvdXA6IENvcmVcclxuLy8+PmRlc2NyaXB0aW9uOiBQcm92aWRlcyBhIGZhY3RvcnkgZm9yIGNyZWF0aW5nIHN0YXRlZnVsIHdpZGdldHMgd2l0aCBhIGNvbW1vbiBBUEkuXHJcbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9qUXVlcnkud2lkZ2V0L1xyXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vd2lkZ2V0L1xyXG5cclxuXHJcblxyXG52YXIgd2lkZ2V0VXVpZCA9IDA7XHJcbnZhciB3aWRnZXRTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcbiQuY2xlYW5EYXRhID0gKCBmdW5jdGlvbiggb3JpZyApIHtcclxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1zICkge1xyXG5cdFx0dmFyIGV2ZW50cywgZWxlbSwgaTtcclxuXHRcdGZvciAoIGkgPSAwOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xyXG5cdFx0XHR0cnkge1xyXG5cclxuXHRcdFx0XHQvLyBPbmx5IHRyaWdnZXIgcmVtb3ZlIHdoZW4gbmVjZXNzYXJ5IHRvIHNhdmUgdGltZVxyXG5cdFx0XHRcdGV2ZW50cyA9ICQuX2RhdGEoIGVsZW0sIFwiZXZlbnRzXCIgKTtcclxuXHRcdFx0XHRpZiAoIGV2ZW50cyAmJiBldmVudHMucmVtb3ZlICkge1xyXG5cdFx0XHRcdFx0JCggZWxlbSApLnRyaWdnZXJIYW5kbGVyKCBcInJlbW92ZVwiICk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODIzNVxyXG5cdFx0XHR9IGNhdGNoICggZSApIHt9XHJcblx0XHR9XHJcblx0XHRvcmlnKCBlbGVtcyApO1xyXG5cdH07XHJcbn0gKSggJC5jbGVhbkRhdGEgKTtcclxuXHJcbiQud2lkZ2V0ID0gZnVuY3Rpb24oIG5hbWUsIGJhc2UsIHByb3RvdHlwZSApIHtcclxuXHR2YXIgZXhpc3RpbmdDb25zdHJ1Y3RvciwgY29uc3RydWN0b3IsIGJhc2VQcm90b3R5cGU7XHJcblxyXG5cdC8vIFByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcclxuXHQvLyBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGFzIGEgbWl4aW4gZm9yIG11bHRpcGxlIHdpZGdldHMgKCM4ODc2KVxyXG5cdHZhciBwcm94aWVkUHJvdG90eXBlID0ge307XHJcblxyXG5cdHZhciBuYW1lc3BhY2UgPSBuYW1lLnNwbGl0KCBcIi5cIiApWyAwIF07XHJcblx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDEgXTtcclxuXHR2YXIgZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XHJcblxyXG5cdGlmICggIXByb3RvdHlwZSApIHtcclxuXHRcdHByb3RvdHlwZSA9IGJhc2U7XHJcblx0XHRiYXNlID0gJC5XaWRnZXQ7XHJcblx0fVxyXG5cclxuXHRpZiAoICQuaXNBcnJheSggcHJvdG90eXBlICkgKSB7XHJcblx0XHRwcm90b3R5cGUgPSAkLmV4dGVuZC5hcHBseSggbnVsbCwgWyB7fSBdLmNvbmNhdCggcHJvdG90eXBlICkgKTtcclxuXHR9XHJcblxyXG5cdC8vIENyZWF0ZSBzZWxlY3RvciBmb3IgcGx1Z2luXHJcblx0JC5leHByWyBcIjpcIiBdWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgZnVsbE5hbWUgKTtcclxuXHR9O1xyXG5cclxuXHQkWyBuYW1lc3BhY2UgXSA9ICRbIG5hbWVzcGFjZSBdIHx8IHt9O1xyXG5cdGV4aXN0aW5nQ29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdO1xyXG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xyXG5cclxuXHRcdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcIm5ld1wiIGtleXdvcmRcclxuXHRcdGlmICggIXRoaXMuX2NyZWF0ZVdpZGdldCApIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBjb25zdHJ1Y3Rvciggb3B0aW9ucywgZWxlbWVudCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBpbml0aWFsaXppbmcgZm9yIHNpbXBsZSBpbmhlcml0YW5jZVxyXG5cdFx0Ly8gbXVzdCB1c2UgXCJuZXdcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXHJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XHJcblx0XHRcdHRoaXMuX2NyZWF0ZVdpZGdldCggb3B0aW9ucywgZWxlbWVudCApO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIEV4dGVuZCB3aXRoIHRoZSBleGlzdGluZyBjb25zdHJ1Y3RvciB0byBjYXJyeSBvdmVyIGFueSBzdGF0aWMgcHJvcGVydGllc1xyXG5cdCQuZXh0ZW5kKCBjb25zdHJ1Y3RvciwgZXhpc3RpbmdDb25zdHJ1Y3Rvciwge1xyXG5cdFx0dmVyc2lvbjogcHJvdG90eXBlLnZlcnNpb24sXHJcblxyXG5cdFx0Ly8gQ29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXHJcblx0XHQvLyByZWRlZmluZSB0aGUgd2lkZ2V0IGxhdGVyXHJcblx0XHRfcHJvdG86ICQuZXh0ZW5kKCB7fSwgcHJvdG90eXBlICksXHJcblxyXG5cdFx0Ly8gVHJhY2sgd2lkZ2V0cyB0aGF0IGluaGVyaXQgZnJvbSB0aGlzIHdpZGdldCBpbiBjYXNlIHRoaXMgd2lkZ2V0IGlzXHJcblx0XHQvLyByZWRlZmluZWQgYWZ0ZXIgYSB3aWRnZXQgaW5oZXJpdHMgZnJvbSBpdFxyXG5cdFx0X2NoaWxkQ29uc3RydWN0b3JzOiBbXVxyXG5cdH0gKTtcclxuXHJcblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XHJcblxyXG5cdC8vIFdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxyXG5cdC8vIG90aGVyd2lzZSB3ZSdsbCBtb2RpZnkgdGhlIG9wdGlvbnMgaGFzaCBvbiB0aGUgcHJvdG90eXBlIHRoYXQgd2UncmVcclxuXHQvLyBpbmhlcml0aW5nIGZyb21cclxuXHRiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LCBiYXNlUHJvdG90eXBlLm9wdGlvbnMgKTtcclxuXHQkLmVhY2goIHByb3RvdHlwZSwgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xyXG5cdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xyXG5cdFx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSB2YWx1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gKCBmdW5jdGlvbigpIHtcclxuXHRcdFx0ZnVuY3Rpb24gX3N1cGVyKCkge1xyXG5cdFx0XHRcdHJldHVybiBiYXNlLnByb3RvdHlwZVsgcHJvcCBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gX3N1cGVyQXBwbHkoIGFyZ3MgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBfX3N1cGVyID0gdGhpcy5fc3VwZXI7XHJcblx0XHRcdFx0dmFyIF9fc3VwZXJBcHBseSA9IHRoaXMuX3N1cGVyQXBwbHk7XHJcblx0XHRcdFx0dmFyIHJldHVyblZhbHVlO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9zdXBlcjtcclxuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XHJcblxyXG5cdFx0XHRcdHJldHVyblZhbHVlID0gdmFsdWUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9fc3VwZXI7XHJcblx0XHRcdFx0dGhpcy5fc3VwZXJBcHBseSA9IF9fc3VwZXJBcHBseTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHJldHVyblZhbHVlO1xyXG5cdFx0XHR9O1xyXG5cdFx0fSApKCk7XHJcblx0fSApO1xyXG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9ICQud2lkZ2V0LmV4dGVuZCggYmFzZVByb3RvdHlwZSwge1xyXG5cclxuXHRcdC8vIFRPRE86IHJlbW92ZSBzdXBwb3J0IGZvciB3aWRnZXRFdmVudFByZWZpeFxyXG5cdFx0Ly8gYWx3YXlzIHVzZSB0aGUgbmFtZSArIGEgY29sb24gYXMgdGhlIHByZWZpeCwgZS5nLiwgZHJhZ2dhYmxlOnN0YXJ0XHJcblx0XHQvLyBkb24ndCBwcmVmaXggZm9yIHdpZGdldHMgdGhhdCBhcmVuJ3QgRE9NLWJhc2VkXHJcblx0XHR3aWRnZXRFdmVudFByZWZpeDogZXhpc3RpbmdDb25zdHJ1Y3RvciA/ICggYmFzZVByb3RvdHlwZS53aWRnZXRFdmVudFByZWZpeCB8fCBuYW1lICkgOiBuYW1lXHJcblx0fSwgcHJveGllZFByb3RvdHlwZSwge1xyXG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxyXG5cdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXHJcblx0XHR3aWRnZXROYW1lOiBuYW1lLFxyXG5cdFx0d2lkZ2V0RnVsbE5hbWU6IGZ1bGxOYW1lXHJcblx0fSApO1xyXG5cclxuXHQvLyBJZiB0aGlzIHdpZGdldCBpcyBiZWluZyByZWRlZmluZWQgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgYWxsIHdpZGdldHMgdGhhdFxyXG5cdC8vIGFyZSBpbmhlcml0aW5nIGZyb20gaXQgYW5kIHJlZGVmaW5lIGFsbCBvZiB0aGVtIHNvIHRoYXQgdGhleSBpbmhlcml0IGZyb21cclxuXHQvLyB0aGUgbmV3IHZlcnNpb24gb2YgdGhpcyB3aWRnZXQuIFdlJ3JlIGVzc2VudGlhbGx5IHRyeWluZyB0byByZXBsYWNlIG9uZVxyXG5cdC8vIGxldmVsIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXHJcblx0aWYgKCBleGlzdGluZ0NvbnN0cnVjdG9yICkge1xyXG5cdFx0JC5lYWNoKCBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycywgZnVuY3Rpb24oIGksIGNoaWxkICkge1xyXG5cdFx0XHR2YXIgY2hpbGRQcm90b3R5cGUgPSBjaGlsZC5wcm90b3R5cGU7XHJcblxyXG5cdFx0XHQvLyBSZWRlZmluZSB0aGUgY2hpbGQgd2lkZ2V0IHVzaW5nIHRoZSBzYW1lIHByb3RvdHlwZSB0aGF0IHdhc1xyXG5cdFx0XHQvLyBvcmlnaW5hbGx5IHVzZWQsIGJ1dCBpbmhlcml0IGZyb20gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBiYXNlXHJcblx0XHRcdCQud2lkZ2V0KCBjaGlsZFByb3RvdHlwZS5uYW1lc3BhY2UgKyBcIi5cIiArIGNoaWxkUHJvdG90eXBlLndpZGdldE5hbWUsIGNvbnN0cnVjdG9yLFxyXG5cdFx0XHRcdGNoaWxkLl9wcm90byApO1xyXG5cdFx0fSApO1xyXG5cclxuXHRcdC8vIFJlbW92ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjaGlsZCBjb25zdHJ1Y3RvcnMgZnJvbSB0aGUgb2xkIGNvbnN0cnVjdG9yXHJcblx0XHQvLyBzbyB0aGUgb2xkIGNoaWxkIGNvbnN0cnVjdG9ycyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcclxuXHRcdGRlbGV0ZSBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycztcclxuXHR9IGVsc2Uge1xyXG5cdFx0YmFzZS5fY2hpbGRDb25zdHJ1Y3RvcnMucHVzaCggY29uc3RydWN0b3IgKTtcclxuXHR9XHJcblxyXG5cdCQud2lkZ2V0LmJyaWRnZSggbmFtZSwgY29uc3RydWN0b3IgKTtcclxuXHJcblx0cmV0dXJuIGNvbnN0cnVjdG9yO1xyXG59O1xyXG5cclxuJC53aWRnZXQuZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCApIHtcclxuXHR2YXIgaW5wdXQgPSB3aWRnZXRTbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcclxuXHR2YXIgaW5wdXRJbmRleCA9IDA7XHJcblx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xyXG5cdHZhciBrZXk7XHJcblx0dmFyIHZhbHVlO1xyXG5cclxuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xyXG5cdFx0Zm9yICgga2V5IGluIGlucHV0WyBpbnB1dEluZGV4IF0gKSB7XHJcblx0XHRcdHZhbHVlID0gaW5wdXRbIGlucHV0SW5kZXggXVsga2V5IF07XHJcblx0XHRcdGlmICggaW5wdXRbIGlucHV0SW5kZXggXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Ly8gQ2xvbmUgb2JqZWN0c1xyXG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9ICQuaXNQbGFpbk9iamVjdCggdGFyZ2V0WyBrZXkgXSApID9cclxuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdGFyZ2V0WyBrZXkgXSwgdmFsdWUgKSA6XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xyXG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHQvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBieSByZWZlcmVuY2VcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuJC53aWRnZXQuYnJpZGdlID0gZnVuY3Rpb24oIG5hbWUsIG9iamVjdCApIHtcclxuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XHJcblx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XHJcblx0XHR2YXIgaXNNZXRob2RDYWxsID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCI7XHJcblx0XHR2YXIgYXJncyA9IHdpZGdldFNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xyXG5cdFx0dmFyIHJldHVyblZhbHVlID0gdGhpcztcclxuXHJcblx0XHRpZiAoIGlzTWV0aG9kQ2FsbCApIHtcclxuXHJcblx0XHRcdC8vIElmIHRoaXMgaXMgYW4gZW1wdHkgY29sbGVjdGlvbiwgd2UgbmVlZCB0byBoYXZlIHRoZSBpbnN0YW5jZSBtZXRob2RcclxuXHRcdFx0Ly8gcmV0dXJuIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHRoZSBqUXVlcnkgaW5zdGFuY2VcclxuXHRcdFx0aWYgKCAhdGhpcy5sZW5ndGggJiYgb3B0aW9ucyA9PT0gXCJpbnN0YW5jZVwiICkge1xyXG5cdFx0XHRcdHJldHVyblZhbHVlID0gdW5kZWZpbmVkO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgbWV0aG9kVmFsdWU7XHJcblx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zID09PSBcImluc3RhbmNlXCIgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlID0gaW5zdGFuY2U7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoICFpbnN0YW5jZSApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwiY2Fubm90IGNhbGwgbWV0aG9kcyBvbiBcIiArIG5hbWUgK1xyXG5cdFx0XHRcdFx0XHRcdFwiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBcIiArXHJcblx0XHRcdFx0XHRcdFx0XCJhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJ1wiICk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCBpbnN0YW5jZVsgb3B0aW9ucyBdICkgfHwgb3B0aW9ucy5jaGFyQXQoIDAgKSA9PT0gXCJfXCIgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcIm5vIHN1Y2ggbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIicgZm9yIFwiICsgbmFtZSArXHJcblx0XHRcdFx0XHRcdFx0XCIgd2lkZ2V0IGluc3RhbmNlXCIgKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRtZXRob2RWYWx1ZSA9IGluc3RhbmNlWyBvcHRpb25zIF0uYXBwbHkoIGluc3RhbmNlLCBhcmdzICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtZXRob2RWYWx1ZSAhPT0gaW5zdGFuY2UgJiYgbWV0aG9kVmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBtZXRob2RWYWx1ZSAmJiBtZXRob2RWYWx1ZS5qcXVlcnkgP1xyXG5cdFx0XHRcdFx0XHRcdHJldHVyblZhbHVlLnB1c2hTdGFjayggbWV0aG9kVmFsdWUuZ2V0KCkgKSA6XHJcblx0XHRcdFx0XHRcdFx0bWV0aG9kVmFsdWU7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9ICk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBBbGxvdyBtdWx0aXBsZSBoYXNoZXMgdG8gYmUgcGFzc2VkIG9uIGluaXRcclxuXHRcdFx0aWYgKCBhcmdzLmxlbmd0aCApIHtcclxuXHRcdFx0XHRvcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kLmFwcGx5KCBudWxsLCBbIG9wdGlvbnMgXS5jb25jYXQoIGFyZ3MgKSApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcclxuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xyXG5cdFx0XHRcdFx0aW5zdGFuY2Uub3B0aW9uKCBvcHRpb25zIHx8IHt9ICk7XHJcblx0XHRcdFx0XHRpZiAoIGluc3RhbmNlLl9pbml0ICkge1xyXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5faW5pdCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KCBvcHRpb25zLCB0aGlzICkgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XHJcblx0fTtcclxufTtcclxuXHJcbiQuV2lkZ2V0ID0gZnVuY3Rpb24oIC8qIG9wdGlvbnMsIGVsZW1lbnQgKi8gKSB7fTtcclxuJC5XaWRnZXQuX2NoaWxkQ29uc3RydWN0b3JzID0gW107XHJcblxyXG4kLldpZGdldC5wcm90b3R5cGUgPSB7XHJcblx0d2lkZ2V0TmFtZTogXCJ3aWRnZXRcIixcclxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJcIixcclxuXHRkZWZhdWx0RWxlbWVudDogXCI8ZGl2PlwiLFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRjbGFzc2VzOiB7fSxcclxuXHRcdGRpc2FibGVkOiBmYWxzZSxcclxuXHJcblx0XHQvLyBDYWxsYmFja3NcclxuXHRcdGNyZWF0ZTogbnVsbFxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVXaWRnZXQ6IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xyXG5cdFx0ZWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgdGhpcy5kZWZhdWx0RWxlbWVudCB8fCB0aGlzIClbIDAgXTtcclxuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcclxuXHRcdHRoaXMudXVpZCA9IHdpZGdldFV1aWQrKztcclxuXHRcdHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcclxuXHJcblx0XHR0aGlzLmJpbmRpbmdzID0gJCgpO1xyXG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCk7XHJcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoKTtcclxuXHRcdHRoaXMuY2xhc3Nlc0VsZW1lbnRMb29rdXAgPSB7fTtcclxuXHJcblx0XHRpZiAoIGVsZW1lbnQgIT09IHRoaXMgKSB7XHJcblx0XHRcdCQuZGF0YSggZWxlbWVudCwgdGhpcy53aWRnZXRGdWxsTmFtZSwgdGhpcyApO1xyXG5cdFx0XHR0aGlzLl9vbiggdHJ1ZSwgdGhpcy5lbGVtZW50LCB7XHJcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0XHRcdFx0XHRpZiAoIGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudCApIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ICk7XHJcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSAkKCBlbGVtZW50LnN0eWxlID9cclxuXHJcblx0XHRcdFx0Ly8gRWxlbWVudCB3aXRoaW4gdGhlIGRvY3VtZW50XHJcblx0XHRcdFx0ZWxlbWVudC5vd25lckRvY3VtZW50IDpcclxuXHJcblx0XHRcdFx0Ly8gRWxlbWVudCBpcyB3aW5kb3cgb3IgZG9jdW1lbnRcclxuXHRcdFx0XHRlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQgKTtcclxuXHRcdFx0dGhpcy53aW5kb3cgPSAkKCB0aGlzLmRvY3VtZW50WyAwIF0uZGVmYXVsdFZpZXcgfHwgdGhpcy5kb2N1bWVudFsgMCBdLnBhcmVudFdpbmRvdyApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sXHJcblx0XHRcdHRoaXMub3B0aW9ucyxcclxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxyXG5cdFx0XHRvcHRpb25zICk7XHJcblxyXG5cdFx0dGhpcy5fY3JlYXRlKCk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XHJcblx0XHRcdHRoaXMuX3NldE9wdGlvbkRpc2FibGVkKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl90cmlnZ2VyKCBcImNyZWF0ZVwiLCBudWxsLCB0aGlzLl9nZXRDcmVhdGVFdmVudERhdGEoKSApO1xyXG5cdFx0dGhpcy5faW5pdCgpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRDcmVhdGVPcHRpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB7fTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiAkLm5vb3AsXHJcblxyXG5cdF9jcmVhdGU6ICQubm9vcCxcclxuXHJcblx0X2luaXQ6ICQubm9vcCxcclxuXHJcblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdFx0dGhpcy5fZGVzdHJveSgpO1xyXG5cdFx0JC5lYWNoKCB0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcclxuXHRcdFx0dGhhdC5fcmVtb3ZlQ2xhc3MoIHZhbHVlLCBrZXkgKTtcclxuXHRcdH0gKTtcclxuXHJcblx0XHQvLyBXZSBjYW4gcHJvYmFibHkgcmVtb3ZlIHRoZSB1bmJpbmQgY2FsbHMgaW4gMi4wXHJcblx0XHQvLyBhbGwgZXZlbnQgYmluZGluZ3Mgc2hvdWxkIGdvIHRocm91Z2ggdGhpcy5fb24oKVxyXG5cdFx0dGhpcy5lbGVtZW50XHJcblx0XHRcdC5vZmYoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxyXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXRGdWxsTmFtZSApO1xyXG5cdFx0dGhpcy53aWRnZXQoKVxyXG5cdFx0XHQub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcclxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiICk7XHJcblxyXG5cdFx0Ly8gQ2xlYW4gdXAgZXZlbnRzIGFuZCBzdGF0ZXNcclxuXHRcdHRoaXMuYmluZGluZ3Mub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlICk7XHJcblx0fSxcclxuXHJcblx0X2Rlc3Ryb3k6ICQubm9vcCxcclxuXHJcblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XHJcblx0fSxcclxuXHJcblx0b3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcclxuXHRcdHZhciBvcHRpb25zID0ga2V5O1xyXG5cdFx0dmFyIHBhcnRzO1xyXG5cdFx0dmFyIGN1ck9wdGlvbjtcclxuXHRcdHZhciBpO1xyXG5cclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdC8vIERvbid0IHJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgaGFzaFxyXG5cdFx0XHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zICk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xyXG5cclxuXHRcdFx0Ly8gSGFuZGxlIG5lc3RlZCBrZXlzLCBlLmcuLCBcImZvby5iYXJcIiA9PiB7IGZvbzogeyBiYXI6IF9fXyB9IH1cclxuXHRcdFx0b3B0aW9ucyA9IHt9O1xyXG5cdFx0XHRwYXJ0cyA9IGtleS5zcGxpdCggXCIuXCIgKTtcclxuXHRcdFx0a2V5ID0gcGFydHMuc2hpZnQoKTtcclxuXHRcdFx0aWYgKCBwYXJ0cy5sZW5ndGggKSB7XHJcblx0XHRcdFx0Y3VyT3B0aW9uID0gb3B0aW9uc1sga2V5IF0gPSAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnNbIGtleSBdICk7XHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKysgKSB7XHJcblx0XHRcdFx0XHRjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdIHx8IHt9O1xyXG5cdFx0XHRcdFx0Y3VyT3B0aW9uID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGtleSA9IHBhcnRzLnBvcCgpO1xyXG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcclxuXHRcdFx0XHRcdHJldHVybiBjdXJPcHRpb25bIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogY3VyT3B0aW9uWyBrZXkgXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y3VyT3B0aW9uWyBrZXkgXSA9IHZhbHVlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5vcHRpb25zWyBrZXkgXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3NldE9wdGlvbnMoIG9wdGlvbnMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XHJcblx0XHR2YXIga2V5O1xyXG5cclxuXHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xyXG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcclxuXHRcdGlmICgga2V5ID09PSBcImNsYXNzZXNcIiApIHtcclxuXHRcdFx0dGhpcy5fc2V0T3B0aW9uQ2xhc3NlcyggdmFsdWUgKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XHJcblxyXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcclxuXHRcdFx0dGhpcy5fc2V0T3B0aW9uRGlzYWJsZWQoIHZhbHVlICk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3NldE9wdGlvbkNsYXNzZXM6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHRcdHZhciBjbGFzc0tleSwgZWxlbWVudHMsIGN1cnJlbnRFbGVtZW50cztcclxuXHJcblx0XHRmb3IgKCBjbGFzc0tleSBpbiB2YWx1ZSApIHtcclxuXHRcdFx0Y3VycmVudEVsZW1lbnRzID0gdGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cFsgY2xhc3NLZXkgXTtcclxuXHRcdFx0aWYgKCB2YWx1ZVsgY2xhc3NLZXkgXSA9PT0gdGhpcy5vcHRpb25zLmNsYXNzZXNbIGNsYXNzS2V5IF0gfHxcclxuXHRcdFx0XHRcdCFjdXJyZW50RWxlbWVudHMgfHxcclxuXHRcdFx0XHRcdCFjdXJyZW50RWxlbWVudHMubGVuZ3RoICkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBXZSBhcmUgZG9pbmcgdGhpcyB0byBjcmVhdGUgYSBuZXcgalF1ZXJ5IG9iamVjdCBiZWNhdXNlIHRoZSBfcmVtb3ZlQ2xhc3MoKSBjYWxsXHJcblx0XHRcdC8vIG9uIHRoZSBuZXh0IGxpbmUgaXMgZ29pbmcgdG8gZGVzdHJveSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVsZW1lbnRzIGJlaW5nXHJcblx0XHRcdC8vIHRyYWNrZWQuIFdlIG5lZWQgdG8gc2F2ZSBhIGNvcHkgb2YgdGhpcyBjb2xsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCB0aGUgbmV3IGNsYXNzZXNcclxuXHRcdFx0Ly8gYmVsb3cuXHJcblx0XHRcdGVsZW1lbnRzID0gJCggY3VycmVudEVsZW1lbnRzLmdldCgpICk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBjdXJyZW50RWxlbWVudHMsIGNsYXNzS2V5ICk7XHJcblxyXG5cdFx0XHQvLyBXZSBkb24ndCB1c2UgX2FkZENsYXNzKCkgaGVyZSwgYmVjYXVzZSB0aGF0IHVzZXMgdGhpcy5vcHRpb25zLmNsYXNzZXNcclxuXHRcdFx0Ly8gZm9yIGdlbmVyYXRpbmcgdGhlIHN0cmluZyBvZiBjbGFzc2VzLiBXZSB3YW50IHRvIHVzZSB0aGUgdmFsdWUgcGFzc2VkIGluIGZyb21cclxuXHRcdFx0Ly8gX3NldE9wdGlvbigpLCB0aGlzIGlzIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGNsYXNzZXMgb3B0aW9uIHdoaWNoIHdhcyBwYXNzZWQgdG9cclxuXHRcdFx0Ly8gX3NldE9wdGlvbigpLiBXZSBwYXNzIHRoaXMgdmFsdWUgZGlyZWN0bHkgdG8gX2NsYXNzZXMoKS5cclxuXHRcdFx0ZWxlbWVudHMuYWRkQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIHtcclxuXHRcdFx0XHRlbGVtZW50OiBlbGVtZW50cyxcclxuXHRcdFx0XHRrZXlzOiBjbGFzc0tleSxcclxuXHRcdFx0XHRjbGFzc2VzOiB2YWx1ZSxcclxuXHRcdFx0XHRhZGQ6IHRydWVcclxuXHRcdFx0fSApICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3NldE9wdGlvbkRpc2FibGVkOiBmdW5jdGlvbiggdmFsdWUgKSB7XHJcblx0XHR0aGlzLl90b2dnbGVDbGFzcyggdGhpcy53aWRnZXQoKSwgdGhpcy53aWRnZXRGdWxsTmFtZSArIFwiLWRpc2FibGVkXCIsIG51bGwsICEhdmFsdWUgKTtcclxuXHJcblx0XHQvLyBJZiB0aGUgd2lkZ2V0IGlzIGJlY29taW5nIGRpc2FibGVkLCB0aGVuIG5vdGhpbmcgaXMgaW50ZXJhY3RpdmVcclxuXHRcdGlmICggdmFsdWUgKSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmhvdmVyYWJsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmZvY3VzYWJsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb25zKCB7IGRpc2FibGVkOiBmYWxzZSB9ICk7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9ucyggeyBkaXNhYmxlZDogdHJ1ZSB9ICk7XHJcblx0fSxcclxuXHJcblx0X2NsYXNzZXM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xyXG5cdFx0dmFyIGZ1bGwgPSBbXTtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0XHRvcHRpb25zID0gJC5leHRlbmQoIHtcclxuXHRcdFx0ZWxlbWVudDogdGhpcy5lbGVtZW50LFxyXG5cdFx0XHRjbGFzc2VzOiB0aGlzLm9wdGlvbnMuY2xhc3NlcyB8fCB7fVxyXG5cdFx0fSwgb3B0aW9ucyApO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NDbGFzc1N0cmluZyggY2xhc3NlcywgY2hlY2tPcHRpb24gKSB7XHJcblx0XHRcdHZhciBjdXJyZW50LCBpO1xyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdFx0Y3VycmVudCA9IHRoYXQuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzZXNbIGkgXSBdIHx8ICQoKTtcclxuXHRcdFx0XHRpZiAoIG9wdGlvbnMuYWRkICkge1xyXG5cdFx0XHRcdFx0Y3VycmVudCA9ICQoICQudW5pcXVlKCBjdXJyZW50LmdldCgpLmNvbmNhdCggb3B0aW9ucy5lbGVtZW50LmdldCgpICkgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjdXJyZW50ID0gJCggY3VycmVudC5ub3QoIG9wdGlvbnMuZWxlbWVudCApLmdldCgpICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoYXQuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzZXNbIGkgXSBdID0gY3VycmVudDtcclxuXHRcdFx0XHRmdWxsLnB1c2goIGNsYXNzZXNbIGkgXSApO1xyXG5cdFx0XHRcdGlmICggY2hlY2tPcHRpb24gJiYgb3B0aW9ucy5jbGFzc2VzWyBjbGFzc2VzWyBpIF0gXSApIHtcclxuXHRcdFx0XHRcdGZ1bGwucHVzaCggb3B0aW9ucy5jbGFzc2VzWyBjbGFzc2VzWyBpIF0gXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX29uKCBvcHRpb25zLmVsZW1lbnQsIHtcclxuXHRcdFx0XCJyZW1vdmVcIjogXCJfdW50cmFja0NsYXNzZXNFbGVtZW50XCJcclxuXHRcdH0gKTtcclxuXHJcblx0XHRpZiAoIG9wdGlvbnMua2V5cyApIHtcclxuXHRcdFx0cHJvY2Vzc0NsYXNzU3RyaW5nKCBvcHRpb25zLmtleXMubWF0Y2goIC9cXFMrL2cgKSB8fCBbXSwgdHJ1ZSApO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCBvcHRpb25zLmV4dHJhICkge1xyXG5cdFx0XHRwcm9jZXNzQ2xhc3NTdHJpbmcoIG9wdGlvbnMuZXh0cmEubWF0Y2goIC9cXFMrL2cgKSB8fCBbXSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmdWxsLmpvaW4oIFwiIFwiICk7XHJcblx0fSxcclxuXHJcblx0X3VudHJhY2tDbGFzc2VzRWxlbWVudDogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0JC5lYWNoKCB0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcclxuXHRcdFx0aWYgKCAkLmluQXJyYXkoIGV2ZW50LnRhcmdldCwgdmFsdWUgKSAhPT0gLTEgKSB7XHJcblx0XHRcdFx0dGhhdC5jbGFzc2VzRWxlbWVudExvb2t1cFsga2V5IF0gPSAkKCB2YWx1ZS5ub3QoIGV2ZW50LnRhcmdldCApLmdldCgpICk7XHJcblx0XHRcdH1cclxuXHRcdH0gKTtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCBlbGVtZW50LCBrZXlzLCBleHRyYSApIHtcclxuXHRcdHJldHVybiB0aGlzLl90b2dnbGVDbGFzcyggZWxlbWVudCwga2V5cywgZXh0cmEsIGZhbHNlICk7XHJcblx0fSxcclxuXHJcblx0X2FkZENsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdG9nZ2xlQ2xhc3MoIGVsZW1lbnQsIGtleXMsIGV4dHJhLCB0cnVlICk7XHJcblx0fSxcclxuXHJcblx0X3RvZ2dsZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEsIGFkZCApIHtcclxuXHRcdGFkZCA9ICggdHlwZW9mIGFkZCA9PT0gXCJib29sZWFuXCIgKSA/IGFkZCA6IGV4dHJhO1xyXG5cdFx0dmFyIHNoaWZ0ID0gKCB0eXBlb2YgZWxlbWVudCA9PT0gXCJzdHJpbmdcIiB8fCBlbGVtZW50ID09PSBudWxsICksXHJcblx0XHRcdG9wdGlvbnMgPSB7XHJcblx0XHRcdFx0ZXh0cmE6IHNoaWZ0ID8ga2V5cyA6IGV4dHJhLFxyXG5cdFx0XHRcdGtleXM6IHNoaWZ0ID8gZWxlbWVudCA6IGtleXMsXHJcblx0XHRcdFx0ZWxlbWVudDogc2hpZnQgPyB0aGlzLmVsZW1lbnQgOiBlbGVtZW50LFxyXG5cdFx0XHRcdGFkZDogYWRkXHJcblx0XHRcdH07XHJcblx0XHRvcHRpb25zLmVsZW1lbnQudG9nZ2xlQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIG9wdGlvbnMgKSwgYWRkICk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb246IGZ1bmN0aW9uKCBzdXBwcmVzc0Rpc2FibGVkQ2hlY2ssIGVsZW1lbnQsIGhhbmRsZXJzICkge1xyXG5cdFx0dmFyIGRlbGVnYXRlRWxlbWVudDtcclxuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gTm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXHJcblx0XHRpZiAoIHR5cGVvZiBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgIT09IFwiYm9vbGVhblwiICkge1xyXG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XHJcblx0XHRcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XHJcblx0XHRcdHN1cHByZXNzRGlzYWJsZWRDaGVjayA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE5vIGVsZW1lbnQgYXJndW1lbnQsIHNodWZmbGUgYW5kIHVzZSB0aGlzLmVsZW1lbnRcclxuXHRcdGlmICggIWhhbmRsZXJzICkge1xyXG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XHJcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcblx0XHRcdGRlbGVnYXRlRWxlbWVudCA9IHRoaXMud2lkZ2V0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xyXG5cdFx0XHR0aGlzLmJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5hZGQoIGVsZW1lbnQgKTtcclxuXHRcdH1cclxuXHJcblx0XHQkLmVhY2goIGhhbmRsZXJzLCBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXIgKSB7XHJcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcclxuXHJcblx0XHRcdFx0Ly8gQWxsb3cgd2lkZ2V0cyB0byBjdXN0b21pemUgdGhlIGRpc2FibGVkIGhhbmRsaW5nXHJcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cclxuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGNsYXNzIGFzIG1ldGhvZCBmb3IgZGlzYWJsaW5nIGluZGl2aWR1YWwgcGFydHNcclxuXHRcdFx0XHRpZiAoICFzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgJiZcclxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XHJcblx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXHJcblx0XHRcdFx0XHQuYXBwbHkoIGluc3RhbmNlLCBhcmd1bWVudHMgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQ29weSB0aGUgZ3VpZCBzbyBkaXJlY3QgdW5iaW5kaW5nIHdvcmtzXHJcblx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgIT09IFwic3RyaW5nXCIgKSB7XHJcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxyXG5cdFx0XHRcdFx0aGFuZGxlci5ndWlkIHx8IGhhbmRsZXJQcm94eS5ndWlkIHx8ICQuZ3VpZCsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbWF0Y2ggPSBldmVudC5tYXRjaCggL14oW1xcdzotXSopXFxzKiguKikkLyApO1xyXG5cdFx0XHR2YXIgZXZlbnROYW1lID0gbWF0Y2hbIDEgXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlO1xyXG5cdFx0XHR2YXIgc2VsZWN0b3IgPSBtYXRjaFsgMiBdO1xyXG5cclxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcclxuXHRcdFx0XHRkZWxlZ2F0ZUVsZW1lbnQub24oIGV2ZW50TmFtZSwgc2VsZWN0b3IsIGhhbmRsZXJQcm94eSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGVsZW1lbnQub24oIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XHJcblx0XHRcdH1cclxuXHRcdH0gKTtcclxuXHR9LFxyXG5cclxuXHRfb2ZmOiBmdW5jdGlvbiggZWxlbWVudCwgZXZlbnROYW1lICkge1xyXG5cdFx0ZXZlbnROYW1lID0gKCBldmVudE5hbWUgfHwgXCJcIiApLnNwbGl0KCBcIiBcIiApLmpvaW4oIHRoaXMuZXZlbnROYW1lc3BhY2UgKyBcIiBcIiApICtcclxuXHRcdFx0dGhpcy5ldmVudE5hbWVzcGFjZTtcclxuXHRcdGVsZW1lbnQub2ZmKCBldmVudE5hbWUgKS5vZmYoIGV2ZW50TmFtZSApO1xyXG5cclxuXHRcdC8vIENsZWFyIHRoZSBzdGFjayB0byBhdm9pZCBtZW1vcnkgbGVha3MgKCMxMDA1NilcclxuXHRcdHRoaXMuYmluZGluZ3MgPSAkKCB0aGlzLmJpbmRpbmdzLm5vdCggZWxlbWVudCApLmdldCgpICk7XHJcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoIHRoaXMuZm9jdXNhYmxlLm5vdCggZWxlbWVudCApLmdldCgpICk7XHJcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoIHRoaXMuaG92ZXJhYmxlLm5vdCggZWxlbWVudCApLmdldCgpICk7XHJcblx0fSxcclxuXHJcblx0X2RlbGF5OiBmdW5jdGlvbiggaGFuZGxlciwgZGVsYXkgKSB7XHJcblx0XHRmdW5jdGlvbiBoYW5kbGVyUHJveHkoKSB7XHJcblx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxyXG5cdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGluc3RhbmNlID0gdGhpcztcclxuXHRcdHJldHVybiBzZXRUaW1lb3V0KCBoYW5kbGVyUHJveHksIGRlbGF5IHx8IDAgKTtcclxuXHR9LFxyXG5cclxuXHRfaG92ZXJhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcclxuXHRcdHRoaXMuaG92ZXJhYmxlID0gdGhpcy5ob3ZlcmFibGUuYWRkKCBlbGVtZW50ICk7XHJcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xyXG5cdFx0XHRtb3VzZWVudGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdG1vdXNlbGVhdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggJCggZXZlbnQuY3VycmVudFRhcmdldCApLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSApO1xyXG5cdH0sXHJcblxyXG5cdF9mb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xyXG5cdFx0dGhpcy5mb2N1c2FibGUgPSB0aGlzLmZvY3VzYWJsZS5hZGQoIGVsZW1lbnQgKTtcclxuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XHJcblx0XHRcdGZvY3VzaW46IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggJCggZXZlbnQuY3VycmVudFRhcmdldCApLCBudWxsLCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0Zm9jdXNvdXQ6IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggJCggZXZlbnQuY3VycmVudFRhcmdldCApLCBudWxsLCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSApO1xyXG5cdH0sXHJcblxyXG5cdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGRhdGEgKSB7XHJcblx0XHR2YXIgcHJvcCwgb3JpZztcclxuXHRcdHZhciBjYWxsYmFjayA9IHRoaXMub3B0aW9uc1sgdHlwZSBdO1xyXG5cclxuXHRcdGRhdGEgPSBkYXRhIHx8IHt9O1xyXG5cdFx0ZXZlbnQgPSAkLkV2ZW50KCBldmVudCApO1xyXG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XHJcblx0XHRcdHR5cGUgOlxyXG5cdFx0XHR0aGlzLndpZGdldEV2ZW50UHJlZml4ICsgdHlwZSApLnRvTG93ZXJDYXNlKCk7XHJcblxyXG5cdFx0Ly8gVGhlIG9yaWdpbmFsIGV2ZW50IG1heSBjb21lIGZyb20gYW55IGVsZW1lbnRcclxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XHJcblx0XHRldmVudC50YXJnZXQgPSB0aGlzLmVsZW1lbnRbIDAgXTtcclxuXHJcblx0XHQvLyBDb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XHJcblx0XHRvcmlnID0gZXZlbnQub3JpZ2luYWxFdmVudDtcclxuXHRcdGlmICggb3JpZyApIHtcclxuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xyXG5cdFx0XHRcdGlmICggISggcHJvcCBpbiBldmVudCApICkge1xyXG5cdFx0XHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdbIHByb3AgXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggZXZlbnQsIGRhdGEgKTtcclxuXHRcdHJldHVybiAhKCAkLmlzRnVuY3Rpb24oIGNhbGxiYWNrICkgJiZcclxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFsgMCBdLCBbIGV2ZW50IF0uY29uY2F0KCBkYXRhICkgKSA9PT0gZmFsc2UgfHxcclxuXHRcdFx0ZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKTtcclxuXHR9XHJcbn07XHJcblxyXG4kLmVhY2goIHsgc2hvdzogXCJmYWRlSW5cIiwgaGlkZTogXCJmYWRlT3V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgZGVmYXVsdEVmZmVjdCApIHtcclxuXHQkLldpZGdldC5wcm90b3R5cGVbIFwiX1wiICsgbWV0aG9kIF0gPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XHJcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xyXG5cdFx0XHRvcHRpb25zID0geyBlZmZlY3Q6IG9wdGlvbnMgfTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaGFzT3B0aW9ucztcclxuXHRcdHZhciBlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xyXG5cdFx0XHRtZXRob2QgOlxyXG5cdFx0XHRvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiID9cclxuXHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcclxuXHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiApIHtcclxuXHRcdFx0b3B0aW9ucyA9IHsgZHVyYXRpb246IG9wdGlvbnMgfTtcclxuXHRcdH1cclxuXHJcblx0XHRoYXNPcHRpb25zID0gISQuaXNFbXB0eU9iamVjdCggb3B0aW9ucyApO1xyXG5cdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdGlmICggb3B0aW9ucy5kZWxheSApIHtcclxuXHRcdFx0ZWxlbWVudC5kZWxheSggb3B0aW9ucy5kZWxheSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgZWZmZWN0TmFtZSBdICkge1xyXG5cdFx0XHRlbGVtZW50WyBtZXRob2QgXSggb3B0aW9ucyApO1xyXG5cdFx0fSBlbHNlIGlmICggZWZmZWN0TmFtZSAhPT0gbWV0aG9kICYmIGVsZW1lbnRbIGVmZmVjdE5hbWUgXSApIHtcclxuXHRcdFx0ZWxlbWVudFsgZWZmZWN0TmFtZSBdKCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgY2FsbGJhY2sgKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGVsZW1lbnQucXVldWUoIGZ1bmN0aW9uKCBuZXh0ICkge1xyXG5cdFx0XHRcdCQoIHRoaXMgKVsgbWV0aG9kIF0oKTtcclxuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggZWxlbWVudFsgMCBdICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG5leHQoKTtcclxuXHRcdFx0fSApO1xyXG5cdFx0fVxyXG5cdH07XHJcbn0gKTtcclxuXHJcbnZhciB3aWRnZXQgPSAkLndpZGdldDtcclxuXHJcblxyXG5cclxuXHJcbn0pKTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVRBO0FBWUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBTUE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUF0WkE7QUF5WkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/jQueryUiWidget.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.common.js":
/*!*****************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.common.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Ontraport's public facing landing page scripts. These functions are designed to be available both in app\n * and in public facing files\n */\n(function ($, context) {\n  // Don't overwrite our global object\n  var op = context.op || (context.op = {});\n  /**\n  * Border hook used by both the templateprocessor and webcomponents. It takes a settings object discribing borders\n  * and appliest them to the incoming elements.\n  * @param {object} element DOM object\n  * @param {object} settings object describing border and shadow settings.\n  * @param {object} blockSettings block settings object handy for determining if elements exist in a dynamic element.\n  */\n\n  op.border = function (element, settings = {}, blockData) {\n    var _nonZeroBorderRadiusTest = function (styleValues) {\n      return styleValues['border-top-left-radius'] && styleValues['border-top-left-radius'] !== '0px' || styleValues['border-top-right-radius'] && styleValues['border-top-right-radius'] !== '0px' || styleValues['border-bottom-left-radius'] && styleValues['border-bottom-left-radius'] !== '0px' || styleValues['border-bottom-right-radius'] && styleValues['border-bottom-right-radius'] !== '0px';\n    };\n\n    var styleSheetOptions = {},\n        borderClass = 'opt-border'; // If a custom border class is passed in, also pass it along to the stylesheet attribute handler\n\n    if (settings.blockUserDefinedData) {\n      styleSheetOptions.blockUserDefinedData = settings.blockUserDefinedData[0];\n    }\n\n    if (settings['custom-border-class']) {\n      borderClass = settings['custom-border-class'];\n      styleSheetOptions.namespace = settings['custom-border-class'];\n    } // Remove the following classes from the element\n\n\n    var classesToRemove = ['border-arrow--top', 'border-arrow--bottom', 'z-depth-00', 'z-depth-10', 'z-depth-20', 'z-depth-30', 'z-depth-40', 'z-depth-50', 'z-depth-10--hover', 'z-depth-20--hover', 'z-depth-30--hover', 'z-depth-40--hover', 'z-depth-50--hover'];\n    classesToRemove.forEach(function (className) {\n      this.classList.remove(className);\n    }, element); // Remove all classes that container \"color-border\" in them (all border classes)\n\n    var removeColorClasses = [];\n\n    for (var i = 0, l = element.classList.length, c; i < l; i++) {\n      c = element.classList[i];\n\n      if (c.includes('color-border')) {\n        removeColorClasses.push(c);\n      }\n    } // Wrap this in a length check for f'n IE ll\n\n\n    if (removeColorClasses.length) {\n      element.classList.remove(...removeColorClasses);\n    } // Apply the \"zindex\" as an attr so the ajent and editor can apply the zindex in a decending order\n\n\n    var zIndex = settings.applyZindex && settings['z-index'];\n    element.removeAttribute('data-zindex');\n\n    if (zIndex) {\n      element.setAttribute('data-zindex', zIndex);\n    } // Apply box shadow if present\n\n\n    if (settings['box-shadow']) {\n      element.classList.add(settings['box-shadow']);\n    } // Apply hover box shadow if present\n\n\n    if (settings['box-shadow-hover']) {\n      element.classList.add(settings['box-shadow-hover'] + '--hover');\n    } // Special logic for block borders. Sets content box shadow (on the container around the rows)\n\n\n    var $contentContainer = $(element).find('> .container');\n\n    if ($contentContainer.length && (settings['content-box-shadow'] || settings['content-box-shadow-hover'])) {\n      $contentContainer.removeClass(classesToRemove.join(' '));\n\n      if (settings['content-box-shadow']) {\n        $contentContainer.addClass(settings['content-box-shadow']);\n      }\n\n      if (settings['content-box-shadow-hover']) {\n        $contentContainer.addClass(settings['content-box-shadow-hover'] + '--hover');\n      }\n    }\n\n    $contentContainer = null; // Apply border arrow if present\n\n    if (settings['border-arrow']) {\n      // Only append the element if we have a background we can mimic.\n      if (settings.background && settings.background.background_type == 'colors' && settings.background.colors && settings.background.colors.color_type == 'solid') {\n        var borderArrow = document.createElement('div');\n        borderArrow.classList.add('border-arrow--' + settings['border-arrow']);\n        var target = element.querySelector('[class*=\"-overlay\"]'); // Switch order of attrs, so the border is the last one, only target bg-color-overlay\n\n        if (target) {\n          target.appendChild(borderArrow);\n        }\n\n        target = null;\n      }\n    }\n\n    element.classList.add(borderClass);\n    var styleValues = $.extend(true, {}, settings),\n        borderDirections = ['border', 'border-top', 'border-bottom', 'border-left', 'border-right']; // Loop over each border direction (all, top, bottom, left right) and add theme classes if needed\n\n    for (var i = 0, l = borderDirections.length; i < l; i++) {\n      var borderDir = borderDirections[i],\n          borderColor = styleValues[borderDir + '-color'],\n          borderColorHover = styleValues[borderDir + '-color-hover'],\n          borderColorFocus = styleValues[borderDir + '-color-focus'];\n\n      if (borderColor !== undefined && borderColor !== 'transparent' && borderColor.indexOf('#') === -1) {\n        element.classList.add(borderColor + '-' + borderDir);\n\n        if (borderArrow) {\n          borderArrow.classList.add(borderColor + '-' + borderDir);\n        }\n\n        delete styleValues[borderDir + '-color']; //\n        // Add value to for border arrow\n      }\n\n      if (borderColorHover !== undefined) {\n        if (borderColorHover !== 'transparent' && borderColorHover.indexOf('#') === -1) {\n          element.classList.add(borderColorHover + '-' + borderDir + '--hover');\n\n          if (borderArrow) {\n            borderArrow.classList.add(borderColorHover + '-' + borderDir + '--hover');\n          }\n\n          delete styleValues[borderDir + '-color-hover'];\n        } else if (borderDir !== 'border') {\n          // If style is an individual direction and is not class based, make it important since theme hover classes also use important\n          styleValues[borderDir + '-color-hover'] = styleValues[borderDir + '-color-hover'] + ' !important';\n        }\n      }\n\n      if (borderColorFocus !== undefined) {\n        if (borderColorFocus !== 'transparent' && borderColorFocus.indexOf('#') === -1) {\n          element.classList.add(borderColorFocus + '-' + borderDir + '--focus');\n\n          if (borderArrow) {\n            borderArrow.classList.add(borderColorFocus + '-' + borderDir + '--focus');\n          }\n\n          delete styleValues[borderDir + '-color-focus'];\n        } else if (borderDir !== 'border') {\n          // If style is an individual direction and is not class based, make it important since theme focus classes also use important\n          styleValues[borderDir + '-color-focus'] = styleValues[borderDir + '-color-focus'] + ' !important';\n        }\n      }\n    }\n\n    var selectorCarat = ' > ',\n        styleObj = {},\n        hideOverflow = false; // If contained in the 'el__style' wrapper, we are dealing with an element, not a column or block\n    // Remove the immediate selector so that the stylesheet hook will concat the element opt-id\n\n    if (element.closest('.el__style') || element.classList.contains('opt-element') || element.closest('.opt-element')) {\n      // If element has opt-id, make the selector empty string so that the opt-id and opt-border classes touch in the selector\n      // If element does not have an opt-id make selector a space that the selector targets the opt-border class INSIDE the opt-id\n      selectorCarat = element.hasAttribute('opt-id') ? '' : ' ';\n    } else if (_nonZeroBorderRadiusTest(styleValues)) {\n      // Make a style sheet entry that applies border radius to the background. This way we don't need overflow hidden to cover the bg element.\n      styleObj[' .js-opt-bg-img'] = ['border-top-left-radius', 'border-top-right-radius', 'border-bottom-left-radius', 'border-bottom-right-radius']; // If we have border radius and we are dealing with a column, hide the overflow\n\n      if (element.classList.contains('col__style')) {\n        hideOverflow = true;\n      }\n    }\n\n    styleObj[selectorCarat + '.' + borderClass] = ['border-style', 'border-color', 'border-width', 'border-top-left-radius', 'border-top-right-radius', 'border-bottom-left-radius', 'border-bottom-right-radius'];\n\n    if (hideOverflow) {\n      styleObj[selectorCarat + '.' + borderClass].push('overflow');\n      styleValues.overflow = 'hidden';\n    } // Increase the selector weight for individual border directions so they are equal to the selector weight of the theme classes (so they will override any \"all border\" theme styles)\n\n\n    styleObj[selectorCarat + '.' + borderClass + '.' + borderClass] = ['border-top-color', 'border-top-width', 'border-right-color', 'border-right-width', 'border-bottom-color', 'border-bottom-width', 'border-left-color', 'border-left-width'];\n    styleObj[selectorCarat + '.' + borderClass + ':hover'] = [['border-color', 'border-color-hover'], ['border-top-color', 'border-top-color-hover'], ['border-right-color', 'border-right-color-hover'], ['border-bottom-color', 'border-bottom-color-hover'], ['border-left-color', 'border-left-color-hover']];\n    let focusSelector = selectorCarat + '.' + borderClass + ':focus'; // Timestamp fields don't get focus because they are disabled, so leverage the open class\n\n    if (settings.isTimestamp) {\n      focusSelector = '.opt-date-time__picker--open .' + borderClass;\n    }\n\n    styleObj[focusSelector] = [['border-color', 'border-color-focus'], ['border-top-color', 'border-top-color-focus'], ['border-right-color', 'border-right-color-focus'], ['border-bottom-color', 'border-bottom-color-focus'], ['border-left-color', 'border-left-color-focus']]; // Border arrow styles\n    //\n\n    styleObj[selectorCarat + '.' + borderClass + '.' + borderClass + ' > .bg-color-overlay > .border-arrow--bottom'] = ['border-style', 'border-color', 'border-width', // Border left, top\n    'border-bottom-width', ['border-left-color', 'border-bottom-color'], ['border-top-color', 'border-bottom-color']];\n    op.stylesheet(element, styleValues, styleObj, styleSheetOptions, blockData);\n  };\n  /*\n  * Make gradient CSS rules.\n  * @param gradients {object} gradient meta data used to construct the css rules of the form:\n  *        {\n  *           op-gradient-lr-aa00ff-7c4dff: {\n  *               direction: \"lr\",\n  *               color1: \"#aa00ff\",\n  *               color2: \"#7c4dff\",\n  *               hover: false\n  *           }\n  *        }\n  * @param themeColors {object} theme color object defining all the theme colors\n  * @return renderedCSS {string} string of css rules sutable for adding to html. Of the form:\n  *        \".op-gradient-lr-aa00ff-7c4dff { background:linear-gradient(to right, #aa00ff, #7c4dff)}\"\n  */\n\n\n  op.makeGradientCSS = function (gradients, themeColors) {\n    // Mapping of short gradient direction values to their long CSS rule values\n    let GRADIENT_DIRECTIONS = {\n      tb: 'to bottom',\n      lr: 'to right',\n      tlbr: 'to bottom right',\n      trbl: 'to bottom left',\n      radial: 'radial'\n    };\n    let renderedCSS = '';\n\n    for (var gradientClass in gradients) {\n      var gradientObj = gradients[gradientClass],\n          gradientDirection = GRADIENT_DIRECTIONS[gradientObj.direction];\n\n      var generatedGradientObj = op._generateGradientCssRule(gradientObj.color1, gradientObj.color2, themeColors); // Make sure that space before the { is present!\n\n\n      var gradientCSS = '';\n\n      if (gradientDirection === 'radial') {\n        gradientCSS = ' { background:radial-gradient(' + generatedGradientObj.color1 + ', ' + generatedGradientObj.color2 + ')}';\n      } else {\n        gradientCSS = ' { background:linear-gradient(' + gradientDirection + ', ' + generatedGradientObj.color1 + ', ' + generatedGradientObj.color2 + ')}';\n      } // Add hover pseudo-selector:\n      // .op-gradient-lr-primary-dark--hover:hover\n\n\n      if (gradientObj.hover) {\n        gradientClass += ':hover';\n      } // Final String:\n      // .op-gradient-lr-primary-dark { linear-gradient(to right, #FF0000, #000000) }\n\n\n      renderedCSS += '.' + gradientClass + gradientCSS;\n    }\n\n    return renderedCSS;\n  },\n  /**\n  * @brief Generate the appropriate colors for gradients.\n  * @param color1 String: A string color. This could be a hex color (i.e. #FFFAAA) or a theme color name (i.e. primary-color)\n  * @param color2 String: A string color. This could be a hex color (i.e. #FFFAAA) or a theme color name (i.e. primary-color)\n  * @param themeColors Object: An object containing all the theme colors. This will be used to translate \"primary-color\" to a hex color.\n  * @returns {Object} An object that contains the two colors to be used in the gradient.\n  *\n  * {\n  *      color1: hex color value\n  *      colro2: hex color value\n  * }\n  *\n  *          color1 and color2 have to be hex color values\n  * @private\n  */\n  op._generateGradientCssRule = function (color1, color2, themeColors) {\n    var isColor1Transparent = color1 === 'transparent',\n        isColor2Transparent = color2 === 'transparent',\n        isColor1Hex = color1.indexOf('#') !== -1,\n        isColor2Hex = color2.indexOf('#') !== -1,\n        // It's something like 'primary-color or 'dark-color'\n    isColor1ThemedAndNotTransparent = !isColor1Transparent && !isColor1Hex,\n        isColor2ThemedAndNotTransparent = !isColor2Transparent && !isColor2Hex; // We have to do special handling for transparent\n    // Transparent isn't included in the themeData.theme_colors object.\n    // And you can't just specify the colors to be 'transparent' because\n    // Safari is a fool\n    // https://css-tricks.com/thing-know-gradients-transparent-black/\n    // If one color is transparent and the other isn't, then the transparent color\n    // Should be come the RGBA version of the other color\n\n    if (isColor1Transparent && isColor2Transparent) {\n      // If both colors are transparent, just use transparent white for both\n      color1 = op.hexToRgba('#FFFFFF', 0);\n      color2 = color1;\n    } else if (isColor1ThemedAndNotTransparent && isColor2ThemedAndNotTransparent) {\n      color1 = themeColors[color1];\n      color2 = themeColors[color2];\n    } else if (isColor1Transparent && isColor2ThemedAndNotTransparent) {\n      color2 = themeColors[color2];\n      color1 = op.hexToRgba(color2, 0);\n    } else if (isColor2Transparent && isColor1ThemedAndNotTransparent) {\n      color1 = themeColors[color1];\n      color2 = op.hexToRgba(color1, 0);\n    } else if (isColor1Hex && isColor2Transparent) {\n      color2 = op.hexToRgba(color1, 0);\n    } else if (isColor2Hex && isColor1Transparent) {\n      color1 = op.hexToRgba(color2, 0);\n    } else if (isColor1Hex && isColor2ThemedAndNotTransparent) {\n      color2 = themeColors[color2];\n    } else if (isColor2Hex && isColor1ThemedAndNotTransparent) {\n      color1 = themeColors[color1];\n    }\n\n    return {\n      color1: color1,\n      color2: color2\n    };\n  };\n  /**\n  * @brief Convert a color hex string to a rgba value.\n  *\n  * There is an exact copy of the function in temlateprocessor/hooks/column.js.\n  * I just didn't want to make a dependency to it, so I included it there too.\n  *\n  * #d4e157 => rgba(212, 225, 87, 1)\n  *\n  * Alpha value defaults to 1 if none is specified\n  * https://stackoverflow.com/questions/21646738/convert-hex-to-rgba\n  * @param hex\n  * @param alpha (optional)\n  * @returns {string}\n  * @private\n  */\n\n  op.hexToRgba = function (hex, alpha) {\n    var alpha = alpha === undefined ? 1 : alpha,\n        ret;\n\n    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {\n      ret = hex.substring(1).split(''); // Handle hex shorthand inputs\n\n      if (ret.length === 3) {\n        ret = [ret[0], ret[0], ret[1], ret[1], ret[2], ret[2]];\n      }\n\n      ret = '0x' + ret.join('');\n      return 'rgba(' + [ret >> 16 & 255, ret >> 8 & 255, ret & 255].join(',') + ',' + alpha + ')';\n    } else {\n      return 'rgba(0,0,0,0)';\n    }\n  }, // Dup of the template processor get attribute helper. So little code here I thought it prudent to\n  // Duplicate it as opposed to setting up another dependancy. This is required byt the stylesheet method.\n  op.getAttribute = function (attrName) {\n    return function (element) {\n      var ret = [];\n\n      if (element !== undefined) {\n        return element.getAttribute(attrName);\n      }\n\n      for (var i = 0, l = this.length, v; i < l; i++) {\n        v = this[i].getAttribute(attrName);\n\n        if (v && v.indexOf('{field') === -1) {\n          ret.push(v);\n        }\n      }\n\n      return ret;\n    };\n  };\n  op.getId = op.getAttribute('opt-id');\n  /**\n  * Create a style tag for the target element\n  * @author Jesse Baird<jesse@ontraport.com>\n  * @param  {[type]} element   DOM element\n  * @param  {[type]} data      object { background: 'pink', 'border-color'}\n  * // Baffaling paramter name\n  * @param  {[type]} decBlocks {\n  *                             '': [ 'background', ['color', 'dataPropNameThatsNotColor']]\n  *\n  *                             }\n  *  * @param {object} blockSettings block settings object handy for determining if elements exist in a dynamic element.\n  * @return {[type]}           [description]\n  *\n  */\n\n  op.stylesheet = function (element, data, decBlocks, options, blockData) {\n    var _blockData$, _blockData$$settings;\n\n    var closestBlock = element.closest('[opt-type=\"block-v3\"]'),\n        blockId = closestBlock ? this.getId(closestBlock) : '',\n        selectorPrefix = blockId ? '.opt-id-' + blockId : '',\n        styleTagId = blockId ? 's' + blockId : 'border-style',\n        closestColumn = element.closest('[opt-type=\"column\"]'),\n        elContainer = element.closest('.el__style'),\n        isDynamicBlock = false,\n        elId; // Determine if we are working with a dynamic block or an element inside a dynamic block\n\n    if (blockData && Array.isArray(blockData) && ((_blockData$ = blockData[0]) === null || _blockData$ === void 0 ? void 0 : (_blockData$$settings = _blockData$.settings) === null || _blockData$$settings === void 0 ? void 0 : _blockData$$settings.dynamicBlockSettings) || closestBlock && closestBlock.getAttribute('data-dc')) {\n      isDynamicBlock = true;\n    } // If element is an actual opt-element (not column or block), get its ID\n\n\n    if (elContainer !== null) {\n      elId = this.getId(element); // If elId is null, the element target passed into this hook is not the actually opt-element. For example, inputs.\n\n      if (elId === null) {\n        elId = this.getId(elContainer.querySelector('[opt-id]'));\n      }\n\n      styleTagId += '-' + elId;\n      selectorPrefix += ' [opt-id=\"' + elId + '\"]';\n    } else if (closestColumn !== null) {\n      var colId = this.getId(closestColumn);\n      styleTagId += '-' + colId;\n      selectorPrefix += ' [opt-id=\"' + colId + '\"]';\n    } // If a namespace is passed in, append it to the style tag ID\n\n\n    if (options && options.namespace) {\n      styleTagId += '-' + options.namespace;\n    } // If block was not present, grab parent and try to build a valid selector. One place this occurs is favorites\n\n\n    if (closestBlock === null) {\n      closestBlock = element.parentElement; // Convert class list to an array, and look for a class starting with 'opt-id-'. If present, use this as the selector prefix\n\n      var classArr = [].slice.call(closestBlock.classList),\n          closestEl;\n      classArr = classArr.filter(function (singleClass) {\n        return singleClass.indexOf('opt-id-') === 0;\n      }); // If there is not class starting with opt-id, look for the presets-wrapper or favorites-wrapper\n      // For presets and favorites, if we don't add this extra selector, then the styles for each\n      // Preset and favorite will overwrite each other\n\n      if (classArr.length === 0) {\n        closestEl = closestBlock.closest('.opt-palette-style__presets-wrapper');\n\n        if (closestEl) {\n          classArr.push('opt-palette-style__presets-wrapper');\n        }\n      }\n\n      if (classArr.length === 0) {\n        closestEl = closestBlock.closest('.opt-palette-style__favorites-wrapper');\n\n        if (closestEl) {\n          classArr.push('opt-palette-style__favorites-wrapper');\n        }\n      }\n\n      if (classArr.length) {\n        selectorPrefix = '.' + classArr[0];\n      }\n\n      if (element.hasAttribute('opt-id')) {\n        selectorPrefix += ' [opt-id=\"' + element.getAttribute('opt-id') + '\"]';\n      } else {\n        // Inputs pass in their inner elements to the border & stylesheet hooks, so look outward for the outer element to get opt-id\n        var outerEl = element.closest('.opt-element');\n\n        if (outerEl && outerEl.hasAttribute('opt-id')) {\n          selectorPrefix += ' [opt-id=\"' + outerEl.getAttribute('opt-id') + '\"]';\n        }\n\n        outerEl = null;\n      }\n    }\n\n    var rules = [],\n        styleText = '',\n        selector;\n\n    for (selector in decBlocks) {\n      rules = [];\n      decBlocks[selector].forEach(function (rules, data, prop) {\n        var value = data[prop]; // In the case of [ 'css', 'dataobjectprp']\n\n        if (typeof prop == 'object') {\n          value = data[prop[1]];\n          prop = prop[0];\n        }\n\n        if (value) {\n          if (selector === ' .js-opt-bg-img') {\n            if (prop.indexOf('border-') > -1 && prop.indexOf('-radius') > -1) {\n              let borderRadiusNumberVal = +value.replace('px', '');\n              let borderTopWidth = data['border-top-width'] || data['border-width'];\n              let borderRightWidth = data['border-right-width'] || data['border-width'];\n              let borderBotWidth = data['border-bottom-width'] || data['border-width'];\n              let borderLeftWidth = data['border-left-width'] || data['border-width']; // Grab the direction from the radius two middle words ex: \"border-top-left-radius\"\n              // will be top-left, top-right, bottom-left, or bottom-right\n\n              let words = prop.split('-'),\n                  topOrBottom = words[1],\n                  leftOrRight = words[2],\n                  borderWidthMap = {\n                top: +borderTopWidth.replace('px', ''),\n                bottom: +borderBotWidth.replace('px', ''),\n                left: +borderLeftWidth.replace('px', ''),\n                right: +borderRightWidth.replace('px', '')\n              },\n                  horizontalBorderWidth = borderWidthMap[topOrBottom],\n                  verticalBorderWidth = borderWidthMap[leftOrRight]; // Find the larger border width of the two.  if they're equal either will do\n\n              let largerBorderWidth = horizontalBorderWidth > verticalBorderWidth ? horizontalBorderWidth : verticalBorderWidth;\n\n              if (borderRadiusNumberVal > largerBorderWidth) {\n                borderRadiusNumberVal = borderRadiusNumberVal - largerBorderWidth;\n                value = borderRadiusNumberVal + 'px';\n              } else {\n                value = '0px';\n              }\n            }\n          } // We have a rule with a value\n\n\n          rules.push(prop + ': ' + value);\n        }\n      }.bind(this, rules, data)); // If we have rules for this selector, then create a selector for it\n      // OUTPUT: .opt-id-df59c721-1da1-93d6-3936-9fa14d1cc0ae{border: 3px solid green;border-top: 3px solid blue}\n\n      if (rules.length) {\n        var _options$blockUserDef, _options$blockUserDef2;\n\n        rules = rules.join(';');\n\n        if (isDynamicBlock || (options === null || options === void 0 ? void 0 : (_options$blockUserDef = options.blockUserDefinedData) === null || _options$blockUserDef === void 0 ? void 0 : (_options$blockUserDef2 = _options$blockUserDef.settings) === null || _options$blockUserDef2 === void 0 ? void 0 : _options$blockUserDef2.dynamicBlockSettings)) {\n          selectorPrefix = selectorPrefix.replace(`.opt-id-${blockId}`, `[data-template-id=\"${blockId}\"]`);\n        }\n\n        styleText += '\\n' + selectorPrefix + selector + '{' + rules + '}';\n      }\n    } // Remove any existing style tags for this element\n    // NOTE add leading \"s\" to prevent the error \" is not a valid selector\" selectors can't lead with a digit\n\n\n    var existing = closestBlock.querySelector('#' + styleTagId);\n\n    if (existing) {\n      existing.remove();\n    } // If we have style text, then append it to the dom\n\n\n    if (styleText !== '') {\n      var styleTag = document.createElement('style');\n      styleTag.setAttribute('id', styleTagId);\n\n      if (options && options.isMobile) {\n        var mobileBreakpoint = op.mobileBreakpoint || 600;\n        styleText = '@media ( max-width: ' + mobileBreakpoint + 'px ) { ' + styleText + ' }';\n      }\n\n      styleTag.innerHTML = styleText;\n      closestBlock.insertBefore(styleTag, closestBlock.firstChild);\n    }\n  };\n  /**\n  * Adjust the dimensions of the target to fit the container better. This is used for making videos fit in its container\n  * and for parallax effects.\n  * @param options Object in the format:\n  * {\n  *\n  *     containerWidth: Number the width of the container, where the container could be the block or the viewport\n  *     containerHeight: Number the height of the container, where the container could be the block or the viewport\n  *     targetWidth: Number the width of the target, where the target could be the an <image>, <video> or <iframe> element\n  *     targetHeight: Number the height of the target, where the target could be the an <image>, <video> or <iframe> element\n  *     targetTagName: String The DOM tag name of the target. This could be the a <image>, <video> or <iframe>\n  *     stretchFactor Number. Multiply the height and width of the target by this much so that it's big enough to\n  *     give a parallax effect or stretch the video the right amount.\n  * }\n  *\n  * @returns {Object} Returns adjusted height and width properties. If no adjustments needed to be made\n  * and we want the target to just take their natural size, then return null.\n  */\n\n\n  op.adjustDimensions = function (options) {\n    // A = h/w\n    // a => aspect ratio\n    // h => height\n    // w => width\n    // Get height of target\n    // Get height of container\n    var containerWidth = options.containerWidth,\n        containerHeight = options.containerHeight,\n        targetWidth = options.targetWidth,\n        targetHeight = options.targetHeight,\n        targetTagName = options.targetTagName,\n        stretchFactor = options.stretchFactor;\n    var targetAspectRatio = targetHeight / targetWidth,\n        newTargetHeight = targetHeight,\n        newTargetWidth = targetWidth; // Video elements are special. They do not always need to have their height and width adjusted.\n    // They do not need their height and width adjust if they are sufficiently large to cover the container.\n    // Yet, if they are not sufficiently large, then they'll need their width and height updated.\n    // Image elements and iframes which contain videos should always have their width and height updated.\n\n    var isVideoElement = targetTagName === 'VIDEO'; // Keep track of whether the dimensions need to get stretched.\n    // There are cases where the target is big enough to cover the container and does not need to get stretched, so\n    // you don't want to apply the newly calculated stretched value.\n    // These flags help handle the case where the video is tall enough to cover a wide, skinny block, but was not wide\n    // enough. In this case we only wanted to apply the horizontal adjustment to video.\n\n    var needToUpdateHeight = false,\n        needToUpdateWidth = false;\n\n    if (newTargetHeight < containerHeight * stretchFactor) {\n      // If stretching the target height is still too short to cover the container\n      // then make the target the same height as the container, but set the width such that it maintains\n      // the target aspect ratio\n      newTargetHeight = containerHeight;\n      newTargetWidth = newTargetHeight / targetAspectRatio;\n      needToUpdateHeight = true;\n      needToUpdateWidth = true;\n    } // We don't really care to apply the stretchFactor to the width.\n    // For all our calculations, we care that the  height is stretched enough to give the parallax effect.\n    // But we want the width to at least cover the container.\n\n\n    if (newTargetWidth < containerWidth) {\n      // If the target width is still too skinny to cover the container\n      // then make the target the same width as the container, but set the height such that it maintains\n      // the target aspect ratio\n      newTargetWidth = containerWidth;\n      newTargetHeight = newTargetWidth * targetAspectRatio;\n      needToUpdateWidth = true;\n    } // Multiply dimensions by this to stretch the target out just a little bit to make sure we can get a parallax effect\n    // or have the video stretch the right amount.\n\n\n    newTargetHeight = newTargetHeight * stretchFactor;\n    newTargetWidth = newTargetWidth * stretchFactor; // Apply new dimensions to the target\n    // If the new values are 0, then do not apply them and allow other styling to manage this.\n\n    var ret = null;\n\n    if (needToUpdateHeight || !isVideoElement) {\n      ret = {\n        height: newTargetHeight\n      };\n    }\n\n    if (needToUpdateWidth || !isVideoElement) {\n      ret = ret || {};\n      ret.width = newTargetWidth;\n    }\n\n    return ret;\n  };\n  /**\n  * Position the video based off its its own size and its container.\n  * This should stretch and move the video based of the aspect ratio of its container.\n  * @param $block jQuery element - the block that contains the video background\n  * @param videoContainer DOM element - the DOM element that contains the video for the background\n  */\n\n\n  op.positionVideo = function ($block, videoContainer) {\n    if ($block == null || videoContainer == null) {\n      return;\n    } // Get height of video\n    // Get height of block\n    // Find center of each\n\n\n    var blockHeight = $block.height(),\n        blockWidth = $block.width(),\n        blockVerticalCenter = blockHeight / 2,\n        blockHorizontalCenter = blockWidth / 2;\n    let video = videoContainer.querySelector('video, iframe');\n\n    if (!video) {\n      return;\n    }\n\n    let videoHeight = video.clientHeight,\n        videoWidth = video.clientWidth,\n        videoVerticalCenter,\n        videoHorizontalCenter;\n    var moveYDelta = 0,\n        moveXDelta = 0,\n        isParallax = videoContainer.closest('.parallax') != null,\n        isFixedParallax = videoContainer.closest('.parallax.parallax--fixed') != null; // Multiply dimensions by this to stretch the target out just a little bit to make sure we can get a parallax effect\n    // or to make a video stretch just enough to fit in a container.\n\n    var stretchFactor = 1; // For non-fixed parallax, we want to stretch the video by 1.5 so that it's big enough to give the parallax effect.\n\n    if (isParallax && !isFixedParallax) {\n      stretchFactor = 1.5;\n    } // For fixed parallax, we make the window the container, to stretch the video to the window dimensions.\n\n\n    if (isParallax && isFixedParallax) {\n      blockHeight = window.innerHeight;\n    }\n\n    var newDimensions = null;\n\n    if (videoWidth !== 0 && videoHeight !== 0) {\n      newDimensions = op.adjustDimensions({\n        containerWidth: blockWidth,\n        containerHeight: blockHeight,\n        targetWidth: videoWidth,\n        targetHeight: videoHeight,\n        targetTagName: video.tagName,\n        stretchFactor: stretchFactor\n      });\n    }\n\n    if (newDimensions && newDimensions.width !== 0 && newDimensions.height !== 0) {\n      video.style.width = newDimensions.width + 'px';\n      video.style.height = newDimensions.height + 'px';\n    } // After adjusting the dimensions, recalculate and apply the video aspect ratio\n\n\n    op.applyVideoAspectRatio(video); // Update our vars for video height and width and centers\n\n    videoHeight = video.clientHeight;\n    videoWidth = video.clientWidth;\n    videoVerticalCenter = videoHeight / 2;\n    videoHorizontalCenter = videoWidth / 2; // If video height is greater than block height, then move video upwards\n    // Want the center of the video to be at center of block,\n    // Distance to move video is video center minus block center\n\n    if (videoHeight > blockHeight) {\n      moveYDelta = videoVerticalCenter - blockVerticalCenter;\n    }\n\n    if (videoWidth > blockWidth) {\n      moveXDelta = videoHorizontalCenter - blockHorizontalCenter;\n    }\n\n    if (moveYDelta !== 0 || moveXDelta !== 0) {\n      video.style.transform = 'translate(-' + moveXDelta + 'px,-' + moveYDelta + 'px)';\n    }\n  };\n  /**\n  * Calculate and apply the aspect ratio to the video's container.\n  *\n  * OPv3 uses Materialize's video-container class, which assumes videos are 16:9 aspect ratio. It styles\n  * the container with padding-bottom: 56.25% (i.e. 9/16 = .5625).\n  *\n  * Not all videos are 16:9, so we gotta make a calculation and apply styles accordingly.\n  * @param videoElement\n  * @private\n  */\n\n\n  op.applyVideoAspectRatio = function (videoElement) {\n    var height = videoElement.videoHeight,\n        width = videoElement.videoWidth,\n        container = videoElement.parentNode,\n        isVideoElement = $(videoElement).closest('.opt-element').length !== 0,\n        aspectRatio; // Handles cases where the video element is a iframe or video element\n    // !height || !width handles cases where the values are 0 or undefined\n\n    if (!height || !width) {\n      height = videoElement.clientHeight;\n      width = videoElement.clientWidth;\n    }\n\n    aspectRatio = height / width; // If the video's aspect ratio doesn't match the magical 16:9 one, then calculate and apply it.\n    // This should handle portrait and landscape videos.\n\n    if (aspectRatio !== .5625) {\n      // Video elements do not have their width/height set, so that they can just fit themselves naturally\n      if (!isVideoElement) {\n        // Non-video elements (i.e. video background)\n        // This makes the video container fill the container that it's in.\n        container.style.width = '100%';\n        container.style.height = '100%';\n      }\n\n      container.style.paddingBottom = (aspectRatio * 100).toFixed(2, 10) + '%';\n    } else {\n      // If the video does match 16:9, then apply the Materialize class and\n      // Get rid of any padding-bottom styles\n      container.style.paddingBottom = '';\n    }\n  };\n  /**\n  * Initialize <video> elements on the page\n  * Right now, it calculates the aspect ratio of the video and adjust the video containers.\n  * Need to wait for the video to be loaded before we have the necessary dimensions.\n  */\n\n\n  op.initVideos = function () {\n    var $videoElements = $('.opt-element .video-background-container video');\n    $videoElements.each(function (index, videoElement) {\n      // We need to wait for the video to be loaded before we can get accurate dimensions\n      // 4 means the video has enough metadata\n      if (videoElement.readyState !== 4) {\n        videoElement.addEventListener('loadedmetadata', op.applyVideoAspectRatio.bind(this, videoElement));\n      } else {\n        op.applyVideoAspectRatio(videoElement);\n      }\n    });\n    $videoElements = null;\n  };\n  /**\n  * Apply custom classes and inline styles to a materialize drop down field.\n  * The customization is stored on default <select> markup as an opt- attribute.\n  * After the materialize dropdowns are initialized this function runs agains all\n  * of them parsing in the customization and adding the classes and inline style it contains.\n  */\n\n\n  op.styleSelect = function ($select) {\n    var customization = JSON.parse($select.attr('opt-dropdown-styles')),\n        customStyles = null,\n        $elContainer = null,\n        $els = null;\n\n    for (var selector in customization) {\n      customStyles = customization[selector];\n      $elContainer = $select.closest('.opt-input__container');\n      $els = $elContainer.find('.' + selector);\n\n      for (var i = 0, l = customStyles.classes.length; i < l; i++) {\n        $els.addClass(customStyles.classes[i]);\n      }\n\n      $els.css(customStyles.styles);\n    }\n  };\n  /**\n  * Checks for mobile device by checking user agent and screen size.\n  * Fun fact: Switching on/off device toggle in Chrome Dev tools changes user agent to mobile version so it can be\n  * tested on the computer.\n  *\n  * @returns {Boolean} true if mobile device, false if not.\n  */\n\n\n  op.isMobileDevice = function () {\n    // Checking if user agent sent by browser contains 'mobi' (for mobile), or the screen width is small enough\n    // to be considered mobile.\n    const mobileUserAgentMobi = navigator.userAgent.toLowerCase().match(/(mobi|android)/g);\n\n    if (mobileUserAgentMobi) {\n      if (mobileUserAgentMobi.length > 0 || window.innerWidth <= 600) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n  * This is essentially a copy of the getCultureDefinition method on ontraport.common.\n  *\n  * It's copied here since the custom element doesn't have access to ontraport.common\n  * @param currencySettings\n  * @returns {*}\n  */\n\n\n  op.getCultureDefinition = function (currencySettings) {\n    var culture = Globalize.culture(); // Apply currency symbol\n\n    culture.numberFormat.currency.symbol = currencySettings.currency.currency_symbol; // Apply currency format (symbol left/right)\n\n    var currencyFormat = '',\n        currencyCode = currencySettings.currency.currency_code;\n\n    switch (currencySettings.currency_format) {\n      case 'symbol-left':\n        currencyFormat = ['($n)', '$n'];\n        break;\n\n      case 'symbol-left-country-code':\n        currencyFormat = ['($' + currencyCode + ' n)', '$' + currencyCode + ' n'];\n        break;\n\n      case 'symbol-right':\n        currencyFormat = ['-n $', 'n $'];\n        break;\n\n      case 'symbol-right-country-code':\n        currencyFormat = ['-n $' + currencyCode, 'n $' + currencyCode];\n        break;\n\n      default:\n        // Symbol left is default\n        currencyFormat = ['($n)', '$n'];\n        break;\n    }\n\n    culture.numberFormat.currency.pattern = currencyFormat; // Apply number format (comma, decimal placement)\n\n    switch (currencySettings.number_format) {\n      case 'comma-decimal':\n        culture.numberFormat.currency[','] = ',';\n        culture.numberFormat.currency['.'] = '.';\n        break;\n\n      case 'decimal-comma':\n        culture.numberFormat.currency[','] = '.';\n        culture.numberFormat.currency['.'] = ',';\n        break;\n    }\n\n    return culture;\n  };\n\n  return op;\n})(jQuery, window);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9vcHQuY29tbW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vd3d3L2pzLTMuMi4yL29udHJhcG9ydC9vcHRfYXNzZXRzL29wdF9ib2lsZXJwbGF0ZXMvdjMvb3B0LmNvbW1vbi5qcz83ZGI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT250cmFwb3J0J3MgcHVibGljIGZhY2luZyBsYW5kaW5nIHBhZ2Ugc2NyaXB0cy4gVGhlc2UgZnVuY3Rpb25zIGFyZSBkZXNpZ25lZCB0byBiZSBhdmFpbGFibGUgYm90aCBpbiBhcHBcbiAqIGFuZCBpbiBwdWJsaWMgZmFjaW5nIGZpbGVzXG4gKi9cbiggZnVuY3Rpb24oICQsIGNvbnRleHQgKSB7XG4gICAgLy8gRG9uJ3Qgb3ZlcndyaXRlIG91ciBnbG9iYWwgb2JqZWN0XG4gICAgdmFyIG9wID0gY29udGV4dC5vcCB8fCAoIGNvbnRleHQub3AgPSB7fSApO1xuXG4gICAgLyoqXG4gICAqIEJvcmRlciBob29rIHVzZWQgYnkgYm90aCB0aGUgdGVtcGxhdGVwcm9jZXNzb3IgYW5kIHdlYmNvbXBvbmVudHMuIEl0IHRha2VzIGEgc2V0dGluZ3Mgb2JqZWN0IGRpc2NyaWJpbmcgYm9yZGVyc1xuICAgKiBhbmQgYXBwbGllc3QgdGhlbSB0byB0aGUgaW5jb21pbmcgZWxlbWVudHMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IERPTSBvYmplY3RcbiAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIG9iamVjdCBkZXNjcmliaW5nIGJvcmRlciBhbmQgc2hhZG93IHNldHRpbmdzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gYmxvY2tTZXR0aW5ncyBibG9jayBzZXR0aW5ncyBvYmplY3QgaGFuZHkgZm9yIGRldGVybWluaW5nIGlmIGVsZW1lbnRzIGV4aXN0IGluIGEgZHluYW1pYyBlbGVtZW50LlxuICAgKi9cblxuICAgIG9wLmJvcmRlciA9IGZ1bmN0aW9uKCBlbGVtZW50LCBzZXR0aW5ncyA9IHt9LCBibG9ja0RhdGEgKSB7XG4gICAgICAgIHZhciBfbm9uWmVyb0JvcmRlclJhZGl1c1Rlc3QgPSBmdW5jdGlvbiggc3R5bGVWYWx1ZXMgKSB7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVWYWx1ZXNbICdib3JkZXItdG9wLWxlZnQtcmFkaXVzJyBdICYmIHN0eWxlVmFsdWVzWyAnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycgXSAhPT0gJzBweCcgfHwgc3R5bGVWYWx1ZXNbICdib3JkZXItdG9wLXJpZ2h0LXJhZGl1cycgXSAmJiBzdHlsZVZhbHVlc1sgJ2JvcmRlci10b3AtcmlnaHQtcmFkaXVzJyBdICE9PSAnMHB4JyB8fCBzdHlsZVZhbHVlc1sgJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnIF0gJiYgc3R5bGVWYWx1ZXNbICdib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzJyBdICE9PSAnMHB4JyB8fCBzdHlsZVZhbHVlc1sgJ2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzJyBdICYmIHN0eWxlVmFsdWVzWyAnYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMnIF0gIT09ICcwcHgnO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdHlsZVNoZWV0T3B0aW9ucyA9IHt9LFxuICAgICAgICAgICAgYm9yZGVyQ2xhc3MgPSAnb3B0LWJvcmRlcic7IC8vIElmIGEgY3VzdG9tIGJvcmRlciBjbGFzcyBpcyBwYXNzZWQgaW4sIGFsc28gcGFzcyBpdCBhbG9uZyB0byB0aGUgc3R5bGVzaGVldCBhdHRyaWJ1dGUgaGFuZGxlclxuXG4gICAgICAgIGlmICggc2V0dGluZ3MuYmxvY2tVc2VyRGVmaW5lZERhdGEgKSB7XG4gICAgICAgICAgICBzdHlsZVNoZWV0T3B0aW9ucy5ibG9ja1VzZXJEZWZpbmVkRGF0YSA9IHNldHRpbmdzLmJsb2NrVXNlckRlZmluZWREYXRhWyAwIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHNldHRpbmdzWyAnY3VzdG9tLWJvcmRlci1jbGFzcycgXSApIHtcbiAgICAgICAgICAgIGJvcmRlckNsYXNzID0gc2V0dGluZ3NbICdjdXN0b20tYm9yZGVyLWNsYXNzJyBdO1xuICAgICAgICAgICAgc3R5bGVTaGVldE9wdGlvbnMubmFtZXNwYWNlID0gc2V0dGluZ3NbICdjdXN0b20tYm9yZGVyLWNsYXNzJyBdO1xuICAgICAgICB9IC8vIFJlbW92ZSB0aGUgZm9sbG93aW5nIGNsYXNzZXMgZnJvbSB0aGUgZWxlbWVudFxuXG5cbiAgICAgICAgdmFyIGNsYXNzZXNUb1JlbW92ZSA9IFsgJ2JvcmRlci1hcnJvdy0tdG9wJywgJ2JvcmRlci1hcnJvdy0tYm90dG9tJywgJ3otZGVwdGgtMDAnLCAnei1kZXB0aC0xMCcsICd6LWRlcHRoLTIwJywgJ3otZGVwdGgtMzAnLCAnei1kZXB0aC00MCcsICd6LWRlcHRoLTUwJywgJ3otZGVwdGgtMTAtLWhvdmVyJywgJ3otZGVwdGgtMjAtLWhvdmVyJywgJ3otZGVwdGgtMzAtLWhvdmVyJywgJ3otZGVwdGgtNDAtLWhvdmVyJywgJ3otZGVwdGgtNTAtLWhvdmVyJyBdO1xuICAgICAgICBjbGFzc2VzVG9SZW1vdmUuZm9yRWFjaCggZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSggY2xhc3NOYW1lICk7XG4gICAgICAgIH0sIGVsZW1lbnQgKTsgLy8gUmVtb3ZlIGFsbCBjbGFzc2VzIHRoYXQgY29udGFpbmVyIFwiY29sb3ItYm9yZGVyXCIgaW4gdGhlbSAoYWxsIGJvcmRlciBjbGFzc2VzKVxuXG4gICAgICAgIHZhciByZW1vdmVDb2xvckNsYXNzZXMgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBlbGVtZW50LmNsYXNzTGlzdC5sZW5ndGgsIGM7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICBjID0gZWxlbWVudC5jbGFzc0xpc3RbIGkgXTtcblxuICAgICAgICAgICAgaWYgKCBjLmluY2x1ZGVzKCAnY29sb3ItYm9yZGVyJyApICkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNvbG9yQ2xhc3Nlcy5wdXNoKCBjICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gV3JhcCB0aGlzIGluIGEgbGVuZ3RoIGNoZWNrIGZvciBmJ24gSUUgbGxcblxuXG4gICAgICAgIGlmICggcmVtb3ZlQ29sb3JDbGFzc2VzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSggLi4ucmVtb3ZlQ29sb3JDbGFzc2VzICk7XG4gICAgICAgIH0gLy8gQXBwbHkgdGhlIFwiemluZGV4XCIgYXMgYW4gYXR0ciBzbyB0aGUgYWplbnQgYW5kIGVkaXRvciBjYW4gYXBwbHkgdGhlIHppbmRleCBpbiBhIGRlY2VuZGluZyBvcmRlclxuXG5cbiAgICAgICAgdmFyIHpJbmRleCA9IHNldHRpbmdzLmFwcGx5WmluZGV4ICYmIHNldHRpbmdzWyAnei1pbmRleCcgXTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoICdkYXRhLXppbmRleCcgKTtcblxuICAgICAgICBpZiAoIHpJbmRleCApIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCAnZGF0YS16aW5kZXgnLCB6SW5kZXggKTtcbiAgICAgICAgfSAvLyBBcHBseSBib3ggc2hhZG93IGlmIHByZXNlbnRcblxuXG4gICAgICAgIGlmICggc2V0dGluZ3NbICdib3gtc2hhZG93JyBdICkge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCBzZXR0aW5nc1sgJ2JveC1zaGFkb3cnIF0gKTtcbiAgICAgICAgfSAvLyBBcHBseSBob3ZlciBib3ggc2hhZG93IGlmIHByZXNlbnRcblxuXG4gICAgICAgIGlmICggc2V0dGluZ3NbICdib3gtc2hhZG93LWhvdmVyJyBdICkge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCBzZXR0aW5nc1sgJ2JveC1zaGFkb3ctaG92ZXInIF0gKyAnLS1ob3ZlcicgKTtcbiAgICAgICAgfSAvLyBTcGVjaWFsIGxvZ2ljIGZvciBibG9jayBib3JkZXJzLiBTZXRzIGNvbnRlbnQgYm94IHNoYWRvdyAob24gdGhlIGNvbnRhaW5lciBhcm91bmQgdGhlIHJvd3MpXG5cblxuICAgICAgICB2YXIgJGNvbnRlbnRDb250YWluZXIgPSAkKCBlbGVtZW50ICkuZmluZCggJz4gLmNvbnRhaW5lcicgKTtcblxuICAgICAgICBpZiAoICRjb250ZW50Q29udGFpbmVyLmxlbmd0aCAmJiAoIHNldHRpbmdzWyAnY29udGVudC1ib3gtc2hhZG93JyBdIHx8IHNldHRpbmdzWyAnY29udGVudC1ib3gtc2hhZG93LWhvdmVyJyBdICkgKSB7XG4gICAgICAgICAgICAkY29udGVudENvbnRhaW5lci5yZW1vdmVDbGFzcyggY2xhc3Nlc1RvUmVtb3ZlLmpvaW4oICcgJyApICk7XG5cbiAgICAgICAgICAgIGlmICggc2V0dGluZ3NbICdjb250ZW50LWJveC1zaGFkb3cnIF0gKSB7XG4gICAgICAgICAgICAgICAgJGNvbnRlbnRDb250YWluZXIuYWRkQ2xhc3MoIHNldHRpbmdzWyAnY29udGVudC1ib3gtc2hhZG93JyBdICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggc2V0dGluZ3NbICdjb250ZW50LWJveC1zaGFkb3ctaG92ZXInIF0gKSB7XG4gICAgICAgICAgICAgICAgJGNvbnRlbnRDb250YWluZXIuYWRkQ2xhc3MoIHNldHRpbmdzWyAnY29udGVudC1ib3gtc2hhZG93LWhvdmVyJyBdICsgJy0taG92ZXInICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkY29udGVudENvbnRhaW5lciA9IG51bGw7IC8vIEFwcGx5IGJvcmRlciBhcnJvdyBpZiBwcmVzZW50XG5cbiAgICAgICAgaWYgKCBzZXR0aW5nc1sgJ2JvcmRlci1hcnJvdycgXSApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYXBwZW5kIHRoZSBlbGVtZW50IGlmIHdlIGhhdmUgYSBiYWNrZ3JvdW5kIHdlIGNhbiBtaW1pYy5cbiAgICAgICAgICAgIGlmICggc2V0dGluZ3MuYmFja2dyb3VuZCAmJiBzZXR0aW5ncy5iYWNrZ3JvdW5kLmJhY2tncm91bmRfdHlwZSA9PSAnY29sb3JzJyAmJiBzZXR0aW5ncy5iYWNrZ3JvdW5kLmNvbG9ycyAmJiBzZXR0aW5ncy5iYWNrZ3JvdW5kLmNvbG9ycy5jb2xvcl90eXBlID09ICdzb2xpZCcgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvcmRlckFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcbiAgICAgICAgICAgICAgICBib3JkZXJBcnJvdy5jbGFzc0xpc3QuYWRkKCAnYm9yZGVyLWFycm93LS0nICsgc2V0dGluZ3NbICdib3JkZXItYXJyb3cnIF0gKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCAnW2NsYXNzKj1cIi1vdmVybGF5XCJdJyApOyAvLyBTd2l0Y2ggb3JkZXIgb2YgYXR0cnMsIHNvIHRoZSBib3JkZXIgaXMgdGhlIGxhc3Qgb25lLCBvbmx5IHRhcmdldCBiZy1jb2xvci1vdmVybGF5XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRhcmdldCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKCBib3JkZXJBcnJvdyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoIGJvcmRlckNsYXNzICk7XG4gICAgICAgIHZhciBzdHlsZVZhbHVlcyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgc2V0dGluZ3MgKSxcbiAgICAgICAgICAgIGJvcmRlckRpcmVjdGlvbnMgPSBbICdib3JkZXInLCAnYm9yZGVyLXRvcCcsICdib3JkZXItYm90dG9tJywgJ2JvcmRlci1sZWZ0JywgJ2JvcmRlci1yaWdodCcgXTsgLy8gTG9vcCBvdmVyIGVhY2ggYm9yZGVyIGRpcmVjdGlvbiAoYWxsLCB0b3AsIGJvdHRvbSwgbGVmdCByaWdodCkgYW5kIGFkZCB0aGVtZSBjbGFzc2VzIGlmIG5lZWRlZFxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGJvcmRlckRpcmVjdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGJvcmRlckRpciA9IGJvcmRlckRpcmVjdGlvbnNbIGkgXSxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IHN0eWxlVmFsdWVzWyBib3JkZXJEaXIgKyAnLWNvbG9yJyBdLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9ySG92ZXIgPSBzdHlsZVZhbHVlc1sgYm9yZGVyRGlyICsgJy1jb2xvci1ob3ZlcicgXSxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvckZvY3VzID0gc3R5bGVWYWx1ZXNbIGJvcmRlckRpciArICctY29sb3ItZm9jdXMnIF07XG5cbiAgICAgICAgICAgIGlmICggYm9yZGVyQ29sb3IgIT09IHVuZGVmaW5lZCAmJiBib3JkZXJDb2xvciAhPT0gJ3RyYW5zcGFyZW50JyAmJiBib3JkZXJDb2xvci5pbmRleE9mKCAnIycgKSA9PT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCBib3JkZXJDb2xvciArICctJyArIGJvcmRlckRpciApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBib3JkZXJBcnJvdyApIHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQXJyb3cuY2xhc3NMaXN0LmFkZCggYm9yZGVyQ29sb3IgKyAnLScgKyBib3JkZXJEaXIgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgc3R5bGVWYWx1ZXNbIGJvcmRlckRpciArICctY29sb3InIF07IC8vXG4gICAgICAgICAgICAgICAgLy8gQWRkIHZhbHVlIHRvIGZvciBib3JkZXIgYXJyb3dcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBib3JkZXJDb2xvckhvdmVyICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBib3JkZXJDb2xvckhvdmVyICE9PSAndHJhbnNwYXJlbnQnICYmIGJvcmRlckNvbG9ySG92ZXIuaW5kZXhPZiggJyMnICkgPT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoIGJvcmRlckNvbG9ySG92ZXIgKyAnLScgKyBib3JkZXJEaXIgKyAnLS1ob3ZlcicgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGJvcmRlckFycm93ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQXJyb3cuY2xhc3NMaXN0LmFkZCggYm9yZGVyQ29sb3JIb3ZlciArICctJyArIGJvcmRlckRpciArICctLWhvdmVyJyApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlVmFsdWVzWyBib3JkZXJEaXIgKyAnLWNvbG9yLWhvdmVyJyBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJvcmRlckRpciAhPT0gJ2JvcmRlcicgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHN0eWxlIGlzIGFuIGluZGl2aWR1YWwgZGlyZWN0aW9uIGFuZCBpcyBub3QgY2xhc3MgYmFzZWQsIG1ha2UgaXQgaW1wb3J0YW50IHNpbmNlIHRoZW1lIGhvdmVyIGNsYXNzZXMgYWxzbyB1c2UgaW1wb3J0YW50XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVmFsdWVzWyBib3JkZXJEaXIgKyAnLWNvbG9yLWhvdmVyJyBdID0gc3R5bGVWYWx1ZXNbIGJvcmRlckRpciArICctY29sb3ItaG92ZXInIF0gKyAnICFpbXBvcnRhbnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBib3JkZXJDb2xvckZvY3VzICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBib3JkZXJDb2xvckZvY3VzICE9PSAndHJhbnNwYXJlbnQnICYmIGJvcmRlckNvbG9yRm9jdXMuaW5kZXhPZiggJyMnICkgPT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoIGJvcmRlckNvbG9yRm9jdXMgKyAnLScgKyBib3JkZXJEaXIgKyAnLS1mb2N1cycgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGJvcmRlckFycm93ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQXJyb3cuY2xhc3NMaXN0LmFkZCggYm9yZGVyQ29sb3JGb2N1cyArICctJyArIGJvcmRlckRpciArICctLWZvY3VzJyApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlVmFsdWVzWyBib3JkZXJEaXIgKyAnLWNvbG9yLWZvY3VzJyBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJvcmRlckRpciAhPT0gJ2JvcmRlcicgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHN0eWxlIGlzIGFuIGluZGl2aWR1YWwgZGlyZWN0aW9uIGFuZCBpcyBub3QgY2xhc3MgYmFzZWQsIG1ha2UgaXQgaW1wb3J0YW50IHNpbmNlIHRoZW1lIGZvY3VzIGNsYXNzZXMgYWxzbyB1c2UgaW1wb3J0YW50XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVmFsdWVzWyBib3JkZXJEaXIgKyAnLWNvbG9yLWZvY3VzJyBdID0gc3R5bGVWYWx1ZXNbIGJvcmRlckRpciArICctY29sb3ItZm9jdXMnIF0gKyAnICFpbXBvcnRhbnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3RvckNhcmF0ID0gJyA+ICcsXG4gICAgICAgICAgICBzdHlsZU9iaiA9IHt9LFxuICAgICAgICAgICAgaGlkZU92ZXJmbG93ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSWYgY29udGFpbmVkIGluIHRoZSAnZWxfX3N0eWxlJyB3cmFwcGVyLCB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIGVsZW1lbnQsIG5vdCBhIGNvbHVtbiBvciBibG9ja1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGltbWVkaWF0ZSBzZWxlY3RvciBzbyB0aGF0IHRoZSBzdHlsZXNoZWV0IGhvb2sgd2lsbCBjb25jYXQgdGhlIGVsZW1lbnQgb3B0LWlkXG4gICAgICAgIGlmICggZWxlbWVudC5jbG9zZXN0KCAnLmVsX19zdHlsZScgKSB8fCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyggJ29wdC1lbGVtZW50JyApIHx8IGVsZW1lbnQuY2xvc2VzdCggJy5vcHQtZWxlbWVudCcgKSApIHtcbiAgICAgICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIG9wdC1pZCwgbWFrZSB0aGUgc2VsZWN0b3IgZW1wdHkgc3RyaW5nIHNvIHRoYXQgdGhlIG9wdC1pZCBhbmQgb3B0LWJvcmRlciBjbGFzc2VzIHRvdWNoIGluIHRoZSBzZWxlY3RvclxuICAgICAgICAgICAgLy8gSWYgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGFuIG9wdC1pZCBtYWtlIHNlbGVjdG9yIGEgc3BhY2UgdGhhdCB0aGUgc2VsZWN0b3IgdGFyZ2V0cyB0aGUgb3B0LWJvcmRlciBjbGFzcyBJTlNJREUgdGhlIG9wdC1pZFxuICAgICAgICAgICAgc2VsZWN0b3JDYXJhdCA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCAnb3B0LWlkJyApID8gJycgOiAnICc7XG4gICAgICAgIH0gZWxzZSBpZiAoIF9ub25aZXJvQm9yZGVyUmFkaXVzVGVzdCggc3R5bGVWYWx1ZXMgKSApIHtcbiAgICAgICAgICAgIC8vIE1ha2UgYSBzdHlsZSBzaGVldCBlbnRyeSB0aGF0IGFwcGxpZXMgYm9yZGVyIHJhZGl1cyB0byB0aGUgYmFja2dyb3VuZC4gVGhpcyB3YXkgd2UgZG9uJ3QgbmVlZCBvdmVyZmxvdyBoaWRkZW4gdG8gY292ZXIgdGhlIGJnIGVsZW1lbnQuXG4gICAgICAgICAgICBzdHlsZU9ialsgJyAuanMtb3B0LWJnLWltZycgXSA9IFsgJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnLCAnYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMnLCAnYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cycsICdib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cycgXTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBib3JkZXIgcmFkaXVzIGFuZCB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgY29sdW1uLCBoaWRlIHRoZSBvdmVyZmxvd1xuICAgICAgICAgICAgaWYgKCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyggJ2NvbF9fc3R5bGUnICkgKSB7XG4gICAgICAgICAgICAgICAgaGlkZU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlT2JqWyBzZWxlY3RvckNhcmF0ICsgJy4nICsgYm9yZGVyQ2xhc3MgXSA9IFsgJ2JvcmRlci1zdHlsZScsICdib3JkZXItY29sb3InLCAnYm9yZGVyLXdpZHRoJywgJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnLCAnYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMnLCAnYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cycsICdib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cycgXTtcblxuICAgICAgICBpZiAoIGhpZGVPdmVyZmxvdyApIHtcbiAgICAgICAgICAgIHN0eWxlT2JqWyBzZWxlY3RvckNhcmF0ICsgJy4nICsgYm9yZGVyQ2xhc3MgXS5wdXNoKCAnb3ZlcmZsb3cnICk7XG4gICAgICAgICAgICBzdHlsZVZhbHVlcy5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5jcmVhc2UgdGhlIHNlbGVjdG9yIHdlaWdodCBmb3IgaW5kaXZpZHVhbCBib3JkZXIgZGlyZWN0aW9ucyBzbyB0aGV5IGFyZSBlcXVhbCB0byB0aGUgc2VsZWN0b3Igd2VpZ2h0IG9mIHRoZSB0aGVtZSBjbGFzc2VzIChzbyB0aGV5IHdpbGwgb3ZlcnJpZGUgYW55IFwiYWxsIGJvcmRlclwiIHRoZW1lIHN0eWxlcylcbiAgICAgICAgc3R5bGVPYmpbIHNlbGVjdG9yQ2FyYXQgKyAnLicgKyBib3JkZXJDbGFzcyArICcuJyArIGJvcmRlckNsYXNzIF0gPSBbICdib3JkZXItdG9wLWNvbG9yJywgJ2JvcmRlci10b3Atd2lkdGgnLCAnYm9yZGVyLXJpZ2h0LWNvbG9yJywgJ2JvcmRlci1yaWdodC13aWR0aCcsICdib3JkZXItYm90dG9tLWNvbG9yJywgJ2JvcmRlci1ib3R0b20td2lkdGgnLCAnYm9yZGVyLWxlZnQtY29sb3InLCAnYm9yZGVyLWxlZnQtd2lkdGgnIF07XG4gICAgICAgIHN0eWxlT2JqWyBzZWxlY3RvckNhcmF0ICsgJy4nICsgYm9yZGVyQ2xhc3MgKyAnOmhvdmVyJyBdID0gWyBbICdib3JkZXItY29sb3InLCAnYm9yZGVyLWNvbG9yLWhvdmVyJyBdLCBbICdib3JkZXItdG9wLWNvbG9yJywgJ2JvcmRlci10b3AtY29sb3ItaG92ZXInIF0sIFsgJ2JvcmRlci1yaWdodC1jb2xvcicsICdib3JkZXItcmlnaHQtY29sb3ItaG92ZXInIF0sIFsgJ2JvcmRlci1ib3R0b20tY29sb3InLCAnYm9yZGVyLWJvdHRvbS1jb2xvci1ob3ZlcicgXSwgWyAnYm9yZGVyLWxlZnQtY29sb3InLCAnYm9yZGVyLWxlZnQtY29sb3ItaG92ZXInIF0gXTtcbiAgICAgICAgbGV0IGZvY3VzU2VsZWN0b3IgPSBzZWxlY3RvckNhcmF0ICsgJy4nICsgYm9yZGVyQ2xhc3MgKyAnOmZvY3VzJzsgLy8gVGltZXN0YW1wIGZpZWxkcyBkb24ndCBnZXQgZm9jdXMgYmVjYXVzZSB0aGV5IGFyZSBkaXNhYmxlZCwgc28gbGV2ZXJhZ2UgdGhlIG9wZW4gY2xhc3NcblxuICAgICAgICBpZiAoIHNldHRpbmdzLmlzVGltZXN0YW1wICkge1xuICAgICAgICAgICAgZm9jdXNTZWxlY3RvciA9ICcub3B0LWRhdGUtdGltZV9fcGlja2VyLS1vcGVuIC4nICsgYm9yZGVyQ2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZU9ialsgZm9jdXNTZWxlY3RvciBdID0gWyBbICdib3JkZXItY29sb3InLCAnYm9yZGVyLWNvbG9yLWZvY3VzJyBdLCBbICdib3JkZXItdG9wLWNvbG9yJywgJ2JvcmRlci10b3AtY29sb3ItZm9jdXMnIF0sIFsgJ2JvcmRlci1yaWdodC1jb2xvcicsICdib3JkZXItcmlnaHQtY29sb3ItZm9jdXMnIF0sIFsgJ2JvcmRlci1ib3R0b20tY29sb3InLCAnYm9yZGVyLWJvdHRvbS1jb2xvci1mb2N1cycgXSwgWyAnYm9yZGVyLWxlZnQtY29sb3InLCAnYm9yZGVyLWxlZnQtY29sb3ItZm9jdXMnIF0gXTsgLy8gQm9yZGVyIGFycm93IHN0eWxlc1xuICAgICAgICAvL1xuXG4gICAgICAgIHN0eWxlT2JqWyBzZWxlY3RvckNhcmF0ICsgJy4nICsgYm9yZGVyQ2xhc3MgKyAnLicgKyBib3JkZXJDbGFzcyArICcgPiAuYmctY29sb3Itb3ZlcmxheSA+IC5ib3JkZXItYXJyb3ctLWJvdHRvbScgXSA9IFsgJ2JvcmRlci1zdHlsZScsICdib3JkZXItY29sb3InLCAnYm9yZGVyLXdpZHRoJywgLy8gQm9yZGVyIGxlZnQsIHRvcFxuICAgICAgICAgICAgJ2JvcmRlci1ib3R0b20td2lkdGgnLCBbICdib3JkZXItbGVmdC1jb2xvcicsICdib3JkZXItYm90dG9tLWNvbG9yJyBdLCBbICdib3JkZXItdG9wLWNvbG9yJywgJ2JvcmRlci1ib3R0b20tY29sb3InIF0gXTtcbiAgICAgICAgb3Auc3R5bGVzaGVldCggZWxlbWVudCwgc3R5bGVWYWx1ZXMsIHN0eWxlT2JqLCBzdHlsZVNoZWV0T3B0aW9ucywgYmxvY2tEYXRhICk7XG4gICAgfTtcblxuICAgIC8qXG4gICAqIE1ha2UgZ3JhZGllbnQgQ1NTIHJ1bGVzLlxuICAgKiBAcGFyYW0gZ3JhZGllbnRzIHtvYmplY3R9IGdyYWRpZW50IG1ldGEgZGF0YSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgY3NzIHJ1bGVzIG9mIHRoZSBmb3JtOlxuICAgKiAgICAgICAge1xuICAgKiAgICAgICAgICAgb3AtZ3JhZGllbnQtbHItYWEwMGZmLTdjNGRmZjoge1xuICAgKiAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJsclwiLFxuICAgKiAgICAgICAgICAgICAgIGNvbG9yMTogXCIjYWEwMGZmXCIsXG4gICAqICAgICAgICAgICAgICAgY29sb3IyOiBcIiM3YzRkZmZcIixcbiAgICogICAgICAgICAgICAgICBob3ZlcjogZmFsc2VcbiAgICogICAgICAgICAgIH1cbiAgICogICAgICAgIH1cbiAgICogQHBhcmFtIHRoZW1lQ29sb3JzIHtvYmplY3R9IHRoZW1lIGNvbG9yIG9iamVjdCBkZWZpbmluZyBhbGwgdGhlIHRoZW1lIGNvbG9yc1xuICAgKiBAcmV0dXJuIHJlbmRlcmVkQ1NTIHtzdHJpbmd9IHN0cmluZyBvZiBjc3MgcnVsZXMgc3V0YWJsZSBmb3IgYWRkaW5nIHRvIGh0bWwuIE9mIHRoZSBmb3JtOlxuICAgKiAgICAgICAgXCIub3AtZ3JhZGllbnQtbHItYWEwMGZmLTdjNGRmZiB7IGJhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCAjYWEwMGZmLCAjN2M0ZGZmKX1cIlxuICAgKi9cblxuXG4gICAgb3AubWFrZUdyYWRpZW50Q1NTID0gZnVuY3Rpb24oIGdyYWRpZW50cywgdGhlbWVDb2xvcnMgKSB7XG4gICAgLy8gTWFwcGluZyBvZiBzaG9ydCBncmFkaWVudCBkaXJlY3Rpb24gdmFsdWVzIHRvIHRoZWlyIGxvbmcgQ1NTIHJ1bGUgdmFsdWVzXG4gICAgICAgIGxldCBHUkFESUVOVF9ESVJFQ1RJT05TID0ge1xuICAgICAgICAgICAgdGI6ICd0byBib3R0b20nLFxuICAgICAgICAgICAgbHI6ICd0byByaWdodCcsXG4gICAgICAgICAgICB0bGJyOiAndG8gYm90dG9tIHJpZ2h0JyxcbiAgICAgICAgICAgIHRyYmw6ICd0byBib3R0b20gbGVmdCcsXG4gICAgICAgICAgICByYWRpYWw6ICdyYWRpYWwnXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZW5kZXJlZENTUyA9ICcnO1xuXG4gICAgICAgIGZvciAoIHZhciBncmFkaWVudENsYXNzIGluIGdyYWRpZW50cyApIHtcbiAgICAgICAgICAgIHZhciBncmFkaWVudE9iaiA9IGdyYWRpZW50c1sgZ3JhZGllbnRDbGFzcyBdLFxuICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uID0gR1JBRElFTlRfRElSRUNUSU9OU1sgZ3JhZGllbnRPYmouZGlyZWN0aW9uIF07XG5cbiAgICAgICAgICAgIHZhciBnZW5lcmF0ZWRHcmFkaWVudE9iaiA9IG9wLl9nZW5lcmF0ZUdyYWRpZW50Q3NzUnVsZSggZ3JhZGllbnRPYmouY29sb3IxLCBncmFkaWVudE9iai5jb2xvcjIsIHRoZW1lQ29sb3JzICk7IC8vIE1ha2Ugc3VyZSB0aGF0IHNwYWNlIGJlZm9yZSB0aGUgeyBpcyBwcmVzZW50IVxuXG5cbiAgICAgICAgICAgIHZhciBncmFkaWVudENTUyA9ICcnO1xuXG4gICAgICAgICAgICBpZiAoIGdyYWRpZW50RGlyZWN0aW9uID09PSAncmFkaWFsJyApIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudENTUyA9ICcgeyBiYWNrZ3JvdW5kOnJhZGlhbC1ncmFkaWVudCgnICsgZ2VuZXJhdGVkR3JhZGllbnRPYmouY29sb3IxICsgJywgJyArIGdlbmVyYXRlZEdyYWRpZW50T2JqLmNvbG9yMiArICcpfSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50Q1NTID0gJyB7IGJhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KCcgKyBncmFkaWVudERpcmVjdGlvbiArICcsICcgKyBnZW5lcmF0ZWRHcmFkaWVudE9iai5jb2xvcjEgKyAnLCAnICsgZ2VuZXJhdGVkR3JhZGllbnRPYmouY29sb3IyICsgJyl9JztcbiAgICAgICAgICAgIH0gLy8gQWRkIGhvdmVyIHBzZXVkby1zZWxlY3RvcjpcbiAgICAgICAgICAgIC8vIC5vcC1ncmFkaWVudC1sci1wcmltYXJ5LWRhcmstLWhvdmVyOmhvdmVyXG5cblxuICAgICAgICAgICAgaWYgKCBncmFkaWVudE9iai5ob3ZlciApIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudENsYXNzICs9ICc6aG92ZXInO1xuICAgICAgICAgICAgfSAvLyBGaW5hbCBTdHJpbmc6XG4gICAgICAgICAgICAvLyAub3AtZ3JhZGllbnQtbHItcHJpbWFyeS1kYXJrIHsgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCAjRkYwMDAwLCAjMDAwMDAwKSB9XG5cblxuICAgICAgICAgICAgcmVuZGVyZWRDU1MgKz0gJy4nICsgZ3JhZGllbnRDbGFzcyArIGdyYWRpZW50Q1NTO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkQ1NTO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICogQGJyaWVmIEdlbmVyYXRlIHRoZSBhcHByb3ByaWF0ZSBjb2xvcnMgZm9yIGdyYWRpZW50cy5cbiAgICogQHBhcmFtIGNvbG9yMSBTdHJpbmc6IEEgc3RyaW5nIGNvbG9yLiBUaGlzIGNvdWxkIGJlIGEgaGV4IGNvbG9yIChpLmUuICNGRkZBQUEpIG9yIGEgdGhlbWUgY29sb3IgbmFtZSAoaS5lLiBwcmltYXJ5LWNvbG9yKVxuICAgKiBAcGFyYW0gY29sb3IyIFN0cmluZzogQSBzdHJpbmcgY29sb3IuIFRoaXMgY291bGQgYmUgYSBoZXggY29sb3IgKGkuZS4gI0ZGRkFBQSkgb3IgYSB0aGVtZSBjb2xvciBuYW1lIChpLmUuIHByaW1hcnktY29sb3IpXG4gICAqIEBwYXJhbSB0aGVtZUNvbG9ycyBPYmplY3Q6IEFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgdGhlbWUgY29sb3JzLiBUaGlzIHdpbGwgYmUgdXNlZCB0byB0cmFuc2xhdGUgXCJwcmltYXJ5LWNvbG9yXCIgdG8gYSBoZXggY29sb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSB0d28gY29sb3JzIHRvIGJlIHVzZWQgaW4gdGhlIGdyYWRpZW50LlxuICAgKlxuICAgKiB7XG4gICAqICAgICAgY29sb3IxOiBoZXggY29sb3IgdmFsdWVcbiAgICogICAgICBjb2xybzI6IGhleCBjb2xvciB2YWx1ZVxuICAgKiB9XG4gICAqXG4gICAqICAgICAgICAgIGNvbG9yMSBhbmQgY29sb3IyIGhhdmUgdG8gYmUgaGV4IGNvbG9yIHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgICBvcC5fZ2VuZXJhdGVHcmFkaWVudENzc1J1bGUgPSBmdW5jdGlvbiggY29sb3IxLCBjb2xvcjIsIHRoZW1lQ29sb3JzICkge1xuICAgICAgICB2YXIgaXNDb2xvcjFUcmFuc3BhcmVudCA9IGNvbG9yMSA9PT0gJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgIGlzQ29sb3IyVHJhbnNwYXJlbnQgPSBjb2xvcjIgPT09ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICBpc0NvbG9yMUhleCA9IGNvbG9yMS5pbmRleE9mKCAnIycgKSAhPT0gLTEsXG4gICAgICAgICAgICBpc0NvbG9yMkhleCA9IGNvbG9yMi5pbmRleE9mKCAnIycgKSAhPT0gLTEsXG4gICAgICAgICAgICAvLyBJdCdzIHNvbWV0aGluZyBsaWtlICdwcmltYXJ5LWNvbG9yIG9yICdkYXJrLWNvbG9yJ1xuICAgICAgICAgICAgaXNDb2xvcjFUaGVtZWRBbmROb3RUcmFuc3BhcmVudCA9ICFpc0NvbG9yMVRyYW5zcGFyZW50ICYmICFpc0NvbG9yMUhleCxcbiAgICAgICAgICAgIGlzQ29sb3IyVGhlbWVkQW5kTm90VHJhbnNwYXJlbnQgPSAhaXNDb2xvcjJUcmFuc3BhcmVudCAmJiAhaXNDb2xvcjJIZXg7IC8vIFdlIGhhdmUgdG8gZG8gc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJhbnNwYXJlbnRcbiAgICAgICAgLy8gVHJhbnNwYXJlbnQgaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHRoZW1lRGF0YS50aGVtZV9jb2xvcnMgb2JqZWN0LlxuICAgICAgICAvLyBBbmQgeW91IGNhbid0IGp1c3Qgc3BlY2lmeSB0aGUgY29sb3JzIHRvIGJlICd0cmFuc3BhcmVudCcgYmVjYXVzZVxuICAgICAgICAvLyBTYWZhcmkgaXMgYSBmb29sXG4gICAgICAgIC8vIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vdGhpbmcta25vdy1ncmFkaWVudHMtdHJhbnNwYXJlbnQtYmxhY2svXG4gICAgICAgIC8vIElmIG9uZSBjb2xvciBpcyB0cmFuc3BhcmVudCBhbmQgdGhlIG90aGVyIGlzbid0LCB0aGVuIHRoZSB0cmFuc3BhcmVudCBjb2xvclxuICAgICAgICAvLyBTaG91bGQgYmUgY29tZSB0aGUgUkdCQSB2ZXJzaW9uIG9mIHRoZSBvdGhlciBjb2xvclxuXG4gICAgICAgIGlmICggaXNDb2xvcjFUcmFuc3BhcmVudCAmJiBpc0NvbG9yMlRyYW5zcGFyZW50ICkge1xuICAgICAgICAgICAgLy8gSWYgYm90aCBjb2xvcnMgYXJlIHRyYW5zcGFyZW50LCBqdXN0IHVzZSB0cmFuc3BhcmVudCB3aGl0ZSBmb3IgYm90aFxuICAgICAgICAgICAgY29sb3IxID0gb3AuaGV4VG9SZ2JhKCAnI0ZGRkZGRicsIDAgKTtcbiAgICAgICAgICAgIGNvbG9yMiA9IGNvbG9yMTtcbiAgICAgICAgfSBlbHNlIGlmICggaXNDb2xvcjFUaGVtZWRBbmROb3RUcmFuc3BhcmVudCAmJiBpc0NvbG9yMlRoZW1lZEFuZE5vdFRyYW5zcGFyZW50ICkge1xuICAgICAgICAgICAgY29sb3IxID0gdGhlbWVDb2xvcnNbIGNvbG9yMSBdO1xuICAgICAgICAgICAgY29sb3IyID0gdGhlbWVDb2xvcnNbIGNvbG9yMiBdO1xuICAgICAgICB9IGVsc2UgaWYgKCBpc0NvbG9yMVRyYW5zcGFyZW50ICYmIGlzQ29sb3IyVGhlbWVkQW5kTm90VHJhbnNwYXJlbnQgKSB7XG4gICAgICAgICAgICBjb2xvcjIgPSB0aGVtZUNvbG9yc1sgY29sb3IyIF07XG4gICAgICAgICAgICBjb2xvcjEgPSBvcC5oZXhUb1JnYmEoIGNvbG9yMiwgMCApO1xuICAgICAgICB9IGVsc2UgaWYgKCBpc0NvbG9yMlRyYW5zcGFyZW50ICYmIGlzQ29sb3IxVGhlbWVkQW5kTm90VHJhbnNwYXJlbnQgKSB7XG4gICAgICAgICAgICBjb2xvcjEgPSB0aGVtZUNvbG9yc1sgY29sb3IxIF07XG4gICAgICAgICAgICBjb2xvcjIgPSBvcC5oZXhUb1JnYmEoIGNvbG9yMSwgMCApO1xuICAgICAgICB9IGVsc2UgaWYgKCBpc0NvbG9yMUhleCAmJiBpc0NvbG9yMlRyYW5zcGFyZW50ICkge1xuICAgICAgICAgICAgY29sb3IyID0gb3AuaGV4VG9SZ2JhKCBjb2xvcjEsIDAgKTtcbiAgICAgICAgfSBlbHNlIGlmICggaXNDb2xvcjJIZXggJiYgaXNDb2xvcjFUcmFuc3BhcmVudCApIHtcbiAgICAgICAgICAgIGNvbG9yMSA9IG9wLmhleFRvUmdiYSggY29sb3IyLCAwICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIGlzQ29sb3IxSGV4ICYmIGlzQ29sb3IyVGhlbWVkQW5kTm90VHJhbnNwYXJlbnQgKSB7XG4gICAgICAgICAgICBjb2xvcjIgPSB0aGVtZUNvbG9yc1sgY29sb3IyIF07XG4gICAgICAgIH0gZWxzZSBpZiAoIGlzQ29sb3IySGV4ICYmIGlzQ29sb3IxVGhlbWVkQW5kTm90VHJhbnNwYXJlbnQgKSB7XG4gICAgICAgICAgICBjb2xvcjEgPSB0aGVtZUNvbG9yc1sgY29sb3IxIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sb3IxOiBjb2xvcjEsXG4gICAgICAgICAgICBjb2xvcjI6IGNvbG9yMlxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgKiBAYnJpZWYgQ29udmVydCBhIGNvbG9yIGhleCBzdHJpbmcgdG8gYSByZ2JhIHZhbHVlLlxuICAqXG4gICogVGhlcmUgaXMgYW4gZXhhY3QgY29weSBvZiB0aGUgZnVuY3Rpb24gaW4gdGVtbGF0ZXByb2Nlc3Nvci9ob29rcy9jb2x1bW4uanMuXG4gICogSSBqdXN0IGRpZG4ndCB3YW50IHRvIG1ha2UgYSBkZXBlbmRlbmN5IHRvIGl0LCBzbyBJIGluY2x1ZGVkIGl0IHRoZXJlIHRvby5cbiAgKlxuICAqICNkNGUxNTcgPT4gcmdiYSgyMTIsIDIyNSwgODcsIDEpXG4gICpcbiAgKiBBbHBoYSB2YWx1ZSBkZWZhdWx0cyB0byAxIGlmIG5vbmUgaXMgc3BlY2lmaWVkXG4gICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE2NDY3MzgvY29udmVydC1oZXgtdG8tcmdiYVxuICAqIEBwYXJhbSBoZXhcbiAgKiBAcGFyYW0gYWxwaGEgKG9wdGlvbmFsKVxuICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICogQHByaXZhdGVcbiAgKi9cblxuICAgIG9wLmhleFRvUmdiYSA9IGZ1bmN0aW9uKCBoZXgsIGFscGhhICkge1xuICAgICAgICB2YXIgYWxwaGEgPSBhbHBoYSA9PT0gdW5kZWZpbmVkID8gMSA6IGFscGhhLFxuICAgICAgICAgICAgcmV0O1xuXG4gICAgICAgIGlmICggL14jKFtBLUZhLWYwLTldezN9KXsxLDJ9JC8udGVzdCggaGV4ICkgKSB7XG4gICAgICAgICAgICByZXQgPSBoZXguc3Vic3RyaW5nKCAxICkuc3BsaXQoICcnICk7IC8vIEhhbmRsZSBoZXggc2hvcnRoYW5kIGlucHV0c1xuXG4gICAgICAgICAgICBpZiAoIHJldC5sZW5ndGggPT09IDMgKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gWyByZXRbIDAgXSwgcmV0WyAwIF0sIHJldFsgMSBdLCByZXRbIDEgXSwgcmV0WyAyIF0sIHJldFsgMiBdIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldCA9ICcweCcgKyByZXQuam9pbiggJycgKTtcbiAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgWyByZXQgPj4gMTYgJiAyNTUsIHJldCA+PiA4ICYgMjU1LCByZXQgJiAyNTUgXS5qb2luKCAnLCcgKSArICcsJyArIGFscGhhICsgJyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgfVxuICAgIH0sIC8vIER1cCBvZiB0aGUgdGVtcGxhdGUgcHJvY2Vzc29yIGdldCBhdHRyaWJ1dGUgaGVscGVyLiBTbyBsaXR0bGUgY29kZSBoZXJlIEkgdGhvdWdodCBpdCBwcnVkZW50IHRvXG4gICAgLy8gRHVwbGljYXRlIGl0IGFzIG9wcG9zZWQgdG8gc2V0dGluZyB1cCBhbm90aGVyIGRlcGVuZGFuY3kuIFRoaXMgaXMgcmVxdWlyZWQgYnl0IHRoZSBzdHlsZXNoZWV0IG1ldGhvZC5cbiAgICBvcC5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYXR0ck5hbWUgKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgICAgICAgaWYgKCBlbGVtZW50ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCBhdHRyTmFtZSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aCwgdjsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICB2ID0gdGhpc1sgaSBdLmdldEF0dHJpYnV0ZSggYXR0ck5hbWUgKTtcblxuICAgICAgICAgICAgICAgIGlmICggdiAmJiB2LmluZGV4T2YoICd7ZmllbGQnICkgPT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaCggdiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIG9wLmdldElkID0gb3AuZ2V0QXR0cmlidXRlKCAnb3B0LWlkJyApO1xuXG4gICAgLyoqXG4gICAqIENyZWF0ZSBhIHN0eWxlIHRhZyBmb3IgdGhlIHRhcmdldCBlbGVtZW50XG4gICAqIEBhdXRob3IgSmVzc2UgQmFpcmQ8amVzc2VAb250cmFwb3J0LmNvbT5cbiAgICogQHBhcmFtICB7W3R5cGVdfSBlbGVtZW50ICAgRE9NIGVsZW1lbnRcbiAgICogQHBhcmFtICB7W3R5cGVdfSBkYXRhICAgICAgb2JqZWN0IHsgYmFja2dyb3VuZDogJ3BpbmsnLCAnYm9yZGVyLWNvbG9yJ31cbiAgICogLy8gQmFmZmFsaW5nIHBhcmFtdGVyIG5hbWVcbiAgICogQHBhcmFtICB7W3R5cGVdfSBkZWNCbG9ja3Mge1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyc6IFsgJ2JhY2tncm91bmQnLCBbJ2NvbG9yJywgJ2RhdGFQcm9wTmFtZVRoYXRzTm90Q29sb3InXV1cbiAgICpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICogICogQHBhcmFtIHtvYmplY3R9IGJsb2NrU2V0dGluZ3MgYmxvY2sgc2V0dGluZ3Mgb2JqZWN0IGhhbmR5IGZvciBkZXRlcm1pbmluZyBpZiBlbGVtZW50cyBleGlzdCBpbiBhIGR5bmFtaWMgZWxlbWVudC5cbiAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKlxuICAgKi9cblxuICAgIG9wLnN0eWxlc2hlZXQgPSBmdW5jdGlvbiggZWxlbWVudCwgZGF0YSwgZGVjQmxvY2tzLCBvcHRpb25zLCBibG9ja0RhdGEgKSB7XG4gICAgICAgIHZhciBjbG9zZXN0QmxvY2sgPSBlbGVtZW50LmNsb3Nlc3QoICdbb3B0LXR5cGU9XCJibG9jay12M1wiXScgKSxcbiAgICAgICAgICAgIGJsb2NrSWQgPSBjbG9zZXN0QmxvY2sgPyB0aGlzLmdldElkKCBjbG9zZXN0QmxvY2sgKSA6ICcnLFxuICAgICAgICAgICAgc2VsZWN0b3JQcmVmaXggPSBibG9ja0lkID8gJy5vcHQtaWQtJyArIGJsb2NrSWQgOiAnJyxcbiAgICAgICAgICAgIHN0eWxlVGFnSWQgPSBibG9ja0lkID8gJ3MnICsgYmxvY2tJZCA6ICdib3JkZXItc3R5bGUnLFxuICAgICAgICAgICAgY2xvc2VzdENvbHVtbiA9IGVsZW1lbnQuY2xvc2VzdCggJ1tvcHQtdHlwZT1cImNvbHVtblwiXScgKSxcbiAgICAgICAgICAgIGVsQ29udGFpbmVyID0gZWxlbWVudC5jbG9zZXN0KCAnLmVsX19zdHlsZScgKSxcbiAgICAgICAgICAgIGlzRHluYW1pY0Jsb2NrID0gZmFsc2UsXG4gICAgICAgICAgICBlbElkO1xuXG4gICAgICAgIC8vIERldGVybWluZSBpZiB3ZSBhcmUgd29ya2luZyB3aXRoIGEgZHluYW1pYyBibG9jayBvciBhbiBlbGVtZW50IGluc2lkZSBhIGR5bmFtaWMgYmxvY2tcbiAgICAgICAgaWYgKCAoIGJsb2NrRGF0YSAmJiBBcnJheS5pc0FycmF5KCBibG9ja0RhdGEgKSAmJiBibG9ja0RhdGFbIDAgXT8uc2V0dGluZ3M/LmR5bmFtaWNCbG9ja1NldHRpbmdzICkgfHxcbiAgICAgICAgICAgICggY2xvc2VzdEJsb2NrICYmIGNsb3Nlc3RCbG9jay5nZXRBdHRyaWJ1dGUoICdkYXRhLWRjJyApIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpc0R5bmFtaWNCbG9jayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBlbGVtZW50IGlzIGFuIGFjdHVhbCBvcHQtZWxlbWVudCAobm90IGNvbHVtbiBvciBibG9jayksIGdldCBpdHMgSURcbiAgICAgICAgaWYgKCBlbENvbnRhaW5lciAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgIGVsSWQgPSB0aGlzLmdldElkKCBlbGVtZW50ICk7IC8vIElmIGVsSWQgaXMgbnVsbCwgdGhlIGVsZW1lbnQgdGFyZ2V0IHBhc3NlZCBpbnRvIHRoaXMgaG9vayBpcyBub3QgdGhlIGFjdHVhbGx5IG9wdC1lbGVtZW50LiBGb3IgZXhhbXBsZSwgaW5wdXRzLlxuXG4gICAgICAgICAgICBpZiAoIGVsSWQgPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgZWxJZCA9IHRoaXMuZ2V0SWQoIGVsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoICdbb3B0LWlkXScgKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHlsZVRhZ0lkICs9ICctJyArIGVsSWQ7XG4gICAgICAgICAgICBzZWxlY3RvclByZWZpeCArPSAnIFtvcHQtaWQ9XCInICsgZWxJZCArICdcIl0nO1xuICAgICAgICB9IGVsc2UgaWYgKCBjbG9zZXN0Q29sdW1uICE9PSBudWxsICkge1xuICAgICAgICAgICAgdmFyIGNvbElkID0gdGhpcy5nZXRJZCggY2xvc2VzdENvbHVtbiApO1xuICAgICAgICAgICAgc3R5bGVUYWdJZCArPSAnLScgKyBjb2xJZDtcbiAgICAgICAgICAgIHNlbGVjdG9yUHJlZml4ICs9ICcgW29wdC1pZD1cIicgKyBjb2xJZCArICdcIl0nO1xuICAgICAgICB9IC8vIElmIGEgbmFtZXNwYWNlIGlzIHBhc3NlZCBpbiwgYXBwZW5kIGl0IHRvIHRoZSBzdHlsZSB0YWcgSURcblxuXG4gICAgICAgIGlmICggb3B0aW9ucyAmJiBvcHRpb25zLm5hbWVzcGFjZSApIHtcbiAgICAgICAgICAgIHN0eWxlVGFnSWQgKz0gJy0nICsgb3B0aW9ucy5uYW1lc3BhY2U7XG4gICAgICAgIH0gLy8gSWYgYmxvY2sgd2FzIG5vdCBwcmVzZW50LCBncmFiIHBhcmVudCBhbmQgdHJ5IHRvIGJ1aWxkIGEgdmFsaWQgc2VsZWN0b3IuIE9uZSBwbGFjZSB0aGlzIG9jY3VycyBpcyBmYXZvcml0ZXNcblxuXG4gICAgICAgIGlmICggY2xvc2VzdEJsb2NrID09PSBudWxsICkge1xuICAgICAgICAgICAgY2xvc2VzdEJsb2NrID0gZWxlbWVudC5wYXJlbnRFbGVtZW50OyAvLyBDb252ZXJ0IGNsYXNzIGxpc3QgdG8gYW4gYXJyYXksIGFuZCBsb29rIGZvciBhIGNsYXNzIHN0YXJ0aW5nIHdpdGggJ29wdC1pZC0nLiBJZiBwcmVzZW50LCB1c2UgdGhpcyBhcyB0aGUgc2VsZWN0b3IgcHJlZml4XG5cbiAgICAgICAgICAgIHZhciBjbGFzc0FyciA9IFtdLnNsaWNlLmNhbGwoIGNsb3Nlc3RCbG9jay5jbGFzc0xpc3QgKSxcbiAgICAgICAgICAgICAgICBjbG9zZXN0RWw7XG4gICAgICAgICAgICBjbGFzc0FyciA9IGNsYXNzQXJyLmZpbHRlciggZnVuY3Rpb24oIHNpbmdsZUNsYXNzICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW5nbGVDbGFzcy5pbmRleE9mKCAnb3B0LWlkLScgKSA9PT0gMDtcbiAgICAgICAgICAgIH0gKTsgLy8gSWYgdGhlcmUgaXMgbm90IGNsYXNzIHN0YXJ0aW5nIHdpdGggb3B0LWlkLCBsb29rIGZvciB0aGUgcHJlc2V0cy13cmFwcGVyIG9yIGZhdm9yaXRlcy13cmFwcGVyXG4gICAgICAgICAgICAvLyBGb3IgcHJlc2V0cyBhbmQgZmF2b3JpdGVzLCBpZiB3ZSBkb24ndCBhZGQgdGhpcyBleHRyYSBzZWxlY3RvciwgdGhlbiB0aGUgc3R5bGVzIGZvciBlYWNoXG4gICAgICAgICAgICAvLyBQcmVzZXQgYW5kIGZhdm9yaXRlIHdpbGwgb3ZlcndyaXRlIGVhY2ggb3RoZXJcblxuICAgICAgICAgICAgaWYgKCBjbGFzc0Fyci5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdEVsID0gY2xvc2VzdEJsb2NrLmNsb3Nlc3QoICcub3B0LXBhbGV0dGUtc3R5bGVfX3ByZXNldHMtd3JhcHBlcicgKTtcblxuICAgICAgICAgICAgICAgIGlmICggY2xvc2VzdEVsICkge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc0Fyci5wdXNoKCAnb3B0LXBhbGV0dGUtc3R5bGVfX3ByZXNldHMtd3JhcHBlcicgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggY2xhc3NBcnIubGVuZ3RoID09PSAwICkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RFbCA9IGNsb3Nlc3RCbG9jay5jbG9zZXN0KCAnLm9wdC1wYWxldHRlLXN0eWxlX19mYXZvcml0ZXMtd3JhcHBlcicgKTtcblxuICAgICAgICAgICAgICAgIGlmICggY2xvc2VzdEVsICkge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc0Fyci5wdXNoKCAnb3B0LXBhbGV0dGUtc3R5bGVfX2Zhdm9yaXRlcy13cmFwcGVyJyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBjbGFzc0Fyci5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JQcmVmaXggPSAnLicgKyBjbGFzc0FyclsgMCBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGVsZW1lbnQuaGFzQXR0cmlidXRlKCAnb3B0LWlkJyApICkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yUHJlZml4ICs9ICcgW29wdC1pZD1cIicgKyBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ29wdC1pZCcgKSArICdcIl0nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbnB1dHMgcGFzcyBpbiB0aGVpciBpbm5lciBlbGVtZW50cyB0byB0aGUgYm9yZGVyICYgc3R5bGVzaGVldCBob29rcywgc28gbG9vayBvdXR3YXJkIGZvciB0aGUgb3V0ZXIgZWxlbWVudCB0byBnZXQgb3B0LWlkXG4gICAgICAgICAgICAgICAgdmFyIG91dGVyRWwgPSBlbGVtZW50LmNsb3Nlc3QoICcub3B0LWVsZW1lbnQnICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG91dGVyRWwgJiYgb3V0ZXJFbC5oYXNBdHRyaWJ1dGUoICdvcHQtaWQnICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yUHJlZml4ICs9ICcgW29wdC1pZD1cIicgKyBvdXRlckVsLmdldEF0dHJpYnV0ZSggJ29wdC1pZCcgKSArICdcIl0nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG91dGVyRWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJ1bGVzID0gW10sXG4gICAgICAgICAgICBzdHlsZVRleHQgPSAnJyxcbiAgICAgICAgICAgIHNlbGVjdG9yO1xuXG4gICAgICAgIGZvciAoIHNlbGVjdG9yIGluIGRlY0Jsb2NrcyApIHtcbiAgICAgICAgICAgIHJ1bGVzID0gW107XG4gICAgICAgICAgICBkZWNCbG9ja3NbIHNlbGVjdG9yIF0uZm9yRWFjaCggZnVuY3Rpb24oIHJ1bGVzLCBkYXRhLCBwcm9wICkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFbIHByb3AgXTsgLy8gSW4gdGhlIGNhc2Ugb2YgWyAnY3NzJywgJ2RhdGFvYmplY3RwcnAnXVxuXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgcHJvcCA9PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhWyBwcm9wWyAxIF0gXTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3BbIDAgXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlbGVjdG9yID09PSAnIC5qcy1vcHQtYmctaW1nJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcHJvcC5pbmRleE9mKCAnYm9yZGVyLScgKSA+IC0xICYmIHByb3AuaW5kZXhPZiggJy1yYWRpdXMnICkgPiAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm9yZGVyUmFkaXVzTnVtYmVyVmFsID0gK3ZhbHVlLnJlcGxhY2UoICdweCcsICcnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJvcmRlclRvcFdpZHRoID0gZGF0YVsgJ2JvcmRlci10b3Atd2lkdGgnIF0gfHwgZGF0YVsgJ2JvcmRlci13aWR0aCcgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm9yZGVyUmlnaHRXaWR0aCA9IGRhdGFbICdib3JkZXItcmlnaHQtd2lkdGgnIF0gfHwgZGF0YVsgJ2JvcmRlci13aWR0aCcgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm9yZGVyQm90V2lkdGggPSBkYXRhWyAnYm9yZGVyLWJvdHRvbS13aWR0aCcgXSB8fCBkYXRhWyAnYm9yZGVyLXdpZHRoJyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBib3JkZXJMZWZ0V2lkdGggPSBkYXRhWyAnYm9yZGVyLWxlZnQtd2lkdGgnIF0gfHwgZGF0YVsgJ2JvcmRlci13aWR0aCcgXTsgLy8gR3JhYiB0aGUgZGlyZWN0aW9uIGZyb20gdGhlIHJhZGl1cyB0d28gbWlkZGxlIHdvcmRzIGV4OiBcImJvcmRlci10b3AtbGVmdC1yYWRpdXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLWxlZnQsIG9yIGJvdHRvbS1yaWdodFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdvcmRzID0gcHJvcC5zcGxpdCggJy0nICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcE9yQm90dG9tID0gd29yZHNbIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdE9yUmlnaHQgPSB3b3Jkc1sgMiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJXaWR0aE1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogK2JvcmRlclRvcFdpZHRoLnJlcGxhY2UoICdweCcsICcnICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b206ICtib3JkZXJCb3RXaWR0aC5yZXBsYWNlKCAncHgnLCAnJyApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogK2JvcmRlckxlZnRXaWR0aC5yZXBsYWNlKCAncHgnLCAnJyApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6ICtib3JkZXJSaWdodFdpZHRoLnJlcGxhY2UoICdweCcsICcnIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbEJvcmRlcldpZHRoID0gYm9yZGVyV2lkdGhNYXBbIHRvcE9yQm90dG9tIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyV2lkdGggPSBib3JkZXJXaWR0aE1hcFsgbGVmdE9yUmlnaHQgXTsgLy8gRmluZCB0aGUgbGFyZ2VyIGJvcmRlciB3aWR0aCBvZiB0aGUgdHdvLiAgaWYgdGhleSdyZSBlcXVhbCBlaXRoZXIgd2lsbCBkb1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhcmdlckJvcmRlcldpZHRoID0gaG9yaXpvbnRhbEJvcmRlcldpZHRoID4gdmVydGljYWxCb3JkZXJXaWR0aCA/IGhvcml6b250YWxCb3JkZXJXaWR0aCA6IHZlcnRpY2FsQm9yZGVyV2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGJvcmRlclJhZGl1c051bWJlclZhbCA+IGxhcmdlckJvcmRlcldpZHRoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXNOdW1iZXJWYWwgPSBib3JkZXJSYWRpdXNOdW1iZXJWYWwgLSBsYXJnZXJCb3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBib3JkZXJSYWRpdXNOdW1iZXJWYWwgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJzBweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IC8vIFdlIGhhdmUgYSBydWxlIHdpdGggYSB2YWx1ZVxuXG5cbiAgICAgICAgICAgICAgICAgICAgcnVsZXMucHVzaCggcHJvcCArICc6ICcgKyB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCggdGhpcywgcnVsZXMsIGRhdGEgKSApOyAvLyBJZiB3ZSBoYXZlIHJ1bGVzIGZvciB0aGlzIHNlbGVjdG9yLCB0aGVuIGNyZWF0ZSBhIHNlbGVjdG9yIGZvciBpdFxuICAgICAgICAgICAgLy8gT1VUUFVUOiAub3B0LWlkLWRmNTljNzIxLTFkYTEtOTNkNi0zOTM2LTlmYTE0ZDFjYzBhZXtib3JkZXI6IDNweCBzb2xpZCBncmVlbjtib3JkZXItdG9wOiAzcHggc29saWQgYmx1ZX1cbiAgICAgICAgICAgIGlmICggcnVsZXMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIHJ1bGVzID0gcnVsZXMuam9pbiggJzsnICk7XG4gICAgICAgICAgICAgICAgaWYgKCBpc0R5bmFtaWNCbG9jayB8fCBvcHRpb25zPy5ibG9ja1VzZXJEZWZpbmVkRGF0YT8uc2V0dGluZ3M/LmR5bmFtaWNCbG9ja1NldHRpbmdzICkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclByZWZpeCA9IHNlbGVjdG9yUHJlZml4LnJlcGxhY2UoIGAub3B0LWlkLSR7YmxvY2tJZH1gLCBgW2RhdGEtdGVtcGxhdGUtaWQ9XCIke2Jsb2NrSWR9XCJdYCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHlsZVRleHQgKz0gJ1xcbicgKyBzZWxlY3RvclByZWZpeCArIHNlbGVjdG9yICsgJ3snICsgcnVsZXMgKyAnfSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIHN0eWxlIHRhZ3MgZm9yIHRoaXMgZWxlbWVudFxuICAgICAgICAvLyBOT1RFIGFkZCBsZWFkaW5nIFwic1wiIHRvIHByZXZlbnQgdGhlIGVycm9yIFwiIGlzIG5vdCBhIHZhbGlkIHNlbGVjdG9yXCIgc2VsZWN0b3JzIGNhbid0IGxlYWQgd2l0aCBhIGRpZ2l0XG4gICAgICAgIHZhciBleGlzdGluZyA9IGNsb3Nlc3RCbG9jay5xdWVyeVNlbGVjdG9yKCAnIycgKyBzdHlsZVRhZ0lkICk7XG5cbiAgICAgICAgaWYgKCBleGlzdGluZyApIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLnJlbW92ZSgpO1xuICAgICAgICB9IC8vIElmIHdlIGhhdmUgc3R5bGUgdGV4dCwgdGhlbiBhcHBlbmQgaXQgdG8gdGhlIGRvbVxuXG5cbiAgICAgICAgaWYgKCBzdHlsZVRleHQgIT09ICcnICkge1xuICAgICAgICAgICAgdmFyIHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3N0eWxlJyApO1xuICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCAnaWQnLCBzdHlsZVRhZ0lkICk7XG5cbiAgICAgICAgICAgIGlmICggb3B0aW9ucyAmJiBvcHRpb25zLmlzTW9iaWxlICkge1xuICAgICAgICAgICAgICAgIHZhciBtb2JpbGVCcmVha3BvaW50ID0gb3AubW9iaWxlQnJlYWtwb2ludCB8fCA2MDA7XG4gICAgICAgICAgICAgICAgc3R5bGVUZXh0ID0gJ0BtZWRpYSAoIG1heC13aWR0aDogJyArIG1vYmlsZUJyZWFrcG9pbnQgKyAncHggKSB7ICcgKyBzdHlsZVRleHQgKyAnIH0nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHlsZVRhZy5pbm5lckhUTUwgPSBzdHlsZVRleHQ7XG4gICAgICAgICAgICBjbG9zZXN0QmxvY2suaW5zZXJ0QmVmb3JlKCBzdHlsZVRhZywgY2xvc2VzdEJsb2NrLmZpcnN0Q2hpbGQgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICogQWRqdXN0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0YXJnZXQgdG8gZml0IHRoZSBjb250YWluZXIgYmV0dGVyLiBUaGlzIGlzIHVzZWQgZm9yIG1ha2luZyB2aWRlb3MgZml0IGluIGl0cyBjb250YWluZXJcbiAgICogYW5kIGZvciBwYXJhbGxheCBlZmZlY3RzLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBPYmplY3QgaW4gdGhlIGZvcm1hdDpcbiAgICoge1xuICAgKlxuICAgKiAgICAgY29udGFpbmVyV2lkdGg6IE51bWJlciB0aGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lciwgd2hlcmUgdGhlIGNvbnRhaW5lciBjb3VsZCBiZSB0aGUgYmxvY2sgb3IgdGhlIHZpZXdwb3J0XG4gICAqICAgICBjb250YWluZXJIZWlnaHQ6IE51bWJlciB0aGUgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIsIHdoZXJlIHRoZSBjb250YWluZXIgY291bGQgYmUgdGhlIGJsb2NrIG9yIHRoZSB2aWV3cG9ydFxuICAgKiAgICAgdGFyZ2V0V2lkdGg6IE51bWJlciB0aGUgd2lkdGggb2YgdGhlIHRhcmdldCwgd2hlcmUgdGhlIHRhcmdldCBjb3VsZCBiZSB0aGUgYW4gPGltYWdlPiwgPHZpZGVvPiBvciA8aWZyYW1lPiBlbGVtZW50XG4gICAqICAgICB0YXJnZXRIZWlnaHQ6IE51bWJlciB0aGUgaGVpZ2h0IG9mIHRoZSB0YXJnZXQsIHdoZXJlIHRoZSB0YXJnZXQgY291bGQgYmUgdGhlIGFuIDxpbWFnZT4sIDx2aWRlbz4gb3IgPGlmcmFtZT4gZWxlbWVudFxuICAgKiAgICAgdGFyZ2V0VGFnTmFtZTogU3RyaW5nIFRoZSBET00gdGFnIG5hbWUgb2YgdGhlIHRhcmdldC4gVGhpcyBjb3VsZCBiZSB0aGUgYSA8aW1hZ2U+LCA8dmlkZW8+IG9yIDxpZnJhbWU+XG4gICAqICAgICBzdHJldGNoRmFjdG9yIE51bWJlci4gTXVsdGlwbHkgdGhlIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlIHRhcmdldCBieSB0aGlzIG11Y2ggc28gdGhhdCBpdCdzIGJpZyBlbm91Z2ggdG9cbiAgICogICAgIGdpdmUgYSBwYXJhbGxheCBlZmZlY3Qgb3Igc3RyZXRjaCB0aGUgdmlkZW8gdGhlIHJpZ2h0IGFtb3VudC5cbiAgICogfVxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFkanVzdGVkIGhlaWdodCBhbmQgd2lkdGggcHJvcGVydGllcy4gSWYgbm8gYWRqdXN0bWVudHMgbmVlZGVkIHRvIGJlIG1hZGVcbiAgICogYW5kIHdlIHdhbnQgdGhlIHRhcmdldCB0byBqdXN0IHRha2UgdGhlaXIgbmF0dXJhbCBzaXplLCB0aGVuIHJldHVybiBudWxsLlxuICAgKi9cblxuXG4gICAgb3AuYWRqdXN0RGltZW5zaW9ucyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgIC8vIEEgPSBoL3dcbiAgICAvLyBhID0+IGFzcGVjdCByYXRpb1xuICAgIC8vIGggPT4gaGVpZ2h0XG4gICAgLy8gdyA9PiB3aWR0aFxuICAgIC8vIEdldCBoZWlnaHQgb2YgdGFyZ2V0XG4gICAgLy8gR2V0IGhlaWdodCBvZiBjb250YWluZXJcbiAgICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gb3B0aW9ucy5jb250YWluZXJXaWR0aCxcbiAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodCA9IG9wdGlvbnMuY29udGFpbmVySGVpZ2h0LFxuICAgICAgICAgICAgdGFyZ2V0V2lkdGggPSBvcHRpb25zLnRhcmdldFdpZHRoLFxuICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gb3B0aW9ucy50YXJnZXRIZWlnaHQsXG4gICAgICAgICAgICB0YXJnZXRUYWdOYW1lID0gb3B0aW9ucy50YXJnZXRUYWdOYW1lLFxuICAgICAgICAgICAgc3RyZXRjaEZhY3RvciA9IG9wdGlvbnMuc3RyZXRjaEZhY3RvcjtcbiAgICAgICAgdmFyIHRhcmdldEFzcGVjdFJhdGlvID0gdGFyZ2V0SGVpZ2h0IC8gdGFyZ2V0V2lkdGgsXG4gICAgICAgICAgICBuZXdUYXJnZXRIZWlnaHQgPSB0YXJnZXRIZWlnaHQsXG4gICAgICAgICAgICBuZXdUYXJnZXRXaWR0aCA9IHRhcmdldFdpZHRoOyAvLyBWaWRlbyBlbGVtZW50cyBhcmUgc3BlY2lhbC4gVGhleSBkbyBub3QgYWx3YXlzIG5lZWQgdG8gaGF2ZSB0aGVpciBoZWlnaHQgYW5kIHdpZHRoIGFkanVzdGVkLlxuICAgICAgICAvLyBUaGV5IGRvIG5vdCBuZWVkIHRoZWlyIGhlaWdodCBhbmQgd2lkdGggYWRqdXN0IGlmIHRoZXkgYXJlIHN1ZmZpY2llbnRseSBsYXJnZSB0byBjb3ZlciB0aGUgY29udGFpbmVyLlxuICAgICAgICAvLyBZZXQsIGlmIHRoZXkgYXJlIG5vdCBzdWZmaWNpZW50bHkgbGFyZ2UsIHRoZW4gdGhleSdsbCBuZWVkIHRoZWlyIHdpZHRoIGFuZCBoZWlnaHQgdXBkYXRlZC5cbiAgICAgICAgLy8gSW1hZ2UgZWxlbWVudHMgYW5kIGlmcmFtZXMgd2hpY2ggY29udGFpbiB2aWRlb3Mgc2hvdWxkIGFsd2F5cyBoYXZlIHRoZWlyIHdpZHRoIGFuZCBoZWlnaHQgdXBkYXRlZC5cblxuICAgICAgICB2YXIgaXNWaWRlb0VsZW1lbnQgPSB0YXJnZXRUYWdOYW1lID09PSAnVklERU8nOyAvLyBLZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlIGRpbWVuc2lvbnMgbmVlZCB0byBnZXQgc3RyZXRjaGVkLlxuICAgICAgICAvLyBUaGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlIHRhcmdldCBpcyBiaWcgZW5vdWdoIHRvIGNvdmVyIHRoZSBjb250YWluZXIgYW5kIGRvZXMgbm90IG5lZWQgdG8gZ2V0IHN0cmV0Y2hlZCwgc29cbiAgICAgICAgLy8geW91IGRvbid0IHdhbnQgdG8gYXBwbHkgdGhlIG5ld2x5IGNhbGN1bGF0ZWQgc3RyZXRjaGVkIHZhbHVlLlxuICAgICAgICAvLyBUaGVzZSBmbGFncyBoZWxwIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgdmlkZW8gaXMgdGFsbCBlbm91Z2ggdG8gY292ZXIgYSB3aWRlLCBza2lubnkgYmxvY2ssIGJ1dCB3YXMgbm90IHdpZGVcbiAgICAgICAgLy8gZW5vdWdoLiBJbiB0aGlzIGNhc2Ugd2Ugb25seSB3YW50ZWQgdG8gYXBwbHkgdGhlIGhvcml6b250YWwgYWRqdXN0bWVudCB0byB2aWRlby5cblxuICAgICAgICB2YXIgbmVlZFRvVXBkYXRlSGVpZ2h0ID0gZmFsc2UsXG4gICAgICAgICAgICBuZWVkVG9VcGRhdGVXaWR0aCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICggbmV3VGFyZ2V0SGVpZ2h0IDwgY29udGFpbmVySGVpZ2h0ICogc3RyZXRjaEZhY3RvciApIHtcbiAgICAgICAgICAgIC8vIElmIHN0cmV0Y2hpbmcgdGhlIHRhcmdldCBoZWlnaHQgaXMgc3RpbGwgdG9vIHNob3J0IHRvIGNvdmVyIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgIC8vIHRoZW4gbWFrZSB0aGUgdGFyZ2V0IHRoZSBzYW1lIGhlaWdodCBhcyB0aGUgY29udGFpbmVyLCBidXQgc2V0IHRoZSB3aWR0aCBzdWNoIHRoYXQgaXQgbWFpbnRhaW5zXG4gICAgICAgICAgICAvLyB0aGUgdGFyZ2V0IGFzcGVjdCByYXRpb1xuICAgICAgICAgICAgbmV3VGFyZ2V0SGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgICAgbmV3VGFyZ2V0V2lkdGggPSBuZXdUYXJnZXRIZWlnaHQgLyB0YXJnZXRBc3BlY3RSYXRpbztcbiAgICAgICAgICAgIG5lZWRUb1VwZGF0ZUhlaWdodCA9IHRydWU7XG4gICAgICAgICAgICBuZWVkVG9VcGRhdGVXaWR0aCA9IHRydWU7XG4gICAgICAgIH0gLy8gV2UgZG9uJ3QgcmVhbGx5IGNhcmUgdG8gYXBwbHkgdGhlIHN0cmV0Y2hGYWN0b3IgdG8gdGhlIHdpZHRoLlxuICAgICAgICAvLyBGb3IgYWxsIG91ciBjYWxjdWxhdGlvbnMsIHdlIGNhcmUgdGhhdCB0aGUgIGhlaWdodCBpcyBzdHJldGNoZWQgZW5vdWdoIHRvIGdpdmUgdGhlIHBhcmFsbGF4IGVmZmVjdC5cbiAgICAgICAgLy8gQnV0IHdlIHdhbnQgdGhlIHdpZHRoIHRvIGF0IGxlYXN0IGNvdmVyIHRoZSBjb250YWluZXIuXG5cblxuICAgICAgICBpZiAoIG5ld1RhcmdldFdpZHRoIDwgY29udGFpbmVyV2lkdGggKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IHdpZHRoIGlzIHN0aWxsIHRvbyBza2lubnkgdG8gY292ZXIgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgLy8gdGhlbiBtYWtlIHRoZSB0YXJnZXQgdGhlIHNhbWUgd2lkdGggYXMgdGhlIGNvbnRhaW5lciwgYnV0IHNldCB0aGUgaGVpZ2h0IHN1Y2ggdGhhdCBpdCBtYWludGFpbnNcbiAgICAgICAgICAgIC8vIHRoZSB0YXJnZXQgYXNwZWN0IHJhdGlvXG4gICAgICAgICAgICBuZXdUYXJnZXRXaWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuICAgICAgICAgICAgbmV3VGFyZ2V0SGVpZ2h0ID0gbmV3VGFyZ2V0V2lkdGggKiB0YXJnZXRBc3BlY3RSYXRpbztcbiAgICAgICAgICAgIG5lZWRUb1VwZGF0ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBNdWx0aXBseSBkaW1lbnNpb25zIGJ5IHRoaXMgdG8gc3RyZXRjaCB0aGUgdGFyZ2V0IG91dCBqdXN0IGEgbGl0dGxlIGJpdCB0byBtYWtlIHN1cmUgd2UgY2FuIGdldCBhIHBhcmFsbGF4IGVmZmVjdFxuICAgICAgICAvLyBvciBoYXZlIHRoZSB2aWRlbyBzdHJldGNoIHRoZSByaWdodCBhbW91bnQuXG5cblxuICAgICAgICBuZXdUYXJnZXRIZWlnaHQgPSBuZXdUYXJnZXRIZWlnaHQgKiBzdHJldGNoRmFjdG9yO1xuICAgICAgICBuZXdUYXJnZXRXaWR0aCA9IG5ld1RhcmdldFdpZHRoICogc3RyZXRjaEZhY3RvcjsgLy8gQXBwbHkgbmV3IGRpbWVuc2lvbnMgdG8gdGhlIHRhcmdldFxuICAgICAgICAvLyBJZiB0aGUgbmV3IHZhbHVlcyBhcmUgMCwgdGhlbiBkbyBub3QgYXBwbHkgdGhlbSBhbmQgYWxsb3cgb3RoZXIgc3R5bGluZyB0byBtYW5hZ2UgdGhpcy5cblxuICAgICAgICB2YXIgcmV0ID0gbnVsbDtcblxuICAgICAgICBpZiAoIG5lZWRUb1VwZGF0ZUhlaWdodCB8fCAhaXNWaWRlb0VsZW1lbnQgKSB7XG4gICAgICAgICAgICByZXQgPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdUYXJnZXRIZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG5lZWRUb1VwZGF0ZVdpZHRoIHx8ICFpc1ZpZGVvRWxlbWVudCApIHtcbiAgICAgICAgICAgIHJldCA9IHJldCB8fCB7fTtcbiAgICAgICAgICAgIHJldC53aWR0aCA9IG5ld1RhcmdldFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAqIFBvc2l0aW9uIHRoZSB2aWRlbyBiYXNlZCBvZmYgaXRzIGl0cyBvd24gc2l6ZSBhbmQgaXRzIGNvbnRhaW5lci5cbiAgICogVGhpcyBzaG91bGQgc3RyZXRjaCBhbmQgbW92ZSB0aGUgdmlkZW8gYmFzZWQgb2YgdGhlIGFzcGVjdCByYXRpbyBvZiBpdHMgY29udGFpbmVyLlxuICAgKiBAcGFyYW0gJGJsb2NrIGpRdWVyeSBlbGVtZW50IC0gdGhlIGJsb2NrIHRoYXQgY29udGFpbnMgdGhlIHZpZGVvIGJhY2tncm91bmRcbiAgICogQHBhcmFtIHZpZGVvQ29udGFpbmVyIERPTSBlbGVtZW50IC0gdGhlIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHZpZGVvIGZvciB0aGUgYmFja2dyb3VuZFxuICAgKi9cblxuXG4gICAgb3AucG9zaXRpb25WaWRlbyA9IGZ1bmN0aW9uKCAkYmxvY2ssIHZpZGVvQ29udGFpbmVyICkge1xuICAgICAgICBpZiAoICRibG9jayA9PSBudWxsIHx8IHZpZGVvQ29udGFpbmVyID09IG51bGwgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gR2V0IGhlaWdodCBvZiB2aWRlb1xuICAgICAgICAvLyBHZXQgaGVpZ2h0IG9mIGJsb2NrXG4gICAgICAgIC8vIEZpbmQgY2VudGVyIG9mIGVhY2hcblxuXG4gICAgICAgIHZhciBibG9ja0hlaWdodCA9ICRibG9jay5oZWlnaHQoKSxcbiAgICAgICAgICAgIGJsb2NrV2lkdGggPSAkYmxvY2sud2lkdGgoKSxcbiAgICAgICAgICAgIGJsb2NrVmVydGljYWxDZW50ZXIgPSBibG9ja0hlaWdodCAvIDIsXG4gICAgICAgICAgICBibG9ja0hvcml6b250YWxDZW50ZXIgPSBibG9ja1dpZHRoIC8gMjtcbiAgICAgICAgbGV0IHZpZGVvID0gdmlkZW9Db250YWluZXIucXVlcnlTZWxlY3RvciggJ3ZpZGVvLCBpZnJhbWUnICk7XG5cbiAgICAgICAgaWYgKCAhdmlkZW8gKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmlkZW9IZWlnaHQgPSB2aWRlby5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICB2aWRlb1dpZHRoID0gdmlkZW8uY2xpZW50V2lkdGgsXG4gICAgICAgICAgICB2aWRlb1ZlcnRpY2FsQ2VudGVyLFxuICAgICAgICAgICAgdmlkZW9Ib3Jpem9udGFsQ2VudGVyO1xuICAgICAgICB2YXIgbW92ZVlEZWx0YSA9IDAsXG4gICAgICAgICAgICBtb3ZlWERlbHRhID0gMCxcbiAgICAgICAgICAgIGlzUGFyYWxsYXggPSB2aWRlb0NvbnRhaW5lci5jbG9zZXN0KCAnLnBhcmFsbGF4JyApICE9IG51bGwsXG4gICAgICAgICAgICBpc0ZpeGVkUGFyYWxsYXggPSB2aWRlb0NvbnRhaW5lci5jbG9zZXN0KCAnLnBhcmFsbGF4LnBhcmFsbGF4LS1maXhlZCcgKSAhPSBudWxsOyAvLyBNdWx0aXBseSBkaW1lbnNpb25zIGJ5IHRoaXMgdG8gc3RyZXRjaCB0aGUgdGFyZ2V0IG91dCBqdXN0IGEgbGl0dGxlIGJpdCB0byBtYWtlIHN1cmUgd2UgY2FuIGdldCBhIHBhcmFsbGF4IGVmZmVjdFxuICAgICAgICAvLyBvciB0byBtYWtlIGEgdmlkZW8gc3RyZXRjaCBqdXN0IGVub3VnaCB0byBmaXQgaW4gYSBjb250YWluZXIuXG5cbiAgICAgICAgdmFyIHN0cmV0Y2hGYWN0b3IgPSAxOyAvLyBGb3Igbm9uLWZpeGVkIHBhcmFsbGF4LCB3ZSB3YW50IHRvIHN0cmV0Y2ggdGhlIHZpZGVvIGJ5IDEuNSBzbyB0aGF0IGl0J3MgYmlnIGVub3VnaCB0byBnaXZlIHRoZSBwYXJhbGxheCBlZmZlY3QuXG5cbiAgICAgICAgaWYgKCBpc1BhcmFsbGF4ICYmICFpc0ZpeGVkUGFyYWxsYXggKSB7XG4gICAgICAgICAgICBzdHJldGNoRmFjdG9yID0gMS41O1xuICAgICAgICB9IC8vIEZvciBmaXhlZCBwYXJhbGxheCwgd2UgbWFrZSB0aGUgd2luZG93IHRoZSBjb250YWluZXIsIHRvIHN0cmV0Y2ggdGhlIHZpZGVvIHRvIHRoZSB3aW5kb3cgZGltZW5zaW9ucy5cblxuXG4gICAgICAgIGlmICggaXNQYXJhbGxheCAmJiBpc0ZpeGVkUGFyYWxsYXggKSB7XG4gICAgICAgICAgICBibG9ja0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdEaW1lbnNpb25zID0gbnVsbDtcblxuICAgICAgICBpZiAoIHZpZGVvV2lkdGggIT09IDAgJiYgdmlkZW9IZWlnaHQgIT09IDAgKSB7XG4gICAgICAgICAgICBuZXdEaW1lbnNpb25zID0gb3AuYWRqdXN0RGltZW5zaW9ucygge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiBibG9ja1dpZHRoLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogYmxvY2tIZWlnaHQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0V2lkdGg6IHZpZGVvV2lkdGgsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0OiB2aWRlb0hlaWdodCxcbiAgICAgICAgICAgICAgICB0YXJnZXRUYWdOYW1lOiB2aWRlby50YWdOYW1lLFxuICAgICAgICAgICAgICAgIHN0cmV0Y2hGYWN0b3I6IHN0cmV0Y2hGYWN0b3JcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbmV3RGltZW5zaW9ucyAmJiBuZXdEaW1lbnNpb25zLndpZHRoICE9PSAwICYmIG5ld0RpbWVuc2lvbnMuaGVpZ2h0ICE9PSAwICkge1xuICAgICAgICAgICAgdmlkZW8uc3R5bGUud2lkdGggPSBuZXdEaW1lbnNpb25zLndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIHZpZGVvLnN0eWxlLmhlaWdodCA9IG5ld0RpbWVuc2lvbnMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgfSAvLyBBZnRlciBhZGp1c3RpbmcgdGhlIGRpbWVuc2lvbnMsIHJlY2FsY3VsYXRlIGFuZCBhcHBseSB0aGUgdmlkZW8gYXNwZWN0IHJhdGlvXG5cblxuICAgICAgICBvcC5hcHBseVZpZGVvQXNwZWN0UmF0aW8oIHZpZGVvICk7IC8vIFVwZGF0ZSBvdXIgdmFycyBmb3IgdmlkZW8gaGVpZ2h0IGFuZCB3aWR0aCBhbmQgY2VudGVyc1xuXG4gICAgICAgIHZpZGVvSGVpZ2h0ID0gdmlkZW8uY2xpZW50SGVpZ2h0O1xuICAgICAgICB2aWRlb1dpZHRoID0gdmlkZW8uY2xpZW50V2lkdGg7XG4gICAgICAgIHZpZGVvVmVydGljYWxDZW50ZXIgPSB2aWRlb0hlaWdodCAvIDI7XG4gICAgICAgIHZpZGVvSG9yaXpvbnRhbENlbnRlciA9IHZpZGVvV2lkdGggLyAyOyAvLyBJZiB2aWRlbyBoZWlnaHQgaXMgZ3JlYXRlciB0aGFuIGJsb2NrIGhlaWdodCwgdGhlbiBtb3ZlIHZpZGVvIHVwd2FyZHNcbiAgICAgICAgLy8gV2FudCB0aGUgY2VudGVyIG9mIHRoZSB2aWRlbyB0byBiZSBhdCBjZW50ZXIgb2YgYmxvY2ssXG4gICAgICAgIC8vIERpc3RhbmNlIHRvIG1vdmUgdmlkZW8gaXMgdmlkZW8gY2VudGVyIG1pbnVzIGJsb2NrIGNlbnRlclxuXG4gICAgICAgIGlmICggdmlkZW9IZWlnaHQgPiBibG9ja0hlaWdodCApIHtcbiAgICAgICAgICAgIG1vdmVZRGVsdGEgPSB2aWRlb1ZlcnRpY2FsQ2VudGVyIC0gYmxvY2tWZXJ0aWNhbENlbnRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdmlkZW9XaWR0aCA+IGJsb2NrV2lkdGggKSB7XG4gICAgICAgICAgICBtb3ZlWERlbHRhID0gdmlkZW9Ib3Jpem9udGFsQ2VudGVyIC0gYmxvY2tIb3Jpem9udGFsQ2VudGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBtb3ZlWURlbHRhICE9PSAwIHx8IG1vdmVYRGVsdGEgIT09IDAgKSB7XG4gICAgICAgICAgICB2aWRlby5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC0nICsgbW92ZVhEZWx0YSArICdweCwtJyArIG1vdmVZRGVsdGEgKyAncHgpJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICogQ2FsY3VsYXRlIGFuZCBhcHBseSB0aGUgYXNwZWN0IHJhdGlvIHRvIHRoZSB2aWRlbydzIGNvbnRhaW5lci5cbiAgICpcbiAgICogT1B2MyB1c2VzIE1hdGVyaWFsaXplJ3MgdmlkZW8tY29udGFpbmVyIGNsYXNzLCB3aGljaCBhc3N1bWVzIHZpZGVvcyBhcmUgMTY6OSBhc3BlY3QgcmF0aW8uIEl0IHN0eWxlc1xuICAgKiB0aGUgY29udGFpbmVyIHdpdGggcGFkZGluZy1ib3R0b206IDU2LjI1JSAoaS5lLiA5LzE2ID0gLjU2MjUpLlxuICAgKlxuICAgKiBOb3QgYWxsIHZpZGVvcyBhcmUgMTY6OSwgc28gd2UgZ290dGEgbWFrZSBhIGNhbGN1bGF0aW9uIGFuZCBhcHBseSBzdHlsZXMgYWNjb3JkaW5nbHkuXG4gICAqIEBwYXJhbSB2aWRlb0VsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICAgIG9wLmFwcGx5VmlkZW9Bc3BlY3RSYXRpbyA9IGZ1bmN0aW9uKCB2aWRlb0VsZW1lbnQgKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSB2aWRlb0VsZW1lbnQudmlkZW9IZWlnaHQsXG4gICAgICAgICAgICB3aWR0aCA9IHZpZGVvRWxlbWVudC52aWRlb1dpZHRoLFxuICAgICAgICAgICAgY29udGFpbmVyID0gdmlkZW9FbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgICAgICBpc1ZpZGVvRWxlbWVudCA9ICQoIHZpZGVvRWxlbWVudCApLmNsb3Nlc3QoICcub3B0LWVsZW1lbnQnICkubGVuZ3RoICE9PSAwLFxuICAgICAgICAgICAgYXNwZWN0UmF0aW87IC8vIEhhbmRsZXMgY2FzZXMgd2hlcmUgdGhlIHZpZGVvIGVsZW1lbnQgaXMgYSBpZnJhbWUgb3IgdmlkZW8gZWxlbWVudFxuICAgICAgICAvLyAhaGVpZ2h0IHx8ICF3aWR0aCBoYW5kbGVzIGNhc2VzIHdoZXJlIHRoZSB2YWx1ZXMgYXJlIDAgb3IgdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKCAhaGVpZ2h0IHx8ICF3aWR0aCApIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHZpZGVvRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IHZpZGVvRWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzcGVjdFJhdGlvID0gaGVpZ2h0IC8gd2lkdGg7IC8vIElmIHRoZSB2aWRlbydzIGFzcGVjdCByYXRpbyBkb2Vzbid0IG1hdGNoIHRoZSBtYWdpY2FsIDE2Ojkgb25lLCB0aGVuIGNhbGN1bGF0ZSBhbmQgYXBwbHkgaXQuXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGhhbmRsZSBwb3J0cmFpdCBhbmQgbGFuZHNjYXBlIHZpZGVvcy5cblxuICAgICAgICBpZiAoIGFzcGVjdFJhdGlvICE9PSAuNTYyNSApIHtcbiAgICAgICAgICAgIC8vIFZpZGVvIGVsZW1lbnRzIGRvIG5vdCBoYXZlIHRoZWlyIHdpZHRoL2hlaWdodCBzZXQsIHNvIHRoYXQgdGhleSBjYW4ganVzdCBmaXQgdGhlbXNlbHZlcyBuYXR1cmFsbHlcbiAgICAgICAgICAgIGlmICggIWlzVmlkZW9FbGVtZW50ICkge1xuICAgICAgICAgICAgICAgIC8vIE5vbi12aWRlbyBlbGVtZW50cyAoaS5lLiB2aWRlbyBiYWNrZ3JvdW5kKVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWFrZXMgdGhlIHZpZGVvIGNvbnRhaW5lciBmaWxsIHRoZSBjb250YWluZXIgdGhhdCBpdCdzIGluLlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUucGFkZGluZ0JvdHRvbSA9ICggYXNwZWN0UmF0aW8gKiAxMDAgKS50b0ZpeGVkKCAyLCAxMCApICsgJyUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHZpZGVvIGRvZXMgbWF0Y2ggMTY6OSwgdGhlbiBhcHBseSB0aGUgTWF0ZXJpYWxpemUgY2xhc3MgYW5kXG4gICAgICAgICAgICAvLyBHZXQgcmlkIG9mIGFueSBwYWRkaW5nLWJvdHRvbSBzdHlsZXNcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5wYWRkaW5nQm90dG9tID0gJyc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAqIEluaXRpYWxpemUgPHZpZGVvPiBlbGVtZW50cyBvbiB0aGUgcGFnZVxuICAgKiBSaWdodCBub3csIGl0IGNhbGN1bGF0ZXMgdGhlIGFzcGVjdCByYXRpbyBvZiB0aGUgdmlkZW8gYW5kIGFkanVzdCB0aGUgdmlkZW8gY29udGFpbmVycy5cbiAgICogTmVlZCB0byB3YWl0IGZvciB0aGUgdmlkZW8gdG8gYmUgbG9hZGVkIGJlZm9yZSB3ZSBoYXZlIHRoZSBuZWNlc3NhcnkgZGltZW5zaW9ucy5cbiAgICovXG5cblxuICAgIG9wLmluaXRWaWRlb3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICR2aWRlb0VsZW1lbnRzID0gJCggJy5vcHQtZWxlbWVudCAudmlkZW8tYmFja2dyb3VuZC1jb250YWluZXIgdmlkZW8nICk7XG4gICAgICAgICR2aWRlb0VsZW1lbnRzLmVhY2goIGZ1bmN0aW9uKCBpbmRleCwgdmlkZW9FbGVtZW50ICkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgdmlkZW8gdG8gYmUgbG9hZGVkIGJlZm9yZSB3ZSBjYW4gZ2V0IGFjY3VyYXRlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIC8vIDQgbWVhbnMgdGhlIHZpZGVvIGhhcyBlbm91Z2ggbWV0YWRhdGFcbiAgICAgICAgICAgIGlmICggdmlkZW9FbGVtZW50LnJlYWR5U3RhdGUgIT09IDQgKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkZWRtZXRhZGF0YScsIG9wLmFwcGx5VmlkZW9Bc3BlY3RSYXRpby5iaW5kKCB0aGlzLCB2aWRlb0VsZW1lbnQgKSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcC5hcHBseVZpZGVvQXNwZWN0UmF0aW8oIHZpZGVvRWxlbWVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICk7XG4gICAgICAgICR2aWRlb0VsZW1lbnRzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAqIEFwcGx5IGN1c3RvbSBjbGFzc2VzIGFuZCBpbmxpbmUgc3R5bGVzIHRvIGEgbWF0ZXJpYWxpemUgZHJvcCBkb3duIGZpZWxkLlxuICAgKiBUaGUgY3VzdG9taXphdGlvbiBpcyBzdG9yZWQgb24gZGVmYXVsdCA8c2VsZWN0PiBtYXJrdXAgYXMgYW4gb3B0LSBhdHRyaWJ1dGUuXG4gICAqIEFmdGVyIHRoZSBtYXRlcmlhbGl6ZSBkcm9wZG93bnMgYXJlIGluaXRpYWxpemVkIHRoaXMgZnVuY3Rpb24gcnVucyBhZ2FpbnMgYWxsXG4gICAqIG9mIHRoZW0gcGFyc2luZyBpbiB0aGUgY3VzdG9taXphdGlvbiBhbmQgYWRkaW5nIHRoZSBjbGFzc2VzIGFuZCBpbmxpbmUgc3R5bGUgaXQgY29udGFpbnMuXG4gICAqL1xuXG5cbiAgICBvcC5zdHlsZVNlbGVjdCA9IGZ1bmN0aW9uKCAkc2VsZWN0ICkge1xuICAgICAgICB2YXIgY3VzdG9taXphdGlvbiA9IEpTT04ucGFyc2UoICRzZWxlY3QuYXR0ciggJ29wdC1kcm9wZG93bi1zdHlsZXMnICkgKSxcbiAgICAgICAgICAgIGN1c3RvbVN0eWxlcyA9IG51bGwsXG4gICAgICAgICAgICAkZWxDb250YWluZXIgPSBudWxsLFxuICAgICAgICAgICAgJGVscyA9IG51bGw7XG5cbiAgICAgICAgZm9yICggdmFyIHNlbGVjdG9yIGluIGN1c3RvbWl6YXRpb24gKSB7XG4gICAgICAgICAgICBjdXN0b21TdHlsZXMgPSBjdXN0b21pemF0aW9uWyBzZWxlY3RvciBdO1xuICAgICAgICAgICAgJGVsQ29udGFpbmVyID0gJHNlbGVjdC5jbG9zZXN0KCAnLm9wdC1pbnB1dF9fY29udGFpbmVyJyApO1xuICAgICAgICAgICAgJGVscyA9ICRlbENvbnRhaW5lci5maW5kKCAnLicgKyBzZWxlY3RvciApO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjdXN0b21TdHlsZXMuY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgJGVscy5hZGRDbGFzcyggY3VzdG9tU3R5bGVzLmNsYXNzZXNbIGkgXSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkZWxzLmNzcyggY3VzdG9tU3R5bGVzLnN0eWxlcyApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgKiBDaGVja3MgZm9yIG1vYmlsZSBkZXZpY2UgYnkgY2hlY2tpbmcgdXNlciBhZ2VudCBhbmQgc2NyZWVuIHNpemUuXG4gICAqIEZ1biBmYWN0OiBTd2l0Y2hpbmcgb24vb2ZmIGRldmljZSB0b2dnbGUgaW4gQ2hyb21lIERldiB0b29scyBjaGFuZ2VzIHVzZXIgYWdlbnQgdG8gbW9iaWxlIHZlcnNpb24gc28gaXQgY2FuIGJlXG4gICAqIHRlc3RlZCBvbiB0aGUgY29tcHV0ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIG1vYmlsZSBkZXZpY2UsIGZhbHNlIGlmIG5vdC5cbiAgICovXG5cblxuICAgIG9wLmlzTW9iaWxlRGV2aWNlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2hlY2tpbmcgaWYgdXNlciBhZ2VudCBzZW50IGJ5IGJyb3dzZXIgY29udGFpbnMgJ21vYmknIChmb3IgbW9iaWxlKSwgb3IgdGhlIHNjcmVlbiB3aWR0aCBpcyBzbWFsbCBlbm91Z2hcbiAgICAvLyB0byBiZSBjb25zaWRlcmVkIG1vYmlsZS5cbiAgICAgICAgY29uc3QgbW9iaWxlVXNlckFnZW50TW9iaSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCggLyhtb2JpfGFuZHJvaWQpL2cgKTtcblxuICAgICAgICBpZiAoIG1vYmlsZVVzZXJBZ2VudE1vYmkgKSB7XG4gICAgICAgICAgICBpZiAoIG1vYmlsZVVzZXJBZ2VudE1vYmkubGVuZ3RoID4gMCB8fCB3aW5kb3cuaW5uZXJXaWR0aCA8PSA2MDAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAqIFRoaXMgaXMgZXNzZW50aWFsbHkgYSBjb3B5IG9mIHRoZSBnZXRDdWx0dXJlRGVmaW5pdGlvbiBtZXRob2Qgb24gb250cmFwb3J0LmNvbW1vbi5cbiAgKlxuICAqIEl0J3MgY29waWVkIGhlcmUgc2luY2UgdGhlIGN1c3RvbSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gb250cmFwb3J0LmNvbW1vblxuICAqIEBwYXJhbSBjdXJyZW5jeVNldHRpbmdzXG4gICogQHJldHVybnMgeyp9XG4gICovXG5cblxuICAgIG9wLmdldEN1bHR1cmVEZWZpbml0aW9uID0gZnVuY3Rpb24oIGN1cnJlbmN5U2V0dGluZ3MgKSB7XG4gICAgICAgIHZhciBjdWx0dXJlID0gR2xvYmFsaXplLmN1bHR1cmUoKTsgLy8gQXBwbHkgY3VycmVuY3kgc3ltYm9sXG5cbiAgICAgICAgY3VsdHVyZS5udW1iZXJGb3JtYXQuY3VycmVuY3kuc3ltYm9sID0gY3VycmVuY3lTZXR0aW5ncy5jdXJyZW5jeS5jdXJyZW5jeV9zeW1ib2w7IC8vIEFwcGx5IGN1cnJlbmN5IGZvcm1hdCAoc3ltYm9sIGxlZnQvcmlnaHQpXG5cbiAgICAgICAgdmFyIGN1cnJlbmN5Rm9ybWF0ID0gJycsXG4gICAgICAgICAgICBjdXJyZW5jeUNvZGUgPSBjdXJyZW5jeVNldHRpbmdzLmN1cnJlbmN5LmN1cnJlbmN5X2NvZGU7XG5cbiAgICAgICAgc3dpdGNoICggY3VycmVuY3lTZXR0aW5ncy5jdXJyZW5jeV9mb3JtYXQgKSB7XG4gICAgICAgIGNhc2UgJ3N5bWJvbC1sZWZ0JzpcbiAgICAgICAgICAgIGN1cnJlbmN5Rm9ybWF0ID0gWyAnKCRuKScsICckbicgXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N5bWJvbC1sZWZ0LWNvdW50cnktY29kZSc6XG4gICAgICAgICAgICBjdXJyZW5jeUZvcm1hdCA9IFsgJygkJyArIGN1cnJlbmN5Q29kZSArICcgbiknLCAnJCcgKyBjdXJyZW5jeUNvZGUgKyAnIG4nIF07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzeW1ib2wtcmlnaHQnOlxuICAgICAgICAgICAgY3VycmVuY3lGb3JtYXQgPSBbICctbiAkJywgJ24gJCcgXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N5bWJvbC1yaWdodC1jb3VudHJ5LWNvZGUnOlxuICAgICAgICAgICAgY3VycmVuY3lGb3JtYXQgPSBbICctbiAkJyArIGN1cnJlbmN5Q29kZSwgJ24gJCcgKyBjdXJyZW5jeUNvZGUgXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFN5bWJvbCBsZWZ0IGlzIGRlZmF1bHRcbiAgICAgICAgICAgIGN1cnJlbmN5Rm9ybWF0ID0gWyAnKCRuKScsICckbicgXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VsdHVyZS5udW1iZXJGb3JtYXQuY3VycmVuY3kucGF0dGVybiA9IGN1cnJlbmN5Rm9ybWF0OyAvLyBBcHBseSBudW1iZXIgZm9ybWF0IChjb21tYSwgZGVjaW1hbCBwbGFjZW1lbnQpXG5cbiAgICAgICAgc3dpdGNoICggY3VycmVuY3lTZXR0aW5ncy5udW1iZXJfZm9ybWF0ICkge1xuICAgICAgICBjYXNlICdjb21tYS1kZWNpbWFsJzpcbiAgICAgICAgICAgIGN1bHR1cmUubnVtYmVyRm9ybWF0LmN1cnJlbmN5WyAnLCcgXSA9ICcsJztcbiAgICAgICAgICAgIGN1bHR1cmUubnVtYmVyRm9ybWF0LmN1cnJlbmN5WyAnLicgXSA9ICcuJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlY2ltYWwtY29tbWEnOlxuICAgICAgICAgICAgY3VsdHVyZS5udW1iZXJGb3JtYXQuY3VycmVuY3lbICcsJyBdID0gJy4nO1xuICAgICAgICAgICAgY3VsdHVyZS5udW1iZXJGb3JtYXQuY3VycmVuY3lbICcuJyBdID0gJywnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VsdHVyZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG9wO1xufSApKCBqUXVlcnksIHdpbmRvdyApO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFIQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.common.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.init.js":
/*!***************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.init.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// See if we found some global block grdients that need to be added to the page and add them\nif (op.gbGradients && Object.keys(op.gbGradients).length) {\n  op.addGbGradientCss(op.gbGradients);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9vcHQuaW5pdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3d3dy9qcy0zLjIuMi9vbnRyYXBvcnQvb3B0X2Fzc2V0cy9vcHRfYm9pbGVycGxhdGVzL3YzL29wdC5pbml0LmpzPzc1YTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2VlIGlmIHdlIGZvdW5kIHNvbWUgZ2xvYmFsIGJsb2NrIGdyZGllbnRzIHRoYXQgbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgcGFnZSBhbmQgYWRkIHRoZW1cbmlmICggb3AuZ2JHcmFkaWVudHMgJiYgT2JqZWN0LmtleXMoIG9wLmdiR3JhZGllbnRzICkubGVuZ3RoICkge1xuICAgIG9wLmFkZEdiR3JhZGllbnRDc3MoIG9wLmdiR3JhZGllbnRzICk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.init.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.lazyload.ts":
/*!*******************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.lazyload.ts ***!
  \*******************************************************************************/
/*! exports provided: OpLazyLoad */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OpLazyLoad\", function() { return OpLazyLoad; });\n/**\n * @author lorenzo@ontraport.com\n * @class  OpLazyLoad\n * Ontraport Pages lazy loader! Right now all we lazy load are images. Be happy we have big plans to lazy load other large assets. In a nut shell, the\n *         lazy loader observes images and downloads them once they enter the viewport. This means Pages don't request assets from the server that the user\n *         isn't viewing/using.\n *\n *         The lazy loader works in conjunction with the Pages editor. The editor hides images (via css) and builds placeholders for them that\n *         match their dimensions (yes, placeholders are responsive). The placeholders make sure image dimensions are accounted for before\n *         images enter the viewport and are downloaded. This is done so pages don't 'jump' or 'shift around' as images entery the viewport, are downloaded,\n *         and become visible.\n *\n *         Here is the algorithm:\n *         1) Get all the images\n *         2) Attach an intersection observer to each image\n *         3) On viewport intersection bind a load event to the image\n *         4) On load fade in the image remove the placeholder\n */\nclass OpLazyLoad {\n    /**\n     * CONSTRUCTOR -----------------------------------------------------------------------------------------------------\n     * If intersection observation is supported by the browser, on document load get all the lazy load images and attach an\n     *        intersection observer to them. Else, load all the images.\n     */\n    constructor() {\n        document.addEventListener('DOMContentLoaded', () => {\n            this.bindImages(this.getLazyImage());\n        });\n    }\n    /*\n     *  INSTANCE METHODS------------------------------------------------------------------------------------------------\n     */\n    /*\n     * Find images to lazy load.\n     */\n    getLazyImage(templateUuid) {\n        let lazyImages;\n        // Create a qualifier for dynamic blocks, we only want to select the images in a dynamic block's object record blocks.\n        let templateChildren = (templateUuid) ? `[data-template-id=\"${templateUuid}\"]` : '';\n        // Create an array es5 style for IE11, when we transpile down to es5 this can be changed to Array.from()\n        lazyImages = [].slice.call(document.querySelectorAll(`${templateChildren}.opt-row:not([data-dc]) .opt-lazy-img__img:not(.opt-lazy-img__img--bound)`), 0);\n        lazyImages.forEach((lazyImage) => {\n            // ONTRA-20844, Firefox 69 does not correctly calcualate the padding-bottom of the no height image if only\n            // the width attribute is set. So here, grab the attr and set the style property.\n            lazyImage.style.width = lazyImage.getAttribute('width') + 'px';\n        });\n        return lazyImages;\n    }\n    bindImages(lazyImages) {\n        if (!lazyImages.length) {\n            return;\n        }\n        // If the browser supports the intersection observer and we are not in the editor then lazy load.\n        // ONTRA-19918. IntersectionObserver does not work consistently with Safari, so do not lazy load images\n        // with Safari.\n        const isSafari = (Object.prototype.toString.call(HTMLElement).indexOf('Constructor') > 0 ||\n            window.webkitAudioContext !== undefined);\n        if ('IntersectionObserver' in window && !isSafari) {\n            // Dont rebind if we are adding dynamic images\n            if (!this.lazyImageObserver) {\n                this.lazyImageObserver = new IntersectionObserver(this.intersectionCallback.bind(this));\n            }\n            lazyImages.forEach((lazyImage) => {\n                // Set up observation\n                this.lazyImageObserver && this.lazyImageObserver.observe(lazyImage);\n                lazyImage.classList.add('opt-lazy-img__img--bound');\n            });\n        }\n        else {\n            // Fall back, we immediately set the src to the data-src value and all the images are loaded.\n            lazyImages.forEach((img) => {\n                this.imgLoadCallback(img);\n                img.classList.add('opt-lazy-img__img--bound');\n            });\n        }\n    }\n    /**\n     * The image has been moved into the viewport. Bind a load event, once downloaded fade the image in and remove the\n     * dimension placeholder.\n     */\n    imgLoadCallback(img) {\n        var _a, _b;\n        let imgWrapper = img.closest('.img-container');\n        if (!imgWrapper) {\n            console.error('opt.lazyload.ts failed to find .img-container');\n            return false;\n        }\n        let hoverImg = imgWrapper.querySelector('.hover-img');\n        let imgDataSrc = img.dataset.src || '';\n        let imgDataSrcset = img.dataset.srcset || '';\n        let hoverImgDatasrc = ((_a = hoverImg) === null || _a === void 0 ? void 0 : _a.dataset.src) || '';\n        let hoverImgDatasrcset = ((_b = hoverImg) === null || _b === void 0 ? void 0 : _b.dataset.srcset) || '';\n        // Attach the load, event listener before we assign the source\n        // prevents us from missing the load event firing before the handler is attached.\n        img.addEventListener('load', function (imgWrapper, ev) {\n            let placeholder = imgWrapper.querySelector('.opt-lazy-img__placeholder');\n            img.classList.remove('opt-lazy-img__img', 'opt-lazy-img__img--bound');\n            this.style.paddingBottom = '';\n            imgWrapper.style.maxWidth = '';\n            imgWrapper.style.maxHeight = '';\n            imgWrapper.classList.remove('opt-lazy-img');\n            placeholder.remove();\n            // If IE11, sigh.. IE11 doesn't max width % restriction on width px value. So we flip flop the width and\n            // max-width. This is a bit of a slap on patch, but IE11 is scheduled to get beheaded.\n            if (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > -1) {\n                img.style.maxWidth = img.style.width;\n                img.style.width = '100%';\n            }\n        }.bind(img, imgWrapper));\n        // Set the data src on the image element.\n        img.src = imgDataSrc;\n        img.srcset = imgDataSrcset;\n        // Remove the data-src attrs because they are no longer needed and they interfere with showing/hiding hover\n        // images.\n        img.removeAttribute('data-src');\n        if (hoverImg && hoverImgDatasrc) {\n            hoverImg.removeAttribute('data-src');\n            hoverImg.src = hoverImgDatasrc;\n            hoverImg.srcset = hoverImgDatasrcset;\n        }\n        else if (hoverImg && hoverImg.parentElement) {\n            hoverImg.parentElement && hoverImg.parentElement.removeChild(hoverImg);\n        }\n    }\n    /*\n     * When an intersection occurs this method gets called. Remove the intersection observer from the observed img and\n     * run the image load logic.\n     */\n    intersectionCallback(entries, observer) {\n        entries.forEach((entry) => {\n            let img = entry.target;\n            // If the img is visible in the viewport load the image\n            if (entry.isIntersecting === true) {\n                this.lazyImageObserver && this.lazyImageObserver.unobserve(img);\n                this.imgLoadCallback(img);\n            }\n        });\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9vcHQubGF6eWxvYWQudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9vcHQubGF6eWxvYWQudHM/OWNlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBhdXRob3IgbG9yZW56b0BvbnRyYXBvcnQuY29tXG4gKiBAY2xhc3MgIE9wTGF6eUxvYWRcbiAqIE9udHJhcG9ydCBQYWdlcyBsYXp5IGxvYWRlciEgUmlnaHQgbm93IGFsbCB3ZSBsYXp5IGxvYWQgYXJlIGltYWdlcy4gQmUgaGFwcHkgd2UgaGF2ZSBiaWcgcGxhbnMgdG8gbGF6eSBsb2FkIG90aGVyIGxhcmdlIGFzc2V0cy4gSW4gYSBudXQgc2hlbGwsIHRoZVxuICogICAgICAgICBsYXp5IGxvYWRlciBvYnNlcnZlcyBpbWFnZXMgYW5kIGRvd25sb2FkcyB0aGVtIG9uY2UgdGhleSBlbnRlciB0aGUgdmlld3BvcnQuIFRoaXMgbWVhbnMgUGFnZXMgZG9uJ3QgcmVxdWVzdCBhc3NldHMgZnJvbSB0aGUgc2VydmVyIHRoYXQgdGhlIHVzZXJcbiAqICAgICAgICAgaXNuJ3Qgdmlld2luZy91c2luZy5cbiAqXG4gKiAgICAgICAgIFRoZSBsYXp5IGxvYWRlciB3b3JrcyBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBQYWdlcyBlZGl0b3IuIFRoZSBlZGl0b3IgaGlkZXMgaW1hZ2VzICh2aWEgY3NzKSBhbmQgYnVpbGRzIHBsYWNlaG9sZGVycyBmb3IgdGhlbSB0aGF0XG4gKiAgICAgICAgIG1hdGNoIHRoZWlyIGRpbWVuc2lvbnMgKHllcywgcGxhY2Vob2xkZXJzIGFyZSByZXNwb25zaXZlKS4gVGhlIHBsYWNlaG9sZGVycyBtYWtlIHN1cmUgaW1hZ2UgZGltZW5zaW9ucyBhcmUgYWNjb3VudGVkIGZvciBiZWZvcmVcbiAqICAgICAgICAgaW1hZ2VzIGVudGVyIHRoZSB2aWV3cG9ydCBhbmQgYXJlIGRvd25sb2FkZWQuIFRoaXMgaXMgZG9uZSBzbyBwYWdlcyBkb24ndCAnanVtcCcgb3IgJ3NoaWZ0IGFyb3VuZCcgYXMgaW1hZ2VzIGVudGVyeSB0aGUgdmlld3BvcnQsIGFyZSBkb3dubG9hZGVkLFxuICogICAgICAgICBhbmQgYmVjb21lIHZpc2libGUuXG4gKlxuICogICAgICAgICBIZXJlIGlzIHRoZSBhbGdvcml0aG06XG4gKiAgICAgICAgIDEpIEdldCBhbGwgdGhlIGltYWdlc1xuICogICAgICAgICAyKSBBdHRhY2ggYW4gaW50ZXJzZWN0aW9uIG9ic2VydmVyIHRvIGVhY2ggaW1hZ2VcbiAqICAgICAgICAgMykgT24gdmlld3BvcnQgaW50ZXJzZWN0aW9uIGJpbmQgYSBsb2FkIGV2ZW50IHRvIHRoZSBpbWFnZVxuICogICAgICAgICA0KSBPbiBsb2FkIGZhZGUgaW4gdGhlIGltYWdlIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXJcbiAqL1xuIGNsYXNzIE9wTGF6eUxvYWQge1xuXG4gICAgLypcbiAgICAgKiBTVEFUSUMgVkFSSUFCTEVTIEFORCBNRVRIT0RTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gICAgLypcbiAgICAgKiBJTlNUQU5DRSBWQVJJQUJMRVMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuICAgIHByaXZhdGUgbGF6eUltYWdlT2JzZXJ2ZXIgPzogSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG5cbiAgICAvKipcbiAgICAgKiBDT05TVFJVQ1RPUiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIElmIGludGVyc2VjdGlvbiBvYnNlcnZhdGlvbiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIsIG9uIGRvY3VtZW50IGxvYWQgZ2V0IGFsbCB0aGUgbGF6eSBsb2FkIGltYWdlcyBhbmQgYXR0YWNoIGFuXG4gICAgICogICAgICAgIGludGVyc2VjdGlvbiBvYnNlcnZlciB0byB0aGVtLiBFbHNlLCBsb2FkIGFsbCB0aGUgaW1hZ2VzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmluZEltYWdlcyggdGhpcy5nZXRMYXp5SW1hZ2UoKSApO1xuICAgICAgICB9ICk7XG4gICAgfVxuXG5cbiAgICAvKlxuICAgICAqICBJTlNUQU5DRSBNRVRIT0RTLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG5cbiAgICAvKlxuICAgICAqIEZpbmQgaW1hZ2VzIHRvIGxhenkgbG9hZC5cbiAgICAgKi9cbiAgICBnZXRMYXp5SW1hZ2UoIHRlbXBsYXRlVXVpZCA/OiBzdHJpbmcgKSB7XG4gICAgICAgIGxldCBsYXp5SW1hZ2VzIDogQXJyYXk8SFRNTEltYWdlRWxlbWVudD47XG4gICAgICAgIC8vIENyZWF0ZSBhIHF1YWxpZmllciBmb3IgZHluYW1pYyBibG9ja3MsIHdlIG9ubHkgd2FudCB0byBzZWxlY3QgdGhlIGltYWdlcyBpbiBhIGR5bmFtaWMgYmxvY2sncyBvYmplY3QgcmVjb3JkIGJsb2Nrcy5cbiAgICAgICAgbGV0IHRlbXBsYXRlQ2hpbGRyZW4gPSAoIHRlbXBsYXRlVXVpZCApP2BbZGF0YS10ZW1wbGF0ZS1pZD1cIiR7dGVtcGxhdGVVdWlkfVwiXWA6Jyc7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBhcnJheSBlczUgc3R5bGUgZm9yIElFMTEsIHdoZW4gd2UgdHJhbnNwaWxlIGRvd24gdG8gZXM1IHRoaXMgY2FuIGJlIGNoYW5nZWQgdG8gQXJyYXkuZnJvbSgpXG4gICAgICAgIGxhenlJbWFnZXMgPSBbXS5zbGljZS5jYWxsKCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCBgJHt0ZW1wbGF0ZUNoaWxkcmVufS5vcHQtcm93Om5vdChbZGF0YS1kY10pIC5vcHQtbGF6eS1pbWdfX2ltZzpub3QoLm9wdC1sYXp5LWltZ19faW1nLS1ib3VuZClgICksIDAgKTtcblxuICAgICAgICBsYXp5SW1hZ2VzLmZvckVhY2goICggbGF6eUltYWdlICkgPT4ge1xuICAgICAgICAgICAgLy8gT05UUkEtMjA4NDQsIEZpcmVmb3ggNjkgZG9lcyBub3QgY29ycmVjdGx5IGNhbGN1YWxhdGUgdGhlIHBhZGRpbmctYm90dG9tIG9mIHRoZSBubyBoZWlnaHQgaW1hZ2UgaWYgb25seVxuICAgICAgICAgICAgLy8gdGhlIHdpZHRoIGF0dHJpYnV0ZSBpcyBzZXQuIFNvIGhlcmUsIGdyYWIgdGhlIGF0dHIgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkuXG4gICAgICAgICAgICBsYXp5SW1hZ2Uuc3R5bGUud2lkdGggPSBsYXp5SW1hZ2UuZ2V0QXR0cmlidXRlKCAnd2lkdGgnICkrJ3B4JztcbiAgICAgICAgfSApO1xuICAgICAgICByZXR1cm4gbGF6eUltYWdlcztcbiAgICB9XG5cbiAgICBiaW5kSW1hZ2VzKCBsYXp5SW1hZ2VzIDogQXJyYXk8SFRNTEltYWdlRWxlbWVudD4gKSB7XG4gICAgICAgICAgICBpZiAoICFsYXp5SW1hZ2VzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXIgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGVkaXRvciB0aGVuIGxhenkgbG9hZC5cbiAgICAgICAgICAgIC8vIE9OVFJBLTE5OTE4LiBJbnRlcnNlY3Rpb25PYnNlcnZlciBkb2VzIG5vdCB3b3JrIGNvbnNpc3RlbnRseSB3aXRoIFNhZmFyaSwgc28gZG8gbm90IGxhenkgbG9hZCBpbWFnZXNcbiAgICAgICAgICAgIC8vIHdpdGggU2FmYXJpLlxuICAgICAgICAgICAgY29uc3QgaXNTYWZhcmkgPSAoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggSFRNTEVsZW1lbnQgKS5pbmRleE9mKCAnQ29uc3RydWN0b3InICkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCAhPT0gdW5kZWZpbmVkICk7XG5cbiAgICAgICAgICAgIGlmICggJ0ludGVyc2VjdGlvbk9ic2VydmVyJyBpbiB3aW5kb3cgJiYgIWlzU2FmYXJpICkge1xuICAgICAgICAgICAgICAgIC8vIERvbnQgcmViaW5kIGlmIHdlIGFyZSBhZGRpbmcgZHluYW1pYyBpbWFnZXNcbiAgICAgICAgICAgICAgICBpZiAoICF0aGlzLmxhenlJbWFnZU9ic2VydmVyICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhenlJbWFnZU9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKCB0aGlzLmludGVyc2VjdGlvbkNhbGxiYWNrLmJpbmQoIHRoaXMgKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXp5SW1hZ2VzLmZvckVhY2goICggbGF6eUltYWdlICkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdXAgb2JzZXJ2YXRpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXp5SW1hZ2VPYnNlcnZlciAmJiB0aGlzLmxhenlJbWFnZU9ic2VydmVyLm9ic2VydmUoIGxhenlJbWFnZSApO1xuICAgICAgICAgICAgICAgICAgICBsYXp5SW1hZ2UuY2xhc3NMaXN0LmFkZCggJ29wdC1sYXp5LWltZ19faW1nLS1ib3VuZCcgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2ssIHdlIGltbWVkaWF0ZWx5IHNldCB0aGUgc3JjIHRvIHRoZSBkYXRhLXNyYyB2YWx1ZSBhbmQgYWxsIHRoZSBpbWFnZXMgYXJlIGxvYWRlZC5cbiAgICAgICAgICAgICAgICBsYXp5SW1hZ2VzLmZvckVhY2goICggaW1nICkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltZ0xvYWRDYWxsYmFjayggaW1nICk7XG4gICAgICAgICAgICAgICAgICAgIGltZy5jbGFzc0xpc3QuYWRkKCAnb3B0LWxhenktaW1nX19pbWctLWJvdW5kJyApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBoYXMgYmVlbiBtb3ZlZCBpbnRvIHRoZSB2aWV3cG9ydC4gQmluZCBhIGxvYWQgZXZlbnQsIG9uY2UgZG93bmxvYWRlZCBmYWRlIHRoZSBpbWFnZSBpbiBhbmQgcmVtb3ZlIHRoZVxuICAgICAqIGRpbWVuc2lvbiBwbGFjZWhvbGRlci5cbiAgICAgKi9cbiAgICBwcml2YXRlIGltZ0xvYWRDYWxsYmFjayggaW1nIDogSFRNTEltYWdlRWxlbWVudCApIHtcbiAgICAgICAgbGV0IGltZ1dyYXBwZXIgPSBpbWcuY2xvc2VzdCggJy5pbWctY29udGFpbmVyJyApIGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgIGlmICggIWltZ1dyYXBwZXIgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnb3B0Lmxhenlsb2FkLnRzIGZhaWxlZCB0byBmaW5kIC5pbWctY29udGFpbmVyJyApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBob3ZlckltZyA6IEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsID0gaW1nV3JhcHBlci5xdWVyeVNlbGVjdG9yKCAnLmhvdmVyLWltZycgKTtcblxuICAgICAgICBsZXQgaW1nRGF0YVNyYyA6IHN0cmluZyA9IGltZy5kYXRhc2V0LnNyYyB8fCAnJztcbiAgICAgICAgbGV0IGltZ0RhdGFTcmNzZXQgOiBzdHJpbmcgPSBpbWcuZGF0YXNldC5zcmNzZXQgfHwgJyc7XG4gICAgICAgIGxldCBob3ZlckltZ0RhdGFzcmMgOiBzdHJpbmcgPSBob3ZlckltZz8uZGF0YXNldC5zcmMgfHwgJyc7XG4gICAgICAgIGxldCBob3ZlckltZ0RhdGFzcmNzZXQgOiBzdHJpbmcgPSBob3ZlckltZz8uZGF0YXNldC5zcmNzZXQgfHwgJyc7XG5cblxuICAgICAgICAvLyBBdHRhY2ggdGhlIGxvYWQsIGV2ZW50IGxpc3RlbmVyIGJlZm9yZSB3ZSBhc3NpZ24gdGhlIHNvdXJjZVxuICAgICAgICAvLyBwcmV2ZW50cyB1cyBmcm9tIG1pc3NpbmcgdGhlIGxvYWQgZXZlbnQgZmlyaW5nIGJlZm9yZSB0aGUgaGFuZGxlciBpcyBhdHRhY2hlZC5cbiAgICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24oIHRoaXMgOiBIVE1MSW1hZ2VFbGVtZW50LCBpbWdXcmFwcGVyIDogSFRNTEVsZW1lbnQsIGV2IDogRXZlbnQgKSB7XG4gICAgICAgICAgICBsZXQgcGxhY2Vob2xkZXIgPSBpbWdXcmFwcGVyLnF1ZXJ5U2VsZWN0b3IoICcub3B0LWxhenktaW1nX19wbGFjZWhvbGRlcicgKSE7XG5cbiAgICAgICAgICAgIGltZy5jbGFzc0xpc3QucmVtb3ZlKCAnb3B0LWxhenktaW1nX19pbWcnLCAnb3B0LWxhenktaW1nX19pbWctLWJvdW5kJyApO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5wYWRkaW5nQm90dG9tID0gJyc7XG4gICAgICAgICAgICBpbWdXcmFwcGVyLnN0eWxlLm1heFdpZHRoID0gJyc7XG4gICAgICAgICAgICBpbWdXcmFwcGVyLnN0eWxlLm1heEhlaWdodCA9ICcnO1xuICAgICAgICAgICAgaW1nV3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCAnb3B0LWxhenktaW1nJyApO1xuXG4gICAgICAgICAgICBwbGFjZWhvbGRlci5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy8gSWYgSUUxMSwgc2lnaC4uIElFMTEgZG9lc24ndCBtYXggd2lkdGggJSByZXN0cmljdGlvbiBvbiB3aWR0aCBweCB2YWx1ZS4gU28gd2UgZmxpcCBmbG9wIHRoZSB3aWR0aCBhbmRcbiAgICAgICAgICAgIC8vIG1heC13aWR0aC4gVGhpcyBpcyBhIGJpdCBvZiBhIHNsYXAgb24gcGF0Y2gsIGJ1dCBJRTExIGlzIHNjaGVkdWxlZCB0byBnZXQgYmVoZWFkZWQuXG4gICAgICAgICAgICBpZiAoIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZiggJ01TSUUnICkhPT0tMSB8fCBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCAnVHJpZGVudC8nICkgPiAtMSApIHtcbiAgICAgICAgICAgICAgICBpbWcuc3R5bGUubWF4V2lkdGggPSBpbWcuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICAgICAgaW1nLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0uYmluZCggaW1nLCBpbWdXcmFwcGVyICkgKTtcblxuXG4gICAgICAgIC8vIFNldCB0aGUgZGF0YSBzcmMgb24gdGhlIGltYWdlIGVsZW1lbnQuXG4gICAgICAgIGltZy5zcmMgPSBpbWdEYXRhU3JjO1xuICAgICAgICBpbWcuc3Jjc2V0ID0gaW1nRGF0YVNyY3NldDtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGRhdGEtc3JjIGF0dHJzIGJlY2F1c2UgdGhleSBhcmUgbm8gbG9uZ2VyIG5lZWRlZCBhbmQgdGhleSBpbnRlcmZlcmUgd2l0aCBzaG93aW5nL2hpZGluZyBob3ZlclxuICAgICAgICAvLyBpbWFnZXMuXG4gICAgICAgIGltZy5yZW1vdmVBdHRyaWJ1dGUoICdkYXRhLXNyYycgKTtcblxuICAgICAgICBpZiAoIGhvdmVySW1nICYmIGhvdmVySW1nRGF0YXNyYyApIHtcbiAgICAgICAgICAgIGhvdmVySW1nLnJlbW92ZUF0dHJpYnV0ZSggJ2RhdGEtc3JjJyApO1xuICAgICAgICAgICAgaG92ZXJJbWcuc3JjID0gaG92ZXJJbWdEYXRhc3JjO1xuICAgICAgICAgICAgaG92ZXJJbWcuc3Jjc2V0ID0gaG92ZXJJbWdEYXRhc3Jjc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKCBob3ZlckltZyAmJiBob3ZlckltZy5wYXJlbnRFbGVtZW50ICkge1xuICAgICAgICAgICAgaG92ZXJJbWcucGFyZW50RWxlbWVudCAmJiBob3ZlckltZy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBob3ZlckltZyApO1xuICAgICAgICB9XG5cblxuICAgIH1cblxuXG4gICAgLypcbiAgICAgKiBXaGVuIGFuIGludGVyc2VjdGlvbiBvY2N1cnMgdGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQuIFJlbW92ZSB0aGUgaW50ZXJzZWN0aW9uIG9ic2VydmVyIGZyb20gdGhlIG9ic2VydmVkIGltZyBhbmRcbiAgICAgKiBydW4gdGhlIGltYWdlIGxvYWQgbG9naWMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbnRlcnNlY3Rpb25DYWxsYmFjayggZW50cmllcyA6IEFycmF5PEludGVyc2VjdGlvbk9ic2VydmVyRW50cnk+LCBvYnNlcnZlciA6IEludGVyc2VjdGlvbk9ic2VydmVyICkge1xuXG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCggKCBlbnRyeSA6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkgKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBpbWcgPSA8SFRNTEltYWdlRWxlbWVudD5lbnRyeS50YXJnZXQ7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBpbWcgaXMgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnQgbG9hZCB0aGUgaW1hZ2VcbiAgICAgICAgICAgIGlmICggZW50cnkuaXNJbnRlcnNlY3RpbmcgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxhenlJbWFnZU9ic2VydmVyICYmIHRoaXMubGF6eUltYWdlT2JzZXJ2ZXIudW5vYnNlcnZlKCBpbWcgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmltZ0xvYWRDYWxsYmFjayggaW1nICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgIH1cblxuXG4gfVxuXG5cbmV4cG9ydCB7IE9wTGF6eUxvYWQgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBV0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7QUFHQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUdBOzs7QUFHQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFHQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.lazyload.ts\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.materialize.js":
/*!**********************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.materialize.js ***!
  \**********************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _opt_lazyload_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./opt.lazyload.ts */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.lazyload.ts\");\n/* harmony import */ var _opt_optionalScripts_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./opt.optionalScripts.ts */ \"./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.optionalScripts.ts\");\n\n\n\n // SLIDER -------------------------------------------------------------------------------------------------\n\n/*\n * @brief Overloading the materialize slider because we don't use images in slider, we replaced them with\n *        an opt-type='background-v3' element\n */\n\n(function ($) {\n  const methods = {\n    init: function (options) {\n      const defaults = {\n        indicators: true,\n        height: 400,\n        transition: 500,\n        interval: 6000\n      };\n      return this.each(function () {\n        // If no options have been specified and we have stored options in this.initOptions,\n        // then use the stored options\n        if (options === undefined && this.initOptions !== undefined) {\n          options = this.initOptions;\n        }\n\n        if (options && options.height === 'fullscreen') {\n          options.height = $(window).height();\n        }\n\n        options = $.extend(defaults, options); // Save initOptions, so that it can be reused later, if needed\n\n        this.initOptions = options; // For each slider, we want to keep track of\n        // Which slide is active and its associated content\n\n        var $this = $(this),\n            $slider = $this.find('ul.slides').first(),\n            // We have to support the fact that some of the slides have their visibility turned off in the editor\n        $slides = $slider.find('> li:visible'),\n            $active_index = $slides.filter('.active').index(),\n            $arrowLeft = $this.find('.slider__arrow--left'),\n            $arrowRight = $this.find('.slider__arrow--right'),\n            themeClasses = ['primary-color-text', 'complementary-color-text', 'dark-color-text', 'light-color-text', 'white-color-text'],\n            themeBackgroundClasses = themeClasses.map(function (el) {\n          return el.replace('-text', '-background');\n        }),\n            themeHoverClasses = themeClasses.map(function (el) {\n          return el + '--hover';\n        }),\n            $active,\n            $indicators,\n            $interval,\n            arrowClick;\n\n        if ($active_index != -1) {\n          $active = $slides.eq($active_index);\n        } // Transitions the caption depending on alignment\n\n\n        function captionTransition($active, duration) {\n          var transitionStart = $active.attr('slideAnimationStartPosition'),\n              $caption = $active.find('.caption');\n\n          if (transitionStart === 'top') {\n            $caption.velocity({\n              opacity: 0,\n              translateY: -100\n            }, {\n              duration: duration,\n              queue: false\n            });\n          } else if (transitionStart === 'right') {\n            $caption.velocity({\n              opacity: 0,\n              translateX: 100\n            }, {\n              duration: duration,\n              queue: false\n            });\n          } else if (transitionStart === 'bottom') {\n            $caption.velocity({\n              opacity: 0,\n              translateY: 100\n            }, {\n              duration: duration,\n              queue: false\n            });\n          } else if (transitionStart === 'left') {\n            $caption.velocity({\n              opacity: 0,\n              translateX: -100\n            }, {\n              duration: duration,\n              queue: false\n            });\n          }\n\n          $caption = null;\n        } // Because some slides can be hidden we need to search only the visible slides to get index\n\n\n        function getActiveIndex() {\n          var activeIndex;\n          $slides.filter(':visible').each(function (index, el) {\n            if (el.classList.contains('active')) {\n              activeIndex = index;\n            }\n          });\n          return activeIndex !== undefined ? activeIndex : -1;\n        } // This function will transition the slide to any index of the next slide\n\n\n        function moveToSlide(index) {\n          // Wrap around indices.\n          if (index >= $slides.length) {\n            index = 0;\n          } else if (index < 0) {\n            index = $slides.length - 1;\n          }\n\n          $active_index = getActiveIndex(); // Only do if index changes\n\n          if ($active_index != index) {\n            $active = $slides.eq($active_index);\n            $slides.removeClass('active');\n            $active.velocity({\n              opacity: 0\n            }, {\n              duration: options.transition,\n              queue: false,\n              easing: 'easeOutQuad',\n              complete: function () {\n                $slides.not('.active').velocity({\n                  opacity: 0,\n                  translateX: 0,\n                  translateY: 0\n                }, {\n                  duration: 0,\n                  queue: false\n                });\n              }\n            });\n            captionTransition($active, options.transition); // Update indicators\n\n            if (options.indicators) {\n              $indicators.removeClass('active');\n            }\n\n            $slides.eq(index).velocity({\n              opacity: 1\n            }, {\n              duration: options.transition,\n              queue: false,\n              easing: 'easeOutQuad'\n            });\n            $slides.eq(index).find('.caption').velocity({\n              opacity: 1,\n              translateX: 0,\n              translateY: 0\n            }, {\n              duration: options.transition,\n              delay: options.transition,\n              queue: false,\n              easing: 'easeOutQuad'\n            });\n            $slides.eq(index).addClass('active'); // Update indicators\n\n            if (options.indicators) {\n              $indicators.eq(index).addClass('active');\n            }\n          }\n        }\n        /*\n         * @brief Reset the interval! This happens when the slide show starts and when ever a user initiates an event that loads a new slide before the previous interval\n         *        was up.\n         */\n\n\n        function resetInterval() {\n          if (!options.interval) {\n            return;\n          } // Reset interval\n\n\n          clearInterval($interval);\n          $interval = setInterval(function () {\n            $active_index = getActiveIndex();\n\n            if ($slides.length == $active_index + 1) {\n              $active_index = 0; // Loop to start\n            } else {\n              $active_index += 1;\n            }\n\n            moveToSlide($active_index);\n          }, options.transition + options.interval);\n        }\n        /*\n         * @brief Detect if a string is a hex color\n         */\n\n\n        function isHexColor(colorString) {\n          return colorString.indexOf('#') === 0 && colorString.length === 7;\n        } // Set height of slider\n        // If fullscreen, do nothing\n\n\n        if (!$this.hasClass('fullscreen')) {\n          $this.height(options.height);\n        } // Keep track if any of the slides has a video background\n\n\n        var hasVideoBackground = false; // Set initial positions of captions\n\n        $slides.each(function () {\n          captionTransition($(this), 0);\n\n          if (this.querySelector('.video-background-wrapper') !== null) {\n            hasVideoBackground = true;\n          }\n        }); // Dynamically add indicators\n\n        if (options.indicators) {\n          $indicators = $('<ul class=\"indicators\"></ul>');\n          var color = '',\n              rowId = $this.closest('.opt-row').attr('id'),\n              optId = $this.attr('opt-id'); // Default indicator selected color to the page primary color\n\n          $this.find('.indicator-selected-styles').remove();\n\n          if (!options.indicatorColorSelected) {\n            options.indicatorColorSelected = 'primary-color-text';\n          }\n\n          if (isHexColor(options.indicatorColorSelected)) {\n            color = options.indicatorColorSelected;\n          } else {\n            // This is a little tricky, to write a 'selected' style to overload materializes default indicator color we need a theme bg color value.\n            // Once we have the color we can build a style theme the 'selected' indicator. We get the color by creating a temp div appendining it to\n            // The dom getting its color value then removing it.\n            var $colorDummy = $('<div class=\"theme-color-dummy ' + options.indicatorColorSelected + '\" ></div>'),\n                color = '';\n            $('body').append($colorDummy);\n            color = getComputedStyle($colorDummy[0]).color;\n            $colorDummy.remove();\n          }\n\n          $indicators.prepend($('<style class=\"indicator-selected-styles\"></style>').text('#' + rowId + ' [opt-id=\"' + optId + '\"] .indicator-item.active { background-color: ' + color + ' !important }'));\n          $slides.each(function (index) {\n            var $indicator = $('<li class=\"indicator-item\"></li>'); // Set indicator colors.\n\n            if (options.indicatorColor) {\n              if (isHexColor(options.indicatorColor)) {\n                $indicator.attr('style', 'background-color:' + options.indicatorColor);\n              } else {\n                $indicator.removeClass(themeBackgroundClasses.join());\n                $indicator.addClass(options.indicatorColor + '-background');\n              }\n            } else {\n              // Default to the theme light color\n              $indicator.addClass('light-color-background');\n            } // Handle clicks on indicators\n\n\n            $indicator.click(function () {\n              var curr_index = $(this).index();\n              moveToSlide(curr_index - 1); // Reset interval\n\n              resetInterval();\n            });\n            $indicators.append($indicator);\n          });\n          $this.append($indicators);\n          $indicators = $this.find('ul.indicators').find('li.indicator-item');\n        }\n\n        if (options.arrows) {\n          // Handle clicks on slides\n          $arrowLeft.css('display', '');\n          $arrowRight.css('display', '');\n\n          arrowClick = function (getActiveIndex) {\n            return function (ev) {\n              var curr_index = getActiveIndex();\n\n              if (ev.delegateTarget.classList.contains('slider__arrow--right')) {\n                moveToSlide(curr_index + 1);\n              } else {\n                moveToSlide(curr_index + -1);\n              }\n\n              resetInterval();\n            };\n          }(getActiveIndex);\n\n          $arrowLeft.on('click', arrowClick);\n          $arrowRight.on('click', arrowClick); // Set the arrow colors\n\n          $arrowLeft.removeClass(themeClasses.join(' ') + ' ' + themeHoverClasses.join(' '));\n          $arrowRight.removeClass(themeClasses.join(' ') + ' ' + themeHoverClasses.join(' '));\n\n          if (options.arrowColor) {\n            $arrowLeft.attr('style', '');\n            $arrowRight.attr('style', '');\n\n            if (isHexColor(options.arrowColor)) {\n              $arrowLeft.css('color', options.arrowColor);\n              $arrowRight.css('color', options.arrowColor);\n            } else {\n              $arrowLeft.addClass(options.arrowColor);\n              $arrowRight.addClass(options.arrowColor);\n            }\n          }\n\n          if (options.arrowColorHover) {\n            $this.find('.slider__arrow-hover').remove();\n\n            if (isHexColor(options.arrowColorHover)) {\n              $this.prepend($('<style class=\"slider__arrow-hover\"></style>').text('.slider .slider__arrow i:hover { color: ' + options.arrowColorHover + ' }'));\n            } else {\n              $arrowLeft.addClass(options.arrowColorHover + '--hover');\n              $arrowRight.addClass(options.arrowColorHover + '--hover');\n            }\n          }\n        } else {\n          // Hides the arrows\n          $arrowLeft.css('display', 'none');\n          $arrowRight.css('display', 'none');\n\n          if (arrowClick) {\n            // If arrow click exists we are in the editor and the user has remove the slide show arrows so upbind the click handlers.\n            $arrowLeft.off('click', arrowClick);\n            $arrowRight.off('click', arrowClick);\n          }\n        }\n\n        if ($active) {\n          $active.show();\n        } else {\n          $slides.first().addClass('active').velocity({\n            opacity: 1\n          }, {\n            duration: options.transition,\n            queue: false,\n            easing: 'easeOutQuad'\n          });\n          $active_index = 0;\n          $active = $slides.eq($active_index); // Update indicators\n\n          if (options.indicators) {\n            $indicators.eq($active_index).addClass('active');\n          }\n        } // Adjust height to current slide\n\n\n        $active.find('.slide__style').each(function () {\n          $active.find('.caption').velocity({\n            opacity: 1,\n            translateX: 0,\n            translateY: 0\n          }, {\n            duration: options.transition,\n            queue: false,\n            easing: 'easeOutQuad'\n          });\n        }); // Auto scroll\n\n        resetInterval(); // HammerJS, Swipe navigation\n        // Touch Event\n\n        var panning = false;\n        var swipeLeft = false;\n        var swipeRight = false;\n        $this.hammer({\n          prevent_default: false\n        }).on('pan', function (e) {\n          if (e.gesture.pointerType === 'touch') {\n            // Reset interval\n            clearInterval($interval);\n            var direction = e.gesture.direction;\n            var x = e.gesture.deltaX;\n            var velocityX = e.gesture.velocityX;\n            var velocityY = e.gesture.velocityY;\n            var $curr_slide = $slides.filter('.active');\n\n            if (Math.abs(velocityX) > Math.abs(velocityY)) {\n              $curr_slide.velocity({\n                translateX: x\n              }, {\n                duration: 50,\n                queue: false,\n                easing: 'easeOutQuad'\n              });\n            } // Swipe Left\n\n\n            if (direction === 4 && (x > $this.innerWidth() / 2 || velocityX < -0.65)) {\n              swipeRight = true;\n            } // Swipe Right\n            else if (direction === 2 && (x < -1 * $this.innerWidth() / 2 || velocityX > 0.65)) {\n                swipeLeft = true;\n              } // Make Slide Behind active slide visible\n\n\n            var next_slide;\n\n            if (swipeLeft) {\n              next_slide = $curr_slide.next();\n\n              if (next_slide.length === 0) {\n                next_slide = $slides.first();\n              }\n\n              next_slide.velocity({\n                opacity: 1\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad'\n              });\n            }\n\n            if (swipeRight) {\n              next_slide = $curr_slide.prev();\n\n              if (next_slide.length === 0) {\n                next_slide = $slides.last();\n              }\n\n              next_slide.velocity({\n                opacity: 1\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad'\n              });\n            }\n          }\n        }).on('panend', function (e) {\n          if (e.gesture.pointerType === 'touch') {\n            var $curr_slide = $slides.filter('.active');\n            panning = false;\n            var curr_index = getActiveIndex();\n\n            if (!swipeRight && !swipeLeft || $slides.length <= 1) {\n              // Return to original spot\n              $curr_slide.velocity({\n                translateX: 0\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad'\n              });\n            } else if (swipeLeft) {\n              moveToSlide(curr_index + 1);\n              $curr_slide.velocity({\n                translateX: -1 * $this.innerWidth()\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad',\n                complete: function () {\n                  $curr_slide.velocity({\n                    opacity: 0,\n                    translateX: 0\n                  }, {\n                    duration: 0,\n                    queue: false\n                  });\n                }\n              });\n            } else if (swipeRight) {\n              moveToSlide(curr_index - 1);\n              $curr_slide.velocity({\n                translateX: $this.innerWidth()\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad',\n                complete: function () {\n                  $curr_slide.velocity({\n                    opacity: 0,\n                    translateX: 0\n                  }, {\n                    duration: 0,\n                    queue: false\n                  });\n                }\n              });\n            }\n\n            swipeLeft = false;\n            swipeRight = false; // Restart interval\n\n            resetInterval();\n          }\n        });\n        $this.on('sliderPause', function () {\n          clearInterval($interval);\n        });\n        $this.on('sliderStart', function () {\n          resetInterval();\n        });\n        $this.on('sliderNext', function () {\n          $active_index = getActiveIndex();\n          moveToSlide($active_index + 1);\n        });\n        $this.on('sliderPrev', function () {\n          $active_index = getActiveIndex();\n          moveToSlide($active_index - 1);\n        });\n        $this.on('sliderRemove', function () {\n          clearInterval($interval); // Remove all the event handlers\n\n          $this.off();\n          $slider = null;\n          $slides = null;\n          $arrowLeft = null;\n          $arrowRight = null;\n        });\n\n        if (hasVideoBackground) {\n          // Reposition background videos when the slide get resized, as needed\n          window.addEventListener('resize', op.throttle(function (_$slides) {\n            _$slides.each(function (index, slide) {\n              op.positionVideo($(slide), slide.querySelector('.video-background-wrapper'));\n            });\n          }.bind(this, $slides), 250));\n        }\n      });\n    },\n    pause: function () {\n      $(this).trigger('sliderPause');\n    },\n    start: function () {\n      $(this).trigger('sliderStart');\n    },\n    next: function () {\n      $(this).trigger('sliderNext');\n    },\n    prev: function () {\n      $(this).trigger('sliderPrev');\n    },\n    remove: function () {\n      $(this).trigger('sliderRemove');\n    }\n  };\n\n  $.fn.slider = function (methodOrOptions) {\n    if (methods[methodOrOptions]) {\n      return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {\n      // Default to \"init\"\n      return methods.init.apply(this, arguments);\n    } else {\n      $.error('Method ' + methodOrOptions + ' does not exist on jQuery.tooltip');\n    }\n  }; // Plugin end\n\n})(jQuery); // STICKY BLOCKS--------------------------------------------------------------------------------------------------------\n\n\n(function ($) {\n  /*\n   * @brief Update the materialize push pin compensate for the height of the pinned element.\n   */\n  $.fn.pushpin = function (options) {\n    // Defaults\n    var defaults = {\n      top: 0,\n      bottom: Infinity,\n      offset: 0\n    }; // Remove pushpin event and classes\n\n    if (options === 'remove') {\n      this.each(function () {\n        var id = $(this).data('pushpin-id');\n\n        if (id) {\n          $(window).off('scroll.' + id);\n          $(this).removeData('pushpin-id').removeClass('pin-top pinned pin-bottom').css({\n            top: '',\n            transition: ''\n          });\n        }\n      });\n      return false;\n    }\n\n    options = $.extend(defaults, options);\n    return this.each(function () {\n      this.stickyBlockOptions = options;\n\n      this.updateStickyBlockSize = () => {\n        const wrapper = this.closest('.sticky-wrapper');\n\n        if (!wrapper) {\n          return;\n        }\n\n        this.stickyBlockOptions.top = wrapper.offsetTop;\n        this.stickyBlockOptions.bottom = wrapper.offsetTop + this.parentElement.clientHeight - this.offsetHeight;\n        this.$original_offset = wrapper.offsetTop;\n      };\n\n      var $uniqueId = Materialize.guid(),\n          $this = $(this),\n          oldScrollValue = 0,\n          scrollDirection;\n      this.$original_offset = $(this).offset().top;\n\n      function removePinClasses(object) {\n        object.removeClass('pin-top');\n        object.removeClass('pinned');\n        object.removeClass('pin-bottom');\n      }\n\n      function updateElements(objects, scrolled) {\n        scrollDirection = scrolled > oldScrollValue ? 'down' : 'up';\n        oldScrollValue = scrolled;\n        objects.each(function () {\n          var $this = $(this);\n          this.updateStickyBlockSize(); // Add position fixed (because its between top and bottom)\n\n          if (scrolled > 0 && options.top <= scrolled && options.bottom >= scrolled) {\n            if (!$this.hasClass('pinned')) {\n              removePinClasses($this);\n              $this.css('top', options.offset);\n              $this.addClass('pinned');\n              $this.parent().css({\n                'padding-top': $this.height()\n              });\n            }\n\n            if (options.hide) {\n              $this.css({\n                transition: 'top .3s ease-in-out'\n              });\n              var offSetMax = $this.height() + 50,\n                  scrolledOffset = scrolled - options.top;\n\n              if (scrollDirection === 'up') {\n                var transition = parseInt($this.css('top')) > 0 ? '' : 'top .3s ease-in-out';\n                $this.css({\n                  top: 0,\n                  transition: transition\n                });\n              } else {\n                // Scrolling down\n                if (scrolledOffset > offSetMax) {\n                  $this.css({\n                    top: -1 * offSetMax\n                  });\n                } else {\n                  $this.css({\n                    // Subtract an extra 50 for box shadows\n                    transition: '',\n                    top: -1 * scrolledOffset\n                  });\n                }\n              }\n            }\n          } // Add pin-top (when scrolled position is above top)\n\n\n          if (scrolled < options.top && !$this.hasClass('pin-top')) {\n            removePinClasses($this);\n            $this.css('top', 0);\n            $this.addClass('pin-top');\n            $this.parent().css({\n              'padding-top': 0\n            });\n\n            if (options.hide) {\n              $this.css({\n                transition: ''\n              });\n            }\n          } // I removed the pin-bottom check to get the 'hidden' sticky block working not sure if this will break anything.\n          // If (scrolled > options.bottom && !$this.hasClass('pin-bottom')) {\n\n\n          if (scrolled >= options.bottom) {\n            if (options.hide) {\n              $this.css({\n                transition: 'top .3s ease-in-out'\n              });\n\n              if (scrollDirection === 'down') {\n                $this.css({\n                  top: 0\n                });\n              }\n\n              if (scrollDirection === 'up') {\n                $this.css({\n                  top: options.bottom - this.$original_offset\n                });\n              }\n            } else {\n              $this.css('top', options.bottom - this.$original_offset);\n            }\n\n            removePinClasses($this);\n            $this.addClass('pin-bottom');\n            $this.parent().css({\n              'padding-top': 0\n            });\n          }\n        });\n      }\n\n      $(this).data('pushpin-id', $uniqueId);\n      updateElements($this, $(window).scrollTop());\n      $(window).on('scroll.' + $uniqueId, function () {\n        var $scrolled = $(window).scrollTop() + options.offset;\n        updateElements($this, $scrolled);\n      });\n    });\n  };\n})(jQuery); // PARALLAX ------------------------------------------------------------------------------------------------------------\n\n/*\n * @brief Overloading materialize parallax so we can offer the fixed, parallax slow, parallax medium, parallax fast that\n *        are so desperately pivotal to ontraport's success.\n */\n\n\n(function ($) {\n  $.fn.parallax = function (options) {\n    var $window = $(window),\n        window_width = $window.width(); // Parallax Scripts\n\n    return this.each(function (i) {\n      // This is the block that has the parallax\n      var $this = $(this),\n          speedModifier = .66;\n\n      if (options.speed === 'parallax_slow') {\n        speedModifier = .33;\n      } else if (options.speed === 'parallax_fast') {\n        speedModifier = 1;\n      }\n\n      $this.addClass('parallax');\n\n      if (options.speed === 'fixed') {\n        $this.addClass('parallax--fixed');\n      }\n\n      var videoSelector = 'video, iframe',\n          isVideo = $this.find(videoSelector).length > 0,\n          imageElement = $this.find('img')[0],\n          container = this;\n      var containerWidth, containerHeight, targetWidth, targetHeight; // Determine what the container dimensions should be. Page or block.\n\n      if (options.speed === 'fixed') {\n        // Fixed background will stretch the target image or video to be the size of the window.\n        // This is because the container of the block acts as a window that reveals the target underneath it\n        // as it scrolls up/down through the page.\n        // We want the target to be stretched to the size of the window so that the target will always be visible\n        // as the block reveals it. If we don't stretch it to window size, then if the target is too small, we'll\n        // see the background color underneath the target.\n        container = window;\n        containerHeight = window.innerHeight; // But ultimately for fixed background, we only need the target to be as wide as its block. Since the\n        // the width of the block acts as the window that reveals the background target.\n        // In the cases where the block width is less than the page width (like if you set your page width to be\n        // \"small\"), then forcing the target to stretch to the page width would cause unnecessary stretching.\n\n        containerWidth = this.clientWidth;\n      } else {\n        // Any other options besides fixed, should use the block as its container\n        containerHeight = this.clientHeight;\n        containerWidth = this.clientWidth;\n      } // Set the initial position of the video\n\n\n      if (isVideo) {\n        op.positionVideo($(container), this);\n      } else {\n        // It's image parallax. Stretch by different factors depending on window size.\n        // Also, we stretch differently depending on whether its fixed parallax or non-fixed parallax (slow, med, fast).\n        var parallaxStretchFactor = 1; // Use the natural dimensions of the image to better determine how much the image needs to stretch.\n\n        targetHeight = imageElement.naturalHeight;\n        targetWidth = imageElement.naturalWidth; // The image needs to be a little bigger than the container so that a parallax scroll effect is possible.\n        // Through arbitrary testing, parallax scrolling is best when the image is at least 1.5 times the container.\n        // Therefore, only stretch the image if it's not at least 1.5 times larger than the container\n        // Don't add a stretch factor for fixed parallax scrolling since it does not need to stretch past container\n\n        if (options.speed !== 'fixed' && (targetHeight < this.clientHeight * 1.5 || targetWidth < this.clientWidth * 1.5)) {\n          parallaxStretchFactor = 1.5;\n        }\n\n        var newDimensions = null;\n\n        if (targetWidth !== 0 && targetHeight !== 0) {\n          newDimensions = op.adjustDimensions({\n            containerWidth: containerWidth,\n            containerHeight: containerHeight,\n            targetWidth: targetWidth,\n            targetHeight: targetHeight,\n            targetTagName: imageElement.tagName,\n            stretchFactor: parallaxStretchFactor\n          });\n        }\n\n        if (newDimensions && newDimensions.width !== 0 && newDimensions.height !== 0) {\n          imageElement.style.width = newDimensions.width + 'px';\n          imageElement.style.height = newDimensions.height + 'px';\n        }\n      }\n\n      function updateParallax(initial) {\n        var supportedParallaxElementsSelector = 'img, video, iframe',\n            imageSelector = 'img',\n            videoSelector = 'video, iframe',\n            containerHeight = $this.height(),\n            mobileSize = +op.mobileBreakpoint || 600;\n\n        if (window_width <= mobileSize) {\n          containerHeight = containerHeight > 0 ? containerHeight : $this.find(supportedParallaxElementsSelector).height();\n        } else {\n          containerHeight = containerHeight > 0 ? containerHeight : 500;\n        } // $parallaxTarget is the img or video that is to be parallaxed\n\n\n        var $parallaxTarget = $this.find(supportedParallaxElementsSelector).first(),\n            imgHeight = $parallaxTarget.height(),\n            imgWidth = $parallaxTarget.width(),\n            viewportHeight = window.innerHeight,\n            viewportWidth = window.innerWidth,\n            parallax_dist = imgHeight - containerHeight,\n            bottom = $this.offset().top + containerHeight,\n            top = $this.offset().top,\n            scrollTop = $(window).scrollTop(),\n            windowHeight,\n            windowBottom,\n            percentScrolled,\n            parallax;\n\n        if (initial) {\n          $parallaxTarget.css('display', 'block');\n        } // If there's a video, make sure the video-background overlay covers precisely\n\n\n        if ($this.find('.video-container video').length) {\n          // Ensure the overlay covers the video inside the .parallax-image element\n          $this.find('.video-background-overlay').css('height', $this.find('.parallax-image').height() + 'px');\n        }\n\n        var $videoContainer = $this.find('.video-container'),\n            isVideo = $this.find(videoSelector).length > 0,\n            moveDeltaX = '0'; // Stretch the videos out some so that they cover the block, if needed\n        // Center the video as needed\n\n        if (isVideo) {\n          if (imgWidth > viewportWidth) {\n            // Re-center the video\n            moveDeltaX = '-' + (imgWidth / 2 - viewportWidth / 2) + 'px'; // Since we've adjusted the video's dimensions, we don't need to apply this class\n            // Which is mostly used to maintain the aspect ratio of the video to hide black bars.\n\n            $videoContainer.removeClass('video-container');\n          }\n        }\n\n        if (options.speed === 'fixed') {\n          parallax = Math.round(imgHeight - containerHeight - (top - scrollTop));\n\n          if (isVideo) {\n            $this.find(videoSelector).css('transform', 'translate3D(' + moveDeltaX + ',' + parallax + 'px, 0)');\n          } else {\n            // For images, use -50% for the X argument to center the image\n            $this.find(imageSelector).css('transform', 'translate3D( -50%,' + parallax + 'px, 0)');\n          }\n        } else {\n          windowHeight = window.innerHeight;\n          windowBottom = scrollTop + windowHeight;\n          percentScrolled = (windowBottom - top) / (containerHeight + windowHeight) * speedModifier;\n\n          if (percentScrolled < 0) {\n            percentScrolled = 0;\n          } else if (percentScrolled > 1) {\n            percentScrolled = 1;\n          }\n\n          parallax = Math.round(parallax_dist * percentScrolled);\n\n          if (bottom > scrollTop && top < scrollTop + windowHeight) {\n            if (isVideo) {\n              // Videos are already centered, so use 0 for the X argument\n              $this.find(videoSelector).first().css('transform', 'translate3D(' + moveDeltaX + ',' + parallax + 'px, 0)');\n            } else {\n              // For images, use -50% for the X argument to center the image\n              $this.find(imageSelector).first().css('transform', 'translate3D( -50%,' + parallax + 'px, 0)');\n            }\n          }\n        }\n\n        $parallaxTarget = $videoContainer = null;\n      } // Wait for image load\n\n\n      $this.find('img').one('load', function () {\n        window.requestAnimationFrame(updateParallax.bind(this, true));\n      }).each(function () {\n        if (this.complete) {\n          $(this).trigger('load');\n        }\n      });\n      $this.find('video').one('playing', function () {\n        window.requestAnimationFrame(updateParallax.bind(this, true));\n      });\n      $(window).scroll(function () {\n        window_width = $window.width();\n        window.requestAnimationFrame(updateParallax.bind(this, false));\n      });\n      $(window).resize(function () {\n        window_width = $window.width();\n        window.requestAnimationFrame(updateParallax.bind(this, false));\n      });\n    });\n  };\n})(jQuery); // JUMP TO BLOCK  ------------------------------------------------------------------------------------------------------\n\n/*\n * Provide functionality to jump to a specific block on the page.\n */\n\n\n(function ($) {\n  $.fn.scrollToBlock = function () {\n    var $scrollToBlock = this;\n\n    if ($scrollToBlock.length === 1) {\n      var scrollToPosition = $scrollToBlock.offset().top; // Check if there will be a sticky block present when scrolled to element\n\n      if ($scrollToBlock.closest('.sticky-wrapper').length) {\n        // Find the sticky block closest to the element we are scrolling to\n        var $stickyBlock = $scrollToBlock.prevAll('.opt-sticky-block').eq(0);\n\n        if ($stickyBlock.length) {\n          // Get the sticky block definition\n          var optId = $stickyBlock.attr('opt-id'),\n              stickyBlockDef = stickyBlocks.filter(function (block) {\n            return block.id === optId;\n          }); // If sticky block is not hidden, subtract its height from the scrollTop\n\n          if (stickyBlockDef.length && !stickyBlockDef[0].hide) {\n            scrollToPosition -= $stickyBlock.height() + parseInt($stickyBlock.css('padding-top'));\n          }\n        }\n      }\n\n      $('body, html').animate({\n        scrollTop: scrollToPosition\n      }, 1000);\n    }\n  };\n\n  $('a[data-url_type=\"block_link\"]').on('click', function (ev) {\n    ev.preventDefault();\n    var blockId = this.getAttribute('href');\n    $(blockId).scrollToBlock();\n  });\n})(jQuery);\n/*\n * @brief Ontraports public facing landing page scripts. These scripts are designed to only run on public facing sites.\n */\n\n\n(function ($, context) {\n  var _submitAttempts = {},\n      $documentBody = $(document.body),\n      iframe_done = false,\n      op = context.op || (context.op = {}),\n      OPreCaptchaAllowSubmit = false;\n  window.ACCOUNT_SIGNUP_ERROR = 10;\n  window.CC_VERIFY_POST = 42;\n  window.CC_VERIFY_SHOW_IFRAME = 183;\n  window.CC_VERIFY_HIDE_IFRAME = 184;\n  window.CC_VERIFY_GET_CC_DATA = 185;\n  window.LOG_LEVEL_ERROR = 0;\n  window.LOG_LEVEL_WARNING = 1;\n  window.LOG_LEVEL_DEBUG = 2;\n  window.PROTOCOL = 'https://', window.COUPON_PROCESS_DOMAIN = PROTOCOL + 'forms.ontraport.com', window.IN_DEBUG_MODE = false, window.FORM_PROCESS_DOMAIN = PROTOCOL + 'forms.ontraport.com', window.CC_VERIFY_DOMAIN = FORM_PROCESS_DOMAIN + '/v2.4/cc_verify.php'; // Initialize logging.\n\n  var script = document.createElement('script');\n  script.src = 'https://optassets.ontraport.com/opt_assets/static/js/logging.js';\n  script.async = true;\n  document.getElementsByTagName('head')[0].appendChild(script);\n  op.debug = false;\n  op.currencySettings = false; // Lazy load images\n\n  const opLazyLoad = new _opt_lazyload_ts__WEBPACK_IMPORTED_MODULE_0__[\"OpLazyLoad\"]();\n  op.opLazyLoad = opLazyLoad; // Check if the page has dynamic content\n\n  Object(_opt_optionalScripts_ts__WEBPACK_IMPORTED_MODULE_1__[\"opDynamicContent\"])(); // Check for icons.\n\n  const hasFontAwesomeIcons = Object(_opt_optionalScripts_ts__WEBPACK_IMPORTED_MODULE_1__[\"opFontAwesomeIcons\"])(); // Check for and load facebook comments elements\n\n  const hasFbComments = Object(_opt_optionalScripts_ts__WEBPACK_IMPORTED_MODULE_1__[\"opFacebookComments\"])(); // Check for ontraforms\n\n  const hasOntraForms = Object(_opt_optionalScripts_ts__WEBPACK_IMPORTED_MODULE_1__[\"opOntraForms\"])(); // Check for recaptcha elements\n\n  const hasRecaptcha = Object(_opt_optionalScripts_ts__WEBPACK_IMPORTED_MODULE_1__[\"opRecaptcha\"])(); // Check for countdown timers\n\n  const hasCountDownTimer = Object(_opt_optionalScripts_ts__WEBPACK_IMPORTED_MODULE_1__[\"opCountDownTimer\"])(); // Check for order summaries\n\n  const hasOrderSummary = Object(_opt_optionalScripts_ts__WEBPACK_IMPORTED_MODULE_1__[\"opOrderSummary\"])(); // Check for payment info\n\n  const hasPaymentInfo = Object(_opt_optionalScripts_ts__WEBPACK_IMPORTED_MODULE_1__[\"opPaymentInfo\"])(); // @TODO: This will be invalidated by dynamic blocks. See if this code needs updating\n  // Check for recaptcha elements\n\n  const reCaptchaArray = document.querySelectorAll('.g-recaptcha');\n  /*\n   * @brief Build and or refresh sticky blocks.\n   */\n\n  op.buildStickyBlocks = function (stickyBlocks) {\n    var activeElement = document.activeElement.nodeName; // Check if there are sticky blocks on the page, if not return. IF you turn off a global sticky block the sticky block script is still backed into the page until\n    // the user republishes, we get around this by checking if any of the blockare still sticky by checking for the class.\n    //\n    // If an iframe video (youtube or wistia) is playing, don't rebuild sticky blocks.\n    // We'll also check to see if there is a iframe embedded form.\n    // OPF__embedded-form is checking for ontraforms.\n    // [class*=\"moonray-form-iframe\"] is checking for legacy forms.\n\n    if (document.querySelectorAll('.opt-sticky-block').length === 0 || activeElement === 'IFRAME' && ($(document.activeElement.parentElement).hasClass('video-container') || document.activeElement.closest('.OPF__embedded-form') || document.activeElement.closest('[class*=\"moonray-form-iframe\"]'))) {\n      return;\n    } // Loop through the stick blocks and make sure that all of the blocks are still sticky by searching for the block id and verifying it has a sticky block class. If it doesn't\n    // Remove the stickyblock from the list.\n\n\n    for (var i = stickyBlocks.length - 1; i >= 0; i--) {\n      let block = document.querySelector('.opt-id-' + stickyBlocks[i].id);\n\n      if (!block) {\n        stickyBlocks.splice(i, 1);\n      } else if (!block.classList.contains('opt-sticky-block')) {\n        stickyBlocks.splice(i, 1);\n      }\n    } // If we're on a mobile page, and there's an input active, hide sticky blocks so they don't cover the input\n\n\n    if ((activeElement === 'INPUT' || activeElement === 'TEXTAREA') && op.isMobileDevice() === true) {\n      // Hide all sticky blocks\n      $('.opt-sticky-block').addClass('opt-sticky-block--hidden');\n      return;\n    } else {\n      // If there are any hidden sticky blocks, show them\n      $('.opt-sticky-block').removeClass('opt-sticky-block--hidden');\n    }\n\n    var top, bottom, selector, $wrapper; // Clean up, Remove any sticky wrappers in case the user is resizing and we have to redeclare stickyblocks\n\n    $('.sticky-wrapper').children().unwrap();\n\n    for (var i = 0, l = stickyBlocks.length; i < l; i++) {\n      var block = stickyBlocks[i],\n          $stickyBlock = $('.opt-id-' + block.id); // Clean up\n\n      if ($stickyBlock.pushpin) {\n        $stickyBlock.pushpin('remove');\n      } // If the sticky block is not yet visible no need to initialize it yet.\n\n\n      if ($stickyBlock[0].style.display === 'none') {\n        continue;\n      } // Check the viewport size restrictions\n\n\n      var viewport = $stickyBlock.attr('data-block-viewport-display');\n\n      if (viewport !== 'all' && viewport !== op.getViewportSize()) {\n        continue;\n      }\n\n      if ($stickyBlock.data('pushpinId')) {\n        $stickyBlock.pushpin('remove');\n      }\n\n      $wrapper = $stickyBlock.closest('.sticky-wrapper');\n\n      if (!$wrapper.length) {\n        selector = '.opt-id-' + block.nextId;\n        $stickyBlock.nextUntil(selector + '[data-block-viewport-display=\"all\"],' + selector + '[data-block-viewport-display=\"' + op.getViewportSize() + '\"]').addBack().wrapAll('<div class=\\'sticky-wrapper\\' />');\n        $wrapper = $stickyBlock.closest('.sticky-wrapper');\n      }\n\n      $wrapper.height($wrapper.height());\n      top = $wrapper.offset().top;\n      bottom = $wrapper.offset().top + $stickyBlock.parent().innerHeight() - $stickyBlock.outerHeight();\n      $stickyBlock.pushpin({\n        top: top,\n        bottom: bottom,\n        hide: block.hide\n      });\n    }\n  };\n  /*\n   * Borrowed from Underscore.js 1.9.1\n   * Some functions take a variable number of arguments, or a few expected\n   * arguments at the beginning and then a variable number of values to operate\n   * on. This helper accumulates all remaining arguments past the function’s\n   * argument length (or an explicit `startIndex`), into an array that becomes\n   * the last argument. Similar to ES6’s \"rest parameter\".\n   */\n\n\n  op.restArguments = function (func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function () {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n\n      switch (startIndex) {\n        case 0:\n          return func.call(this, rest);\n\n        case 1:\n          return func.call(this, arguments[0], rest);\n\n        case 2:\n          return func.call(this, arguments[0], arguments[1], rest);\n      }\n\n      var args = Array(startIndex + 1);\n\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n  /*\n   * Borrowed from Underscore.js 1.9.1\n   * Returns a function, that, as long as it continues to be invoked, will not\n   * be triggered. The function will be called after it stops being called for\n   * N milliseconds. If `immediate` is passed, trigger the function on the\n   * leading edge, instead of the trailing.\n   */\n\n\n  op.debounce = function (func, wait, immediate) {\n    var timeout, result;\n\n    var later = function (context, args) {\n      timeout = null;\n\n      if (args) {\n        result = func.apply(context, args);\n      }\n    };\n\n    var debounced = op.restArguments(function (args) {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n\n        if (callNow) {\n          result = func.apply(this, args);\n        }\n      } else {\n        timeout = op.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function () {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  }; // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n\n\n  op.delay = op.restArguments(function (func, wait, args) {\n    return setTimeout(function () {\n      return func(...args);\n    }, wait);\n  });\n  /*\n   *\n   */\n\n  op.displaySettings = function (selector, displayDelay) {\n    setTimeout(function (_selector) {\n      return function () {\n        let _$block = $(_selector); // Force the block to not be visible\n\n\n        _$block.css({\n          display: '',\n          opacity: 0\n        }); // If its a sticky block rebuild all the sticky block thresholds\n\n\n        if (_$block.hasClass('opt-sticky-block')) {\n          op.buildStickyBlocks(stickyBlocks);\n        } // Push the opacity change to the bottom of the stack so we can see the opacity transition.\n\n\n        setTimeout(function () {\n          // Reveal the block\n          _$block.css({\n            opacity: 1\n          });\n\n          _$block.removeClass('conditions__display_time_seconds--hidden'); // If there are any slideshows in the block, reinitialize them.\n          // Otherwise, their contents will not render.\n          // Iterate over each slideshow element individually so that their initOption can be applied\n          // individually.\n\n\n          let $slideshows = _$block.find('.opt-element.slider');\n\n          if ($slideshows.length) {\n            for (let i = 0, l = $slideshows.length; i < l; ++i) {\n              $slideshows.eq(i).slider();\n            }\n          }\n\n          $slideshows = null;\n        }, 0);\n      };\n    }(selector), displayDelay);\n  };\n\n  op.formatCreditCard = function () {\n    var AMEX_CARD = {\n      pattern: /^3[47]/,\n      formats: [{\n        length: 15,\n        format: 'xxxx - xxxxxxx - xxxx'\n      }]\n    },\n        // This pattern covers the rest of the cards: Visa, Mastercard, Diners Club, or JCB\n    DEFAULT_CARD = {\n      formats: [{\n        length: 20,\n        format: 'xxxx - xxxx - xxxx - xxxx - xxxx'\n      }]\n    },\n        CC_DELIMITER = ' - ',\n        getCardType = function (cc_num) {\n      var cardType = DEFAULT_CARD;\n\n      if (cc_num.match(AMEX_CARD.pattern)) {\n        cardType = AMEX_CARD;\n      }\n\n      return cardType;\n    },\n        getCardFormatString = function (cc_num, card_type) {\n      for (var i in card_type.formats) {\n        var format = card_type.formats[i];\n\n        if (cc_num.length <= format.length) {\n          return format.format;\n        }\n      }\n\n      return DEFAULT_CARD.formats[0].format;\n    },\n        formatCardNumber = function (cc_num, card_type) {\n      var numAppendedChars = 0,\n          formattedNumber = '';\n\n      if (!card_type) {\n        return cc_num;\n      }\n\n      var cardFormatString = getCardFormatString(cc_num, card_type);\n\n      for (var i = 0, cardFormatIndex = 0; i < cc_num.length; i++) {\n        cardFormatIndex = i + numAppendedChars;\n\n        if (!cardFormatString || cardFormatIndex >= cardFormatString.length) {\n          return cc_num;\n        }\n\n        if (cardFormatString.charAt(cardFormatIndex) !== 'x') {\n          numAppendedChars += CC_DELIMITER.length;\n          formattedNumber += CC_DELIMITER + cc_num.charAt(i);\n        } else {\n          formattedNumber += cc_num.charAt(i);\n        }\n      }\n\n      return formattedNumber;\n    },\n        monitorCcFormat = function () {\n      var $el = $(this),\n          cc_num = $el.val().replace(/\\D/g, ''),\n          card_type = getCardType(cc_num);\n      $el.val(formatCardNumber(cc_num, card_type));\n    };\n\n    return monitorCcFormat;\n  }();\n  /*\n   * @brief Search for order bumps in the submited form. Detect which bumps have been opted into, check for editable quantity\n   *        then build the orderbump value and add it to the form payload.\n   * @param $form {jQuery} reference to the form that has been submited.\n   */\n\n\n  op.getOrderBumps = function ($form) {\n    var $orderBumps = $form.find('.opt-order-bump[offer]'),\n        payload = {},\n        checkbox,\n        quantityWrapper,\n        quantityInput,\n        quantityValue,\n        $input; // No order bumps return false.\n\n    if (!$orderBumps.length) {\n      return false;\n    }\n\n    $orderBumps.each(function (index, bump) {\n      // Check if the order bump is checke / opted in\n      checkbox = bump.querySelector('[type=\"checkbox\"]');\n\n      if (checkbox.checked) {\n        quantityValue = true;\n        quantityWrapper = bump.querySelector('.opt-order-bump__quantity');\n\n        if (quantityWrapper.style.display !== 'none') {\n          quantityInput = bump.querySelector('.opt-order-bump__quantity-input');\n          quantityValue = quantityInput.value;\n        }\n\n        payload[bump.getAttribute('opt-id')] = quantityValue;\n      }\n    }); // No order bumps are selected return false\n\n    if ($.isEmptyObject(payload)) {\n      return false;\n    } // We have selected order bumps so add the orderbumps input to the form\n\n\n    $input = $('<input name=\"orderbumps\" type=\"hidden\" />');\n    $input.val(JSON.stringify(payload));\n    $form.append($input);\n  };\n  /*\n   * Return a string representation of the viewport size. I made a helper so we have a central place\n   * to do this check and extend it. The return values should match the possible values of the opt element\n   * data-block-viewport-display values used in block_v3.js and opt.materializecss.css.\n   */\n\n\n  op.getViewportSize = function () {\n    var mobileSize = +op.mobileBreakpoint || 600,\n        width = window.outerWidth,\n        size = 'desktop';\n\n    if (width <= mobileSize) {\n      size = 'mobile';\n    }\n\n    return size;\n  }; // Data target id of the last opened material select field. We keep track of it because we need it to toggle the zindex of the containing blocks/rows\n\n\n  op.materialSelectLast = null;\n  /*\n   * @brief Material select close callback. Toggle the block and row z-index back to there original values if they have been modified because of a select opening upward.\n   */\n\n  op.materialSelectClose = function (select) {\n    var col = select.closest('.col__style'); // When materialize dropdowns are closing, make sure we remove any overflow\n    // that we hardcoded when the dropdown was opening\n\n    if (col) {\n      col.style.overflow = '';\n    } // If it is not a select that opens towards the top abort mission.\n\n\n    if (parseInt(this.dropdownEl.style.top) >= 0) {\n      return;\n    } // Get the wrapping block and rows and restore their original z-index.\n\n\n    var block = select.closest('[opt-type=\"block-v3\"]'),\n        row = select.closest('.row');\n\n    if (this.id === op.materialSelectLast) {\n      if (block.zIndexVal || block.zIndexVal === '') {\n        block.style.zIndex = block.zIndexVal;\n      }\n\n      if (row.zIndexVal || row.zIndexVal === '') {\n        row.style.zIndex = row.zIndexVal;\n      }\n\n      if (col.zIndexVal || col.zIndexVal === '') {\n        col.style.zIndex = col.zIndexVal;\n      }\n    }\n  };\n  /*\n   * @brief Material select open callback, we toggle the row and block zindex to auto so select options will open on top of rows and columns above them.\n            Note, This runs on  selectOpenStart event so we have to use the settimeout.\n            We can't run this on the end of the open because materialize hard codes a funtion onto that callback.\n            Nerds..\n   * @todo  Still have an edge case, if the select options don'e exceed the size of the row or block we don't need to do this.\n   */\n\n\n  op.materialSelectOpen = function (select) {\n    // We have to use a setTimeout so we give the select options time to render. Then we can call _getDropdownPostion to determine if the select is opening upward.\n    setTimeout(function () {\n      var p = this._getDropdownPosition(),\n          mobileSize = +op.mobileBreakpoint || 600;\n\n      op.materialSelectLast = this.id;\n      var col = select.closest('.col__style');\n\n      if (col) {\n        // Force the column style to overflow visible when the dropdown is opening,\n        // incase it was hidden if border radius was added\n        col.style.overflow = 'visible'; // If we are on mobile, the columns are stacked so we need to bump up the column z-index while dropdown is open\n\n        if (window.innerWidth <= mobileSize) {\n          if (!col.zIndexVal && col.zIndexVal !== '') {\n            col.zIndexVal = col.style.zIndex;\n          }\n\n          col.style.zIndex = '9999';\n        }\n      }\n\n      if (p.verticalAlignment === 'bottom') {\n        var block = select.closest('[opt-type=\"block-v3\"]'),\n            row = select.closest('.row');\n\n        if (!block.zIndexVal && block.zIndexVal !== '') {\n          block.zIndexVal = block.style.zIndex;\n        }\n\n        if (!row.zIndexVal && row.zIndexVal !== '') {\n          row.zIndexVal = row.style.zIndex;\n        }\n\n        block.style.zIndex = '9999';\n        row.style.zIndex = '9999';\n      }\n    }.bind(this), 50);\n  };\n  /*\n   * Borrowed from underscore js\n   * Returns a function, that, when invoked, will only be triggered at most once\n   * during a given window of time. Normally, the throttled function will run\n   * as much as it can, without ever going more than once per `wait` duration;\n   * but if you'd like to disable the execution on the leading edge, pass\n   * `{leading: false}`. To disable execution on the trailing edge, ditto.\n   */\n\n\n  op.throttle = function (func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n\n    if (!options) {\n      options = {};\n    }\n\n    var later = function () {\n      previous = options.leading === false ? 0 : Date.now();\n      timeout = null;\n      result = func.apply(context, args);\n\n      if (!timeout) {\n        context = args = null;\n      }\n    };\n\n    return function () {\n      var now = Date.now();\n\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n\n        previous = now;\n        result = func.apply(context, args);\n\n        if (!timeout) {\n          context = args = null;\n        }\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n\n      return result;\n    };\n  };\n  /*\n   * @brief Event handler run when order bump is checked/unchecked. This adds/removes the order bump to/from the order summary\n   * @param ev {event} event reference from the checkbox event.\n   */\n\n\n  op.updateOrderSummaryWithOrderBump = function (ev) {\n    var form = ev.target.closest('form'),\n        orderSummary = form && form.querySelector('ontraport-order-summary');\n\n    if (orderSummary) {\n      var orderBump = ev.target.closest('.opt-order-bump'),\n          obOffer = JSON.parse(orderBump.getAttribute('offer')),\n          obTaxes = JSON.parse(orderBump.getAttribute('taxes')),\n          obShipping = JSON.parse(orderBump.getAttribute('shipping')),\n          osOffer = JSON.parse(orderSummary.getAttribute('offer')),\n          osTaxes = JSON.parse(orderSummary.getAttribute('taxes')),\n          osShipping = JSON.parse(orderSummary.getAttribute('shipping')),\n          isChecked = ev.target.checked; // Make sure we preserve the existing coupon offer if present\n\n      const grid = form.querySelector('.moonray-from-offer-grid');\n\n      if (!grid) {\n        console.warning('updateOrderSummaryWithOrderBump(), failure to find the offer grid. ');\n      } else {\n        var offerElement = $(grid);\n\n        if (offerElement) {\n          let controller = offerElement.controller();\n\n          if (controller && controller.offerCopy) {\n            var currentOfferCoupon = controller.offerCopy.serialize().coupon;\n\n            if (currentOfferCoupon) {\n              osOffer.coupon = currentOfferCoupon;\n            }\n          }\n        }\n      } // Check for products with editable quantity we need to update them in the offer if the user has made changes\n\n\n      osOffer.products.forEach(product => {\n        if (product.quantityEditable == true || product.quantityEditable == 'true') {\n          product.quantity = +document.querySelector('[name*=\"' + product.uid + '\"]').value;\n        }\n      }); // If checked, add products and taxes of order bump from the order summary\n\n      if (isChecked) {\n        // Force order bump products to have their quantity be not editable when adding to the order summary.\n        // Editable quantity should be edited in the order bump\n        obOffer.products = obOffer.products.map(function (obProduct) {\n          obProduct.quantityEditable = false;\n          return obProduct;\n        });\n        osOffer.products = osOffer.products.concat(obOffer.products); // Extract the order summary's tax IDs so that we can filter those out of the order bump to prevent duplicates.\n\n        var osTaxIds = osTaxes.map(function (osTax) {\n          return osTax.id;\n        }); // Filter out the taxes that are currently present in the OS so we don't readd them\n\n        obTaxes = obTaxes.filter(function (obTax) {\n          return !osTaxIds.includes(obTax.id);\n        });\n        osTaxes = osTaxes.concat(obTaxes);\n        osShipping = osShipping.concat(obShipping); // Else not checked, so remove the products and taxes of order bump from the order summary\n      } else {\n        // Extract the order bump's product and tax IDs to know what to remove from the order summary\n        var obProductIds = obOffer.products.map(function (obProduct) {\n          return obProduct.id;\n        }),\n            obTaxIds = obTaxes.map(function (obTax) {\n          return obTax.id;\n        }),\n            obShippingIds = obShipping.map(function (obShip) {\n          return obShip.id;\n        }),\n            // This grabs all order bumps present besides the one that is selected\n        otherOrderBumps = form.querySelectorAll('.opt-order-bump[offer]:not([opt-id=\"' + orderBump.getAttribute('opt-id') + '\"])'); // This loops over all other order bumps (besides the one that was just unchecked) and if the other\n        // Order bump is checked, it compares its tax IDs to those in the obTaxIds array and removes them.\n        // This will prevent the unchecking of an order bump from removing a tax if it is also present\n        // In another order bump that is currently checked.\n\n        for (var i = 0, l = otherOrderBumps.length, otherObTaxIds, otherObShippingIds; i < l; i++) {\n          if (otherOrderBumps[i].querySelector('input[type=\"checkbox\"]').checked) {\n            otherObTaxIds = JSON.parse(otherOrderBumps[i].getAttribute('taxes')).map(function (obTax) {\n              return obTax.id;\n            });\n            obTaxIds = obTaxIds.filter(function (obTaxId) {\n              return !otherObTaxIds.includes(obTaxId);\n            });\n            otherObShippingIds = JSON.parse(otherOrderBumps[i].getAttribute('shipping')).map(function (obShip) {\n              return obShip.id;\n            });\n            obShippingIds = obShippingIds.filter(function (id) {\n              return !obShippingIds.includes(id);\n            });\n          }\n        } // Remove the order bump's products from the order summary offer\n\n\n        osOffer.products = osOffer.products.filter(function (osProduct) {\n          return !obProductIds.includes(osProduct.id);\n        }); // Remove the order bump's taxes from the order summary taxes\n\n        osTaxes = osTaxes.filter(function (osTax) {\n          return !obTaxIds.includes(osTax.id);\n        }); // Remove the order bump's shipping from the order summary shipping\n\n        osShipping = osShipping.filter(function (osShip) {\n          return !obShippingIds.includes(osShip.id);\n        });\n      }\n\n      orderSummary.setAttribute('offer', JSON.stringify(osOffer));\n      orderSummary.setAttribute('taxes', JSON.stringify(osTaxes));\n      orderSummary.setAttribute('shipping', JSON.stringify(osShipping));\n    }\n  };\n\n  op.updateOrderBumpQuantity = function (ev) {\n    var form = ev.target.closest('form'),\n        orderSummary = form && form.querySelector('ontraport-order-summary');\n\n    if (orderSummary) {\n      var orderBump = ev.target.closest('.opt-order-bump'),\n          obOffer = JSON.parse(orderBump.getAttribute('offer')),\n          newQuantity = ev.target.value,\n          editableId; // Find the editable product, update its quantity, and save the ID incase we need to update the product\n\n      obOffer.products = obOffer.products.map(function (obProduct) {\n        if (obProduct.quantityEditable) {\n          editableId = obProduct.id;\n          obProduct.quantity = newQuantity;\n        }\n\n        return obProduct;\n      });\n      orderBump.setAttribute('offer', JSON.stringify(obOffer)); // If the order bump is checked, also update the order summary's product quantity\n\n      if (orderBump.querySelector('input[type=\"checkbox\"]').checked) {\n        var osOffer = JSON.parse(orderSummary.getAttribute('offer'));\n        osOffer.products = osOffer.products.map(function (osProduct) {\n          if (osProduct.id === editableId) {\n            osProduct.quantity = newQuantity;\n          }\n\n          return osProduct;\n        });\n        orderSummary.setAttribute('offer', JSON.stringify(osOffer));\n      }\n    }\n  };\n  /*\n   * @brief Set value on a shipping field\n   */\n\n\n  op.setShippingFieldValue = function ($relatedShippingField, newVal) {\n    let $relatedShippingFieldContainer = $relatedShippingField.closest('.opt-input'); // If field in question in a dropdown, use materialize's internal update function\n\n    if ($relatedShippingField.hasClass('select-field')) {\n      let shippingFieldMaterializeDropdown = M.FormSelect.getInstance($relatedShippingField.get(0));\n\n      if (shippingFieldMaterializeDropdown) {\n        // Loop over target materialize dropdown's \"value dictionary\", which keeps an internal mapping between the select option and the generated LIs\n        let valueDictionary = shippingFieldMaterializeDropdown._valueDict;\n\n        for (let key in valueDictionary) {\n          // Once we find the option field that has the new value, use the key to find the corresponding LI\n          // and use it to trigger materialize's internal selection handler\n          if (valueDictionary[key].el.value === newVal) {\n            shippingFieldMaterializeDropdown._handleOptionClick({\n              target: $relatedShippingFieldContainer.find('#' + key),\n              preventDefault: $.noop,\n              stopPropagation: $.noop\n            });\n\n            break;\n          }\n        }\n      }\n    } else {\n      // Set target input value\n      $relatedShippingField.val(newVal); // If it is a materialize input, add the active class if value is not empty string, otherwise remove it\n\n      if ($relatedShippingFieldContainer.attr('opt-input-style') === 'default') {\n        $relatedShippingFieldContainer.find('label').toggleClass('active', newVal !== '');\n      }\n    }\n  };\n  /**\n   * This functionality is only supposed to be run once per page. Since we made initForms a function that can be invoked again,\n   * prevent this logic from running more than once by flipping a special flag in the op object and checking it before the next call\n   */\n\n\n  op.onceOnlyFormInitialization = function () {\n    if (op.oneTimeFormInitializationRan) {\n      return;\n    }\n    /*  What is this craziness?? Well, let me tell you...\n     *  So iOS will screen zoom in/out on form input elements if the font size is\n     *  anything other than 16px.  Upon zoom, the click event for the select option's\n     *  <li> will not fire!  Materialize solves this by forcing inputs to always be 16px.\n     *  We can't do that with our editor cause we're pro-font sizes, so here we are overriding\n     *  the CLOSE click handler and manually triggering the selected option.\n     *\n     *  @author jp@ontraport.com\n     */\n\n\n    (function (_handleDocumentClick) {\n      M.Dropdown.prototype._handleDocumentClick = function (e) {\n        var $target = $(e.target);\n\n        if ($target.closest('.dropdown-content').length && !this.isTouchMoving) {\n          $target.parents('li:not(.optgroup)').trigger('click');\n        }\n\n        _handleDocumentClick.call(this, e);\n      };\n    })(M.Dropdown.prototype._handleDocumentClick); // Init the elements\n\n\n    if (!$.fn.datepicker) {\n      // Sometimes the datepicker and formselector won't be inited in jquery so we do it explicitly.\n      // Not sure why this happens, we suspect it's a byproduct of the webpack build.\n      // Once jquery gets added to the webpack build we can get rid of this.\n      M.initializeJqueryWrapper(M.Datepicker, 'datepicker', 'M_Datepicker');\n      M.initializeJqueryWrapper(M.FormSelect, 'formSelect', 'M_FormSelect');\n    }\n\n    op.oneTimeFormInitializationRan = true;\n  };\n  /*\n   * @brief Init form inputs and bind submit buttons.\n   */\n\n\n  op.initForms = function (formIds) {\n    op.onceOnlyFormInitialization();\n    let v3FormElements = []; // First check if there are any v3 forms on the page\n\n    if (formIds && formIds.length) {\n      formIds.forEach(formId => {\n        const formEl = document.querySelector(`form[opt-id=\"${formId}\"]`);\n\n        if (formEl) {\n          v3FormElements.push(formEl);\n        }\n      });\n    } else {\n      v3FormElements = Array.from(document.forms).filter(form => {\n        // Get op v3 forms that are not dynamic block templates\n        return form.classList.contains('opt-row') && !form.hasAttribute('data-dc');\n      });\n    }\n\n    if (!v3FormElements.length) {\n      // No v3 forms found so jump ship\n      return false;\n    }\n\n    v3FormElements.forEach(formElement => {\n      op.initForm(formElement);\n    });\n  }; // End init forms\n\n\n  op.initForm = function (formElement) {\n    if (!formElement) {\n      return false;\n    }\n\n    let $v3Form = $(formElement);\n\n    if (!$v3Form.length || !$v3Form.attr('opt-id') || !$v3Form.is('form') || !$v3Form.hasClass('opt-row') || $v3Form.hasClass('opt-form--initialized')) {\n      return false;\n    } // Make sure all conditional redirect forms have the proper form action flag\n\n\n    if ($v3Form.is('[data-conditional-redirect]')) {\n      let conditionalFormAction = $v3Form.attr('action');\n\n      if (conditionalFormAction) {\n        $v3Form.attr('action', conditionalFormAction + '&_conditionalResponse=true');\n      }\n    }\n\n    var $expirationYear = $v3Form.find('select[name=\"payment_expire_year\"]'); // Search for year expiration fields and stub out there options\n\n    $expirationYear.each(function (el) {\n      var currentYear = new Date().getFullYear(),\n          options = '',\n          // Dont leave this undefined, otherwise the += \"<option..\" below will add it to \"undefined\"\n      year; // Remove every value-less option that isn't the first.\n      // the first value-less option will be the option that just says 'Select...' by default (but can be customized by user)\n\n      $(this).find('option[value=\"\"]:not(:first)').remove();\n\n      for (var i = 0; i <= 25; i++) {\n        year = i + currentYear; // Check for dupes before adding option.\n\n        if ($(this).find('option[value=\"' + year + '\"]').length == 0) {\n          options += '<option value=\"' + year + '\">' + year + '</option>';\n        }\n      }\n\n      $(this).append(options);\n    }); // When expiration year is changed, trigger events on it and the expiration month to get the validation to run\n\n    $expirationYear.on('change', function () {\n      var $this = $(this),\n          $expireMonth = $this.closest('form').find('select[name=\"payment_expire_month\"]');\n      $this.trigger('blur');\n      $this.trigger('input');\n      $expireMonth.trigger('blur');\n      $expireMonth.trigger('input');\n    }); // When expiration month is changed, trigger events on it and the expiration year to get the validation to run\n\n    $v3Form.find('select[name=\"payment_expire_month\"]').on('change', function () {\n      var $this = $(this),\n          $expireYear = $this.closest('form').find('select[name=\"payment_expire_year\"]');\n      $this.trigger('blur');\n      $this.trigger('input');\n      $expireYear.trigger('blur');\n      $expireYear.trigger('input');\n    });\n    $v3Form.find('input[name=\"payment_number\"]').each(function () {\n      var $el = $(this);\n      $el.on('input', op.formatCreditCard);\n    }); // This selector is used to add the new opt datetime picker library, if fulldate has been migrated we'll include that\n    // in the selector string\n\n    let eventListenerSelector = '[opt-input-type=\"timestamp\"]'; // The new opt datepicker library adds a second input that is disabled to store the date from the date picker, but\n    // with the old library there is only one input that isn't disabled.\n\n    if (!$v3Form.find('[opt-input-type=\"fulldate\"] input[disabled=\"disabled\"]').length) {\n      // If the page hasn't been re-saved to use the new date picker library then run the legacy event listener\n      $v3Form.find('[opt-input-style=\"default\"][opt-input-type=\"fulldate\"] input').on('focus', function (ev) {\n        let datePicker = M.Datepicker.getInstance(ev.target);\n\n        if (datePicker) {\n          datePicker.open();\n        }\n      });\n    } else {\n      // We're using the new opt datepicker library so the listeners are going to be the same for timestamp and fulldate input types.\n      eventListenerSelector += ', [opt-input-type=\"fulldate\"]';\n    }\n\n    $v3Form.find(eventListenerSelector).on('click', OptDateTimePicker.dateTimeFieldClickHandler).on('dateTimePickerSave', OptDateTimePicker.dateTimeFieldSaveHandler).on('dateTimePickerCancel', OptDateTimePicker.dateTimeFieldCancelHandler);\n    var $orderBumps = $v3Form.find('.opt-order-bump[offer]');\n    $orderBumps.each(function () {\n      var form = this.closest('form'),\n          orderSummary = form && form.querySelector('ontraport-order-summary');\n\n      if (orderSummary) {\n        var osTaxes = JSON.parse(orderSummary.getAttribute('taxes')),\n            obTaxes = JSON.parse(this.getAttribute('taxes')),\n            osTaxIds = osTaxes.map(function (osTax) {\n          return osTax.id;\n        }); // Remove any duplicate taxes from the order bump present in the offer summary so that they\n        // Are not double counted in the offer summary when order bump data is merged\n\n        obTaxes = obTaxes.filter(function (obTax) {\n          return !osTaxIds.includes(obTax.id);\n        });\n        this.setAttribute('taxes', JSON.stringify(obTaxes)); // Bind handlers to checkbox and quantity inputs of order bumps\n\n        $(this).find('input[type=\"checkbox\"]').on('change', op.updateOrderSummaryWithOrderBump);\n        $(this).find('.opt-order-bump__quantity-input').on('change', op.updateOrderBumpQuantity);\n      }\n    }); // Loop over each order bump and update the order summarys accordingly. This needs a seperate loop\n    // From the code above so that the taxes are filtered out from the order bumps before any are checked.\n    // If we were to combine these loops, then it is possible to check an order bump which will add the tax\n    // To the order summary, and then have another order bump remove that tax ID incorrectly.\n    // We need to make sure the grid offer model has been constructed so bind to gridOfferControllerReady.\n    // The method goes off every time a change is made to the grid (it goes off like 10 times) so the call\n    // back here makes a closure to ensure we only run the order bump logic once. More or less the native\n    // equivalent of jQuery's .one method.\n\n    $v3Form.each((i, form) => {\n      form.addEventListener('gridOfferControllerReady', function () {\n        let called = false;\n\n        const temp = ev => {\n          // Check if the callback is called\n          if (called) {\n            document.removeEventListener('gridOfferControllerReady', temp);\n            return false;\n          }\n\n          called = true; // Get all the orderbumps in the row of the order summary that triggered the ready event. Next see if we need to update any of\n          // them because they are checked.\n\n          const orderBumps = ev.target.closest('.opt-row').querySelectorAll('.opt-order-bump[offer]');\n          orderBumps.forEach(el => {\n            let $checkbox = $(el).find('input[type=\"checkbox\"]'); // If checkbox is checked, run the update OS handler.\n\n            if ($checkbox.get(0).checked) {\n              op.updateOrderSummaryWithOrderBump({\n                target: $checkbox.get(0)\n              });\n            }\n          });\n        };\n\n        return temp;\n      }());\n    });\n    $v3Form.find('.opt-element .datepicker').datepicker({\n      format: 'yyyy-mm-dd',\n      container: document.body,\n      yearRange: 100,\n      onClose: function () {\n        // After picker is closed, trigger focus on datepicker input to trigger validation\n        if (this.el && this.el.focus) {\n          this.el.focus();\n        }\n      },\n      onDraw: function (context) {\n        // When date picker is rendered, replace the onOpenEnd function since its \"scroll to menu item\" functionality does not work\n        let materializeSelect = M.FormSelect.getInstance(context.calendarEl.querySelector('.orig-select-year'));\n\n        if (materializeSelect && materializeSelect.dropdown) {\n          materializeSelect.dropdown.options.onOpenEnd = function (originalOnOpenEnd) {\n            return function (ev) {\n              // Call original \"onOpenEnd\"\n              originalOnOpenEnd();\n\n              if (this.dropdownEl) {\n                let selectedDropdownItem = this.dropdownEl.querySelector('.selected');\n\n                if (selectedDropdownItem) {\n                  // Determine where to scroll the date picker's year select to. The goal is to center the selected option in the menu\n                  // Start by getting the top position of the selected item, and offset it by the top position of the menu itself\n                  let newScrollTop = selectedDropdownItem.getBoundingClientRect().top - this.dropdownEl.getBoundingClientRect().top; // Add the current scroll position. At this point the newScrollTop should\n                  // make the selected menu item appear at the top of the menu\n\n                  newScrollTop += this.dropdownEl.scrollTop; // Now subtract half the menu height so that the selected menu item is centered\n\n                  newScrollTop -= this.dropdownEl.clientHeight / 2;\n\n                  if (newScrollTop > 0) {\n                    this.dropdownEl.scrollTop = newScrollTop;\n                  }\n                }\n              }\n            };\n          }(materializeSelect.dropdown.options.onOpenEnd);\n        }\n      }\n    });\n    const $selectField = $v3Form.find('.opt-element select:not(.moonray-form-cart-shipping-select)');\n    $selectField.formSelect({\n      dropdownOptions: {\n        onOpenStart: op.materialSelectOpen,\n        onCloseStart: op.materialSelectClose\n      }\n    }); // Dropdowns are missing the \"opt-input__field\" that gets added to all inputs from the editor,\n    // because the input gets generated dynamically by materialize. Add the missing class.\n\n    $selectField.closest('.opt-element').find('input.select-dropdown').addClass('opt-input__field'); // @TODO: Check this works\n    // Make the forms smart forms and add the form conditions plugin.\n\n    $v3Form.moonraySmartForm().formConditions({\n      processorMutator: function (condition, rulesResult) {\n        if (rulesResult && condition.tru != undefined) {\n          this._processOutcomes(condition.tru, true); // This should work for all cart / payment related conditions\n\n        } else if (rulesResult == false && condition.fal != undefined) {\n          this._processOutcomes(condition.fal, false); // Just invert\n\n        } else if (rulesResult == false) {\n          this._processOutcomes(condition.tru, false);\n        }\n      },\n      outcomeActionMutator: function (outcome, rulesResult) {\n        var ret = outcome.action; // Invert only if its a show\n\n        if (rulesResult === false) {\n          // If its a string filp the result. tax and shipping rules sets are funcs\n          if ($.type(outcome.action) == 'string') {\n            if (outcome.action == 'show') {\n              ret = 'hide';\n            } else {\n              ret = null;\n            }\n          }\n        }\n\n        return ret;\n      },\n      inputEvent: 'blur change',\n      conditions: []\n    }); // Set the form currency settings.\n\n    if (op.currencySettings && op.currencySettings !== '[currency_settings]') {\n      $v3Form.find('ontraport-order-summary').attr('currency-settings', op.currencySettings);\n    } // Shipping fields same as billing toggle.\n\n\n    var shippingCheck = $v3Form.find('[name=\"shipping_same_as_billing\"]');\n\n    if (shippingCheck.length) {\n      // Get all the shipping elements from the same block and show or hide them depending on the 'same as billing' checkbox status.\n      // If hiding them, also retrieve the values from the billing field so that tax rules still function properly\n      shippingCheck.change(function (ev) {\n        var shippingInputWrappers = this.closest('.container').querySelectorAll('.opt-shipping-input'),\n            checked = this.checked;\n        shippingInputWrappers.forEach(function (input) {\n          if (checked) {\n            input.classList.add('opt-shipping-input--show');\n          } else {\n            input.classList.remove('opt-shipping-input--show');\n            let isDropdown = input.firstChild.classList.contains('opt-input--dropdown'),\n                $inputEl = $(input).find(isDropdown ? 'select' : 'input');\n\n            if ($inputEl.length) {\n              // Get the related billing field's value and set it on the shipping field\n              let billingVal = $inputEl.closest('form').find('[name=' + $inputEl.attr('name').replace('shipping_', 'billing_') + ']').val();\n              op.setShippingFieldValue($inputEl, billingVal);\n            }\n\n            $inputEl = null;\n          }\n        });\n      });\n    } else {\n      // @TODO: This can cause a bug with dynamic blocks\n      document.body.classList.add('opt-shipping-input--show');\n    }\n    /*\n     * @brief Bind form inputs keyup to check for \"enter\" btn clicks. If they click enter submit the form.\n     */\n\n\n    $v3Form.find('.opt-input__field').on('keyup', function ($ev) {\n      // Submit on enter, but allow newlines to be made in long text fields.\n      if ($ev.key === 'Enter' && $ev.target.nodeName !== 'TEXTAREA') {\n        $(this.closest('form')).trigger('submit', 'submitBtn');\n      }\n    });\n    /**\n     * When billing fields are updated, update shipping fields if \"different shipping\" checkbox is present but unchecked\n     * This is needed for tax rules that depend on shipping fields\n     */\n\n    $v3Form.find('[name^=billing_]').on('change', function (ev) {\n      let $form = $(ev.target).closest('form'),\n          $differentShippingCheckbox = $form.find('[name=shipping_same_as_billing]'); // If \"different shipping\" checkbox is present and unchecked, update shipping field\n\n      if ($differentShippingCheckbox.length && $differentShippingCheckbox.prop('checked') === false) {\n        let $relatedShippingField = $form.find('[ name=' + ev.target.name.replace('billing_', 'shipping_') + ' ]'),\n            newVal = ev.target.value;\n\n        if ($relatedShippingField.length) {\n          op.setShippingFieldValue($relatedShippingField, newVal);\n        }\n      }\n    });\n    /*\n     * @brief Something got clicked and is trying to submit the from. Figure out what got clicked and trigger a form submission and send who clicked it along.\n     */\n\n    $v3Form.find('.opt-button--submit, .opt-button--paypal, .opt-button--upsell-yes, .opt-button--upsell-no').on('click', function (ev) {\n      var $form = $(this.closest('form')),\n          submitTrigger;\n\n      if (ev.delegateTarget.classList.contains('opt-button--submit')) {\n        submitTrigger = 'submitBtn';\n      } else if (ev.delegateTarget.classList.contains('opt-button--paypal')) {\n        submitTrigger = 'paypalBtn';\n      } else if (ev.delegateTarget.classList.contains('opt-button--upsell-yes')) {\n        submitTrigger = 'upsellYes';\n      } else if (ev.delegateTarget.classList.contains('opt-button--upsell-no')) {\n        submitTrigger = 'upsellNo';\n      } else {\n        $form = null;\n        return false;\n      } // Interesting note while working on ONTRA-17803.\n      // This will not trigger the formSubmitHandler function in ONTRAFORMS.js, which is responsible for preloading\n      // subsequent forms and updating rememberFields.\n      // However, if you press enter to submit the form, then formSubmitHandler does get fired.\n      // I could never figure out why, but ultimately, it wasn't essential to make things work since forms on\n      // landing pages are spec'd to not prefill fields on progressive forms.\n\n\n      $form.trigger('submit', submitTrigger);\n      $form = null;\n    }); // Textarea autogrow\n\n    $v3Form.find('[opt-input-type=\"longtext\"][opt-input-style=\"custom\"][opt-textarea-autogrow=\"true\"]').each(function () {\n      var $textarea = $(this).find('textarea'),\n          lineHeight = parseInt($textarea.css('lineHeight')),\n          paddingTop = parseInt($textarea.css('padding-top')),\n          paddingBottom = parseInt($textarea.css('padding-bottom'));\n      $textarea.on('keyup', function () {\n        var numRows = parseInt($textarea.attr('rows')),\n            minRows = parseInt($textarea.attr('opt-min-rows')),\n            scrollHeight = $textarea[0].scrollHeight,\n            trueHeight = scrollHeight - paddingTop - paddingBottom,\n            rowHeight = numRows * lineHeight,\n            maxRows = 10,\n            newRows,\n            newRowTotal;\n\n        if (trueHeight > rowHeight) {\n          newRows = (trueHeight - rowHeight) / lineHeight;\n          newRowTotal = numRows + newRows;\n\n          if (newRowTotal <= maxRows) {\n            $(this).attr('rows', newRowTotal);\n          } else {\n            $(this).attr('rows', maxRows);\n          }\n        } else if (numRows > minRows) {\n          $(this).attr('rows', minRows);\n          trueHeight = $textarea[0].scrollHeight - paddingTop - paddingBottom;\n          rowHeight = minRows * lineHeight;\n\n          if (trueHeight > rowHeight) {\n            newRows = (trueHeight - rowHeight) / lineHeight;\n            newRowTotal = minRows + newRows;\n            $(this).attr('rows', newRowTotal);\n          }\n        }\n      });\n    });\n    /*\n     * @brief Apply custom classes and inline styles to a materialize drop down field.\n     *        The customization is stored on default <select> markup as an opt- attribute.\n     *        After the materialize dropdowns are initialized this function runs agains all\n     *        of them parsing in the customization and adding the classes and inline style it contains.\n     */\n\n    $v3Form.find('[opt-dropdown-styles]').each(function (index, el) {\n      // StyleSelect defined in opt.common.js\n      op.styleSelect($(this));\n    }); // @TODO: Check this works\n    // Init validation\n\n    $v3Form.validator({\n      errorClass: 'moonray-form-state-error',\n      messageClass: 'moonray-form-error-message moonray-form-state-error',\n      offset: [0, 13],\n      errorInputEvent: 'input',\n      inputEvent: 'blur',\n      formEvent: null,\n      effect: 'opt-v3',\n      grouped: 'true'\n    }); // Sometimes dropdowns will open upwards. This logic will make sure the block that contains the dropdown has a\n    // higher z-index than the row above it to ensure that the dropdown is not covered.\n\n    $v3Form.find('form .opt-input--dropdown ul.dropdown-content').each(function () {\n      var mutationCallback = function (mutationsList) {\n        var styleMutations = mutationsList.filter(function (mutation) {\n          return mutation.type === 'attributes' && mutation.attributeName === 'style';\n        }); // Only run this functionality once, and only if it is a style mutation.\n\n        if (styleMutations.length) {\n          var mutation = styleMutations[0],\n              displayValue = mutation.target.style.getPropertyValue('display'),\n              parentBlock = mutation.target.closest('.opt-row');\n\n          if (displayValue === 'block') {\n            // Menu show\n            // Make the parent block z-index really high so the menus show on top of everything\n            var oldZIndex = parentBlock.style.zIndex;\n\n            if (oldZIndex != 9999) {\n              parentBlock.setAttribute('data-old-zIndex', oldZIndex);\n            }\n\n            parentBlock.style.zIndex = 9999;\n          } else {\n            // Menu hide\n            // Loop over all dropdown lists in block. If one is still open, do not unset z-index\n            var dropdownLists = parentBlock.querySelectorAll('.dropdown-content');\n\n            for (var i = 0, l = dropdownLists.length; i < l; i++) {\n              if (dropdownLists[i].style.getPropertyValue('display') === 'block') {\n                return;\n              }\n            } // Restore parent z-index\n\n\n            parentBlock.style.zIndex = parentBlock.getAttribute('data-old-zIndex');\n            parentBlock.removeAttribute('data-old-zIndex');\n          }\n        }\n      }; // Options for the observer (which mutations to observe)\n\n\n      var config = {\n        attributes: true,\n        childList: false,\n        subtree: false\n      }; // Create an observer instance linked to the callback function\n\n      var observer = new MutationObserver(mutationCallback); // Start observing the target node for configured mutations\n\n      observer.observe(this, config);\n    }); // @TODO: Check this works\n    // Check for recaptcha elements and do an initial recaptcha scaling\n\n    $v3Form.find('.g-recaptcha').each((i, reCap) => {\n      op.rescaleCaptcha(reCap);\n    });\n    $v3Form.addClass('opt-form--initialized');\n  };\n  /*\n   * @brief Moonray form dependancy\n   */\n\n\n  op.readCookie = function (name) {\n    var pattern = new RegExp('(^|;\\\\s*)' + name + '=([^;]*)($|;)');\n    var match = pattern.exec(document.cookie);\n\n    if (match) {\n      let ret; // Try to decode, if it fails it is already decoded so just use that match\n\n      try {\n        ret = decodeURIComponent(match[2]);\n      } catch (err) {\n        ret = match[2];\n      }\n\n      return ret;\n    } else {\n      return null;\n    }\n  };\n  /*\n   * Rescale a recaptcha element to fit its parent element. Because our grid is responsive, and googgle didnt\n   * make recaptcha responsive.\n   */\n\n\n  op.rescaleCaptcha = function (reCap) {\n    if (!reCap) {\n      return false;\n    }\n\n    let width = reCap.parentNode.offsetWidth;\n    let scale;\n\n    if (width < 302 && window.innerWidth > 600) {\n      scale = width / 302;\n    } else {\n      scale = 1.0;\n    }\n\n    reCap.style.transform = 'scale(' + scale + ')';\n    reCap.style.transformOrigin = '0 0';\n  };\n  /*\n   * The page has been resized take action.\n   */\n\n\n  op.resize = function () {\n    // Check for recaptcha elements\n    reCaptchaArray.forEach(reCap => op.rescaleCaptcha(reCap)); // Adujst stickyBlocks\n\n    if (window.stickyBlocks) {\n      // We are in portrait mode\n      if (op.previousWindowHeight > op.previousWindowWidth) {\n        let currWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),\n            currHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0); // The change in window size is small\n        // this is probably the address bar on a mobile device hiding/showing\n\n        if (Math.abs(op.previousWindowHeight - currHeight) < 100 && op.previousWindowWidth == currWidth) {\n          return;\n        }\n      }\n\n      op.previousWindowHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n      op.previousWindowWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n      op.buildStickyBlocks(stickyBlocks);\n    }\n  };\n\n  window.OPCapcha_filled = function () {\n    OPreCaptchaAllowSubmit = true;\n    $('.g-recaptcha').removeClass('moonray-form-state-error');\n  };\n\n  window.OPCapcha_expired = function () {\n    OPreCaptchaAllowSubmit = false;\n  };\n  /*\n   * @brief\n   * @todo Can we get rid of the $clickedSubmit stuff in v3? Moonray form dependancy\n   */\n\n\n  op.serializeFormToObject = function ($form) {\n    var fields = {},\n        $clickedSubmit = $form.find('[data-submit-clicked]');\n    $.each($form.serializeArray(), function (i, field) {\n      fields[field.name] = field.value;\n    }); // Pick up the submit button that was clicked. needed for mostly upsell\n\n    if ($clickedSubmit.length && $clickedSubmit.attr('name')) {\n      fields[$clickedSubmit.attr('name')] = $clickedSubmit.val();\n    }\n\n    return fields;\n  };\n  /*\n  * Super small templating engine\n  * http://mir.aculo.us/2011/03/09/little-helpers-a-tweet-sized-javascript-templating-engine/\n  *\n  * used to display the status messages when contacting the server\n  */\n\n\n  op.t = function (s, d) {\n    for (var p in d) {\n      s = s.replace(new RegExp('{' + p + '}', 'g'), d[p]);\n    }\n\n    return s;\n  };\n\n  op.previousWindowHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n  op.previousWindowWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0); // Bind an op global resize event.\n\n  window.addEventListener('resize', op.debounce(op.resize, 250));\n  /*\n   * @brief Stuff to make form conditions work.\n            Override outcomes, with ones that detect if the input is required and toggle the requiredness\n   */\n\n  if ($.jb) {\n    $.extend($.jb.formConditions.prototype.outcomeActions, {\n      show: function (elem) {\n        var required = elem.attr('data-required');\n\n        if (required == 'true') {\n          elem.attr('required', 'required');\n        }\n\n        elem.parent().show();\n      },\n      hide: function (elem) {\n        var required = elem.attr('data-required');\n\n        if (required == 'true') {\n          elem.removeAttr('required');\n        }\n\n        elem.parent().hide();\n      }\n    });\n  }\n  /*\n   * @brief Make v3 form smart\n   */\n\n\n  $.fn.moonraySmartForm = function (options) {\n    $.extend($.fn.moonraySmartForm, {\n      settings: {\n        debug: IN_DEBUG_MODE\n      }\n    });\n    $documentBody.moonrayUILockerV2();\n    /**\n     * Handles and interesting use case where mozilla reuses a rendered page on history.go( -1 ).\n     * The uiLockerMessage would still be on the page (as though the form was still processing).\n     * So before the window unloads, turn off the uiLocker \"Processing\" dialog.\n     */\n\n    $(window).on('unload', function () {\n      $(document.body).trigger('moonray.uiLockerV2');\n    }); // TOOD: add in debug settings\n    // this refers to the form on the page\n\n    return this.each(function () {\n      var gridController,\n          $this = $(this),\n          $form = $this,\n          // Check if element is present\n      UID = $form.find('[name=\"uid\"]').val(),\n          log_key = $form.find('[name=\"mopbelg\"]').val(),\n          // Used to communicate with the BE for  credit card processing, captcha, coupon codes and upsell forms with ontraforms\n      $iframe = $('<iframe/>'),\n          _log = function (name, data, level) {\n        if (op && op.log) {\n          op.log(log_key, name, data, level);\n        }\n      },\n          _flushDebugLogs = function () {\n        if (op && op.flushDebugLogs) {\n          op.flushDebugLogs();\n        }\n      },\n          _debugLog = function () {\n        _log('cc_verify_fe', {\n          args: arguments\n        }, window.LOG_LEVEL_DEBUG);\n\n        if (op.debug || IN_DEBUG_MODE) {\n          console.log(Array.prototype.slice.call(arguments));\n        }\n      },\n\n      /**\n       * This is an important variable. We set this to false just before we load a new iframe. When it finally\n       * loads, then we set this var to true. It's mostly used to control whether to keep displaying the\n       * \"form is processing\" dialog.\n       * @type {boolean}\n       */\n      iframe_done = false;\n\n      if ($.fn.moonraySmartForm.settings.debug) {\n        // Lets make it easy to see whats going in the form processor\n        $iframe.attr({\n          width: '100%',\n          height: '1000px'\n        });\n      } else {\n        $iframe.hide().attr({\n          width: 0,\n          height: 0\n        });\n      }\n\n      $iframe.attr({\n        frameborder: 0,\n        name: 'postmessage-' + UID\n      }).appendTo(document.body); // These 3 vars are used for swapping the ui locker processing dialog\n\n      const timeout = 180000,\n            incrementer = 1000;\n      let count = 0;\n      let processingStateMessages = [{\n        title: 'Still processing...'\n      }, {\n        title: 'Still working...'\n      }, {\n        title: 'Taking a little longer than expected...'\n      }]; // If the page dumps some custom information on the page, then use that data instead.\n      // multipleData is an array of objects that will be rendered in the processing dialog.\n      // We specify this data right when the form is initialized so that the _processingStateMessages argument\n      // for the uiLockerSwapMessage IIFE can be captured.\n      // TODO: this system only allows for ONE set of custom form processing data per page.\n      // If the user would want to have custom for processing data for each form on the page,\n      // then we would need to come up with a system to organize that.\n\n      if (window.op && window.op.customFormProcessingData && window.op.customFormProcessingData.theme === 'multiple' && window.op.customFormProcessingData.multipleData && window.op.customFormProcessingData.multipleData.length > 0) {\n        processingStateMessages = window.op.customFormProcessingData.multipleData;\n      } // Will iterate through and display the _processingStateMessages\n      // This allows us to have the processing dialog show different content\n\n\n      const uiLockerSwapMessage = function (_processingStateMessages, _$documentBody) {\n        let messageIndex = 0;\n        return function (showMessage) {\n          // Remove current message\n          _$documentBody.trigger('moonray.uiLockerV2');\n\n          if (showMessage === undefined) {\n            showMessage = _processingStateMessages[messageIndex % _processingStateMessages.length];\n\n            if (messageIndex > 3) {\n              // 20 seconds has elapsed\n              showMessage.theme = 'warning';\n            } // Increment the messageIndex\n\n\n            messageIndex++;\n          } // Show new message\n\n\n          _$documentBody.trigger('moonray.uiLockerV2', showMessage);\n        };\n      }(processingStateMessages, $documentBody); // Continually call itself and uiLockerSwapMessage to show different content in the processing dialog\n\n\n      const uiLockerSwapContentChecker = function () {\n        if (iframe_done == false) {\n          count += incrementer;\n\n          if (count % 5000 === 0) {\n            // Every 5 seconds, update the processing message\n            uiLockerSwapMessage();\n          }\n\n          if (count == 40000) {\n            _flushDebugLogs();\n          }\n\n          if (count >= timeout) {\n            // Post the new message\n            uiLockerSwapMessage({\n              title: 'Transaction failed',\n              message: 'Please try again later',\n              closeButton: true,\n              theme: 'error'\n            });\n\n            _debugLog('processing timed out. iframe done is true.');\n\n            iframe_done = true;\n\n            _flushDebugLogs();\n\n            $form.removeAttr('locked');\n            $iframe.css({\n              display: 'none'\n            });\n          } else {\n            setTimeout(uiLockerSwapContentChecker, incrementer);\n          }\n        } else if (iframe_done === true) {\n          _debugLog('iframe done is true in swap content checker');\n        }\n      };\n      /*\n       * Used as our CORS\n       * also handles the feed back of were the request is getting sent\n       *\n       * ? is appended to each url -  makes it easy to work with params\n       */\n\n\n      var changeIframeUrl = function changeIframeUrl(url, params, disableChecker, hash) {\n        iframe_done = false;\n        params = params || {};\n\n        if (url == '#') {\n          $form.removeAttr('locked');\n          $iframe.css({\n            display: 'none'\n          });\n          /*\n           * Doing makes ssl pages unsecure\n           * iframe.removeAttr('src')\n           */\n\n          $iframe[0].contentWindow.location.replace('about:blank');\n        } else {\n          // Track the number of times this dialog pops up\n          if (_submitAttempts[UID] === undefined) {\n            _submitAttempts[UID] = 0;\n          }\n\n          _submitAttempts[UID]++; // Add the random so if we change the url to the same url it will reload\n\n          params.mr_rand = Math.floor(Math.random() * 9999991); // Send the uid of this form so the document.postMessage handler knows what form the response is for\n\n          params.uid = UID;\n          params.submitAttempts = _submitAttempts[UID];\n          var urihash;\n\n          if (hash === undefined) {\n            urihash = document.location.href;\n          } else {\n            urihash = hash;\n            params.parent_url = document.location.href;\n          }\n\n          urihash = encodeURIComponent(urihash);\n          params = $.param(params);\n\n          _debugLog('iframe changing url to ', url + '?' + params);\n\n          $iframe[0].contentWindow.location.replace(url + '?' + params + '#' + urihash);\n\n          $iframe[0] // Use onload instead of .load cause the load function ends up getting called the # of times\n          // the submit button gets called\n          .onload = function () {\n            _debugLog('iframe loaded', url);\n\n            if (hash === undefined) {\n              // Only stop the checker if there's no hash. Otherwise, we rely on external\n              // checks to decide if we're done.\n              _debugLog('setting iframe_done to true when no hash');\n\n              iframe_done = true;\n            }\n          };\n\n          if (!disableChecker) {\n            uiLockerSwapContentChecker();\n          }\n        }\n      },\n\n      /*\n          Called on form submit, needed to verify with the server and or post data to the server to verify everything is allset\n      */\n      PROCESSORS = {\n        cc_verify: function () {\n          if ($form.find('input[name=payment_number]').length == 1) {\n            // They are paying with paypal so we don't need to hit up cc verify.\n            if ($form.find('input[name=paypal]').val() === 'yes') {\n              return true;\n            } // These fields get injected into the form if the credit card is valid.\n\n\n            if ($form.find(':input[name=payer_id], :input[name=transaction_id]').length != 2) {\n              var fields = op.serializeFormToObject($form); // Get the contact / cid out of the action url if any\n              // Add the cid to post fields so we use the same contact id if we have one\n\n              var fAction = $form.attr('action').split('form_processor.php?')[1].split('&'),\n                  i = fAction.length;\n\n              while (i--) {\n                if (fAction[i].match(/cid=/)) {\n                  fields.cid = fAction[i].replace('cid=', ''); // Spoof the lpid for cc verfiy\n\n                  if (window.mr_lp_id == undefined) {\n                    fields.lpid = -1;\n                  } else {\n                    fields.lpid = window.mr_lp_id;\n                  }\n                }\n              }\n\n              var isONTRAform = window.isONTRAform,\n                  ONTRAformID = isONTRAform && isONTRAform.formUID.split('f')[1];\n\n              if (isONTRAform && ONTRAformID) {\n                fields.light_form_id = ONTRAformID;\n              } // Let order form know if they are dynamic pages.\n\n\n              if (op.isDynamicPage) {\n                fields.isDynamicPage = 1;\n              } // Remove any spaces and dashes in cc number\n\n\n              fields.payment_number = fields.payment_number.replace(/[ -]/g, '');\n              changeIframeUrl(CC_VERIFY_DOMAIN, {}, false, stringToHex(des('Un1cOrns', unescape(encodeURIComponent(JSON.stringify(fields))), 1)));\n              return false;\n            }\n\n            return true;\n          } // No payment fields, pass\n\n\n          return true;\n        },\n        // Upsells are getting fancy\n        isUpsellForm: function (ev, submitTrigger) {\n          var isupsell = $form.find('.opt-button--upsell').length === 2,\n              formAction = $form.attr('action'),\n              isONTRAform = window.isONTRAform,\n              ONTRAformID = isONTRAform && isONTRAform.formUID.split('f')[1]; // Check if we could end up with an ontraform popup\n\n          if (isupsell) {\n            /**\n             * Need to parse out the form action this form was submitted with and look\n             * for specific parameters.\n             *\n             * Logic pulled from ONTRAFORMS.js\n             */\n            var fields = op.serializeFormToObject($form),\n                paramString = formAction.split('?')[1],\n                parsedFormActions = {};\n\n            if (paramString && paramString.replace) {\n              paramString.replace(/([^=&]{1,})=([^&]{1,})/g, function (keyValuePair, key, value, index, source) {\n                parsedFormActions[key] = value;\n              });\n            }\n            /**\n             * Cid, light_form_id and _lightResponse are needed by the BE in form_processor.php.\n             *\n             * These properties are not fields in the form, but they are part of the form action.\n             *\n             * So let's make sure these are part of the data we send over to the BE.\n             */\n\n\n            var cid = parsedFormActions.cid,\n                light_form_id = parsedFormActions.light_form_id,\n                lightResponse = parsedFormActions._lightResponse;\n\n            if (cid) {\n              fields.cid = cid;\n            }\n\n            if (light_form_id) {\n              fields.light_form_id = light_form_id;\n            } else if (ONTRAformID) {\n              fields.light_form_id = ONTRAformID;\n            }\n\n            if (lightResponse) {\n              fields._lightResponse = lightResponse;\n            } else {\n              // We possibly have an ONTRAFORM\n              fields._lightResponse = 1;\n            } // Add the submit upsell field to the fields so the BE knows its an upsell\n\n\n            if (submitTrigger) {\n              if (submitTrigger === 'upsellYes') {\n                fields.upsell_form_action_yes = 'yes';\n              } else {\n                fields.upsell_form_action_no = 'no';\n              }\n            }\n\n            changeIframeUrl(formAction.split('?')[0], fields);\n            return false;\n          }\n\n          return true;\n        }\n      }; // Interaction queue classes.\n\n\n      $form.delegate('input:not(:submit), select, textarea', 'focus blur', function (ev) {\n        $(this).toggleClass('moonray-form-state-active'); // Force the order summary to update styles if the number is toggled, changing the quantity triggers the change callback handler in the order summary to fire.\n\n        if (this.classList.contains('ontraport_gridcell_input_number--edit-quantity')) {\n          var os = this.closest('ontraport-order-summary'),\n              qty = os.getAttribute('update-summary-style');\n          os.setAttribute('update-summary-style', +qty + 1);\n        }\n      }); // Need to know what submit button was clicked, this is especially the case for upsell forms.\n\n      $form.delegate('input[type=\"submit\"], input[type=\"image\"]', 'click', function (e) {\n        $(this).attr('data-submit-clicked', true);\n      });\n      /*\n       * Find all of the required inputs and add create a data-required flag\n       * this way conditions can pickup on them\n       *\n       * TODO: make sure this gets set on the shipping select and payment plan radios\n       *      not sure this is needed because, we will never hide these inputs, thus never make them unrequired\n       */\n\n      $form.find('[required]').attr('data-required', 'true');\n      const isUsingOptDateTimePickerInputs = $form.find('.opt-date-time-field__hidden-field.opt-date-field[type=\"hidden\"]').length > 0 ? true : false; // Check for date fields and restore the input type so we can have date placeholders on IOS devices.\n\n      if (!isUsingOptDateTimePickerInputs) {\n        $form.find('input[type=date], input.opt-date-time-field').each(function () {\n          if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream && !this.getAttribute('value')) {\n            // Force date inputs to use the date type on iOS\n            this.type = 'date';\n            this.onblur = null;\n          }\n        });\n      } // Coupon code handler, and event bindings\n      // debouce this because the click event is fired from the user click and triggered in the grid cell controller\n      // this keeps us from hitting the back end twice for the same request.\n\n\n      const _couponEventHandler = op.debounce(function _couponEventHandler(falslycheck) {\n        var couponValue = $form.find('input[name=\"couponCode\"]').val();\n\n        if (couponValue == '' && falslycheck === true) {\n          return;\n        }\n\n        gridController = $form.find('.moonray-from-offer-grid').controller();\n        var offerModel = gridController.offerCopy;\n        setTimeout(function () {\n          _triggerCouponChange(couponValue, offerModel);\n        }, 50);\n      }, 100);\n\n      op._couponEventHandler = _couponEventHandler;\n      $form.delegate('input[name*=\\'payment_plan\\']', 'change', function () {\n        _couponEventHandler(true);\n      });\n      $form.delegate('td.ontraport_gridcell_input_number', 'click', function (ev, el) {\n        _couponEventHandler(true);\n      });\n      $form.delegate('input[name=\"couponCode\"]', 'change', _couponEventHandler);\n      $form.delegate('.coupon-code-submit-btn', 'click', _couponEventHandler); // Capture enter key in the coupon input, so we can prevent it from submitting the form\n\n      $form.delegate('.grid-summary-coupon-input', 'keydown', function (ev) {\n        if (ev.keyCode === 13) {\n          _couponEventHandler();\n\n          return false;\n        }\n      });\n\n      var _triggerCouponChange = function _triggerCouponChange(couponCodeVal, offerModel) {\n        if ($form[0].hasAttribute('locked')) {\n          _debugLog('The form is locked, do not validate coupon.');\n\n          return;\n        }\n\n        var coupError = $form.find('.coupon-error');\n\n        if (coupError.length > 0) {\n          coupError.remove();\n          $form.find('.grid-summary_coupon-input__input').removeClass('grid-summary-coupon-input--error');\n        }\n\n        $form.find('.grid-summary-coupon-input .label').css('paddingBottom', '0');\n\n        if (!couponCodeVal) {\n          return;\n        } // Will need to alter this to pass along the new PAYMENTS-2.1.1 quantity change ... for now i just grabbed it from offer data...\n\n\n        var model = offerModel,\n            args = {\n          coupon_code: couponCodeVal\n        };\n        var product = {};\n        $.each(model.products, function (key, value) {\n          product['product[' + value.id + ']'] = value.quantity;\n          product['price[' + value.id + ']'] = value.price[0].price;\n        });\n        $.extend(args, product);\n        changeIframeUrl(COUPON_PROCESS_DOMAIN + '/v2.4/coupon_validator.php', args, true);\n      };\n      /*\n       * http://stackoverflow.com/questions/729330/jquery-triggersubmit-breaking\n       * since we trigger submit again after the form is submitted, we cant have an element named submit\n       */\n\n\n      $form.find('input[name=submit]').attr('name', 'mr-name-changed-from-submit'); // Also do this on submit regardless of captcha\n\n      $form.submit(function (e, submitTrigger) {\n        // If we're already processing, bail.\n        if ($form[0].hasAttribute('locked')) {\n          e.preventDefault();\n          return false;\n        } // Add the isDynamicPage var to query string\n\n\n        $form[0].action = $form[0].action + `&isDynamicPage=${op.isDynamicPage ? 1 : 0}`; // Make sure we trigger client side validation before doing any server side stuff.\n        // Pass in if the form was submitted by the paypal button. If its a paypal button we bypass the credit card validation.\n\n        var isPayPalBtnSubmit = submitTrigger === 'paypalBtn';\n\n        if (isPayPalBtnSubmit) {\n          $form.find('[name=\"paypal_toggle\"]').val('yes');\n          $form.find('[name=\"paypal\"]').val('yes');\n        } // Frontend input validation\n\n\n        if ($form.data('validator').checkValidity(false, false, isPayPalBtnSubmit) === false) {\n          return false;\n        } // Order bumps\n\n\n        op.getOrderBumps($form); // If this is a preview from don't need to do any thing but show a form processing dialog preview.\n\n        if (this.getAttribute('action') === '[system_form_processor]') {\n          $documentBody.trigger('moonray.uiLockerV2', {\n            title: 'Processing...',\n            message: 'You can\\'t submit a form on a preview page. This dialog shows an example of what your visitors will see when submitting forms on your page. You can close it by clicking the X icon in the upper right corner.',\n            closeButton: true,\n            theme: 'error'\n          });\n          return false;\n        }\n\n        if ($form.find('.g-recaptcha').length >= 1) {\n          var $g = $('.g-recaptcha');\n          $g.removeClass('opt-recaptcha--error');\n\n          if (!OPreCaptchaAllowSubmit) {\n            $g.addClass('opt-recaptcha--error');\n            return false;\n          }\n\n          $g = null;\n        } // Find our hidden spam blocker field, creating it if necesssary.\n\n\n        var $sb = $form.find('#mr_opsblck');\n\n        if (!$sb.length) {\n          $sb = $('<input>').attr({\n            type: 'hidden',\n            id: 'mr_opsblck',\n            name: 'mr_opsblck'\n          }).appendTo($form);\n        }\n\n        if ($sb) {\n          // Encrypt the form's UID and current timestamp and pass as a hidden field.\n          var uid = $form.find('[name=\"uid\"]').val(); // Create an encryption key based on the uid.\n\n          var ekey = [0, 0, 0, 0, 0, 0, 0, 0];\n          var euid = 'af8cde800fbc41e989e668f91be8ecb0' + uid;\n          var uidlen = euid.length;\n\n          for (var i = 0; i < uidlen; ++i) {\n            ekey[i % 8] = ekey[i % 8] ^ euid.charCodeAt(i);\n          }\n\n          var key = '';\n\n          for (i = 0; i < ekey.length; ++i) {\n            key += String.fromCharCode(ekey[i] & 0x7f);\n          }\n\n          var opsblck = stringToHex(des(key, uid + ':' + Date.now() + ':', 1));\n          $sb.val(opsblck);\n        }\n\n        $sb = null;\n        $form.attr('locked', ''); // If there's any customFormProcessingData, then kickoff the cycle of swapping the content out\n\n        if (window.op && window.op.customFormProcessingData && window.op.customFormProcessingData.theme === 'multiple' && window.op.customFormProcessingData.multipleData && window.op.customFormProcessingData.multipleData.length > 0) {\n          uiLockerSwapMessage();\n          uiLockerSwapContentChecker();\n        } else {\n          $documentBody.trigger('moonray.uiLockerV2', {\n            title: 'Processing...'\n          });\n        }\n        /*\n         * Tracking fields\n         */\n\n\n        if (typeof window._mri != undefined) {\n          var hidden = ['contact_id', 'afft_', 'aff_', 'ref_', 'own_', 'sess_', 'utm_source', 'utm_medium', 'utm_term', 'utm_content', 'utm_campaign', 'referral_page', 'oprid', '_op_gclid', '_fbc', '_fbp'];\n\n          for (var i = 0, _cookie; hidden.length > i; i++) {\n            _cookie = op.readCookie(hidden[i]);\n\n            if (_cookie != undefined) {\n              $form.find('[name=\"' + hidden[i] + '\"]').val(_cookie);\n            }\n          }\n\n          if (window.ga) {\n            window.ga(function () {\n              var trackers = window.ga.getAll();\n              trackers.forEach(function (tracker) {\n                $form.find('[name=_op_gcid]').val(tracker.get('clientId'));\n              });\n            });\n          }\n        }\n        /*\n         * Check and process captcha, payments and upsells that have a ontraform popup\n         */\n\n\n        if (PROCESSORS.cc_verify(e) === false || PROCESSORS.isUpsellForm(e, submitTrigger) === false) {\n          e.preventDefault();\n          return;\n        }\n      }); // End $form.submit\n\n      /*\n       * Handle running in an iframe\n       */\n\n      if (top !== self) {\n        var handler = function (e) {\n          try {\n            // E.data could not be valid json, data could be from another script\n            var data = JSON.parse(e.data);\n            $.each(data, function (key, value) {\n              if (!moonrayJS.readCookie(key)) {\n                var exdate = new Date();\n                exdate.setDate(exdate.getDate() + 365);\n                document.cookie = key + '=' + escape(value) + '; expires=' + exdate.toUTCString() + '; path=/';\n              }\n            });\n          } catch (e) {}\n        };\n\n        if (window.addEventListener) {\n          window.addEventListener('message', handler, false);\n        } else {\n          window.attachEvent('onmessage', handler);\n        } // When we submit the form we change the parent page url\n\n\n        var formTargetAttr = $form.attr('target'),\n            possibleOpfTarget = formTargetAttr && (formTargetAttr.indexOf('opfFormTrigger-') !== -1 || formTargetAttr.indexOf('conditionalRedirectTrigger-') !== -1);\n\n        if (!possibleOpfTarget) {\n          $form.attr('target', '_top'); // Ontraforms manage their dim, no need to send\n\n          var targetWindow = parent.postMessage ? parent : parent.document.postMessage ? parent.document : undefined,\n              sendDim = function () {\n            var message = {\n              uid: UID,\n              width: $documentBody.outerWidth(true),\n              height: $documentBody.outerHeight(true)\n            };\n            targetWindow.postMessage(JSON.stringify(message), '*');\n          }; // Since we can delegate the load event on the captach image\n          // Set this in a loop, this way the height will always be calculated\n          // This also catches forms conditions that are slow loading, sometimes the for gets \"chopped\" because of the conditions\n\n\n          sendDim();\n          setInterval(sendDim, 1000); // Trigger on event, used for formConditions\n\n          $form.delegate(':input', 'change', function () {\n            sendDim();\n          });\n        }\n      }\n      /*\n       * Need to check captcha, validate that\n       * then check for sales\n       */\n\n\n      XD.receiveMessage(function (message) {\n        _debugLog('received message ', message);\n        /*\n         * If message data == 'false' string is captcha, true\n         *\n         * if message.data has property result_code\n         *\n         */\n\n\n        var data;\n\n        if (typeof message.data === 'object') {\n          // ONTRAforms passes around objects, not strings.\n\n          /*\n               But now upsells are fancy, so we need to do so something with them\n          */\n          data = message.data;\n\n          if (data.type == 'formProcessorMessage') {\n            /*\n                This forwards the user on to the next page, when one of the yes / no / timeout pages is pop and ontraform\n                but the clicked action / button is not and ontraform\n            */\n            // This response only occurs for upsell blocks on ontraforms\n            var isONTRAformParent = typeof __OPF !== 'undefined';\n\n            if (data.data.type == 'script') {\n              _debugLog('script type', data.data.message);\n              /*\n                  Depending on the order in which the user got to the form we need to detect if ontraforms.js\n                  has been loaded on the page. If its currently there, pop the form open, otherwise fetch it from\n                  the server and open the form.\n              */\n\n\n              var scriptAttrs = JSON.parse(data.data.message),\n                  _opfOpen = function () {\n                // Clean up the original form processing message\n                $documentBody.trigger('moonray.uiLockerV2');\n\n                __OPF.open(scriptAttrs.uid, true);\n              };\n\n              if (isONTRAformParent) {\n                _opfOpen();\n              } else {\n                $.getScript(scriptAttrs.src, _opfOpen);\n              }\n              /*\n                  Disable all of the submit buttons on the original upsell form, prevents the user from being\n                  able to \"submit\" / cycle through the chain\n              */\n\n\n              $form.css('opacity', '.3') // See the notes about disabled in form.default.css\n              .attr('disabled', true);\n            } else if (data.data.type == 'route') {\n              // Assume is a redirect\n              _debugLog('Sending the user to this URL: ', data.data.message); // Quick note, IE 6 and 7 wont have the reffer header set, not worrying about that since T-Rex is younger than they are\n\n\n              window.location = data.data.message;\n            } else if (data.data.type === 'conditionalRedirect') {\n              if (data.data.redirectType === 'block_link') {\n                $documentBody.trigger('moonray.uiLockerV2');\n                $(data.data.url).scrollToBlock(); // For everything else besides ONTRAform. So: custom URL, Landing Page, Hosted File, or Tracked Link\n              } else if (data.data.redirectType !== 'ontraform') {\n                // Open in new window if flag set or if type is hosted file\n                if (data.data.newWindow || data.data.redirectType === 'hosted_file') {\n                  window.open(data.data.url, '_blank');\n                  $documentBody.trigger('moonray.uiLockerV2');\n                } else {\n                  window.location = data.data.url;\n                }\n              }\n            } // Change / blank the iframe URL otherwise when the user clicks back they will get stuck in a redirect loop\n\n\n            changeIframeUrl('#');\n          }\n\n          return;\n        }\n\n        data = eval('(' + unescape(message.data) + ')'); // Move handling of Coupon into the same processing domain\n\n        if (data.type !== undefined && data.type == 'coupon-validation' && data.uid == UID) {\n          var coupError = $form.find('.coupon-error');\n\n          if (coupError.length > 0) {\n            coupError.remove();\n          }\n\n          var $couponRow = $form.find('.grid-summary-coupon-input'),\n              $couponInput = $form.find('input[name=\\'couponCode\\']');\n          $couponRow.find('.label').css('paddingBottom', '0');\n          gridController = $form.find('.moonray-from-offer-grid').controller();\n          gridController.applyCoupon(data);\n\n          if (data.result_code != 1) {\n            var couponVal = $couponInput.val(); // Only show an error if there is a value in the coupon input\n\n            if (couponVal != '') {\n              $couponRow.find('.label').css('paddingBottom', '1em');\n              var errorDom = $(op.t('<div class=\"coupon-error grid-summary-coupon--error\"><span>{message}</span></div>', data));\n              $form.find('.grid-summary_coupon-input__input').addClass('grid-summary-coupon-input--error').parent().after(errorDom);\n            }\n          }\n\n          return;\n        }\n        /**\n         * We also receive internal messages from ONTRAforms.js. This message is received when ONTRAforms is done\n         * loading its forms.\n         *\n         * We were encountering race conditions with progressive form chains where the initial form processing\n         * took about 5 seconds to load, which is the interval for swapping messages in the form processing\n         * dialog. The subsequent form would load, but it would be covered by the form processing dialog and\n         * the user could not interact with the form to proceed.\n         *\n         * The form processing dialog was in the middle of swapping messages when the subsequent form was\n         * loading. This would cause the message swapping to start again and since the form already loaded,\n         * the swapping never ended.\n         *\n         * So explicitly set iframe_done to true to avoid this condition.\n         */\n\n\n        if (data.type !== undefined && data.type === 'internalMessage') {\n          _debugLog('received message from ontraforms');\n\n          if (data.data && data.data.fin === true) {\n            iframe_done = true;\n          }\n        }\n\n        $('<input type=\"hidden\">').attr({\n          name: 'submitPath',\n          value: '1'\n        }).appendTo($form);\n\n        if (data === false || data === true) {\n          changeIframeUrl('#');\n\n          _debugLog('processing captcha');\n\n          $documentBody.trigger('moonray.uiLockerV2');\n\n          if (data === false) {\n            Recaptcha.reload();\n          } else {\n            $('<input type=\"hidden\">').attr({\n              name: '_capb',\n              value: '1'\n            }).appendTo($form);\n            /*\n                                This works great when there isn't a grid on the same form, it just by passes cc_verify check\n                                leaving it here so you / me don't re introduce that bug\n                                //$form[0].submit();\n            */\n\n            $form.find(':input[name=submitPath]').attr({\n              value: 2\n            });\n            $form.trigger('submit');\n          }\n          /*\n              Non captcha responses have a result code\n              also we only want to fire this event for this form\n              document.postmessage handlers fire every time a message is fired, we only want to handle this response if the\n              data.uid is the same as this forms\n              NOTE: XD is a global variable defined in the \"postmessage.js\" script. It will only be included if form scripts are included\n          */\n\n        } else if (data.result_code != undefined && data.uid == UID) {\n          // Data.result_code = 2\n          if (data.result_code == 1) {\n            changeIframeUrl('#');\n\n            _debugLog('setting iframe_done to true after result_code 1');\n\n            iframe_done = true;\n\n            _debugLog('processing credit card', 'success');\n\n            if (data.cid) {\n              var $cid_input = $form.find(':input[name=cid]');\n\n              if ($cid_input.length == 0) {\n                $form.append(op.t('<input type=\"hidden\" name=\"cid\" value=\"{cid}\">', data));\n              } else {\n                $cid_input.val(data.cid);\n              }\n            }\n\n            $form.append(op.t('<input type=\"hidden\" name=\"payer_id\" value=\"{payer_id}\"><input type=\"hidden\" name=\"transaction_id\" value=\"{transaction_id}\">', data));\n            var formAction = $form.attr('action'),\n                cidRegex = /(cid=[0-9]*)/g,\n                cidParam = 'cid=' + data.cid,\n                newFormAction;\n\n            if (cidRegex.test(formAction)) {\n              newFormAction = formAction.replace(cidRegex, function () {\n                // Splice in the CID into the form action\n                return cidParam;\n              });\n            } else {\n              newFormAction = formAction + '&' + cidParam;\n            }\n\n            $form.attr('action', newFormAction);\n            $form.find(':input[name=submitPath]').attr({\n              value: 3\n            });\n            $form[0].submit();\n          } else if (data.result_code == CC_VERIFY_POST) {// This is sent by the first cc_verify call. We continue and wait for the\n            // response of the second one.\n          } else if (data.result_code == CC_VERIFY_SHOW_IFRAME) {\n            _debugLog('result_code is cc verify show iframe'); // Hide the locker, show the iframe and center it over our window.\n\n\n            $documentBody.trigger('moonray.uiLockerV2');\n            iframe_done = true;\n            $iframe.css({\n              display: 'block',\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: document.documentElement.scrollWidth,\n              height: document.documentElement.scrollHeight,\n              'z-index': 999999\n            });\n          } else if (data.result_code == CC_VERIFY_HIDE_IFRAME) {\n            // Hide the iframe and retrigger the locker.\n            $iframe.css({\n              display: 'none'\n            });\n            iframe_done = false;\n            $documentBody.trigger('moonray.uiLockerV2', {\n              title: 'Processing...'\n            });\n          } else if (data.result_code == CC_VERIFY_GET_CC_DATA) {\n            $iframe[0].contentWindow.postMessage(op.serializeFormToObject($form), CC_VERIFY_DOMAIN);\n          } else if ($form.hasClass('opf-ignore-form')) {\n            /*\n            * @TODO: Come up with a better fix for this, so that we don't have to require customers\n            * to add this class. ISSUE: When creating an ONTRApage, if you add a smartform block with\n            * an ONTRAform pop up as the thank you page, then add a click to pop ONTRAform in a custom HTML\n            * block, and THEN add just a regular HTML form to the page (not associated with ontraport),\n            * and make sure the HTML form is the first form on the page, the page gets covered by the\n            * uiLockerV2 overlay and infinitely loads opf.js. For some reason the regular HTML form is\n            * automatically submitted, and it falls into the else statement below.\n            */\n          } else {\n            changeIframeUrl('#');\n            iframe_done = true;\n\n            _debugLog('processing credit card', 'error'); // Show error message\n\n\n            $documentBody.trigger('moonray.uiLockerV2');\n            const title = data.result_code == window.ACCOUNT_SIGNUP_ERROR ? 'Sign up error' : 'Transaction failed'; // Show the message to the user\n\n            $documentBody.trigger('moonray.uiLockerV2', {\n              title: title,\n              message: data.error || data.message,\n              closeButton: true,\n              theme: 'error'\n            });\n          }\n        }\n      }, FORM_PROCESS_DOMAIN);\n    });\n  };\n})(jQuery, window);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9vcHQubWF0ZXJpYWxpemUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9vcHQubWF0ZXJpYWxpemUuanM/Y2FiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IE9wTGF6eUxvYWQgfSBmcm9tICcuL29wdC5sYXp5bG9hZC50cycgO1xuaW1wb3J0IHtcbiAgICBvcENvdW50RG93blRpbWVyLFxuICAgIG9wRHluYW1pY0NvbnRlbnQsXG4gICAgb3BGYWNlYm9va0NvbW1lbnRzLFxuICAgIG9wRm9udEF3ZXNvbWVJY29ucyxcbiAgICBvcE9udHJhRm9ybXMsXG4gICAgb3BPcmRlclN1bW1hcnksXG4gICAgb3BQYXltZW50SW5mbyxcbiAgICBvcFJlY2FwdGNoYVxufSBmcm9tICcuL29wdC5vcHRpb25hbFNjcmlwdHMudHMnIDtcblxuLy8gU0xJREVSIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qXG4gKiBAYnJpZWYgT3ZlcmxvYWRpbmcgdGhlIG1hdGVyaWFsaXplIHNsaWRlciBiZWNhdXNlIHdlIGRvbid0IHVzZSBpbWFnZXMgaW4gc2xpZGVyLCB3ZSByZXBsYWNlZCB0aGVtIHdpdGhcbiAqICAgICAgICBhbiBvcHQtdHlwZT0nYmFja2dyb3VuZC12MycgZWxlbWVudFxuICovXG4oIGZ1bmN0aW9uKCAkICkge1xuXG4gICAgY29uc3QgbWV0aG9kcyA9IHtcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQwMCxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiA1MDAsXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IDYwMDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gb3B0aW9ucyBoYXZlIGJlZW4gc3BlY2lmaWVkIGFuZCB3ZSBoYXZlIHN0b3JlZCBvcHRpb25zIGluIHRoaXMuaW5pdE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB1c2UgdGhlIHN0b3JlZCBvcHRpb25zXG4gICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zID09PSB1bmRlZmluZWQgJiYgdGhpcy5pbml0T3B0aW9ucyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy5pbml0T3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5oZWlnaHQgPT09ICdmdWxsc2NyZWVuJyApIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oZWlnaHQgPSAkKCB3aW5kb3cgKS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoIGRlZmF1bHRzLCBvcHRpb25zICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTYXZlIGluaXRPcHRpb25zLCBzbyB0aGF0IGl0IGNhbiBiZSByZXVzZWQgbGF0ZXIsIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdE9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggc2xpZGVyLCB3ZSB3YW50IHRvIGtlZXAgdHJhY2sgb2ZcbiAgICAgICAgICAgICAgICAvLyBXaGljaCBzbGlkZSBpcyBhY3RpdmUgYW5kIGl0cyBhc3NvY2lhdGVkIGNvbnRlbnRcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKCB0aGlzICksXG4gICAgICAgICAgICAgICAgICAgICRzbGlkZXIgPSAkdGhpcy5maW5kKCAndWwuc2xpZGVzJyApLmZpcnN0KCksXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gc3VwcG9ydCB0aGUgZmFjdCB0aGF0IHNvbWUgb2YgdGhlIHNsaWRlcyBoYXZlIHRoZWlyIHZpc2liaWxpdHkgdHVybmVkIG9mZiBpbiB0aGUgZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICRzbGlkZXMgPSAkc2xpZGVyLmZpbmQoICc+IGxpOnZpc2libGUnICksXG4gICAgICAgICAgICAgICAgICAgICRhY3RpdmVfaW5kZXggPSAkc2xpZGVzLmZpbHRlciggJy5hY3RpdmUnICkuaW5kZXgoKSxcbiAgICAgICAgICAgICAgICAgICAgJGFycm93TGVmdCA9ICR0aGlzLmZpbmQoICcuc2xpZGVyX19hcnJvdy0tbGVmdCcgKSxcbiAgICAgICAgICAgICAgICAgICAgJGFycm93UmlnaHQgPSAkdGhpcy5maW5kKCAnLnNsaWRlcl9fYXJyb3ctLXJpZ2h0JyApLFxuICAgICAgICAgICAgICAgICAgICB0aGVtZUNsYXNzZXMgPSBbICdwcmltYXJ5LWNvbG9yLXRleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbXBsZW1lbnRhcnktY29sb3ItdGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGFyay1jb2xvci10ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaWdodC1jb2xvci10ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aGl0ZS1jb2xvci10ZXh0JyBdLFxuICAgICAgICAgICAgICAgICAgICB0aGVtZUJhY2tncm91bmRDbGFzc2VzID0gdGhlbWVDbGFzc2VzLm1hcCggZnVuY3Rpb24oIGVsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLnJlcGxhY2UoICctdGV4dCcsICctYmFja2dyb3VuZCcgKTtcbiAgICAgICAgICAgICAgICAgICAgfSApLFxuICAgICAgICAgICAgICAgICAgICB0aGVtZUhvdmVyQ2xhc3NlcyA9IHRoZW1lQ2xhc3Nlcy5tYXAoIGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbCArICctLWhvdmVyJztcbiAgICAgICAgICAgICAgICAgICAgfSApLFxuICAgICAgICAgICAgICAgICAgICAkYWN0aXZlLCAkaW5kaWNhdG9ycywgJGludGVydmFsLCBhcnJvd0NsaWNrO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAkYWN0aXZlX2luZGV4ICE9IC0xICkge1xuICAgICAgICAgICAgICAgICAgICAkYWN0aXZlID0gJHNsaWRlcy5lcSggJGFjdGl2ZV9pbmRleCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRyYW5zaXRpb25zIHRoZSBjYXB0aW9uIGRlcGVuZGluZyBvbiBhbGlnbm1lbnRcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYXB0aW9uVHJhbnNpdGlvbiggJGFjdGl2ZSwgZHVyYXRpb24gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25TdGFydCA9ICRhY3RpdmUuYXR0ciggJ3NsaWRlQW5pbWF0aW9uU3RhcnRQb3NpdGlvbicgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICRjYXB0aW9uID0gJGFjdGl2ZS5maW5kKCAnLmNhcHRpb24nICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0cmFuc2l0aW9uU3RhcnQgPT09ICd0b3AnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGNhcHRpb24udmVsb2NpdHkoIHsgb3BhY2l0eTogMCwgdHJhbnNsYXRlWTogLTEwMCB9LCB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgcXVldWU6IGZhbHNlIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdHJhbnNpdGlvblN0YXJ0ID09PSAncmlnaHQnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGNhcHRpb24udmVsb2NpdHkoIHsgb3BhY2l0eTogMCwgdHJhbnNsYXRlWDogMTAwIH0sIHsgZHVyYXRpb246IGR1cmF0aW9uLCBxdWV1ZTogZmFsc2UgfSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0cmFuc2l0aW9uU3RhcnQgPT09ICdib3R0b20nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGNhcHRpb24udmVsb2NpdHkoIHsgb3BhY2l0eTogMCwgdHJhbnNsYXRlWTogMTAwIH0sIHsgZHVyYXRpb246IGR1cmF0aW9uLCBxdWV1ZTogZmFsc2UgfSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0cmFuc2l0aW9uU3RhcnQgPT09ICdsZWZ0JyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRjYXB0aW9uLnZlbG9jaXR5KCB7IG9wYWNpdHk6IDAsIHRyYW5zbGF0ZVg6IC0xMDAgfSwgeyBkdXJhdGlvbjogZHVyYXRpb24sIHF1ZXVlOiBmYWxzZSB9ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkY2FwdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHNvbWUgc2xpZGVzIGNhbiBiZSBoaWRkZW4gd2UgbmVlZCB0byBzZWFyY2ggb25seSB0aGUgdmlzaWJsZSBzbGlkZXMgdG8gZ2V0IGluZGV4XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QWN0aXZlSW5kZXgoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgJHNsaWRlcy5maWx0ZXIoICc6dmlzaWJsZScgKS5lYWNoKCBmdW5jdGlvbiggaW5kZXgsIGVsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbC5jbGFzc0xpc3QuY29udGFpbnMoICdhY3RpdmUnICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIGFjdGl2ZUluZGV4ICE9PSB1bmRlZmluZWQgKSA/IGFjdGl2ZUluZGV4IDogLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHRyYW5zaXRpb24gdGhlIHNsaWRlIHRvIGFueSBpbmRleCBvZiB0aGUgbmV4dCBzbGlkZVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1vdmVUb1NsaWRlKCBpbmRleCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXcmFwIGFyb3VuZCBpbmRpY2VzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIGluZGV4ID49ICRzbGlkZXMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBpbmRleCA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9ICRzbGlkZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICRhY3RpdmVfaW5kZXggPSBnZXRBY3RpdmVJbmRleCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgZG8gaWYgaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoICRhY3RpdmVfaW5kZXggIT0gaW5kZXggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkYWN0aXZlID0gJHNsaWRlcy5lcSggJGFjdGl2ZV9pbmRleCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2xpZGVzLnJlbW92ZUNsYXNzKCAnYWN0aXZlJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGFjdGl2ZS52ZWxvY2l0eSggeyBvcGFjaXR5OiAwIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzbGlkZXMubm90KCAnLmFjdGl2ZScgKS52ZWxvY2l0eSggeyBvcGFjaXR5OiAwLCB0cmFuc2xhdGVYOiAwLCB0cmFuc2xhdGVZOiAwIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXB0aW9uVHJhbnNpdGlvbiggJGFjdGl2ZSwgb3B0aW9ucy50cmFuc2l0aW9uICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBpbmRpY2F0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMuaW5kaWNhdG9ycyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5kaWNhdG9ycy5yZW1vdmVDbGFzcyggJ2FjdGl2ZScgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgJHNsaWRlcy5lcSggaW5kZXggKS52ZWxvY2l0eSggeyBvcGFjaXR5OiAxIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzbGlkZXMuZXEoIGluZGV4ICkuZmluZCggJy5jYXB0aW9uJyApLnZlbG9jaXR5KCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHsgZHVyYXRpb246IG9wdGlvbnMudHJhbnNpdGlvbiwgZGVsYXk6IG9wdGlvbnMudHJhbnNpdGlvbiwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCcgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNsaWRlcy5lcSggaW5kZXggKS5hZGRDbGFzcyggJ2FjdGl2ZScgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGluZGljYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy5pbmRpY2F0b3JzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbmRpY2F0b3JzLmVxKCBpbmRleCApLmFkZENsYXNzKCAnYWN0aXZlJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBAYnJpZWYgUmVzZXQgdGhlIGludGVydmFsISBUaGlzIGhhcHBlbnMgd2hlbiB0aGUgc2xpZGUgc2hvdyBzdGFydHMgYW5kIHdoZW4gZXZlciBhIHVzZXIgaW5pdGlhdGVzIGFuIGV2ZW50IHRoYXQgbG9hZHMgYSBuZXcgc2xpZGUgYmVmb3JlIHRoZSBwcmV2aW91cyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAqICAgICAgICB3YXMgdXAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzZXRJbnRlcnZhbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy5pbnRlcnZhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKCAkaW50ZXJ2YWwgKTtcbiAgICAgICAgICAgICAgICAgICAgJGludGVydmFsID0gc2V0SW50ZXJ2YWwoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGFjdGl2ZV9pbmRleCA9IGdldEFjdGl2ZUluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICRzbGlkZXMubGVuZ3RoID09ICRhY3RpdmVfaW5kZXggKyAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhY3RpdmVfaW5kZXggPSAwOyAvLyBMb29wIHRvIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhY3RpdmVfaW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUb1NsaWRlKCAkYWN0aXZlX2luZGV4ICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMudHJhbnNpdGlvbiArIG9wdGlvbnMuaW50ZXJ2YWwgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIEBicmllZiBEZXRlY3QgaWYgYSBzdHJpbmcgaXMgYSBoZXggY29sb3JcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc0hleENvbG9yKCBjb2xvclN0cmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggY29sb3JTdHJpbmcuaW5kZXhPZiggJyMnICkgPT09IDAgJiYgY29sb3JTdHJpbmcubGVuZ3RoID09PSA3ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IGhlaWdodCBvZiBzbGlkZXJcbiAgICAgICAgICAgICAgICAvLyBJZiBmdWxsc2NyZWVuLCBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgaWYgKCAhJHRoaXMuaGFzQ2xhc3MoICdmdWxsc2NyZWVuJyApICkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5oZWlnaHQoIG9wdGlvbnMuaGVpZ2h0ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBpZiBhbnkgb2YgdGhlIHNsaWRlcyBoYXMgYSB2aWRlbyBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgdmFyIGhhc1ZpZGVvQmFja2dyb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgcG9zaXRpb25zIG9mIGNhcHRpb25zXG4gICAgICAgICAgICAgICAgJHNsaWRlcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwdGlvblRyYW5zaXRpb24oICQoIHRoaXMgKSwgMCApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMucXVlcnlTZWxlY3RvciggJy52aWRlby1iYWNrZ3JvdW5kLXdyYXBwZXInICkgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNWaWRlb0JhY2tncm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgLy8gRHluYW1pY2FsbHkgYWRkIGluZGljYXRvcnNcbiAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMuaW5kaWNhdG9ycyApIHtcblxuICAgICAgICAgICAgICAgICAgICAkaW5kaWNhdG9ycyA9ICQoICc8dWwgY2xhc3M9XCJpbmRpY2F0b3JzXCI+PC91bD4nICk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93SWQgPSAkdGhpcy5jbG9zZXN0KCAnLm9wdC1yb3cnICkuYXR0ciggJ2lkJyApLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0SWQgPSAkdGhpcy5hdHRyKCAnb3B0LWlkJyApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgaW5kaWNhdG9yIHNlbGVjdGVkIGNvbG9yIHRvIHRoZSBwYWdlIHByaW1hcnkgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCggJy5pbmRpY2F0b3Itc2VsZWN0ZWQtc3R5bGVzJyApLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFvcHRpb25zLmluZGljYXRvckNvbG9yU2VsZWN0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmluZGljYXRvckNvbG9yU2VsZWN0ZWQgPSAncHJpbWFyeS1jb2xvci10ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNIZXhDb2xvciggb3B0aW9ucy5pbmRpY2F0b3JDb2xvclNlbGVjdGVkICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IG9wdGlvbnMuaW5kaWNhdG9yQ29sb3JTZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsaXR0bGUgdHJpY2t5LCB0byB3cml0ZSBhICdzZWxlY3RlZCcgc3R5bGUgdG8gb3ZlcmxvYWQgbWF0ZXJpYWxpemVzIGRlZmF1bHQgaW5kaWNhdG9yIGNvbG9yIHdlIG5lZWQgYSB0aGVtZSBiZyBjb2xvciB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9uY2Ugd2UgaGF2ZSB0aGUgY29sb3Igd2UgY2FuIGJ1aWxkIGEgc3R5bGUgdGhlbWUgdGhlICdzZWxlY3RlZCcgaW5kaWNhdG9yLiBXZSBnZXQgdGhlIGNvbG9yIGJ5IGNyZWF0aW5nIGEgdGVtcCBkaXYgYXBwZW5kaW5pbmcgaXQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkb20gZ2V0dGluZyBpdHMgY29sb3IgdmFsdWUgdGhlbiByZW1vdmluZyBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkY29sb3JEdW1teSA9ICQoICc8ZGl2IGNsYXNzPVwidGhlbWUtY29sb3ItZHVtbXkgJyArIG9wdGlvbnMuaW5kaWNhdG9yQ29sb3JTZWxlY3RlZCArICdcIiA+PC9kaXY+JyApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCAnYm9keScgKS5hcHBlbmQoICRjb2xvckR1bW15ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGdldENvbXB1dGVkU3R5bGUoICRjb2xvckR1bW15WyAwIF0gKS5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICRjb2xvckR1bW15LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRpbmRpY2F0b3JzLnByZXBlbmQoICQoICc8c3R5bGUgY2xhc3M9XCJpbmRpY2F0b3Itc2VsZWN0ZWQtc3R5bGVzXCI+PC9zdHlsZT4nICkudGV4dCggJyMnICsgcm93SWQgKyAnIFtvcHQtaWQ9XCInICsgb3B0SWQgKyAnXCJdIC5pbmRpY2F0b3ItaXRlbS5hY3RpdmUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAnICsgY29sb3IgKyAnICFpbXBvcnRhbnQgfScgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICRzbGlkZXMuZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRpbmRpY2F0b3IgPSAkKCAnPGxpIGNsYXNzPVwiaW5kaWNhdG9yLWl0ZW1cIj48L2xpPicgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBpbmRpY2F0b3IgY29sb3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLmluZGljYXRvckNvbG9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNIZXhDb2xvciggb3B0aW9ucy5pbmRpY2F0b3JDb2xvciApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5kaWNhdG9yLmF0dHIoICdzdHlsZScsICdiYWNrZ3JvdW5kLWNvbG9yOicgKyBvcHRpb25zLmluZGljYXRvckNvbG9yICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGluZGljYXRvci5yZW1vdmVDbGFzcyggdGhlbWVCYWNrZ3JvdW5kQ2xhc3Nlcy5qb2luKCkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGluZGljYXRvci5hZGRDbGFzcyggb3B0aW9ucy5pbmRpY2F0b3JDb2xvciArICctYmFja2dyb3VuZCcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdGhlIHRoZW1lIGxpZ2h0IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGluZGljYXRvci5hZGRDbGFzcyggJ2xpZ2h0LWNvbG9yLWJhY2tncm91bmQnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjbGlja3Mgb24gaW5kaWNhdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgJGluZGljYXRvci5jbGljayggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJfaW5kZXggPSAkKCB0aGlzICkuaW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlVG9TbGlkZSggY3Vycl9pbmRleCAtIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0SW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRpbmRpY2F0b3JzLmFwcGVuZCggJGluZGljYXRvciApO1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXBwZW5kKCAkaW5kaWNhdG9ycyApO1xuICAgICAgICAgICAgICAgICAgICAkaW5kaWNhdG9ycyA9ICR0aGlzLmZpbmQoICd1bC5pbmRpY2F0b3JzJyApLmZpbmQoICdsaS5pbmRpY2F0b3ItaXRlbScgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMuYXJyb3dzICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2tzIG9uIHNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAkYXJyb3dMZWZ0LmNzcyggJ2Rpc3BsYXknLCAnJyApO1xuICAgICAgICAgICAgICAgICAgICAkYXJyb3dSaWdodC5jc3MoICdkaXNwbGF5JywgJycgKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyb3dDbGljayA9IGZ1bmN0aW9uKCBnZXRBY3RpdmVJbmRleCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZXYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJfaW5kZXggPSBnZXRBY3RpdmVJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXYuZGVsZWdhdGVUYXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCAnc2xpZGVyX19hcnJvdy0tcmlnaHQnICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUb1NsaWRlKCBjdXJyX2luZGV4ICsgMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUb1NsaWRlKCBjdXJyX2luZGV4ICsgLTEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSggZ2V0QWN0aXZlSW5kZXggKTtcbiAgICAgICAgICAgICAgICAgICAgJGFycm93TGVmdC5vbiggJ2NsaWNrJywgYXJyb3dDbGljayApO1xuICAgICAgICAgICAgICAgICAgICAkYXJyb3dSaWdodC5vbiggJ2NsaWNrJywgYXJyb3dDbGljayApO1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGFycm93IGNvbG9yc1xuXG4gICAgICAgICAgICAgICAgICAgICRhcnJvd0xlZnQucmVtb3ZlQ2xhc3MoIHRoZW1lQ2xhc3Nlcy5qb2luKCAnICcgKSArICcgJyArIHRoZW1lSG92ZXJDbGFzc2VzLmpvaW4oICcgJyApICk7XG4gICAgICAgICAgICAgICAgICAgICRhcnJvd1JpZ2h0LnJlbW92ZUNsYXNzKCB0aGVtZUNsYXNzZXMuam9pbiggJyAnICkgKyAnICcgKyB0aGVtZUhvdmVyQ2xhc3Nlcy5qb2luKCAnICcgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy5hcnJvd0NvbG9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGFycm93TGVmdC5hdHRyKCAnc3R5bGUnLCAnJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGFycm93UmlnaHQuYXR0ciggJ3N0eWxlJywgJycgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNIZXhDb2xvciggb3B0aW9ucy5hcnJvd0NvbG9yICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGFycm93TGVmdC5jc3MoICdjb2xvcicsIG9wdGlvbnMuYXJyb3dDb2xvciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhcnJvd1JpZ2h0LmNzcyggJ2NvbG9yJywgb3B0aW9ucy5hcnJvd0NvbG9yICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhcnJvd0xlZnQuYWRkQ2xhc3MoIG9wdGlvbnMuYXJyb3dDb2xvciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhcnJvd1JpZ2h0LmFkZENsYXNzKCBvcHRpb25zLmFycm93Q29sb3IgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMuYXJyb3dDb2xvckhvdmVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCggJy5zbGlkZXJfX2Fycm93LWhvdmVyJyApLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc0hleENvbG9yKCBvcHRpb25zLmFycm93Q29sb3JIb3ZlciApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnByZXBlbmQoICQoICc8c3R5bGUgY2xhc3M9XCJzbGlkZXJfX2Fycm93LWhvdmVyXCI+PC9zdHlsZT4nICkudGV4dCggJy5zbGlkZXIgLnNsaWRlcl9fYXJyb3cgaTpob3ZlciB7IGNvbG9yOiAnICsgb3B0aW9ucy5hcnJvd0NvbG9ySG92ZXIgKyAnIH0nICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGFycm93TGVmdC5hZGRDbGFzcyggb3B0aW9ucy5hcnJvd0NvbG9ySG92ZXIgKyAnLS1ob3ZlcicgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkYXJyb3dSaWdodC5hZGRDbGFzcyggb3B0aW9ucy5hcnJvd0NvbG9ySG92ZXIgKyAnLS1ob3ZlcicgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhpZGVzIHRoZSBhcnJvd3NcbiAgICAgICAgICAgICAgICAgICAgJGFycm93TGVmdC5jc3MoICdkaXNwbGF5JywgJ25vbmUnICk7XG4gICAgICAgICAgICAgICAgICAgICRhcnJvd1JpZ2h0LmNzcyggJ2Rpc3BsYXknLCAnbm9uZScgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhcnJvd0NsaWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYXJyb3cgY2xpY2sgZXhpc3RzIHdlIGFyZSBpbiB0aGUgZWRpdG9yIGFuZCB0aGUgdXNlciBoYXMgcmVtb3ZlIHRoZSBzbGlkZSBzaG93IGFycm93cyBzbyB1cGJpbmQgdGhlIGNsaWNrIGhhbmRsZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgJGFycm93TGVmdC5vZmYoICdjbGljaycsIGFycm93Q2xpY2sgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRhcnJvd1JpZ2h0Lm9mZiggJ2NsaWNrJywgYXJyb3dDbGljayApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCAkYWN0aXZlICkge1xuICAgICAgICAgICAgICAgICAgICAkYWN0aXZlLnNob3coKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc2xpZGVzLmZpcnN0KCkuYWRkQ2xhc3MoICdhY3RpdmUnICkudmVsb2NpdHkoIHsgb3BhY2l0eTogMSB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICRhY3RpdmVfaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAkYWN0aXZlID0gJHNsaWRlcy5lcSggJGFjdGl2ZV9pbmRleCApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBpbmRpY2F0b3JzXG4gICAgICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy5pbmRpY2F0b3JzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGluZGljYXRvcnMuZXEoICRhY3RpdmVfaW5kZXggKS5hZGRDbGFzcyggJ2FjdGl2ZScgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBoZWlnaHQgdG8gY3VycmVudCBzbGlkZVxuICAgICAgICAgICAgICAgICRhY3RpdmUuZmluZCggJy5zbGlkZV9fc3R5bGUnICkuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRhY3RpdmUuZmluZCggJy5jYXB0aW9uJyApLnZlbG9jaXR5KCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IDBcbiAgICAgICAgICAgICAgICAgICAgfSwgeyBkdXJhdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJyB9ICk7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgLy8gQXV0byBzY3JvbGxcbiAgICAgICAgICAgICAgICByZXNldEludGVydmFsKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW1tZXJKUywgU3dpcGUgbmF2aWdhdGlvblxuXG4gICAgICAgICAgICAgICAgLy8gVG91Y2ggRXZlbnRcbiAgICAgICAgICAgICAgICB2YXIgcGFubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBzd2lwZUxlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgc3dpcGVSaWdodCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgJHRoaXMuaGFtbWVyKCB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRfZGVmYXVsdDogZmFsc2VcbiAgICAgICAgICAgICAgICB9ICkub24oICdwYW4nLCBmdW5jdGlvbiggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlLmdlc3R1cmUucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKCAkaW50ZXJ2YWwgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGUuZ2VzdHVyZS5kaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGUuZ2VzdHVyZS5kZWx0YVg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVsb2NpdHlYID0gZS5nZXN0dXJlLnZlbG9jaXR5WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZWxvY2l0eVkgPSBlLmdlc3R1cmUudmVsb2NpdHlZO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGN1cnJfc2xpZGUgPSAkc2xpZGVzLmZpbHRlciggJy5hY3RpdmUnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIE1hdGguYWJzKCB2ZWxvY2l0eVggKSA+IE1hdGguYWJzKCB2ZWxvY2l0eVkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3Vycl9zbGlkZS52ZWxvY2l0eSgge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYOiB4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgeyBkdXJhdGlvbjogNTAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpcGUgTGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXJlY3Rpb24gPT09IDQgJiYgKCB4ID4gJHRoaXMuaW5uZXJXaWR0aCgpIC8gMiB8fCB2ZWxvY2l0eVggPCAtMC42NSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXBlUmlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpcGUgUmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBkaXJlY3Rpb24gPT09IDIgJiYgKCB4IDwgLTEgKiAkdGhpcy5pbm5lcldpZHRoKCkgLyAyIHx8IHZlbG9jaXR5WCA+IDAuNjUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2lwZUxlZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIFNsaWRlIEJlaGluZCBhY3RpdmUgc2xpZGUgdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRfc2xpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN3aXBlTGVmdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0X3NsaWRlID0gJGN1cnJfc2xpZGUubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbmV4dF9zbGlkZS5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRfc2xpZGUgPSAkc2xpZGVzLmZpcnN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRfc2xpZGUudmVsb2NpdHkoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHsgZHVyYXRpb246IDMwMCwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCcgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzd2lwZVJpZ2h0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRfc2xpZGUgPSAkY3Vycl9zbGlkZS5wcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuZXh0X3NsaWRlLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dF9zbGlkZSA9ICRzbGlkZXMubGFzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0X3NsaWRlLnZlbG9jaXR5KCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7IGR1cmF0aW9uOiAzMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gKS5vbiggJ3BhbmVuZCcsIGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGUuZ2VzdHVyZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRjdXJyX3NsaWRlID0gJHNsaWRlcy5maWx0ZXIoICcuYWN0aXZlJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJfaW5kZXggPSBnZXRBY3RpdmVJbmRleCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFzd2lwZVJpZ2h0ICYmICFzd2lwZUxlZnQgfHwgJHNsaWRlcy5sZW5ndGggPD0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdG8gb3JpZ2luYWwgc3BvdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRjdXJyX3NsaWRlLnZlbG9jaXR5KCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7IGR1cmF0aW9uOiAzMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHN3aXBlTGVmdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlVG9TbGlkZSggY3Vycl9pbmRleCArIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3Vycl9zbGlkZS52ZWxvY2l0eSggeyB0cmFuc2xhdGVYOiAtMSAqICR0aGlzLmlubmVyV2lkdGgoKSB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3Vycl9zbGlkZS52ZWxvY2l0eSggeyBvcGFjaXR5OiAwLCB0cmFuc2xhdGVYOiAwIH0sIHsgZHVyYXRpb246IDAsIHF1ZXVlOiBmYWxzZSB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzd2lwZVJpZ2h0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUb1NsaWRlKCBjdXJyX2luZGV4IC0gMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRjdXJyX3NsaWRlLnZlbG9jaXR5KCB7IHRyYW5zbGF0ZVg6ICR0aGlzLmlubmVyV2lkdGgoKSB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3Vycl9zbGlkZS52ZWxvY2l0eSggeyBvcGFjaXR5OiAwLCB0cmFuc2xhdGVYOiAwIH0sIHsgZHVyYXRpb246IDAsIHF1ZXVlOiBmYWxzZSB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2lwZUxlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXBlUmlnaHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdGFydCBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgJHRoaXMub24oICdzbGlkZXJQYXVzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKCAkaW50ZXJ2YWwgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAkdGhpcy5vbiggJ3NsaWRlclN0YXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0SW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAkdGhpcy5vbiggJ3NsaWRlck5leHQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJGFjdGl2ZV9pbmRleCA9IGdldEFjdGl2ZUluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVUb1NsaWRlKCAkYWN0aXZlX2luZGV4ICsgMSApO1xuICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICR0aGlzLm9uKCAnc2xpZGVyUHJldicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkYWN0aXZlX2luZGV4ID0gZ2V0QWN0aXZlSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVRvU2xpZGUoICRhY3RpdmVfaW5kZXggLSAxICk7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgJHRoaXMub24oICdzbGlkZXJSZW1vdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCggJGludGVydmFsICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9mZigpO1xuICAgICAgICAgICAgICAgICAgICAkc2xpZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgJHNsaWRlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICRhcnJvd0xlZnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAkYXJyb3dSaWdodCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBoYXNWaWRlb0JhY2tncm91bmQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcG9zaXRpb24gYmFja2dyb3VuZCB2aWRlb3Mgd2hlbiB0aGUgc2xpZGUgZ2V0IHJlc2l6ZWQsIGFzIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3Jlc2l6ZScsIG9wLnRocm90dGxlKCBmdW5jdGlvbiggXyRzbGlkZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfJHNsaWRlcy5lYWNoKCBmdW5jdGlvbiggaW5kZXgsIHNsaWRlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wLnBvc2l0aW9uVmlkZW8oICQoIHNsaWRlICksIHNsaWRlLnF1ZXJ5U2VsZWN0b3IoICcudmlkZW8tYmFja2dyb3VuZC13cmFwcGVyJyApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCggdGhpcywgJHNsaWRlcyApLCAyNTAgKSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9LFxuICAgICAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKCB0aGlzICkudHJpZ2dlciggJ3NsaWRlclBhdXNlJyApO1xuICAgICAgICB9LFxuICAgICAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKCB0aGlzICkudHJpZ2dlciggJ3NsaWRlclN0YXJ0JyApO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQoIHRoaXMgKS50cmlnZ2VyKCAnc2xpZGVyTmV4dCcgKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJldjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKCB0aGlzICkudHJpZ2dlciggJ3NsaWRlclByZXYnICk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKCB0aGlzICkudHJpZ2dlciggJ3NsaWRlclJlbW92ZScgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLnNsaWRlciA9IGZ1bmN0aW9uKCBtZXRob2RPck9wdGlvbnMgKSB7XG4gICAgICAgIGlmICggbWV0aG9kc1sgbWV0aG9kT3JPcHRpb25zIF0gKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kc1sgbWV0aG9kT3JPcHRpb25zIF0uYXBwbHkoIHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSApO1xuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbWV0aG9kT3JPcHRpb25zID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kT3JPcHRpb25zICkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBcImluaXRcIlxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmVycm9yKCAnTWV0aG9kICcgKyBtZXRob2RPck9wdGlvbnMgKyAnIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS50b29sdGlwJyApO1xuICAgICAgICB9XG4gICAgfTsgLy8gUGx1Z2luIGVuZFxufSApKCBqUXVlcnkgKTtcblxuLy8gU1RJQ0tZIEJMT0NLUy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4oIGZ1bmN0aW9uKCAkICkge1xuXG4gICAgLypcbiAgICAgKiBAYnJpZWYgVXBkYXRlIHRoZSBtYXRlcmlhbGl6ZSBwdXNoIHBpbiBjb21wZW5zYXRlIGZvciB0aGUgaGVpZ2h0IG9mIHRoZSBwaW5uZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICAkLmZuLnB1c2hwaW4gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgICAgICAvLyBEZWZhdWx0c1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBib3R0b206IEluZmluaXR5LFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHB1c2hwaW4gZXZlbnQgYW5kIGNsYXNzZXNcbiAgICAgICAgaWYgKCBvcHRpb25zID09PSAncmVtb3ZlJyApIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gJCggdGhpcyApLmRhdGEoICdwdXNocGluLWlkJyApO1xuICAgICAgICAgICAgICAgIGlmICggaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICQoIHdpbmRvdyApLm9mZiggJ3Njcm9sbC4nICsgaWQgKTtcbiAgICAgICAgICAgICAgICAgICAgJCggdGhpcyApLnJlbW92ZURhdGEoICdwdXNocGluLWlkJyApLnJlbW92ZUNsYXNzKCAncGluLXRvcCBwaW5uZWQgcGluLWJvdHRvbScgKS5jc3MoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKCBkZWZhdWx0cywgb3B0aW9ucyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB0aGlzLnN0aWNreUJsb2NrT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0aWNreUJsb2NrU2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5jbG9zZXN0KCAnLnN0aWNreS13cmFwcGVyJyApO1xuICAgICAgICAgICAgICAgIGlmICggIXdyYXBwZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc3RpY2t5QmxvY2tPcHRpb25zLnRvcCA9IHdyYXBwZXIub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RpY2t5QmxvY2tPcHRpb25zLmJvdHRvbSA9IHdyYXBwZXIub2Zmc2V0VG9wICsgdGhpcy5wYXJlbnRFbGVtZW50LmNsaWVudEhlaWdodCAtIHRoaXMub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuJG9yaWdpbmFsX29mZnNldCA9IHdyYXBwZXIub2Zmc2V0VG9wO1xuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICB2YXIgJHVuaXF1ZUlkID0gTWF0ZXJpYWxpemUuZ3VpZCgpLFxuICAgICAgICAgICAgICAgICR0aGlzID0gJCggdGhpcyApLFxuICAgICAgICAgICAgICAgIG9sZFNjcm9sbFZhbHVlID0gMCxcbiAgICAgICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb247XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRvcmlnaW5hbF9vZmZzZXQgPSAkKCB0aGlzICkub2Zmc2V0KCkudG9wO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVQaW5DbGFzc2VzKCBvYmplY3QgKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnJlbW92ZUNsYXNzKCAncGluLXRvcCcgKTtcbiAgICAgICAgICAgICAgICBvYmplY3QucmVtb3ZlQ2xhc3MoICdwaW5uZWQnICk7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnJlbW92ZUNsYXNzKCAncGluLWJvdHRvbScgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudHMoIG9iamVjdHMsIHNjcm9sbGVkICkge1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gKCBzY3JvbGxlZCA+IG9sZFNjcm9sbFZhbHVlICkgPyAnZG93bicgOiAndXAnO1xuICAgICAgICAgICAgICAgIG9sZFNjcm9sbFZhbHVlID0gc2Nyb2xsZWQ7XG4gICAgICAgICAgICAgICAgb2JqZWN0cy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCggdGhpcyApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0aWNreUJsb2NrU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gZml4ZWQgKGJlY2F1c2UgaXRzIGJldHdlZW4gdG9wIGFuZCBib3R0b20pXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2Nyb2xsZWQgPiAwICYmIG9wdGlvbnMudG9wIDw9IHNjcm9sbGVkICYmIG9wdGlvbnMuYm90dG9tID49IHNjcm9sbGVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhJHRoaXMuaGFzQ2xhc3MoICdwaW5uZWQnICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUGluQ2xhc3NlcyggJHRoaXMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jc3MoICd0b3AnLCBvcHRpb25zLm9mZnNldCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmFkZENsYXNzKCAncGlubmVkJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnBhcmVudCgpLmNzcygge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFkZGluZy10b3AnOiAkdGhpcy5oZWlnaHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLmhpZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuY3NzKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICd0b3AgLjNzIGVhc2UtaW4tb3V0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZTZXRNYXggPSAkdGhpcy5oZWlnaHQoKSArIDUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlZE9mZnNldCA9IHNjcm9sbGVkIC0gb3B0aW9ucy50b3A7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNjcm9sbERpcmVjdGlvbiA9PT0gJ3VwJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSAoIHBhcnNlSW50KCAkdGhpcy5jc3MoICd0b3AnICkgKSA+IDAgKSA/ICcnIDogJ3RvcCAuM3MgZWFzZS1pbi1vdXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jc3MoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNjcm9sbGluZyBkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2Nyb2xsZWRPZmZzZXQgPiBvZmZTZXRNYXggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jc3MoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IC0xICogb2ZmU2V0TWF4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jc3MoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBhbiBleHRyYSA1MCBmb3IgYm94IHNoYWRvd3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IC0xICogc2Nyb2xsZWRPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBwaW4tdG9wICh3aGVuIHNjcm9sbGVkIHBvc2l0aW9uIGlzIGFib3ZlIHRvcClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzY3JvbGxlZCA8IG9wdGlvbnMudG9wICYmICEkdGhpcy5oYXNDbGFzcyggJ3Bpbi10b3AnICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVBpbkNsYXNzZXMoICR0aGlzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jc3MoICd0b3AnLCAwICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hZGRDbGFzcyggJ3Bpbi10b3AnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5wYXJlbnQoKS5jc3MoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFkZGluZy10b3AnOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMuaGlkZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jc3MoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJIHJlbW92ZWQgdGhlIHBpbi1ib3R0b20gY2hlY2sgdG8gZ2V0IHRoZSAnaGlkZGVuJyBzdGlja3kgYmxvY2sgd29ya2luZyBub3Qgc3VyZSBpZiB0aGlzIHdpbGwgYnJlYWsgYW55dGhpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIChzY3JvbGxlZCA+IG9wdGlvbnMuYm90dG9tICYmICEkdGhpcy5oYXNDbGFzcygncGluLWJvdHRvbScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggc2Nyb2xsZWQgPj0gb3B0aW9ucy5ib3R0b20gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy5oaWRlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmNzcygge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAndG9wIC4zcyBlYXNlLWluLW91dCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzY3JvbGxEaXJlY3Rpb24gPT09ICdkb3duJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuY3NzKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNjcm9sbERpcmVjdGlvbiA9PT0gJ3VwJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuY3NzKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IG9wdGlvbnMuYm90dG9tIC0gdGhpcy4kb3JpZ2luYWxfb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmNzcyggJ3RvcCcsIG9wdGlvbnMuYm90dG9tIC0gdGhpcy4kb3JpZ2luYWxfb2Zmc2V0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVBpbkNsYXNzZXMoICR0aGlzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hZGRDbGFzcyggJ3Bpbi1ib3R0b20nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5wYXJlbnQoKS5jc3MoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFkZGluZy10b3AnOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJCggdGhpcyApLmRhdGEoICdwdXNocGluLWlkJywgJHVuaXF1ZUlkICk7XG4gICAgICAgICAgICB1cGRhdGVFbGVtZW50cyggJHRoaXMsICQoIHdpbmRvdyApLnNjcm9sbFRvcCgpICk7XG4gICAgICAgICAgICAkKCB3aW5kb3cgKS5vbiggJ3Njcm9sbC4nICsgJHVuaXF1ZUlkLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHNjcm9sbGVkID0gJCggd2luZG93ICkuc2Nyb2xsVG9wKCkgKyBvcHRpb25zLm9mZnNldDtcbiAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50cyggJHRoaXMsICRzY3JvbGxlZCApO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9ICk7XG4gICAgfTtcbn0gKSggalF1ZXJ5ICk7XG5cbi8vIFBBUkFMTEFYIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLypcbiAqIEBicmllZiBPdmVybG9hZGluZyBtYXRlcmlhbGl6ZSBwYXJhbGxheCBzbyB3ZSBjYW4gb2ZmZXIgdGhlIGZpeGVkLCBwYXJhbGxheCBzbG93LCBwYXJhbGxheCBtZWRpdW0sIHBhcmFsbGF4IGZhc3QgdGhhdFxuICogICAgICAgIGFyZSBzbyBkZXNwZXJhdGVseSBwaXZvdGFsIHRvIG9udHJhcG9ydCdzIHN1Y2Nlc3MuXG4gKi9cbiggZnVuY3Rpb24oICQgKSB7XG4gICAgJC5mbi5wYXJhbGxheCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgICAgICB2YXIgJHdpbmRvdyA9ICQoIHdpbmRvdyApLFxuICAgICAgICAgICAgd2luZG93X3dpZHRoID0gJHdpbmRvdy53aWR0aCgpO1xuXG4gICAgICAgIC8vIFBhcmFsbGF4IFNjcmlwdHNcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBibG9jayB0aGF0IGhhcyB0aGUgcGFyYWxsYXhcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICBzcGVlZE1vZGlmaWVyID0gLjY2O1xuXG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMuc3BlZWQgPT09ICdwYXJhbGxheF9zbG93JyApIHtcbiAgICAgICAgICAgICAgICBzcGVlZE1vZGlmaWVyID0gLjMzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggb3B0aW9ucy5zcGVlZCA9PT0gJ3BhcmFsbGF4X2Zhc3QnICkge1xuICAgICAgICAgICAgICAgIHNwZWVkTW9kaWZpZXIgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkdGhpcy5hZGRDbGFzcyggJ3BhcmFsbGF4JyApO1xuXG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMuc3BlZWQgPT09ICdmaXhlZCcgKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3MoICdwYXJhbGxheC0tZml4ZWQnICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2aWRlb1NlbGVjdG9yID0gJ3ZpZGVvLCBpZnJhbWUnLFxuICAgICAgICAgICAgICAgIGlzVmlkZW8gPSAoICR0aGlzLmZpbmQoIHZpZGVvU2VsZWN0b3IgKS5sZW5ndGggPiAwICksXG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50ID0gJHRoaXMuZmluZCggJ2ltZycgKVsgMCBdLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBjb250YWluZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hhdCB0aGUgY29udGFpbmVyIGRpbWVuc2lvbnMgc2hvdWxkIGJlLiBQYWdlIG9yIGJsb2NrLlxuICAgICAgICAgICAgaWYgKCBvcHRpb25zLnNwZWVkID09PSAnZml4ZWQnICkge1xuICAgICAgICAgICAgICAgIC8vIEZpeGVkIGJhY2tncm91bmQgd2lsbCBzdHJldGNoIHRoZSB0YXJnZXQgaW1hZ2Ugb3IgdmlkZW8gdG8gYmUgdGhlIHNpemUgb2YgdGhlIHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlIGNvbnRhaW5lciBvZiB0aGUgYmxvY2sgYWN0cyBhcyBhIHdpbmRvdyB0aGF0IHJldmVhbHMgdGhlIHRhcmdldCB1bmRlcm5lYXRoIGl0XG4gICAgICAgICAgICAgICAgLy8gYXMgaXQgc2Nyb2xscyB1cC9kb3duIHRocm91Z2ggdGhlIHBhZ2UuXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0aGUgdGFyZ2V0IHRvIGJlIHN0cmV0Y2hlZCB0byB0aGUgc2l6ZSBvZiB0aGUgd2luZG93IHNvIHRoYXQgdGhlIHRhcmdldCB3aWxsIGFsd2F5cyBiZSB2aXNpYmxlXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIGJsb2NrIHJldmVhbHMgaXQuIElmIHdlIGRvbid0IHN0cmV0Y2ggaXQgdG8gd2luZG93IHNpemUsIHRoZW4gaWYgdGhlIHRhcmdldCBpcyB0b28gc21hbGwsIHdlJ2xsXG4gICAgICAgICAgICAgICAgLy8gc2VlIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIHVuZGVybmVhdGggdGhlIHRhcmdldC5cbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gQnV0IHVsdGltYXRlbHkgZm9yIGZpeGVkIGJhY2tncm91bmQsIHdlIG9ubHkgbmVlZCB0aGUgdGFyZ2V0IHRvIGJlIGFzIHdpZGUgYXMgaXRzIGJsb2NrLiBTaW5jZSB0aGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgd2lkdGggb2YgdGhlIGJsb2NrIGFjdHMgYXMgdGhlIHdpbmRvdyB0aGF0IHJldmVhbHMgdGhlIGJhY2tncm91bmQgdGFyZ2V0LlxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlcyB3aGVyZSB0aGUgYmxvY2sgd2lkdGggaXMgbGVzcyB0aGFuIHRoZSBwYWdlIHdpZHRoIChsaWtlIGlmIHlvdSBzZXQgeW91ciBwYWdlIHdpZHRoIHRvIGJlXG4gICAgICAgICAgICAgICAgLy8gXCJzbWFsbFwiKSwgdGhlbiBmb3JjaW5nIHRoZSB0YXJnZXQgdG8gc3RyZXRjaCB0byB0aGUgcGFnZSB3aWR0aCB3b3VsZCBjYXVzZSB1bm5lY2Vzc2FyeSBzdHJldGNoaW5nLlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQW55IG90aGVyIG9wdGlvbnMgYmVzaWRlcyBmaXhlZCwgc2hvdWxkIHVzZSB0aGUgYmxvY2sgYXMgaXRzIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSB2aWRlb1xuICAgICAgICAgICAgaWYgKCBpc1ZpZGVvICkge1xuICAgICAgICAgICAgICAgIG9wLnBvc2l0aW9uVmlkZW8oICQoIGNvbnRhaW5lciApLCB0aGlzICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEl0J3MgaW1hZ2UgcGFyYWxsYXguIFN0cmV0Y2ggYnkgZGlmZmVyZW50IGZhY3RvcnMgZGVwZW5kaW5nIG9uIHdpbmRvdyBzaXplLlxuICAgICAgICAgICAgICAgIC8vIEFsc28sIHdlIHN0cmV0Y2ggZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXRzIGZpeGVkIHBhcmFsbGF4IG9yIG5vbi1maXhlZCBwYXJhbGxheCAoc2xvdywgbWVkLCBmYXN0KS5cbiAgICAgICAgICAgICAgICB2YXIgcGFyYWxsYXhTdHJldGNoRmFjdG9yID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgbmF0dXJhbCBkaW1lbnNpb25zIG9mIHRoZSBpbWFnZSB0byBiZXR0ZXIgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZSBpbWFnZSBuZWVkcyB0byBzdHJldGNoLlxuICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodCA9IGltYWdlRWxlbWVudC5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRhcmdldFdpZHRoID0gaW1hZ2VFbGVtZW50Lm5hdHVyYWxXaWR0aDtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSBpbWFnZSBuZWVkcyB0byBiZSBhIGxpdHRsZSBiaWdnZXIgdGhhbiB0aGUgY29udGFpbmVyIHNvIHRoYXQgYSBwYXJhbGxheCBzY3JvbGwgZWZmZWN0IGlzIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgIC8vIFRocm91Z2ggYXJiaXRyYXJ5IHRlc3RpbmcsIHBhcmFsbGF4IHNjcm9sbGluZyBpcyBiZXN0IHdoZW4gdGhlIGltYWdlIGlzIGF0IGxlYXN0IDEuNSB0aW1lcyB0aGUgY29udGFpbmVyLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgb25seSBzdHJldGNoIHRoZSBpbWFnZSBpZiBpdCdzIG5vdCBhdCBsZWFzdCAxLjUgdGltZXMgbGFyZ2VyIHRoYW4gdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGFkZCBhIHN0cmV0Y2ggZmFjdG9yIGZvciBmaXhlZCBwYXJhbGxheCBzY3JvbGxpbmcgc2luY2UgaXQgZG9lcyBub3QgbmVlZCB0byBzdHJldGNoIHBhc3QgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLnNwZWVkICE9PSAnZml4ZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICggdGFyZ2V0SGVpZ2h0IDwgKCB0aGlzLmNsaWVudEhlaWdodCAqIDEuNSApIHx8XG4gICAgICAgICAgICAgICAgICAgICB0YXJnZXRXaWR0aCA8ICggdGhpcy5jbGllbnRXaWR0aCAqIDEuNSApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFsbGF4U3RyZXRjaEZhY3RvciA9IDEuNTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3RGltZW5zaW9ucyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRhcmdldFdpZHRoICE9PSAwICYmIHRhcmdldEhlaWdodCAhPT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGltZW5zaW9ucyA9IG9wLmFkanVzdERpbWVuc2lvbnMoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiBjb250YWluZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogY29udGFpbmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0V2lkdGg6IHRhcmdldFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0OiB0YXJnZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRUYWdOYW1lOiBpbWFnZUVsZW1lbnQudGFnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmV0Y2hGYWN0b3I6IHBhcmFsbGF4U3RyZXRjaEZhY3RvclxuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBuZXdEaW1lbnNpb25zICYmIG5ld0RpbWVuc2lvbnMud2lkdGggIT09IDAgJiYgbmV3RGltZW5zaW9ucy5oZWlnaHQgIT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC5zdHlsZS53aWR0aCA9IG5ld0RpbWVuc2lvbnMud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gbmV3RGltZW5zaW9ucy5oZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlUGFyYWxsYXgoIGluaXRpYWwgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3VwcG9ydGVkUGFyYWxsYXhFbGVtZW50c1NlbGVjdG9yID0gJ2ltZywgdmlkZW8sIGlmcmFtZScsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU2VsZWN0b3IgPSAnaW1nJyxcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9TZWxlY3RvciA9ICd2aWRlbywgaWZyYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gJHRoaXMuaGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgIG1vYmlsZVNpemUgPSArb3AubW9iaWxlQnJlYWtwb2ludCB8fCA2MDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHdpbmRvd193aWR0aCA8PSBtb2JpbGVTaXplICkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXJIZWlnaHQgPiAwID8gY29udGFpbmVySGVpZ2h0IDogJHRoaXMuZmluZCggc3VwcG9ydGVkUGFyYWxsYXhFbGVtZW50c1NlbGVjdG9yICkuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0ID4gMCA/IGNvbnRhaW5lckhlaWdodCA6IDUwMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAkcGFyYWxsYXhUYXJnZXQgaXMgdGhlIGltZyBvciB2aWRlbyB0aGF0IGlzIHRvIGJlIHBhcmFsbGF4ZWRcbiAgICAgICAgICAgICAgICB2YXIgJHBhcmFsbGF4VGFyZ2V0ID0gJHRoaXMuZmluZCggc3VwcG9ydGVkUGFyYWxsYXhFbGVtZW50c1NlbGVjdG9yICkuZmlyc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgaW1nSGVpZ2h0ID0gJHBhcmFsbGF4VGFyZ2V0LmhlaWdodCgpLFxuICAgICAgICAgICAgICAgICAgICBpbWdXaWR0aCA9ICRwYXJhbGxheFRhcmdldC53aWR0aCgpLFxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbGxheF9kaXN0ID0gaW1nSGVpZ2h0IC0gY29udGFpbmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBib3R0b20gPSAkdGhpcy5vZmZzZXQoKS50b3AgKyBjb250YWluZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9ICR0aGlzLm9mZnNldCgpLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gJCggd2luZG93ICkuc2Nyb2xsVG9wKCksXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Qm90dG9tLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50U2Nyb2xsZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFsbGF4O1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpbml0aWFsICkge1xuICAgICAgICAgICAgICAgICAgICAkcGFyYWxsYXhUYXJnZXQuY3NzKCAnZGlzcGxheScsICdibG9jaycgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgdmlkZW8sIG1ha2Ugc3VyZSB0aGUgdmlkZW8tYmFja2dyb3VuZCBvdmVybGF5IGNvdmVycyBwcmVjaXNlbHlcbiAgICAgICAgICAgICAgICBpZiAoICR0aGlzLmZpbmQoICcudmlkZW8tY29udGFpbmVyIHZpZGVvJyApLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBvdmVybGF5IGNvdmVycyB0aGUgdmlkZW8gaW5zaWRlIHRoZSAucGFyYWxsYXgtaW1hZ2UgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCAnLnZpZGVvLWJhY2tncm91bmQtb3ZlcmxheScgKS5jc3MoICdoZWlnaHQnLCAkdGhpcy5maW5kKCAnLnBhcmFsbGF4LWltYWdlJyApLmhlaWdodCgpICsgJ3B4JyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciAkdmlkZW9Db250YWluZXIgPSAkdGhpcy5maW5kKCAnLnZpZGVvLWNvbnRhaW5lcicgKSxcbiAgICAgICAgICAgICAgICAgICAgaXNWaWRlbyA9ICggJHRoaXMuZmluZCggdmlkZW9TZWxlY3RvciApLmxlbmd0aCA+IDAgKSxcbiAgICAgICAgICAgICAgICAgICAgbW92ZURlbHRhWCA9ICcwJztcblxuICAgICAgICAgICAgICAgIC8vIFN0cmV0Y2ggdGhlIHZpZGVvcyBvdXQgc29tZSBzbyB0aGF0IHRoZXkgY292ZXIgdGhlIGJsb2NrLCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIHZpZGVvIGFzIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmICggaXNWaWRlbyApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGltZ1dpZHRoID4gdmlld3BvcnRXaWR0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLWNlbnRlciB0aGUgdmlkZW9cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVEZWx0YVggPSAnLScgKyAoIGltZ1dpZHRoLzIgLSB2aWV3cG9ydFdpZHRoLzIgKSArICdweCc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGFkanVzdGVkIHRoZSB2aWRlbydzIGRpbWVuc2lvbnMsIHdlIGRvbid0IG5lZWQgdG8gYXBwbHkgdGhpcyBjbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hpY2ggaXMgbW9zdGx5IHVzZWQgdG8gbWFpbnRhaW4gdGhlIGFzcGVjdCByYXRpbyBvZiB0aGUgdmlkZW8gdG8gaGlkZSBibGFjayBiYXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgJHZpZGVvQ29udGFpbmVyLnJlbW92ZUNsYXNzKCAndmlkZW8tY29udGFpbmVyJyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLnNwZWVkID09PSAnZml4ZWQnICkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbGxheCA9IE1hdGgucm91bmQoICggaW1nSGVpZ2h0IC0gY29udGFpbmVySGVpZ2h0ICkgLSAoIHRvcCAtIHNjcm9sbFRvcCApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1ZpZGVvICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCggdmlkZW9TZWxlY3RvciApLmNzcyggJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzRCgnICsgbW92ZURlbHRhWCArICcsJyArIHBhcmFsbGF4ICsgJ3B4LCAwKScgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBpbWFnZXMsIHVzZSAtNTAlIGZvciB0aGUgWCBhcmd1bWVudCB0byBjZW50ZXIgdGhlIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCBpbWFnZVNlbGVjdG9yICkuY3NzKCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNEKCAtNTAlLCcgKyBwYXJhbGxheCArICdweCwgMCknICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0JvdHRvbSA9IHNjcm9sbFRvcCArIHdpbmRvd0hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudFNjcm9sbGVkID0gKCB3aW5kb3dCb3R0b20gLSB0b3AgKSAvICggY29udGFpbmVySGVpZ2h0ICsgd2luZG93SGVpZ2h0ICkgKiBzcGVlZE1vZGlmaWVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHBlcmNlbnRTY3JvbGxlZCA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50U2Nyb2xsZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBwZXJjZW50U2Nyb2xsZWQgPiAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudFNjcm9sbGVkID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJhbGxheCA9IE1hdGgucm91bmQoIHBhcmFsbGF4X2Rpc3QgKiBwZXJjZW50U2Nyb2xsZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBib3R0b20gPiBzY3JvbGxUb3AgJiYgdG9wIDwgc2Nyb2xsVG9wICsgd2luZG93SGVpZ2h0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlzVmlkZW8gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmlkZW9zIGFyZSBhbHJlYWR5IGNlbnRlcmVkLCBzbyB1c2UgMCBmb3IgdGhlIFggYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCB2aWRlb1NlbGVjdG9yICkuZmlyc3QoKS5jc3MoICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM0QoJyArIG1vdmVEZWx0YVggKyAnLCcgKyBwYXJhbGxheCArICdweCwgMCknICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBpbWFnZXMsIHVzZSAtNTAlIGZvciB0aGUgWCBhcmd1bWVudCB0byBjZW50ZXIgdGhlIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCggaW1hZ2VTZWxlY3RvciApLmZpcnN0KCkuY3NzKCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNEKCAtNTAlLCcgKyBwYXJhbGxheCArICdweCwgMCknICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkcGFyYWxsYXhUYXJnZXQgPSAkdmlkZW9Db250YWluZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXYWl0IGZvciBpbWFnZSBsb2FkXG4gICAgICAgICAgICAkdGhpcy5maW5kKCAnaW1nJyApLm9uZSggJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB1cGRhdGVQYXJhbGxheC5iaW5kKCB0aGlzLCB0cnVlICkgKTtcbiAgICAgICAgICAgIH0gKS5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuY29tcGxldGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICQoIHRoaXMgKS50cmlnZ2VyKCAnbG9hZCcgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICR0aGlzLmZpbmQoICd2aWRlbycgKS5vbmUoICdwbGF5aW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggdXBkYXRlUGFyYWxsYXguYmluZCggdGhpcywgdHJ1ZSApICk7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICQoIHdpbmRvdyApLnNjcm9sbCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgd2luZG93X3dpZHRoID0gJHdpbmRvdy53aWR0aCgpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZVBhcmFsbGF4LmJpbmQoIHRoaXMsIGZhbHNlICkgKTtcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgJCggd2luZG93ICkucmVzaXplKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dfd2lkdGggPSAkd2luZG93LndpZHRoKCk7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggdXBkYXRlUGFyYWxsYXguYmluZCggdGhpcywgZmFsc2UgKSApO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9ICk7XG4gICAgfTtcbn0gKSggalF1ZXJ5ICk7XG5cbi8vIEpVTVAgVE8gQkxPQ0sgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLypcbiAqIFByb3ZpZGUgZnVuY3Rpb25hbGl0eSB0byBqdW1wIHRvIGEgc3BlY2lmaWMgYmxvY2sgb24gdGhlIHBhZ2UuXG4gKi9cbiggZnVuY3Rpb24oICQgKSB7XG4gICAgJC5mbi5zY3JvbGxUb0Jsb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciAkc2Nyb2xsVG9CbG9jayA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCAkc2Nyb2xsVG9CbG9jay5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsVG9Qb3NpdGlvbiA9ICRzY3JvbGxUb0Jsb2NrLm9mZnNldCgpLnRvcDtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgd2lsbCBiZSBhIHN0aWNreSBibG9jayBwcmVzZW50IHdoZW4gc2Nyb2xsZWQgdG8gZWxlbWVudFxuICAgICAgICAgICAgaWYgKCAkc2Nyb2xsVG9CbG9jay5jbG9zZXN0KCAnLnN0aWNreS13cmFwcGVyJyApLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBzdGlja3kgYmxvY2sgY2xvc2VzdCB0byB0aGUgZWxlbWVudCB3ZSBhcmUgc2Nyb2xsaW5nIHRvXG4gICAgICAgICAgICAgICAgdmFyICRzdGlja3lCbG9jayA9ICRzY3JvbGxUb0Jsb2NrLnByZXZBbGwoICcub3B0LXN0aWNreS1ibG9jaycgKS5lcSggMCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAkc3RpY2t5QmxvY2subGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHN0aWNreSBibG9jayBkZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRJZCA9ICRzdGlja3lCbG9jay5hdHRyKCAnb3B0LWlkJyApLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RpY2t5QmxvY2tEZWYgPSBzdGlja3lCbG9ja3MuZmlsdGVyKCBmdW5jdGlvbiggYmxvY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggYmxvY2suaWQgPT09IG9wdElkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3RpY2t5IGJsb2NrIGlzIG5vdCBoaWRkZW4sIHN1YnRyYWN0IGl0cyBoZWlnaHQgZnJvbSB0aGUgc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RpY2t5QmxvY2tEZWYubGVuZ3RoICYmICFzdGlja3lCbG9ja0RlZlsgMCBdLmhpZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb1Bvc2l0aW9uIC09ICRzdGlja3lCbG9jay5oZWlnaHQoKSArIHBhcnNlSW50KCAkc3RpY2t5QmxvY2suY3NzKCAncGFkZGluZy10b3AnICkgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJCggJ2JvZHksIGh0bWwnICkuYW5pbWF0ZSgge1xuICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9Qb3NpdGlvblxuICAgICAgICAgICAgfSwgMTAwMCApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQoICdhW2RhdGEtdXJsX3R5cGU9XCJibG9ja19saW5rXCJdJyApLm9uKCAnY2xpY2snLCBmdW5jdGlvbiggZXYgKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGJsb2NrSWQgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ2hyZWYnICk7XG5cbiAgICAgICAgJCggYmxvY2tJZCApLnNjcm9sbFRvQmxvY2soKTtcbiAgICB9ICk7XG59ICkoIGpRdWVyeSApO1xuXG4vKlxuICogQGJyaWVmIE9udHJhcG9ydHMgcHVibGljIGZhY2luZyBsYW5kaW5nIHBhZ2Ugc2NyaXB0cy4gVGhlc2Ugc2NyaXB0cyBhcmUgZGVzaWduZWQgdG8gb25seSBydW4gb24gcHVibGljIGZhY2luZyBzaXRlcy5cbiAqL1xuXG4oIGZ1bmN0aW9uKCAkLCBjb250ZXh0ICkge1xuXG4gICAgdmFyIF9zdWJtaXRBdHRlbXB0cyA9IHt9LFxuICAgICAgICAkZG9jdW1lbnRCb2R5ID0gJCggZG9jdW1lbnQuYm9keSApLFxuICAgICAgICBpZnJhbWVfZG9uZSA9IGZhbHNlLFxuICAgICAgICBvcCA9IGNvbnRleHQub3AgfHwgKCBjb250ZXh0Lm9wID0ge30gKSxcbiAgICAgICAgT1ByZUNhcHRjaGFBbGxvd1N1Ym1pdCA9IGZhbHNlO1xuXG4gICAgd2luZG93LkFDQ09VTlRfU0lHTlVQX0VSUk9SID0gMTA7XG4gICAgd2luZG93LkNDX1ZFUklGWV9QT1NUID0gNDI7XG4gICAgd2luZG93LkNDX1ZFUklGWV9TSE9XX0lGUkFNRSA9IDE4MztcbiAgICB3aW5kb3cuQ0NfVkVSSUZZX0hJREVfSUZSQU1FID0gMTg0O1xuICAgIHdpbmRvdy5DQ19WRVJJRllfR0VUX0NDX0RBVEEgPSAxODU7XG5cbiAgICB3aW5kb3cuTE9HX0xFVkVMX0VSUk9SID0gMDtcbiAgICB3aW5kb3cuTE9HX0xFVkVMX1dBUk5JTkcgPSAxO1xuICAgIHdpbmRvdy5MT0dfTEVWRUxfREVCVUcgPSAyO1xuXG4gICAgd2luZG93LlBST1RPQ09MID0gJ2h0dHBzOi8vJyxcbiAgICB3aW5kb3cuQ09VUE9OX1BST0NFU1NfRE9NQUlOID0gKCBQUk9UT0NPTCArICdmb3Jtcy5vbnRyYXBvcnQuY29tJyApLFxuICAgIHdpbmRvdy5JTl9ERUJVR19NT0RFID0gZmFsc2UsXG4gICAgd2luZG93LkZPUk1fUFJPQ0VTU19ET01BSU4gPSAoIFBST1RPQ09MICsgJ2Zvcm1zLm9udHJhcG9ydC5jb20nICksXG4gICAgd2luZG93LkNDX1ZFUklGWV9ET01BSU4gPSAoIEZPUk1fUFJPQ0VTU19ET01BSU4gKyAnL3YyLjQvY2NfdmVyaWZ5LnBocCcgKTtcblxuICAgIC8vIEluaXRpYWxpemUgbG9nZ2luZy5cbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3NjcmlwdCcgKTtcbiAgICBzY3JpcHQuc3JjID0gJ2h0dHBzOi8vb3B0YXNzZXRzLm9udHJhcG9ydC5jb20vb3B0X2Fzc2V0cy9zdGF0aWMvanMvbG9nZ2luZy5qcyc7XG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ2hlYWQnIClbIDAgXS5hcHBlbmRDaGlsZCggc2NyaXB0ICk7XG5cbiAgICBvcC5kZWJ1ZyA9IGZhbHNlO1xuICAgIG9wLmN1cnJlbmN5U2V0dGluZ3MgPSBmYWxzZTtcblxuICAgIC8vIExhenkgbG9hZCBpbWFnZXNcbiAgICBjb25zdCBvcExhenlMb2FkID0gbmV3IE9wTGF6eUxvYWQoKTtcbiAgICBvcC5vcExhenlMb2FkID0gb3BMYXp5TG9hZDtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBwYWdlIGhhcyBkeW5hbWljIGNvbnRlbnRcbiAgICBvcER5bmFtaWNDb250ZW50KCk7XG5cbiAgICAvLyBDaGVjayBmb3IgaWNvbnMuXG4gICAgY29uc3QgaGFzRm9udEF3ZXNvbWVJY29ucyA9IG9wRm9udEF3ZXNvbWVJY29ucygpO1xuICAgIC8vIENoZWNrIGZvciBhbmQgbG9hZCBmYWNlYm9vayBjb21tZW50cyBlbGVtZW50c1xuICAgIGNvbnN0IGhhc0ZiQ29tbWVudHMgPSBvcEZhY2Vib29rQ29tbWVudHMoKTtcbiAgICAvLyBDaGVjayBmb3Igb250cmFmb3Jtc1xuICAgIGNvbnN0IGhhc09udHJhRm9ybXMgPSBvcE9udHJhRm9ybXMoKTtcbiAgICAvLyBDaGVjayBmb3IgcmVjYXB0Y2hhIGVsZW1lbnRzXG4gICAgY29uc3QgaGFzUmVjYXB0Y2hhID0gb3BSZWNhcHRjaGEoKTtcbiAgICAvLyBDaGVjayBmb3IgY291bnRkb3duIHRpbWVyc1xuICAgIGNvbnN0IGhhc0NvdW50RG93blRpbWVyID0gb3BDb3VudERvd25UaW1lcigpO1xuICAgIC8vIENoZWNrIGZvciBvcmRlciBzdW1tYXJpZXNcbiAgICBjb25zdCBoYXNPcmRlclN1bW1hcnkgPSBvcE9yZGVyU3VtbWFyeSgpO1xuICAgIC8vIENoZWNrIGZvciBwYXltZW50IGluZm9cbiAgICBjb25zdCBoYXNQYXltZW50SW5mbyA9IG9wUGF5bWVudEluZm8oKTtcbiAgICAvLyBAVE9ETzogVGhpcyB3aWxsIGJlIGludmFsaWRhdGVkIGJ5IGR5bmFtaWMgYmxvY2tzLiBTZWUgaWYgdGhpcyBjb2RlIG5lZWRzIHVwZGF0aW5nXG4gICAgLy8gQ2hlY2sgZm9yIHJlY2FwdGNoYSBlbGVtZW50c1xuICAgIGNvbnN0IHJlQ2FwdGNoYUFycmF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggJy5nLXJlY2FwdGNoYScgKTtcblxuICAgIC8qXG4gICAgICogQGJyaWVmIEJ1aWxkIGFuZCBvciByZWZyZXNoIHN0aWNreSBibG9ja3MuXG4gICAgICovXG4gICAgb3AuYnVpbGRTdGlja3lCbG9ja3MgPSBmdW5jdGlvbiggc3RpY2t5QmxvY2tzICkge1xuXG4gICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgc3RpY2t5IGJsb2NrcyBvbiB0aGUgcGFnZSwgaWYgbm90IHJldHVybi4gSUYgeW91IHR1cm4gb2ZmIGEgZ2xvYmFsIHN0aWNreSBibG9jayB0aGUgc3RpY2t5IGJsb2NrIHNjcmlwdCBpcyBzdGlsbCBiYWNrZWQgaW50byB0aGUgcGFnZSB1bnRpbFxuICAgICAgICAvLyB0aGUgdXNlciByZXB1Ymxpc2hlcywgd2UgZ2V0IGFyb3VuZCB0aGlzIGJ5IGNoZWNraW5nIGlmIGFueSBvZiB0aGUgYmxvY2thcmUgc3RpbGwgc3RpY2t5IGJ5IGNoZWNraW5nIGZvciB0aGUgY2xhc3MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIGFuIGlmcmFtZSB2aWRlbyAoeW91dHViZSBvciB3aXN0aWEpIGlzIHBsYXlpbmcsIGRvbid0IHJlYnVpbGQgc3RpY2t5IGJsb2Nrcy5cbiAgICAgICAgLy8gV2UnbGwgYWxzbyBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgYSBpZnJhbWUgZW1iZWRkZWQgZm9ybS5cbiAgICAgICAgLy8gT1BGX19lbWJlZGRlZC1mb3JtIGlzIGNoZWNraW5nIGZvciBvbnRyYWZvcm1zLlxuICAgICAgICAvLyBbY2xhc3MqPVwibW9vbnJheS1mb3JtLWlmcmFtZVwiXSBpcyBjaGVja2luZyBmb3IgbGVnYWN5IGZvcm1zLlxuICAgICAgICBpZiAoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICcub3B0LXN0aWNreS1ibG9jaycgKS5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPT09ICdJRlJBTUUnICYmICggJCggZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50ICkuaGFzQ2xhc3MoICd2aWRlby1jb250YWluZXInICkgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jbG9zZXN0KCAnLk9QRl9fZW1iZWRkZWQtZm9ybScgKSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsb3Nlc3QoICdbY2xhc3MqPVwibW9vbnJheS1mb3JtLWlmcmFtZVwiXScgKSApICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBzdGljayBibG9ja3MgYW5kIG1ha2Ugc3VyZSB0aGF0IGFsbCBvZiB0aGUgYmxvY2tzIGFyZSBzdGlsbCBzdGlja3kgYnkgc2VhcmNoaW5nIGZvciB0aGUgYmxvY2sgaWQgYW5kIHZlcmlmeWluZyBpdCBoYXMgYSBzdGlja3kgYmxvY2sgY2xhc3MuIElmIGl0IGRvZXNuJ3RcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdGlja3libG9jayBmcm9tIHRoZSBsaXN0LlxuXG4gICAgICAgIGZvciAoIHZhciBpID0gc3RpY2t5QmxvY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuXG4gICAgICAgICAgICBsZXQgYmxvY2sgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCAnLm9wdC1pZC0nK3N0aWNreUJsb2Nrc1sgaSBdLmlkICk7XG4gICAgICAgICAgICBpZiAoICFibG9jayApIHtcbiAgICAgICAgICAgICAgICBzdGlja3lCbG9ja3Muc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCAhYmxvY2suY2xhc3NMaXN0LmNvbnRhaW5zKCAnb3B0LXN0aWNreS1ibG9jaycgKSApIHtcbiAgICAgICAgICAgICAgICBzdGlja3lCbG9ja3Muc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gSWYgd2UncmUgb24gYSBtb2JpbGUgcGFnZSwgYW5kIHRoZXJlJ3MgYW4gaW5wdXQgYWN0aXZlLCBoaWRlIHN0aWNreSBibG9ja3Mgc28gdGhleSBkb24ndCBjb3ZlciB0aGUgaW5wdXRcbiAgICAgICAgaWYgKCAoIGFjdGl2ZUVsZW1lbnQgPT09ICdJTlBVVCcgfHwgYWN0aXZlRWxlbWVudCA9PT0gJ1RFWFRBUkVBJyApICYmIG9wLmlzTW9iaWxlRGV2aWNlKCkgPT09IHRydWUgKSB7XG4gICAgICAgICAgICAvLyBIaWRlIGFsbCBzdGlja3kgYmxvY2tzXG4gICAgICAgICAgICAkKCAnLm9wdC1zdGlja3ktYmxvY2snICkuYWRkQ2xhc3MoICdvcHQtc3RpY2t5LWJsb2NrLS1oaWRkZW4nICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGhpZGRlbiBzdGlja3kgYmxvY2tzLCBzaG93IHRoZW1cbiAgICAgICAgICAgICQoICcub3B0LXN0aWNreS1ibG9jaycgKS5yZW1vdmVDbGFzcyggJ29wdC1zdGlja3ktYmxvY2stLWhpZGRlbicgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3AsIGJvdHRvbSwgc2VsZWN0b3IsICR3cmFwcGVyO1xuXG4gICAgICAgIC8vIENsZWFuIHVwLCBSZW1vdmUgYW55IHN0aWNreSB3cmFwcGVycyBpbiBjYXNlIHRoZSB1c2VyIGlzIHJlc2l6aW5nIGFuZCB3ZSBoYXZlIHRvIHJlZGVjbGFyZSBzdGlja3libG9ja3NcbiAgICAgICAgJCggJy5zdGlja3ktd3JhcHBlcicgKS5jaGlsZHJlbigpLnVud3JhcCgpO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHN0aWNreUJsb2Nrcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBibG9jayA9IHN0aWNreUJsb2Nrc1sgaSBdLFxuICAgICAgICAgICAgICAgICRzdGlja3lCbG9jayA9ICQoICcub3B0LWlkLScgKyBibG9jay5pZCApO1xuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICAgICAgaWYgKCAkc3RpY2t5QmxvY2sucHVzaHBpbiApIHtcbiAgICAgICAgICAgICAgICAkc3RpY2t5QmxvY2sucHVzaHBpbiggJ3JlbW92ZScgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHN0aWNreSBibG9jayBpcyBub3QgeWV0IHZpc2libGUgbm8gbmVlZCB0byBpbml0aWFsaXplIGl0IHlldC5cbiAgICAgICAgICAgIGlmICggJHN0aWNreUJsb2NrWyAwIF0uc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgdmlld3BvcnQgc2l6ZSByZXN0cmljdGlvbnNcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydCA9ICRzdGlja3lCbG9jay5hdHRyKCAnZGF0YS1ibG9jay12aWV3cG9ydC1kaXNwbGF5JyApO1xuICAgICAgICAgICAgaWYgKCB2aWV3cG9ydCAhPT0gJ2FsbCcgJiYgdmlld3BvcnQgIT09IG9wLmdldFZpZXdwb3J0U2l6ZSgpICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICRzdGlja3lCbG9jay5kYXRhKCAncHVzaHBpbklkJyApICkge1xuICAgICAgICAgICAgICAgICRzdGlja3lCbG9jay5wdXNocGluKCAncmVtb3ZlJyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkd3JhcHBlciA9ICRzdGlja3lCbG9jay5jbG9zZXN0KCAnLnN0aWNreS13cmFwcGVyJyApO1xuXG4gICAgICAgICAgICBpZiAoICEkd3JhcHBlci5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnLm9wdC1pZC0nICsgYmxvY2submV4dElkO1xuICAgICAgICAgICAgICAgICRzdGlja3lCbG9jay5uZXh0VW50aWwoIHNlbGVjdG9yICsgJ1tkYXRhLWJsb2NrLXZpZXdwb3J0LWRpc3BsYXk9XCJhbGxcIl0sJysgc2VsZWN0b3IgKydbZGF0YS1ibG9jay12aWV3cG9ydC1kaXNwbGF5PVwiJyArIG9wLmdldFZpZXdwb3J0U2l6ZSgpICsgJ1wiXScgKS5hZGRCYWNrKCkud3JhcEFsbCggJzxkaXYgY2xhc3M9XFwnc3RpY2t5LXdyYXBwZXJcXCcgLz4nICk7XG4gICAgICAgICAgICAgICAgJHdyYXBwZXIgPSAkc3RpY2t5QmxvY2suY2xvc2VzdCggJy5zdGlja3ktd3JhcHBlcicgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJHdyYXBwZXIuaGVpZ2h0KCAkd3JhcHBlci5oZWlnaHQoKSApO1xuXG4gICAgICAgICAgICB0b3AgPSAkd3JhcHBlci5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICBib3R0b20gPSAkd3JhcHBlci5vZmZzZXQoKS50b3AgKyAkc3RpY2t5QmxvY2sucGFyZW50KCkuaW5uZXJIZWlnaHQoKSAtICRzdGlja3lCbG9jay5vdXRlckhlaWdodCgpO1xuICAgICAgICAgICAgJHN0aWNreUJsb2NrLnB1c2hwaW4oIHtcbiAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICAgICAgICBoaWRlOiBibG9jay5oaWRlXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKlxuICAgICAqIEJvcnJvd2VkIGZyb20gVW5kZXJzY29yZS5qcyAxLjkuMVxuICAgICAqIFNvbWUgZnVuY3Rpb25zIHRha2UgYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCBvciBhIGZldyBleHBlY3RlZFxuICAgICAqIGFyZ3VtZW50cyBhdCB0aGUgYmVnaW5uaW5nIGFuZCB0aGVuIGEgdmFyaWFibGUgbnVtYmVyIG9mIHZhbHVlcyB0byBvcGVyYXRlXG4gICAgICogb24uIFRoaXMgaGVscGVyIGFjY3VtdWxhdGVzIGFsbCByZW1haW5pbmcgYXJndW1lbnRzIHBhc3QgdGhlIGZ1bmN0aW9u4oCZc1xuICAgICAqIGFyZ3VtZW50IGxlbmd0aCAob3IgYW4gZXhwbGljaXQgYHN0YXJ0SW5kZXhgKSwgaW50byBhbiBhcnJheSB0aGF0IGJlY29tZXNcbiAgICAgKiB0aGUgbGFzdCBhcmd1bWVudC4gU2ltaWxhciB0byBFUzbigJlzIFwicmVzdCBwYXJhbWV0ZXJcIi5cbiAgICAgKi9cbiAgICBvcC5yZXN0QXJndW1lbnRzID0gZnVuY3Rpb24oIGZ1bmMsIHN0YXJ0SW5kZXggKSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4ID09IG51bGwgPyBmdW5jLmxlbmd0aCAtIDEgOiArc3RhcnRJbmRleDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KCBhcmd1bWVudHMubGVuZ3RoIC0gc3RhcnRJbmRleCwgMCApLFxuICAgICAgICAgICAgICAgIHJlc3QgPSBBcnJheSggbGVuZ3RoICksXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgICAgICByZXN0WyBpbmRleCBdID0gYXJndW1lbnRzWyBpbmRleCArIHN0YXJ0SW5kZXggXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoIHN0YXJ0SW5kZXggKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwoIHRoaXMsIHJlc3QgKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCggdGhpcywgYXJndW1lbnRzWyAwIF0sIHJlc3QgKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCggdGhpcywgYXJndW1lbnRzWyAwIF0sIGFyZ3VtZW50c1sgMSBdLCByZXN0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5KCBzdGFydEluZGV4ICsgMSApO1xuICAgICAgICAgICAgZm9yICggaW5kZXggPSAwOyBpbmRleCA8IHN0YXJ0SW5kZXg7IGluZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgYXJnc1sgaW5kZXggXSA9IGFyZ3VtZW50c1sgaW5kZXggXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3NbIHN0YXJ0SW5kZXggXSA9IHJlc3Q7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSggdGhpcywgYXJncyApO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEJvcnJvd2VkIGZyb20gVW5kZXJzY29yZS5qcyAxLjkuMVxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgICAgKiBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gICAgICogTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gICAgICogbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgICAgKi9cbiAgICBvcC5kZWJvdW5jZSA9IGZ1bmN0aW9uKCBmdW5jLCB3YWl0LCBpbW1lZGlhdGUgKSB7XG4gICAgICAgIHZhciB0aW1lb3V0LCByZXN1bHQ7XG5cbiAgICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICggYXJncyApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KCBjb250ZXh0LCBhcmdzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRlYm91bmNlZCA9IG9wLnJlc3RBcmd1bWVudHMoIGZ1bmN0aW9uKCBhcmdzICkge1xuICAgICAgICAgICAgaWYgKCB0aW1lb3V0ICkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGltZW91dCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBpbW1lZGlhdGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxOb3cgPSAhdGltZW91dDtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCggbGF0ZXIsIHdhaXQgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGNhbGxOb3cgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoIHRoaXMsIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBvcC5kZWxheSggbGF0ZXIsIHdhaXQsIHRoaXMsIGFyZ3MgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSApO1xuXG4gICAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGltZW91dCApO1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9O1xuXG4gICAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAgIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgICBvcC5kZWxheSA9IG9wLnJlc3RBcmd1bWVudHMoIGZ1bmN0aW9uKCBmdW5jLCB3YWl0LCBhcmdzICkge1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyggLi4uYXJncyApO1xuICAgICAgICB9LCB3YWl0ICk7XG4gICAgfSApO1xuXG4gICAgLypcbiAgICAgKlxuICAgICAqL1xuICAgIG9wLmRpc3BsYXlTZXR0aW5ncyA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgZGlzcGxheURlbGF5ICkge1xuXG5cbiAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oIF9zZWxlY3RvciApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxldCBfJGJsb2NrID0gJCggX3NlbGVjdG9yICk7XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgdGhlIGJsb2NrIHRvIG5vdCBiZSB2aXNpYmxlXG4gICAgICAgICAgICAgICAgXyRibG9jay5jc3MoIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJycsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdHMgYSBzdGlja3kgYmxvY2sgcmVidWlsZCBhbGwgdGhlIHN0aWNreSBibG9jayB0aHJlc2hvbGRzXG4gICAgICAgICAgICAgICAgaWYgKCBfJGJsb2NrLmhhc0NsYXNzKCAnb3B0LXN0aWNreS1ibG9jaycgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgb3AuYnVpbGRTdGlja3lCbG9ja3MoIHN0aWNreUJsb2NrcyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFB1c2ggdGhlIG9wYWNpdHkgY2hhbmdlIHRvIHRoZSBib3R0b20gb2YgdGhlIHN0YWNrIHNvIHdlIGNhbiBzZWUgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbi5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV2ZWFsIHRoZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICBfJGJsb2NrLmNzcygge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgXyRibG9jay5yZW1vdmVDbGFzcyggJ2NvbmRpdGlvbnNfX2Rpc3BsYXlfdGltZV9zZWNvbmRzLS1oaWRkZW4nICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFueSBzbGlkZXNob3dzIGluIHRoZSBibG9jaywgcmVpbml0aWFsaXplIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlaXIgY29udGVudHMgd2lsbCBub3QgcmVuZGVyLlxuICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCBzbGlkZXNob3cgZWxlbWVudCBpbmRpdmlkdWFsbHkgc28gdGhhdCB0aGVpciBpbml0T3B0aW9uIGNhbiBiZSBhcHBsaWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGl2aWR1YWxseS5cbiAgICAgICAgICAgICAgICAgICAgbGV0ICRzbGlkZXNob3dzID0gXyRibG9jay5maW5kKCAnLm9wdC1lbGVtZW50LnNsaWRlcicgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAkc2xpZGVzaG93cy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBsZXQgaSA9IDAsIGwgPSAkc2xpZGVzaG93cy5sZW5ndGg7IGkgPCBsOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNsaWRlc2hvd3MuZXEoIGkgKS5zbGlkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICRzbGlkZXNob3dzID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIH0sIDAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSggc2VsZWN0b3IgKSwgZGlzcGxheURlbGF5ICk7XG5cbiAgICB9O1xuXG4gICAgb3AuZm9ybWF0Q3JlZGl0Q2FyZCA9ICggZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBBTUVYX0NBUkQgPSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogL14zWzQ3XS8sXG4gICAgICAgICAgICAgICAgZm9ybWF0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IDE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAneHh4eCAtIHh4eHh4eHggLSB4eHh4J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFRoaXMgcGF0dGVybiBjb3ZlcnMgdGhlIHJlc3Qgb2YgdGhlIGNhcmRzOiBWaXNhLCBNYXN0ZXJjYXJkLCBEaW5lcnMgQ2x1Yiwgb3IgSkNCXG4gICAgICAgICAgICBERUZBVUxUX0NBUkQgPSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IDIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAneHh4eCAtIHh4eHggLSB4eHh4IC0geHh4eCAtIHh4eHgnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ0NfREVMSU1JVEVSID0gJyAtICcsXG5cbiAgICAgICAgICAgIGdldENhcmRUeXBlID0gZnVuY3Rpb24oIGNjX251bSApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FyZFR5cGUgPSBERUZBVUxUX0NBUkQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGNjX251bS5tYXRjaCggQU1FWF9DQVJELnBhdHRlcm4gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FyZFR5cGUgPSBBTUVYX0NBUkQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcmRUeXBlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q2FyZEZvcm1hdFN0cmluZyA9IGZ1bmN0aW9uKCBjY19udW0sIGNhcmRfdHlwZSApIHtcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSBpbiBjYXJkX3R5cGUuZm9ybWF0cyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGNhcmRfdHlwZS5mb3JtYXRzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIGlmICggY2NfbnVtLmxlbmd0aCA8PSBmb3JtYXQubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gREVGQVVMVF9DQVJELmZvcm1hdHNbIDAgXS5mb3JtYXQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmb3JtYXRDYXJkTnVtYmVyID0gZnVuY3Rpb24oIGNjX251bSwgY2FyZF90eXBlICkge1xuICAgICAgICAgICAgICAgIHZhciBudW1BcHBlbmRlZENoYXJzID0gMCxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkTnVtYmVyID0gJyc7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFjYXJkX3R5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjY19udW07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNhcmRGb3JtYXRTdHJpbmcgPSBnZXRDYXJkRm9ybWF0U3RyaW5nKCBjY19udW0sIGNhcmRfdHlwZSApO1xuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgY2FyZEZvcm1hdEluZGV4ID0gMDsgaSA8IGNjX251bS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FyZEZvcm1hdEluZGV4ID0gaSArIG51bUFwcGVuZGVkQ2hhcnM7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWNhcmRGb3JtYXRTdHJpbmcgfHwgY2FyZEZvcm1hdEluZGV4ID49IGNhcmRGb3JtYXRTdHJpbmcubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNjX251bTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY2FyZEZvcm1hdFN0cmluZy5jaGFyQXQoIGNhcmRGb3JtYXRJbmRleCApICE9PSAneCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1BcHBlbmRlZENoYXJzICs9IENDX0RFTElNSVRFUi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWROdW1iZXIgKz0gQ0NfREVMSU1JVEVSICsgY2NfbnVtLmNoYXJBdCggaSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkTnVtYmVyICs9IGNjX251bS5jaGFyQXQoIGkgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZE51bWJlcjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG1vbml0b3JDY0Zvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciAkZWwgPSAkKCB0aGlzICksXG4gICAgICAgICAgICAgICAgICAgIGNjX251bSA9ICRlbC52YWwoKS5yZXBsYWNlKCAvXFxEL2csICcnICksXG4gICAgICAgICAgICAgICAgICAgIGNhcmRfdHlwZSA9IGdldENhcmRUeXBlKCBjY19udW0gKTtcbiAgICAgICAgICAgICAgICAkZWwudmFsKCBmb3JtYXRDYXJkTnVtYmVyKCBjY19udW0sIGNhcmRfdHlwZSApICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBtb25pdG9yQ2NGb3JtYXQ7XG4gICAgfSApKCk7XG5cbiAgICAvKlxuICAgICAqIEBicmllZiBTZWFyY2ggZm9yIG9yZGVyIGJ1bXBzIGluIHRoZSBzdWJtaXRlZCBmb3JtLiBEZXRlY3Qgd2hpY2ggYnVtcHMgaGF2ZSBiZWVuIG9wdGVkIGludG8sIGNoZWNrIGZvciBlZGl0YWJsZSBxdWFudGl0eVxuICAgICAqICAgICAgICB0aGVuIGJ1aWxkIHRoZSBvcmRlcmJ1bXAgdmFsdWUgYW5kIGFkZCBpdCB0byB0aGUgZm9ybSBwYXlsb2FkLlxuICAgICAqIEBwYXJhbSAkZm9ybSB7alF1ZXJ5fSByZWZlcmVuY2UgdG8gdGhlIGZvcm0gdGhhdCBoYXMgYmVlbiBzdWJtaXRlZC5cbiAgICAgKi9cbiAgICBvcC5nZXRPcmRlckJ1bXBzID0gZnVuY3Rpb24oICRmb3JtICkge1xuXG4gICAgICAgIHZhciAkb3JkZXJCdW1wcyA9ICRmb3JtLmZpbmQoICcub3B0LW9yZGVyLWJ1bXBbb2ZmZXJdJyApLFxuICAgICAgICAgICAgcGF5bG9hZCA9IHt9LFxuICAgICAgICAgICAgY2hlY2tib3gsXG4gICAgICAgICAgICBxdWFudGl0eVdyYXBwZXIsXG4gICAgICAgICAgICBxdWFudGl0eUlucHV0LFxuICAgICAgICAgICAgcXVhbnRpdHlWYWx1ZSxcbiAgICAgICAgICAgICRpbnB1dDtcblxuICAgICAgICAvLyBObyBvcmRlciBidW1wcyByZXR1cm4gZmFsc2UuXG4gICAgICAgIGlmICggISRvcmRlckJ1bXBzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgICRvcmRlckJ1bXBzLmVhY2goIGZ1bmN0aW9uKCBpbmRleCwgYnVtcCApIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG9yZGVyIGJ1bXAgaXMgY2hlY2tlIC8gb3B0ZWQgaW5cbiAgICAgICAgICAgIGNoZWNrYm94ID0gYnVtcC5xdWVyeVNlbGVjdG9yKCAnW3R5cGU9XCJjaGVja2JveFwiXScgKTtcbiAgICAgICAgICAgIGlmICggY2hlY2tib3guY2hlY2tlZCApIHtcbiAgICAgICAgICAgICAgICBxdWFudGl0eVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBxdWFudGl0eVdyYXBwZXIgPSBidW1wLnF1ZXJ5U2VsZWN0b3IoICcub3B0LW9yZGVyLWJ1bXBfX3F1YW50aXR5JyApO1xuICAgICAgICAgICAgICAgIGlmICggcXVhbnRpdHlXcmFwcGVyLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyApIHtcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHlJbnB1dCA9IGJ1bXAucXVlcnlTZWxlY3RvciggJy5vcHQtb3JkZXItYnVtcF9fcXVhbnRpdHktaW5wdXQnICk7XG4gICAgICAgICAgICAgICAgICAgIHF1YW50aXR5VmFsdWUgPSBxdWFudGl0eUlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXlsb2FkWyBidW1wLmdldEF0dHJpYnV0ZSggJ29wdC1pZCcgKSBdID0gcXVhbnRpdHlWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9ICk7XG5cbiAgICAgICAgLy8gTm8gb3JkZXIgYnVtcHMgYXJlIHNlbGVjdGVkIHJldHVybiBmYWxzZVxuICAgICAgICBpZiAoICQuaXNFbXB0eU9iamVjdCggcGF5bG9hZCApICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgaGF2ZSBzZWxlY3RlZCBvcmRlciBidW1wcyBzbyBhZGQgdGhlIG9yZGVyYnVtcHMgaW5wdXQgdG8gdGhlIGZvcm1cbiAgICAgICAgJGlucHV0ID0gJCggJzxpbnB1dCBuYW1lPVwib3JkZXJidW1wc1wiIHR5cGU9XCJoaWRkZW5cIiAvPicgKTtcbiAgICAgICAgJGlucHV0LnZhbCggSlNPTi5zdHJpbmdpZnkoIHBheWxvYWQgKSApO1xuICAgICAgICAkZm9ybS5hcHBlbmQoICRpbnB1dCApO1xuXG4gICAgfTtcblxuICAgIC8qXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2aWV3cG9ydCBzaXplLiBJIG1hZGUgYSBoZWxwZXIgc28gd2UgaGF2ZSBhIGNlbnRyYWwgcGxhY2VcbiAgICAgKiB0byBkbyB0aGlzIGNoZWNrIGFuZCBleHRlbmQgaXQuIFRoZSByZXR1cm4gdmFsdWVzIHNob3VsZCBtYXRjaCB0aGUgcG9zc2libGUgdmFsdWVzIG9mIHRoZSBvcHQgZWxlbWVudFxuICAgICAqIGRhdGEtYmxvY2stdmlld3BvcnQtZGlzcGxheSB2YWx1ZXMgdXNlZCBpbiBibG9ja192My5qcyBhbmQgb3B0Lm1hdGVyaWFsaXplY3NzLmNzcy5cbiAgICAgKi9cbiAgICBvcC5nZXRWaWV3cG9ydFNpemUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbW9iaWxlU2l6ZSA9ICtvcC5tb2JpbGVCcmVha3BvaW50IHx8IDYwMCxcbiAgICAgICAgICAgIHdpZHRoID0gd2luZG93Lm91dGVyV2lkdGgsXG4gICAgICAgICAgICBzaXplID0gJ2Rlc2t0b3AnO1xuXG4gICAgICAgIGlmICggd2lkdGggPD0gbW9iaWxlU2l6ZSApIHtcbiAgICAgICAgICAgIHNpemUgPSAnbW9iaWxlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG5cbiAgICAvLyBEYXRhIHRhcmdldCBpZCBvZiB0aGUgbGFzdCBvcGVuZWQgbWF0ZXJpYWwgc2VsZWN0IGZpZWxkLiBXZSBrZWVwIHRyYWNrIG9mIGl0IGJlY2F1c2Ugd2UgbmVlZCBpdCB0byB0b2dnbGUgdGhlIHppbmRleCBvZiB0aGUgY29udGFpbmluZyBibG9ja3Mvcm93c1xuICAgIG9wLm1hdGVyaWFsU2VsZWN0TGFzdCA9IG51bGw7XG5cbiAgICAvKlxuICAgICAqIEBicmllZiBNYXRlcmlhbCBzZWxlY3QgY2xvc2UgY2FsbGJhY2suIFRvZ2dsZSB0aGUgYmxvY2sgYW5kIHJvdyB6LWluZGV4IGJhY2sgdG8gdGhlcmUgb3JpZ2luYWwgdmFsdWVzIGlmIHRoZXkgaGF2ZSBiZWVuIG1vZGlmaWVkIGJlY2F1c2Ugb2YgYSBzZWxlY3Qgb3BlbmluZyB1cHdhcmQuXG4gICAgICovXG4gICAgb3AubWF0ZXJpYWxTZWxlY3RDbG9zZSA9IGZ1bmN0aW9uKCBzZWxlY3QgKSB7XG4gICAgICAgIHZhciBjb2wgPSBzZWxlY3QuY2xvc2VzdCggJy5jb2xfX3N0eWxlJyApO1xuXG4gICAgICAgIC8vIFdoZW4gbWF0ZXJpYWxpemUgZHJvcGRvd25zIGFyZSBjbG9zaW5nLCBtYWtlIHN1cmUgd2UgcmVtb3ZlIGFueSBvdmVyZmxvd1xuICAgICAgICAvLyB0aGF0IHdlIGhhcmRjb2RlZCB3aGVuIHRoZSBkcm9wZG93biB3YXMgb3BlbmluZ1xuICAgICAgICBpZiAoIGNvbCApIHtcbiAgICAgICAgICAgIGNvbC5zdHlsZS5vdmVyZmxvdyA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGEgc2VsZWN0IHRoYXQgb3BlbnMgdG93YXJkcyB0aGUgdG9wIGFib3J0IG1pc3Npb24uXG4gICAgICAgIGlmICggcGFyc2VJbnQoIHRoaXMuZHJvcGRvd25FbC5zdHlsZS50b3AgKSA+PSAwICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSB3cmFwcGluZyBibG9jayBhbmQgcm93cyBhbmQgcmVzdG9yZSB0aGVpciBvcmlnaW5hbCB6LWluZGV4LlxuICAgICAgICB2YXIgYmxvY2sgPSBzZWxlY3QuY2xvc2VzdCggJ1tvcHQtdHlwZT1cImJsb2NrLXYzXCJdJyApLFxuICAgICAgICAgICAgcm93ID0gc2VsZWN0LmNsb3Nlc3QoICcucm93JyApO1xuXG4gICAgICAgIGlmICggdGhpcy5pZCA9PT0gb3AubWF0ZXJpYWxTZWxlY3RMYXN0ICkge1xuXG4gICAgICAgICAgICBpZiAoIGJsb2NrLnpJbmRleFZhbCB8fCBibG9jay56SW5kZXhWYWwgPT09ICcnICkge1xuICAgICAgICAgICAgICAgIGJsb2NrLnN0eWxlLnpJbmRleCA9IGJsb2NrLnpJbmRleFZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCByb3cuekluZGV4VmFsIHx8IHJvdy56SW5kZXhWYWwgPT09ICcnICkge1xuICAgICAgICAgICAgICAgIHJvdy5zdHlsZS56SW5kZXggPSByb3cuekluZGV4VmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGNvbC56SW5kZXhWYWwgfHwgY29sLnpJbmRleFZhbCA9PT0gJycgKSB7XG4gICAgICAgICAgICAgICAgY29sLnN0eWxlLnpJbmRleCA9IGNvbC56SW5kZXhWYWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQGJyaWVmIE1hdGVyaWFsIHNlbGVjdCBvcGVuIGNhbGxiYWNrLCB3ZSB0b2dnbGUgdGhlIHJvdyBhbmQgYmxvY2sgemluZGV4IHRvIGF1dG8gc28gc2VsZWN0IG9wdGlvbnMgd2lsbCBvcGVuIG9uIHRvcCBvZiByb3dzIGFuZCBjb2x1bW5zIGFib3ZlIHRoZW0uXG4gICAgICAgICAgICAgIE5vdGUsIFRoaXMgcnVucyBvbiAgc2VsZWN0T3BlblN0YXJ0IGV2ZW50IHNvIHdlIGhhdmUgdG8gdXNlIHRoZSBzZXR0aW1lb3V0LlxuICAgICAgICAgICAgICBXZSBjYW4ndCBydW4gdGhpcyBvbiB0aGUgZW5kIG9mIHRoZSBvcGVuIGJlY2F1c2UgbWF0ZXJpYWxpemUgaGFyZCBjb2RlcyBhIGZ1bnRpb24gb250byB0aGF0IGNhbGxiYWNrLlxuICAgICAgICAgICAgICBOZXJkcy4uXG4gICAgICogQHRvZG8gIFN0aWxsIGhhdmUgYW4gZWRnZSBjYXNlLCBpZiB0aGUgc2VsZWN0IG9wdGlvbnMgZG9uJ2UgZXhjZWVkIHRoZSBzaXplIG9mIHRoZSByb3cgb3IgYmxvY2sgd2UgZG9uJ3QgbmVlZCB0byBkbyB0aGlzLlxuICAgICAqL1xuICAgIG9wLm1hdGVyaWFsU2VsZWN0T3BlbiA9IGZ1bmN0aW9uKCBzZWxlY3QgKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gdXNlIGEgc2V0VGltZW91dCBzbyB3ZSBnaXZlIHRoZSBzZWxlY3Qgb3B0aW9ucyB0aW1lIHRvIHJlbmRlci4gVGhlbiB3ZSBjYW4gY2FsbCBfZ2V0RHJvcGRvd25Qb3N0aW9uIHRvIGRldGVybWluZSBpZiB0aGUgc2VsZWN0IGlzIG9wZW5pbmcgdXB3YXJkLlxuICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5fZ2V0RHJvcGRvd25Qb3NpdGlvbigpLFxuICAgICAgICAgICAgICAgIG1vYmlsZVNpemUgPSArb3AubW9iaWxlQnJlYWtwb2ludCB8fCA2MDA7XG5cbiAgICAgICAgICAgIG9wLm1hdGVyaWFsU2VsZWN0TGFzdCA9IHRoaXMuaWQ7XG5cbiAgICAgICAgICAgIHZhciBjb2wgPSBzZWxlY3QuY2xvc2VzdCggJy5jb2xfX3N0eWxlJyApO1xuXG4gICAgICAgICAgICBpZiAoIGNvbCApIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSB0aGUgY29sdW1uIHN0eWxlIHRvIG92ZXJmbG93IHZpc2libGUgd2hlbiB0aGUgZHJvcGRvd24gaXMgb3BlbmluZyxcbiAgICAgICAgICAgICAgICAvLyBpbmNhc2UgaXQgd2FzIGhpZGRlbiBpZiBib3JkZXIgcmFkaXVzIHdhcyBhZGRlZFxuICAgICAgICAgICAgICAgIGNvbC5zdHlsZS5vdmVyZmxvdyA9ICd2aXNpYmxlJztcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBvbiBtb2JpbGUsIHRoZSBjb2x1bW5zIGFyZSBzdGFja2VkIHNvIHdlIG5lZWQgdG8gYnVtcCB1cCB0aGUgY29sdW1uIHotaW5kZXggd2hpbGUgZHJvcGRvd24gaXMgb3BlblxuICAgICAgICAgICAgICAgIGlmICggd2luZG93LmlubmVyV2lkdGggPD0gbW9iaWxlU2l6ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhY29sLnpJbmRleFZhbCAmJiBjb2wuekluZGV4VmFsICE9PSAnJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbC56SW5kZXhWYWwgPSBjb2wuc3R5bGUuekluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29sLnN0eWxlLnpJbmRleCA9ICc5OTk5JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKCBwLnZlcnRpY2FsQWxpZ25tZW50ID09PSdib3R0b20nICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gc2VsZWN0LmNsb3Nlc3QoICdbb3B0LXR5cGU9XCJibG9jay12M1wiXScgKSxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gc2VsZWN0LmNsb3Nlc3QoICcucm93JyApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhYmxvY2suekluZGV4VmFsICYmIGJsb2NrLnpJbmRleFZhbCAhPT0gJycgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnpJbmRleFZhbCA9IGJsb2NrLnN0eWxlLnpJbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoICFyb3cuekluZGV4VmFsICYmIHJvdy56SW5kZXhWYWwgIT09ICcnICkge1xuICAgICAgICAgICAgICAgICAgICByb3cuekluZGV4VmFsID0gcm93LnN0eWxlLnpJbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBibG9jay5zdHlsZS56SW5kZXggPSAnOTk5OSc7XG4gICAgICAgICAgICAgICAgcm93LnN0eWxlLnpJbmRleCA9ICc5OTk5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKCB0aGlzICksNTAgKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBCb3Jyb3dlZCBmcm9tIHVuZGVyc2NvcmUganNcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgICAgKiBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgICAgKiBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gICAgICogYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgICAgKiBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgICAgKi9cbiAgICBvcC50aHJvdHRsZSA9IGZ1bmN0aW9uKCBmdW5jLCB3YWl0LCBvcHRpb25zICkge1xuICAgICAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgICAgIGlmICggIW9wdGlvbnMgKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSggY29udGV4dCwgYXJncyApO1xuICAgICAgICAgICAgaWYgKCAhdGltZW91dCApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKCAhcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKCBub3cgLSBwcmV2aW91cyApO1xuICAgICAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgaWYgKCByZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0ICkge1xuICAgICAgICAgICAgICAgIGlmICggdGltZW91dCApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KCBjb250ZXh0LCBhcmdzICk7XG4gICAgICAgICAgICAgICAgaWYgKCAhdGltZW91dCApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoICF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCBsYXRlciwgcmVtYWluaW5nICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEBicmllZiBFdmVudCBoYW5kbGVyIHJ1biB3aGVuIG9yZGVyIGJ1bXAgaXMgY2hlY2tlZC91bmNoZWNrZWQuIFRoaXMgYWRkcy9yZW1vdmVzIHRoZSBvcmRlciBidW1wIHRvL2Zyb20gdGhlIG9yZGVyIHN1bW1hcnlcbiAgICAgKiBAcGFyYW0gZXYge2V2ZW50fSBldmVudCByZWZlcmVuY2UgZnJvbSB0aGUgY2hlY2tib3ggZXZlbnQuXG4gICAgICovXG4gICAgb3AudXBkYXRlT3JkZXJTdW1tYXJ5V2l0aE9yZGVyQnVtcCA9IGZ1bmN0aW9uKCBldiApIHtcblxuXG4gICAgICAgIHZhciBmb3JtID0gZXYudGFyZ2V0LmNsb3Nlc3QoICdmb3JtJyApLFxuICAgICAgICAgICAgb3JkZXJTdW1tYXJ5ID0gZm9ybSAmJiBmb3JtLnF1ZXJ5U2VsZWN0b3IoICdvbnRyYXBvcnQtb3JkZXItc3VtbWFyeScgKTtcblxuICAgICAgICBpZiAoIG9yZGVyU3VtbWFyeSApIHtcbiAgICAgICAgICAgIHZhciBvcmRlckJ1bXAgPSBldi50YXJnZXQuY2xvc2VzdCggJy5vcHQtb3JkZXItYnVtcCcgKSxcbiAgICAgICAgICAgICAgICBvYk9mZmVyID0gSlNPTi5wYXJzZSggb3JkZXJCdW1wLmdldEF0dHJpYnV0ZSggJ29mZmVyJyApICksXG4gICAgICAgICAgICAgICAgb2JUYXhlcyA9IEpTT04ucGFyc2UoIG9yZGVyQnVtcC5nZXRBdHRyaWJ1dGUoICd0YXhlcycgKSApLFxuICAgICAgICAgICAgICAgIG9iU2hpcHBpbmcgPSBKU09OLnBhcnNlKCBvcmRlckJ1bXAuZ2V0QXR0cmlidXRlKCAnc2hpcHBpbmcnICkgKSxcblxuICAgICAgICAgICAgICAgIG9zT2ZmZXIgPSBKU09OLnBhcnNlKCBvcmRlclN1bW1hcnkuZ2V0QXR0cmlidXRlKCAnb2ZmZXInICkgKSxcbiAgICAgICAgICAgICAgICBvc1RheGVzID0gSlNPTi5wYXJzZSggb3JkZXJTdW1tYXJ5LmdldEF0dHJpYnV0ZSggJ3RheGVzJyApICksXG4gICAgICAgICAgICAgICAgb3NTaGlwcGluZyA9IEpTT04ucGFyc2UoIG9yZGVyU3VtbWFyeS5nZXRBdHRyaWJ1dGUoICdzaGlwcGluZycgKSApLFxuICAgICAgICAgICAgICAgIGlzQ2hlY2tlZCA9IGV2LnRhcmdldC5jaGVja2VkO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcHJlc2VydmUgdGhlIGV4aXN0aW5nIGNvdXBvbiBvZmZlciBpZiBwcmVzZW50XG4gICAgICAgICAgICBjb25zdCBncmlkID0gZm9ybS5xdWVyeVNlbGVjdG9yKCAnLm1vb25yYXktZnJvbS1vZmZlci1ncmlkJyApO1xuICAgICAgICAgICAgaWYgKCAhZ3JpZCApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm5pbmcoICd1cGRhdGVPcmRlclN1bW1hcnlXaXRoT3JkZXJCdW1wKCksIGZhaWx1cmUgdG8gZmluZCB0aGUgb2ZmZXIgZ3JpZC4gJyApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb2ZmZXJFbGVtZW50ID0gJCggZ3JpZCApO1xuICAgICAgICAgICAgICAgIGlmICggb2ZmZXJFbGVtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29udHJvbGxlciA9IG9mZmVyRWxlbWVudC5jb250cm9sbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY29udHJvbGxlciAmJiBjb250cm9sbGVyLm9mZmVyQ29weSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50T2ZmZXJDb3Vwb24gPSBjb250cm9sbGVyLm9mZmVyQ29weS5zZXJpYWxpemUoKS5jb3Vwb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGN1cnJlbnRPZmZlckNvdXBvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvc09mZmVyLmNvdXBvbiA9IGN1cnJlbnRPZmZlckNvdXBvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHByb2R1Y3RzIHdpdGggZWRpdGFibGUgcXVhbnRpdHkgd2UgbmVlZCB0byB1cGRhdGUgdGhlbSBpbiB0aGUgb2ZmZXIgaWYgdGhlIHVzZXIgaGFzIG1hZGUgY2hhbmdlc1xuICAgICAgICAgICAgb3NPZmZlci5wcm9kdWN0cy5mb3JFYWNoKCAoIHByb2R1Y3QgKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCBwcm9kdWN0LnF1YW50aXR5RWRpdGFibGUgPT0gdHJ1ZSB8fCBwcm9kdWN0LnF1YW50aXR5RWRpdGFibGUgPT0gJ3RydWUnICkge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0LnF1YW50aXR5ID0gK2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoICdbbmFtZSo9XCInICsgcHJvZHVjdC51aWQgKyAnXCJdJyApLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIC8vIElmIGNoZWNrZWQsIGFkZCBwcm9kdWN0cyBhbmQgdGF4ZXMgb2Ygb3JkZXIgYnVtcCBmcm9tIHRoZSBvcmRlciBzdW1tYXJ5XG4gICAgICAgICAgICBpZiAoIGlzQ2hlY2tlZCApIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBvcmRlciBidW1wIHByb2R1Y3RzIHRvIGhhdmUgdGhlaXIgcXVhbnRpdHkgYmUgbm90IGVkaXRhYmxlIHdoZW4gYWRkaW5nIHRvIHRoZSBvcmRlciBzdW1tYXJ5LlxuICAgICAgICAgICAgICAgIC8vIEVkaXRhYmxlIHF1YW50aXR5IHNob3VsZCBiZSBlZGl0ZWQgaW4gdGhlIG9yZGVyIGJ1bXBcbiAgICAgICAgICAgICAgICBvYk9mZmVyLnByb2R1Y3RzID0gb2JPZmZlci5wcm9kdWN0cy5tYXAoIGZ1bmN0aW9uKCBvYlByb2R1Y3QgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iUHJvZHVjdC5xdWFudGl0eUVkaXRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYlByb2R1Y3Q7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgb3NPZmZlci5wcm9kdWN0cyA9IG9zT2ZmZXIucHJvZHVjdHMuY29uY2F0KCBvYk9mZmVyLnByb2R1Y3RzICk7XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBvcmRlciBzdW1tYXJ5J3MgdGF4IElEcyBzbyB0aGF0IHdlIGNhbiBmaWx0ZXIgdGhvc2Ugb3V0IG9mIHRoZSBvcmRlciBidW1wIHRvIHByZXZlbnQgZHVwbGljYXRlcy5cbiAgICAgICAgICAgICAgICB2YXIgb3NUYXhJZHMgPSBvc1RheGVzLm1hcCggZnVuY3Rpb24oIG9zVGF4ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3NUYXguaWQ7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdGF4ZXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNlbnQgaW4gdGhlIE9TIHNvIHdlIGRvbid0IHJlYWRkIHRoZW1cbiAgICAgICAgICAgICAgICBvYlRheGVzID0gb2JUYXhlcy5maWx0ZXIoIGZ1bmN0aW9uKCBvYlRheCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFvc1RheElkcy5pbmNsdWRlcyggb2JUYXguaWQgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICBvc1RheGVzID0gb3NUYXhlcy5jb25jYXQoIG9iVGF4ZXMgKTtcbiAgICAgICAgICAgICAgICBvc1NoaXBwaW5nID0gb3NTaGlwcGluZy5jb25jYXQoIG9iU2hpcHBpbmcgKTtcblxuICAgICAgICAgICAgICAgIC8vIEVsc2Ugbm90IGNoZWNrZWQsIHNvIHJlbW92ZSB0aGUgcHJvZHVjdHMgYW5kIHRheGVzIG9mIG9yZGVyIGJ1bXAgZnJvbSB0aGUgb3JkZXIgc3VtbWFyeVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBvcmRlciBidW1wJ3MgcHJvZHVjdCBhbmQgdGF4IElEcyB0byBrbm93IHdoYXQgdG8gcmVtb3ZlIGZyb20gdGhlIG9yZGVyIHN1bW1hcnlcbiAgICAgICAgICAgICAgICB2YXIgb2JQcm9kdWN0SWRzID0gb2JPZmZlci5wcm9kdWN0cy5tYXAoIGZ1bmN0aW9uKCBvYlByb2R1Y3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JQcm9kdWN0LmlkO1xuICAgICAgICAgICAgICAgICAgICB9ICksXG4gICAgICAgICAgICAgICAgICAgIG9iVGF4SWRzID0gb2JUYXhlcy5tYXAoIGZ1bmN0aW9uKCBvYlRheCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYlRheC5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSApLFxuICAgICAgICAgICAgICAgICAgICBvYlNoaXBwaW5nSWRzID0gb2JTaGlwcGluZy5tYXAoIGZ1bmN0aW9uKCBvYlNoaXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JTaGlwLmlkO1xuICAgICAgICAgICAgICAgICAgICB9ICksXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZ3JhYnMgYWxsIG9yZGVyIGJ1bXBzIHByZXNlbnQgYmVzaWRlcyB0aGUgb25lIHRoYXQgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJPcmRlckJ1bXBzID0gZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCAnLm9wdC1vcmRlci1idW1wW29mZmVyXTpub3QoW29wdC1pZD1cIicgKyBvcmRlckJ1bXAuZ2V0QXR0cmlidXRlKCAnb3B0LWlkJyApICsgJ1wiXSknICk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGxvb3BzIG92ZXIgYWxsIG90aGVyIG9yZGVyIGJ1bXBzIChiZXNpZGVzIHRoZSBvbmUgdGhhdCB3YXMganVzdCB1bmNoZWNrZWQpIGFuZCBpZiB0aGUgb3RoZXJcbiAgICAgICAgICAgICAgICAvLyBPcmRlciBidW1wIGlzIGNoZWNrZWQsIGl0IGNvbXBhcmVzIGl0cyB0YXggSURzIHRvIHRob3NlIGluIHRoZSBvYlRheElkcyBhcnJheSBhbmQgcmVtb3ZlcyB0aGVtLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBwcmV2ZW50IHRoZSB1bmNoZWNraW5nIG9mIGFuIG9yZGVyIGJ1bXAgZnJvbSByZW1vdmluZyBhIHRheCBpZiBpdCBpcyBhbHNvIHByZXNlbnRcbiAgICAgICAgICAgICAgICAvLyBJbiBhbm90aGVyIG9yZGVyIGJ1bXAgdGhhdCBpcyBjdXJyZW50bHkgY2hlY2tlZC5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBvdGhlck9yZGVyQnVtcHMubGVuZ3RoLCBvdGhlck9iVGF4SWRzLCBvdGhlck9iU2hpcHBpbmdJZHM7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggb3RoZXJPcmRlckJ1bXBzWyBpIF0ucXVlcnlTZWxlY3RvciggJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScgKS5jaGVja2VkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlck9iVGF4SWRzID0gSlNPTi5wYXJzZSggb3RoZXJPcmRlckJ1bXBzWyBpIF0uZ2V0QXR0cmlidXRlKCAndGF4ZXMnICkgKS5tYXAoIGZ1bmN0aW9uKCBvYlRheCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JUYXguaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iVGF4SWRzID0gb2JUYXhJZHMuZmlsdGVyKCBmdW5jdGlvbiggb2JUYXhJZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIW90aGVyT2JUYXhJZHMuaW5jbHVkZXMoIG9iVGF4SWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJPYlNoaXBwaW5nSWRzID0gSlNPTi5wYXJzZSggb3RoZXJPcmRlckJ1bXBzWyBpIF0uZ2V0QXR0cmlidXRlKCAnc2hpcHBpbmcnICkgKS5tYXAoIGZ1bmN0aW9uKCBvYlNoaXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iU2hpcC5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb2JTaGlwcGluZ0lkcyA9IG9iU2hpcHBpbmdJZHMuZmlsdGVyKCBmdW5jdGlvbiggaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFvYlNoaXBwaW5nSWRzLmluY2x1ZGVzKCBpZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb3JkZXIgYnVtcCdzIHByb2R1Y3RzIGZyb20gdGhlIG9yZGVyIHN1bW1hcnkgb2ZmZXJcbiAgICAgICAgICAgICAgICBvc09mZmVyLnByb2R1Y3RzID0gb3NPZmZlci5wcm9kdWN0cy5maWx0ZXIoIGZ1bmN0aW9uKCBvc1Byb2R1Y3QgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhb2JQcm9kdWN0SWRzLmluY2x1ZGVzKCBvc1Byb2R1Y3QuaWQgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9yZGVyIGJ1bXAncyB0YXhlcyBmcm9tIHRoZSBvcmRlciBzdW1tYXJ5IHRheGVzXG4gICAgICAgICAgICAgICAgb3NUYXhlcyA9IG9zVGF4ZXMuZmlsdGVyKCBmdW5jdGlvbiggb3NUYXggKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhb2JUYXhJZHMuaW5jbHVkZXMoIG9zVGF4LmlkICk7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvcmRlciBidW1wJ3Mgc2hpcHBpbmcgZnJvbSB0aGUgb3JkZXIgc3VtbWFyeSBzaGlwcGluZ1xuICAgICAgICAgICAgICAgIG9zU2hpcHBpbmcgPSBvc1NoaXBwaW5nLmZpbHRlciggZnVuY3Rpb24oIG9zU2hpcCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFvYlNoaXBwaW5nSWRzLmluY2x1ZGVzKCBvc1NoaXAuaWQgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3JkZXJTdW1tYXJ5LnNldEF0dHJpYnV0ZSggJ29mZmVyJywgSlNPTi5zdHJpbmdpZnkoIG9zT2ZmZXIgKSApO1xuICAgICAgICAgICAgb3JkZXJTdW1tYXJ5LnNldEF0dHJpYnV0ZSggJ3RheGVzJywgSlNPTi5zdHJpbmdpZnkoIG9zVGF4ZXMgKSApO1xuICAgICAgICAgICAgb3JkZXJTdW1tYXJ5LnNldEF0dHJpYnV0ZSggJ3NoaXBwaW5nJywgSlNPTi5zdHJpbmdpZnkoIG9zU2hpcHBpbmcgKSApO1xuXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgb3AudXBkYXRlT3JkZXJCdW1wUXVhbnRpdHkgPSBmdW5jdGlvbiggZXYgKSB7XG4gICAgICAgIHZhciBmb3JtID0gZXYudGFyZ2V0LmNsb3Nlc3QoICdmb3JtJyApLFxuICAgICAgICAgICAgb3JkZXJTdW1tYXJ5ID0gZm9ybSAmJiBmb3JtLnF1ZXJ5U2VsZWN0b3IoICdvbnRyYXBvcnQtb3JkZXItc3VtbWFyeScgKTtcblxuICAgICAgICBpZiAoIG9yZGVyU3VtbWFyeSApIHtcbiAgICAgICAgICAgIHZhciBvcmRlckJ1bXAgPSBldi50YXJnZXQuY2xvc2VzdCggJy5vcHQtb3JkZXItYnVtcCcgKSxcbiAgICAgICAgICAgICAgICBvYk9mZmVyID0gSlNPTi5wYXJzZSggb3JkZXJCdW1wLmdldEF0dHJpYnV0ZSggJ29mZmVyJyApICksXG4gICAgICAgICAgICAgICAgbmV3UXVhbnRpdHkgPSBldi50YXJnZXQudmFsdWUsXG4gICAgICAgICAgICAgICAgZWRpdGFibGVJZDtcblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZWRpdGFibGUgcHJvZHVjdCwgdXBkYXRlIGl0cyBxdWFudGl0eSwgYW5kIHNhdmUgdGhlIElEIGluY2FzZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcHJvZHVjdFxuICAgICAgICAgICAgb2JPZmZlci5wcm9kdWN0cyA9IG9iT2ZmZXIucHJvZHVjdHMubWFwKCBmdW5jdGlvbiggb2JQcm9kdWN0ICkge1xuICAgICAgICAgICAgICAgIGlmICggb2JQcm9kdWN0LnF1YW50aXR5RWRpdGFibGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlSWQgPSBvYlByb2R1Y3QuaWQ7XG4gICAgICAgICAgICAgICAgICAgIG9iUHJvZHVjdC5xdWFudGl0eSA9IG5ld1F1YW50aXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JQcm9kdWN0O1xuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICBvcmRlckJ1bXAuc2V0QXR0cmlidXRlKCAnb2ZmZXInLCBKU09OLnN0cmluZ2lmeSggb2JPZmZlciApICk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBvcmRlciBidW1wIGlzIGNoZWNrZWQsIGFsc28gdXBkYXRlIHRoZSBvcmRlciBzdW1tYXJ5J3MgcHJvZHVjdCBxdWFudGl0eVxuICAgICAgICAgICAgaWYgKCBvcmRlckJ1bXAucXVlcnlTZWxlY3RvciggJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScgKS5jaGVja2VkICkge1xuICAgICAgICAgICAgICAgIHZhciBvc09mZmVyID0gSlNPTi5wYXJzZSggb3JkZXJTdW1tYXJ5LmdldEF0dHJpYnV0ZSggJ29mZmVyJyApICk7XG5cbiAgICAgICAgICAgICAgICBvc09mZmVyLnByb2R1Y3RzID0gb3NPZmZlci5wcm9kdWN0cy5tYXAoIGZ1bmN0aW9uKCBvc1Byb2R1Y3QgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggb3NQcm9kdWN0LmlkID09PSBlZGl0YWJsZUlkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3NQcm9kdWN0LnF1YW50aXR5ID0gbmV3UXVhbnRpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3NQcm9kdWN0O1xuICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgIG9yZGVyU3VtbWFyeS5zZXRBdHRyaWJ1dGUoICdvZmZlcicsIEpTT04uc3RyaW5naWZ5KCBvc09mZmVyICkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEBicmllZiBTZXQgdmFsdWUgb24gYSBzaGlwcGluZyBmaWVsZFxuICAgICAqL1xuICAgIG9wLnNldFNoaXBwaW5nRmllbGRWYWx1ZSA9IGZ1bmN0aW9uKCAkcmVsYXRlZFNoaXBwaW5nRmllbGQsIG5ld1ZhbCApIHtcbiAgICAgICAgbGV0ICRyZWxhdGVkU2hpcHBpbmdGaWVsZENvbnRhaW5lciA9ICRyZWxhdGVkU2hpcHBpbmdGaWVsZC5jbG9zZXN0KCAnLm9wdC1pbnB1dCcgKTtcblxuICAgICAgICAvLyBJZiBmaWVsZCBpbiBxdWVzdGlvbiBpbiBhIGRyb3Bkb3duLCB1c2UgbWF0ZXJpYWxpemUncyBpbnRlcm5hbCB1cGRhdGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCAkcmVsYXRlZFNoaXBwaW5nRmllbGQuaGFzQ2xhc3MoICdzZWxlY3QtZmllbGQnICkgKSB7XG4gICAgICAgICAgICBsZXQgc2hpcHBpbmdGaWVsZE1hdGVyaWFsaXplRHJvcGRvd24gPSBNLkZvcm1TZWxlY3QuZ2V0SW5zdGFuY2UoICRyZWxhdGVkU2hpcHBpbmdGaWVsZC5nZXQoIDAgKSApO1xuXG4gICAgICAgICAgICBpZiAoIHNoaXBwaW5nRmllbGRNYXRlcmlhbGl6ZURyb3Bkb3duICkge1xuXG4gICAgICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHRhcmdldCBtYXRlcmlhbGl6ZSBkcm9wZG93bidzIFwidmFsdWUgZGljdGlvbmFyeVwiLCB3aGljaCBrZWVwcyBhbiBpbnRlcm5hbCBtYXBwaW5nIGJldHdlZW4gdGhlIHNlbGVjdCBvcHRpb24gYW5kIHRoZSBnZW5lcmF0ZWQgTElzXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlRGljdGlvbmFyeSA9IHNoaXBwaW5nRmllbGRNYXRlcmlhbGl6ZURyb3Bkb3duLl92YWx1ZURpY3Q7XG4gICAgICAgICAgICAgICAgZm9yICggbGV0IGtleSBpbiB2YWx1ZURpY3Rpb25hcnkgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9uY2Ugd2UgZmluZCB0aGUgb3B0aW9uIGZpZWxkIHRoYXQgaGFzIHRoZSBuZXcgdmFsdWUsIHVzZSB0aGUga2V5IHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgTElcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHVzZSBpdCB0byB0cmlnZ2VyIG1hdGVyaWFsaXplJ3MgaW50ZXJuYWwgc2VsZWN0aW9uIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZURpY3Rpb25hcnlbIGtleSBdLmVsLnZhbHVlID09PSBuZXdWYWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlwcGluZ0ZpZWxkTWF0ZXJpYWxpemVEcm9wZG93bi5faGFuZGxlT3B0aW9uQ2xpY2soIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICRyZWxhdGVkU2hpcHBpbmdGaWVsZENvbnRhaW5lci5maW5kKCAnIycgKyBrZXkgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogJC5ub29wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogJC5ub29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNldCB0YXJnZXQgaW5wdXQgdmFsdWVcbiAgICAgICAgICAgICRyZWxhdGVkU2hpcHBpbmdGaWVsZC52YWwoIG5ld1ZhbCApO1xuXG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhIG1hdGVyaWFsaXplIGlucHV0LCBhZGQgdGhlIGFjdGl2ZSBjbGFzcyBpZiB2YWx1ZSBpcyBub3QgZW1wdHkgc3RyaW5nLCBvdGhlcndpc2UgcmVtb3ZlIGl0XG4gICAgICAgICAgICBpZiAoICRyZWxhdGVkU2hpcHBpbmdGaWVsZENvbnRhaW5lci5hdHRyKCAnb3B0LWlucHV0LXN0eWxlJyApID09PSAnZGVmYXVsdCcgKSB7XG4gICAgICAgICAgICAgICAgJHJlbGF0ZWRTaGlwcGluZ0ZpZWxkQ29udGFpbmVyLmZpbmQoICdsYWJlbCcgKS50b2dnbGVDbGFzcyggJ2FjdGl2ZScsICggbmV3VmFsICE9PSAnJyApICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgb25seSBzdXBwb3NlZCB0byBiZSBydW4gb25jZSBwZXIgcGFnZS4gU2luY2Ugd2UgbWFkZSBpbml0Rm9ybXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBpbnZva2VkIGFnYWluLFxuICAgICAqIHByZXZlbnQgdGhpcyBsb2dpYyBmcm9tIHJ1bm5pbmcgbW9yZSB0aGFuIG9uY2UgYnkgZmxpcHBpbmcgYSBzcGVjaWFsIGZsYWcgaW4gdGhlIG9wIG9iamVjdCBhbmQgY2hlY2tpbmcgaXQgYmVmb3JlIHRoZSBuZXh0IGNhbGxcbiAgICAgKi9cbiAgICBvcC5vbmNlT25seUZvcm1Jbml0aWFsaXphdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIG9wLm9uZVRpbWVGb3JtSW5pdGlhbGl6YXRpb25SYW4gKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvKiAgV2hhdCBpcyB0aGlzIGNyYXppbmVzcz8/IFdlbGwsIGxldCBtZSB0ZWxsIHlvdS4uLlxuICAgICAgICAgKiAgU28gaU9TIHdpbGwgc2NyZWVuIHpvb20gaW4vb3V0IG9uIGZvcm0gaW5wdXQgZWxlbWVudHMgaWYgdGhlIGZvbnQgc2l6ZSBpc1xuICAgICAgICAgKiAgYW55dGhpbmcgb3RoZXIgdGhhbiAxNnB4LiAgVXBvbiB6b29tLCB0aGUgY2xpY2sgZXZlbnQgZm9yIHRoZSBzZWxlY3Qgb3B0aW9uJ3NcbiAgICAgICAgICogIDxsaT4gd2lsbCBub3QgZmlyZSEgIE1hdGVyaWFsaXplIHNvbHZlcyB0aGlzIGJ5IGZvcmNpbmcgaW5wdXRzIHRvIGFsd2F5cyBiZSAxNnB4LlxuICAgICAgICAgKiAgV2UgY2FuJ3QgZG8gdGhhdCB3aXRoIG91ciBlZGl0b3IgY2F1c2Ugd2UncmUgcHJvLWZvbnQgc2l6ZXMsIHNvIGhlcmUgd2UgYXJlIG92ZXJyaWRpbmdcbiAgICAgICAgICogIHRoZSBDTE9TRSBjbGljayBoYW5kbGVyIGFuZCBtYW51YWxseSB0cmlnZ2VyaW5nIHRoZSBzZWxlY3RlZCBvcHRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqICBAYXV0aG9yIGpwQG9udHJhcG9ydC5jb21cbiAgICAgICAgICovXG4gICAgICAgICggZnVuY3Rpb24oIF9oYW5kbGVEb2N1bWVudENsaWNrICkge1xuICAgICAgICAgICAgTS5Ecm9wZG93bi5wcm90b3R5cGUuX2hhbmRsZURvY3VtZW50Q2xpY2sgPSBmdW5jdGlvbiggZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgJHRhcmdldCA9ICQoIGUudGFyZ2V0ICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoICR0YXJnZXQuY2xvc2VzdCggJy5kcm9wZG93bi1jb250ZW50JyApLmxlbmd0aCAmJiAhdGhpcy5pc1RvdWNoTW92aW5nICkge1xuICAgICAgICAgICAgICAgICAgICAkdGFyZ2V0LnBhcmVudHMoICdsaTpub3QoLm9wdGdyb3VwKScgKS50cmlnZ2VyKCAnY2xpY2snICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2hhbmRsZURvY3VtZW50Q2xpY2suY2FsbCggdGhpcywgZSApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSAoIE0uRHJvcGRvd24ucHJvdG90eXBlLl9oYW5kbGVEb2N1bWVudENsaWNrICkgKTtcblxuICAgICAgICAvLyBJbml0IHRoZSBlbGVtZW50c1xuICAgICAgICBpZiAoICEkLmZuLmRhdGVwaWNrZXIgKSB7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgdGhlIGRhdGVwaWNrZXIgYW5kIGZvcm1zZWxlY3RvciB3b24ndCBiZSBpbml0ZWQgaW4ganF1ZXJ5IHNvIHdlIGRvIGl0IGV4cGxpY2l0bHkuXG4gICAgICAgICAgICAvLyBOb3Qgc3VyZSB3aHkgdGhpcyBoYXBwZW5zLCB3ZSBzdXNwZWN0IGl0J3MgYSBieXByb2R1Y3Qgb2YgdGhlIHdlYnBhY2sgYnVpbGQuXG4gICAgICAgICAgICAvLyBPbmNlIGpxdWVyeSBnZXRzIGFkZGVkIHRvIHRoZSB3ZWJwYWNrIGJ1aWxkIHdlIGNhbiBnZXQgcmlkIG9mIHRoaXMuXG4gICAgICAgICAgICBNLmluaXRpYWxpemVKcXVlcnlXcmFwcGVyKCBNLkRhdGVwaWNrZXIsICdkYXRlcGlja2VyJywgJ01fRGF0ZXBpY2tlcicgKTtcbiAgICAgICAgICAgIE0uaW5pdGlhbGl6ZUpxdWVyeVdyYXBwZXIoIE0uRm9ybVNlbGVjdCwgJ2Zvcm1TZWxlY3QnLCAnTV9Gb3JtU2VsZWN0JyApO1xuICAgICAgICB9XG5cbiAgICAgICAgb3Aub25lVGltZUZvcm1Jbml0aWFsaXphdGlvblJhbiA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQGJyaWVmIEluaXQgZm9ybSBpbnB1dHMgYW5kIGJpbmQgc3VibWl0IGJ1dHRvbnMuXG4gICAgICovXG4gICAgb3AuaW5pdEZvcm1zID0gZnVuY3Rpb24oIGZvcm1JZHMgKSB7XG5cbiAgICAgICAgb3Aub25jZU9ubHlGb3JtSW5pdGlhbGl6YXRpb24oKTtcblxuICAgICAgICBsZXQgdjNGb3JtRWxlbWVudHMgPSBbXTtcblxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBhcmUgYW55IHYzIGZvcm1zIG9uIHRoZSBwYWdlXG4gICAgICAgIGlmICggZm9ybUlkcyAmJiBmb3JtSWRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIGZvcm1JZHMuZm9yRWFjaCggKCBmb3JtSWQgKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggYGZvcm1bb3B0LWlkPVwiJHtmb3JtSWR9XCJdYCApO1xuICAgICAgICAgICAgICAgIGlmICggZm9ybUVsICkge1xuICAgICAgICAgICAgICAgICAgICB2M0Zvcm1FbGVtZW50cy5wdXNoKCBmb3JtRWwgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2M0Zvcm1FbGVtZW50cyA9IEFycmF5LmZyb20oIGRvY3VtZW50LmZvcm1zICkuZmlsdGVyKCAoIGZvcm0gKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IG9wIHYzIGZvcm1zIHRoYXQgYXJlIG5vdCBkeW5hbWljIGJsb2NrIHRlbXBsYXRlc1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtLmNsYXNzTGlzdC5jb250YWlucyggJ29wdC1yb3cnICkgJiYgIWZvcm0uaGFzQXR0cmlidXRlKCAnZGF0YS1kYycgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggIXYzRm9ybUVsZW1lbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIC8vIE5vIHYzIGZvcm1zIGZvdW5kIHNvIGp1bXAgc2hpcFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdjNGb3JtRWxlbWVudHMuZm9yRWFjaCggKCBmb3JtRWxlbWVudCApID0+IHtcbiAgICAgICAgICAgIG9wLmluaXRGb3JtKCBmb3JtRWxlbWVudCApO1xuICAgICAgICB9ICk7XG4gICAgfTsvLyBFbmQgaW5pdCBmb3Jtc1xuXG5cbiAgICBvcC5pbml0Rm9ybSA9IGZ1bmN0aW9uKCBmb3JtRWxlbWVudCApIHtcblxuICAgICAgICBpZiAoICFmb3JtRWxlbWVudCApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCAkdjNGb3JtID0gJCggZm9ybUVsZW1lbnQgKTtcblxuICAgICAgICBpZiAoICEkdjNGb3JtLmxlbmd0aCB8fCAhJHYzRm9ybS5hdHRyKCAnb3B0LWlkJyApIHx8ICEkdjNGb3JtLmlzKCAnZm9ybScgKSB8fCAhJHYzRm9ybS5oYXNDbGFzcyggJ29wdC1yb3cnICkgfHwgJHYzRm9ybS5oYXNDbGFzcyggJ29wdC1mb3JtLS1pbml0aWFsaXplZCcgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgY29uZGl0aW9uYWwgcmVkaXJlY3QgZm9ybXMgaGF2ZSB0aGUgcHJvcGVyIGZvcm0gYWN0aW9uIGZsYWdcblxuICAgICAgICBpZiAoICR2M0Zvcm0uaXMoICdbZGF0YS1jb25kaXRpb25hbC1yZWRpcmVjdF0nICkgKSB7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uYWxGb3JtQWN0aW9uID0gJHYzRm9ybS5hdHRyKCAnYWN0aW9uJyApO1xuXG4gICAgICAgICAgICBpZiAoIGNvbmRpdGlvbmFsRm9ybUFjdGlvbiApIHtcbiAgICAgICAgICAgICAgICAkdjNGb3JtLmF0dHIoICdhY3Rpb24nLCBjb25kaXRpb25hbEZvcm1BY3Rpb24gKyAnJl9jb25kaXRpb25hbFJlc3BvbnNlPXRydWUnICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgJGV4cGlyYXRpb25ZZWFyID0gJHYzRm9ybS5maW5kKCAnc2VsZWN0W25hbWU9XCJwYXltZW50X2V4cGlyZV95ZWFyXCJdJyApO1xuXG4gICAgICAgIC8vIFNlYXJjaCBmb3IgeWVhciBleHBpcmF0aW9uIGZpZWxkcyBhbmQgc3R1YiBvdXQgdGhlcmUgb3B0aW9uc1xuICAgICAgICAkZXhwaXJhdGlvblllYXIuZWFjaCggZnVuY3Rpb24oIGVsICkge1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9ICcnLCAvLyBEb250IGxlYXZlIHRoaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgdGhlICs9IFwiPG9wdGlvbi4uXCIgYmVsb3cgd2lsbCBhZGQgaXQgdG8gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgIHllYXI7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBldmVyeSB2YWx1ZS1sZXNzIG9wdGlvbiB0aGF0IGlzbid0IHRoZSBmaXJzdC5cbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCB2YWx1ZS1sZXNzIG9wdGlvbiB3aWxsIGJlIHRoZSBvcHRpb24gdGhhdCBqdXN0IHNheXMgJ1NlbGVjdC4uLicgYnkgZGVmYXVsdCAoYnV0IGNhbiBiZSBjdXN0b21pemVkIGJ5IHVzZXIpXG4gICAgICAgICAgICAkKCB0aGlzICkuZmluZCggJ29wdGlvblt2YWx1ZT1cIlwiXTpub3QoOmZpcnN0KScgKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8PSAyNTsgaSsrICkge1xuICAgICAgICAgICAgICAgIHllYXIgPSBpICsgY3VycmVudFllYXI7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGR1cGVzIGJlZm9yZSBhZGRpbmcgb3B0aW9uLlxuICAgICAgICAgICAgICAgIGlmICggJCggdGhpcyApLmZpbmQoICdvcHRpb25bdmFsdWU9XCInICsgeWVhciArICdcIl0nICkubGVuZ3RoID09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgeWVhciArICdcIj4nICsgeWVhciArICc8L29wdGlvbj4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJCggdGhpcyApLmFwcGVuZCggb3B0aW9ucyApO1xuXG4gICAgICAgIH0gKTtcblxuICAgICAgICAvLyBXaGVuIGV4cGlyYXRpb24geWVhciBpcyBjaGFuZ2VkLCB0cmlnZ2VyIGV2ZW50cyBvbiBpdCBhbmQgdGhlIGV4cGlyYXRpb24gbW9udGggdG8gZ2V0IHRoZSB2YWxpZGF0aW9uIHRvIHJ1blxuICAgICAgICAkZXhwaXJhdGlvblllYXIub24oICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICAkZXhwaXJlTW9udGggPSAkdGhpcy5jbG9zZXN0KCAnZm9ybScgKS5maW5kKCAnc2VsZWN0W25hbWU9XCJwYXltZW50X2V4cGlyZV9tb250aFwiXScgKTtcblxuICAgICAgICAgICAgJHRoaXMudHJpZ2dlciggJ2JsdXInICk7XG4gICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCAnaW5wdXQnICk7XG5cbiAgICAgICAgICAgICRleHBpcmVNb250aC50cmlnZ2VyKCAnYmx1cicgKTtcbiAgICAgICAgICAgICRleHBpcmVNb250aC50cmlnZ2VyKCAnaW5wdXQnICk7XG4gICAgICAgIH0gKTtcblxuICAgICAgICAvLyBXaGVuIGV4cGlyYXRpb24gbW9udGggaXMgY2hhbmdlZCwgdHJpZ2dlciBldmVudHMgb24gaXQgYW5kIHRoZSBleHBpcmF0aW9uIHllYXIgdG8gZ2V0IHRoZSB2YWxpZGF0aW9uIHRvIHJ1blxuICAgICAgICAkdjNGb3JtLmZpbmQoICdzZWxlY3RbbmFtZT1cInBheW1lbnRfZXhwaXJlX21vbnRoXCJdJyApLm9uKCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKCB0aGlzICksXG4gICAgICAgICAgICAgICAgJGV4cGlyZVllYXIgPSAkdGhpcy5jbG9zZXN0KCAnZm9ybScgKS5maW5kKCAnc2VsZWN0W25hbWU9XCJwYXltZW50X2V4cGlyZV95ZWFyXCJdJyApO1xuXG4gICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCAnYmx1cicgKTtcbiAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoICdpbnB1dCcgKTtcblxuICAgICAgICAgICAgJGV4cGlyZVllYXIudHJpZ2dlciggJ2JsdXInICk7XG4gICAgICAgICAgICAkZXhwaXJlWWVhci50cmlnZ2VyKCAnaW5wdXQnICk7XG4gICAgICAgIH0gKTtcblxuICAgICAgICAkdjNGb3JtLmZpbmQoICdpbnB1dFtuYW1lPVwicGF5bWVudF9udW1iZXJcIl0nICkuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJGVsID0gJCggdGhpcyApO1xuXG4gICAgICAgICAgICAkZWwub24oICdpbnB1dCcsIG9wLmZvcm1hdENyZWRpdENhcmQgKTtcbiAgICAgICAgfSApO1xuXG4gICAgICAgIC8vIFRoaXMgc2VsZWN0b3IgaXMgdXNlZCB0byBhZGQgdGhlIG5ldyBvcHQgZGF0ZXRpbWUgcGlja2VyIGxpYnJhcnksIGlmIGZ1bGxkYXRlIGhhcyBiZWVuIG1pZ3JhdGVkIHdlJ2xsIGluY2x1ZGUgdGhhdFxuICAgICAgICAvLyBpbiB0aGUgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgIGxldCBldmVudExpc3RlbmVyU2VsZWN0b3IgPSAnW29wdC1pbnB1dC10eXBlPVwidGltZXN0YW1wXCJdJztcblxuICAgICAgICAvLyBUaGUgbmV3IG9wdCBkYXRlcGlja2VyIGxpYnJhcnkgYWRkcyBhIHNlY29uZCBpbnB1dCB0aGF0IGlzIGRpc2FibGVkIHRvIHN0b3JlIHRoZSBkYXRlIGZyb20gdGhlIGRhdGUgcGlja2VyLCBidXRcbiAgICAgICAgLy8gd2l0aCB0aGUgb2xkIGxpYnJhcnkgdGhlcmUgaXMgb25seSBvbmUgaW5wdXQgdGhhdCBpc24ndCBkaXNhYmxlZC5cbiAgICAgICAgaWYgKCAhJHYzRm9ybS5maW5kKCAnW29wdC1pbnB1dC10eXBlPVwiZnVsbGRhdGVcIl0gaW5wdXRbZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXScgKS5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBwYWdlIGhhc24ndCBiZWVuIHJlLXNhdmVkIHRvIHVzZSB0aGUgbmV3IGRhdGUgcGlja2VyIGxpYnJhcnkgdGhlbiBydW4gdGhlIGxlZ2FjeSBldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgJHYzRm9ybS5maW5kKCAnW29wdC1pbnB1dC1zdHlsZT1cImRlZmF1bHRcIl1bb3B0LWlucHV0LXR5cGU9XCJmdWxsZGF0ZVwiXSBpbnB1dCcgKS5vbiggJ2ZvY3VzJywgZnVuY3Rpb24oIGV2ICkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRlUGlja2VyID0gTS5EYXRlcGlja2VyLmdldEluc3RhbmNlKCBldi50YXJnZXQgKTtcblxuICAgICAgICAgICAgICAgIGlmICggZGF0ZVBpY2tlciApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVBpY2tlci5vcGVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBXZSdyZSB1c2luZyB0aGUgbmV3IG9wdCBkYXRlcGlja2VyIGxpYnJhcnkgc28gdGhlIGxpc3RlbmVycyBhcmUgZ29pbmcgdG8gYmUgdGhlIHNhbWUgZm9yIHRpbWVzdGFtcCBhbmQgZnVsbGRhdGUgaW5wdXQgdHlwZXMuXG4gICAgICAgICAgICBldmVudExpc3RlbmVyU2VsZWN0b3IgKz0gJywgW29wdC1pbnB1dC10eXBlPVwiZnVsbGRhdGVcIl0nO1xuICAgICAgICB9XG5cbiAgICAgICAgJHYzRm9ybS5maW5kKCBldmVudExpc3RlbmVyU2VsZWN0b3IgKVxuICAgICAgICAgICAgLm9uKCAnY2xpY2snLCBPcHREYXRlVGltZVBpY2tlci5kYXRlVGltZUZpZWxkQ2xpY2tIYW5kbGVyIClcbiAgICAgICAgICAgIC5vbiggJ2RhdGVUaW1lUGlja2VyU2F2ZScsIE9wdERhdGVUaW1lUGlja2VyLmRhdGVUaW1lRmllbGRTYXZlSGFuZGxlciApXG4gICAgICAgICAgICAub24oICdkYXRlVGltZVBpY2tlckNhbmNlbCcsIE9wdERhdGVUaW1lUGlja2VyLmRhdGVUaW1lRmllbGRDYW5jZWxIYW5kbGVyICk7XG5cbiAgICAgICAgdmFyICRvcmRlckJ1bXBzID0gJHYzRm9ybS5maW5kKCAnLm9wdC1vcmRlci1idW1wW29mZmVyXScgKTtcblxuICAgICAgICAkb3JkZXJCdW1wcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmb3JtID0gdGhpcy5jbG9zZXN0KCAnZm9ybScgKSxcbiAgICAgICAgICAgICAgICBvcmRlclN1bW1hcnkgPSBmb3JtICYmIGZvcm0ucXVlcnlTZWxlY3RvciggJ29udHJhcG9ydC1vcmRlci1zdW1tYXJ5JyApO1xuXG4gICAgICAgICAgICBpZiAoIG9yZGVyU3VtbWFyeSApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3NUYXhlcyA9IEpTT04ucGFyc2UoIG9yZGVyU3VtbWFyeS5nZXRBdHRyaWJ1dGUoICd0YXhlcycgKSApLFxuICAgICAgICAgICAgICAgICAgICBvYlRheGVzID0gSlNPTi5wYXJzZSggdGhpcy5nZXRBdHRyaWJ1dGUoICd0YXhlcycgKSApLFxuICAgICAgICAgICAgICAgICAgICBvc1RheElkcyA9IG9zVGF4ZXMubWFwKCBmdW5jdGlvbiggb3NUYXggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3NUYXguaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZHVwbGljYXRlIHRheGVzIGZyb20gdGhlIG9yZGVyIGJ1bXAgcHJlc2VudCBpbiB0aGUgb2ZmZXIgc3VtbWFyeSBzbyB0aGF0IHRoZXlcbiAgICAgICAgICAgICAgICAvLyBBcmUgbm90IGRvdWJsZSBjb3VudGVkIGluIHRoZSBvZmZlciBzdW1tYXJ5IHdoZW4gb3JkZXIgYnVtcCBkYXRhIGlzIG1lcmdlZFxuICAgICAgICAgICAgICAgIG9iVGF4ZXMgPSBvYlRheGVzLmZpbHRlciggZnVuY3Rpb24oIG9iVGF4ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIW9zVGF4SWRzLmluY2x1ZGVzKCBvYlRheC5pZCApO1xuICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCAndGF4ZXMnLCBKU09OLnN0cmluZ2lmeSggb2JUYXhlcyApICk7XG5cbiAgICAgICAgICAgICAgICAvLyBCaW5kIGhhbmRsZXJzIHRvIGNoZWNrYm94IGFuZCBxdWFudGl0eSBpbnB1dHMgb2Ygb3JkZXIgYnVtcHNcbiAgICAgICAgICAgICAgICAkKCB0aGlzICkuZmluZCggJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScgKS5vbiggJ2NoYW5nZScsIG9wLnVwZGF0ZU9yZGVyU3VtbWFyeVdpdGhPcmRlckJ1bXAgKTtcbiAgICAgICAgICAgICAgICAkKCB0aGlzICkuZmluZCggJy5vcHQtb3JkZXItYnVtcF9fcXVhbnRpdHktaW5wdXQnICkub24oICdjaGFuZ2UnLCBvcC51cGRhdGVPcmRlckJ1bXBRdWFudGl0eSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIGVhY2ggb3JkZXIgYnVtcCBhbmQgdXBkYXRlIHRoZSBvcmRlciBzdW1tYXJ5cyBhY2NvcmRpbmdseS4gVGhpcyBuZWVkcyBhIHNlcGVyYXRlIGxvb3BcbiAgICAgICAgLy8gRnJvbSB0aGUgY29kZSBhYm92ZSBzbyB0aGF0IHRoZSB0YXhlcyBhcmUgZmlsdGVyZWQgb3V0IGZyb20gdGhlIG9yZGVyIGJ1bXBzIGJlZm9yZSBhbnkgYXJlIGNoZWNrZWQuXG4gICAgICAgIC8vIElmIHdlIHdlcmUgdG8gY29tYmluZSB0aGVzZSBsb29wcywgdGhlbiBpdCBpcyBwb3NzaWJsZSB0byBjaGVjayBhbiBvcmRlciBidW1wIHdoaWNoIHdpbGwgYWRkIHRoZSB0YXhcbiAgICAgICAgLy8gVG8gdGhlIG9yZGVyIHN1bW1hcnksIGFuZCB0aGVuIGhhdmUgYW5vdGhlciBvcmRlciBidW1wIHJlbW92ZSB0aGF0IHRheCBJRCBpbmNvcnJlY3RseS5cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgZ3JpZCBvZmZlciBtb2RlbCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBzbyBiaW5kIHRvIGdyaWRPZmZlckNvbnRyb2xsZXJSZWFkeS5cbiAgICAgICAgLy8gVGhlIG1ldGhvZCBnb2VzIG9mZiBldmVyeSB0aW1lIGEgY2hhbmdlIGlzIG1hZGUgdG8gdGhlIGdyaWQgKGl0IGdvZXMgb2ZmIGxpa2UgMTAgdGltZXMpIHNvIHRoZSBjYWxsXG4gICAgICAgIC8vIGJhY2sgaGVyZSBtYWtlcyBhIGNsb3N1cmUgdG8gZW5zdXJlIHdlIG9ubHkgcnVuIHRoZSBvcmRlciBidW1wIGxvZ2ljIG9uY2UuIE1vcmUgb3IgbGVzcyB0aGUgbmF0aXZlXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgb2YgalF1ZXJ5J3MgLm9uZSBtZXRob2QuXG4gICAgICAgICR2M0Zvcm0uZWFjaCggKCBpLCBmb3JtICkgPT4ge1xuXG4gICAgICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoICdncmlkT2ZmZXJDb250cm9sbGVyUmVhZHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9ICggZXYgKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjYWxsYmFjayBpcyBjYWxsZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZ3JpZE9mZmVyQ29udHJvbGxlclJlYWR5JywgdGVtcCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBhbGwgdGhlIG9yZGVyYnVtcHMgaW4gdGhlIHJvdyBvZiB0aGUgb3JkZXIgc3VtbWFyeSB0aGF0IHRyaWdnZXJlZCB0aGUgcmVhZHkgZXZlbnQuIE5leHQgc2VlIGlmIHdlIG5lZWQgdG8gdXBkYXRlIGFueSBvZlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVtIGJlY2F1c2UgdGhleSBhcmUgY2hlY2tlZC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJCdW1wcyA9IGV2LnRhcmdldC5jbG9zZXN0KCAnLm9wdC1yb3cnICkucXVlcnlTZWxlY3RvckFsbCggJy5vcHQtb3JkZXItYnVtcFtvZmZlcl0nICk7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyQnVtcHMuZm9yRWFjaCggKCBlbCApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCAkY2hlY2tib3ggPSAkKCBlbCApLmZpbmQoICdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBjaGVja2JveCBpcyBjaGVja2VkLCBydW4gdGhlIHVwZGF0ZSBPUyBoYW5kbGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAkY2hlY2tib3guZ2V0KCAwICkuY2hlY2tlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcC51cGRhdGVPcmRlclN1bW1hcnlXaXRoT3JkZXJCdW1wKCB7IHRhcmdldDogJGNoZWNrYm94LmdldCggMCApIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXA7XG4gICAgICAgICAgICB9KCkgKTtcblxuICAgICAgICB9ICk7XG5cbiAgICAgICAgJHYzRm9ybS5maW5kKCAnLm9wdC1lbGVtZW50IC5kYXRlcGlja2VyJyApLmRhdGVwaWNrZXIoIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ3l5eXktbW0tZGQnLFxuICAgICAgICAgICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgeWVhclJhbmdlOiAxMDAsXG4gICAgICAgICAgICBvbkNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBBZnRlciBwaWNrZXIgaXMgY2xvc2VkLCB0cmlnZ2VyIGZvY3VzIG9uIGRhdGVwaWNrZXIgaW5wdXQgdG8gdHJpZ2dlciB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmVsICYmIHRoaXMuZWwuZm9jdXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EcmF3OiBmdW5jdGlvbiggY29udGV4dCApIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGRhdGUgcGlja2VyIGlzIHJlbmRlcmVkLCByZXBsYWNlIHRoZSBvbk9wZW5FbmQgZnVuY3Rpb24gc2luY2UgaXRzIFwic2Nyb2xsIHRvIG1lbnUgaXRlbVwiIGZ1bmN0aW9uYWxpdHkgZG9lcyBub3Qgd29ya1xuICAgICAgICAgICAgICAgIGxldCBtYXRlcmlhbGl6ZVNlbGVjdCA9IE0uRm9ybVNlbGVjdC5nZXRJbnN0YW5jZSggY29udGV4dC5jYWxlbmRhckVsLnF1ZXJ5U2VsZWN0b3IoICcub3JpZy1zZWxlY3QteWVhcicgKSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbGl6ZVNlbGVjdCAmJiBtYXRlcmlhbGl6ZVNlbGVjdC5kcm9wZG93biApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemVTZWxlY3QuZHJvcGRvd24ub3B0aW9ucy5vbk9wZW5FbmQgPSAoIGZ1bmN0aW9uKCBvcmlnaW5hbE9uT3BlbkVuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZXYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBvcmlnaW5hbCBcIm9uT3BlbkVuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxPbk9wZW5FbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuZHJvcGRvd25FbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkRHJvcGRvd25JdGVtID0gdGhpcy5kcm9wZG93bkVsLnF1ZXJ5U2VsZWN0b3IoICcuc2VsZWN0ZWQnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWxlY3RlZERyb3Bkb3duSXRlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB3aGVyZSB0byBzY3JvbGwgdGhlIGRhdGUgcGlja2VyJ3MgeWVhciBzZWxlY3QgdG8uIFRoZSBnb2FsIGlzIHRvIGNlbnRlciB0aGUgc2VsZWN0ZWQgb3B0aW9uIGluIHRoZSBtZW51XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBieSBnZXR0aW5nIHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIHNlbGVjdGVkIGl0ZW0sIGFuZCBvZmZzZXQgaXQgYnkgdGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgbWVudSBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdTY3JvbGxUb3AgPSBzZWxlY3RlZERyb3Bkb3duSXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSB0aGlzLmRyb3Bkb3duRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLiBBdCB0aGlzIHBvaW50IHRoZSBuZXdTY3JvbGxUb3Agc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSBzZWxlY3RlZCBtZW51IGl0ZW0gYXBwZWFyIGF0IHRoZSB0b3Agb2YgdGhlIG1lbnVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njcm9sbFRvcCArPSB0aGlzLmRyb3Bkb3duRWwuc2Nyb2xsVG9wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3cgc3VidHJhY3QgaGFsZiB0aGUgbWVudSBoZWlnaHQgc28gdGhhdCB0aGUgc2VsZWN0ZWQgbWVudSBpdGVtIGlzIGNlbnRlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY3JvbGxUb3AgLT0gKCB0aGlzLmRyb3Bkb3duRWwuY2xpZW50SGVpZ2h0IC8gMiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5ld1Njcm9sbFRvcCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bkVsLnNjcm9sbFRvcCA9IG5ld1Njcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gKSggbWF0ZXJpYWxpemVTZWxlY3QuZHJvcGRvd24ub3B0aW9ucy5vbk9wZW5FbmQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICBjb25zdCAkc2VsZWN0RmllbGQgPSAkdjNGb3JtLmZpbmQoICcub3B0LWVsZW1lbnQgc2VsZWN0Om5vdCgubW9vbnJheS1mb3JtLWNhcnQtc2hpcHBpbmctc2VsZWN0KScgKTtcblxuICAgICAgICAkc2VsZWN0RmllbGQuZm9ybVNlbGVjdCgge1xuICAgICAgICAgICAgZHJvcGRvd25PcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgb25PcGVuU3RhcnQ6IG9wLm1hdGVyaWFsU2VsZWN0T3BlbixcbiAgICAgICAgICAgICAgICBvbkNsb3NlU3RhcnQ6IG9wLm1hdGVyaWFsU2VsZWN0Q2xvc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIC8vIERyb3Bkb3ducyBhcmUgbWlzc2luZyB0aGUgXCJvcHQtaW5wdXRfX2ZpZWxkXCIgdGhhdCBnZXRzIGFkZGVkIHRvIGFsbCBpbnB1dHMgZnJvbSB0aGUgZWRpdG9yLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBpbnB1dCBnZXRzIGdlbmVyYXRlZCBkeW5hbWljYWxseSBieSBtYXRlcmlhbGl6ZS4gQWRkIHRoZSBtaXNzaW5nIGNsYXNzLlxuICAgICAgICAkc2VsZWN0RmllbGQuY2xvc2VzdCggJy5vcHQtZWxlbWVudCcgKS5maW5kKCAnaW5wdXQuc2VsZWN0LWRyb3Bkb3duJyApLmFkZENsYXNzKCAnb3B0LWlucHV0X19maWVsZCcgKTtcblxuICAgICAgICAvLyBAVE9ETzogQ2hlY2sgdGhpcyB3b3Jrc1xuICAgICAgICAvLyBNYWtlIHRoZSBmb3JtcyBzbWFydCBmb3JtcyBhbmQgYWRkIHRoZSBmb3JtIGNvbmRpdGlvbnMgcGx1Z2luLlxuICAgICAgICAkdjNGb3JtLm1vb25yYXlTbWFydEZvcm0oKS5mb3JtQ29uZGl0aW9ucygge1xuICAgICAgICAgICAgcHJvY2Vzc29yTXV0YXRvcjogZnVuY3Rpb24oIGNvbmRpdGlvbiwgcnVsZXNSZXN1bHQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBydWxlc1Jlc3VsdCAmJiBjb25kaXRpb24udHJ1ICE9IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc091dGNvbWVzKCBjb25kaXRpb24udHJ1LCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIHdvcmsgZm9yIGFsbCBjYXJ0IC8gcGF5bWVudCByZWxhdGVkIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBydWxlc1Jlc3VsdCA9PSBmYWxzZSAmJiBjb25kaXRpb24uZmFsICE9IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc091dGNvbWVzKCBjb25kaXRpb24uZmFsLCBmYWxzZSApO1xuICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGludmVydFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHJ1bGVzUmVzdWx0ID09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzT3V0Y29tZXMoIGNvbmRpdGlvbi50cnUsIGZhbHNlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG91dGNvbWVBY3Rpb25NdXRhdG9yOiBmdW5jdGlvbiggb3V0Y29tZSwgcnVsZXNSZXN1bHQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG91dGNvbWUuYWN0aW9uO1xuICAgICAgICAgICAgICAgIC8vIEludmVydCBvbmx5IGlmIGl0cyBhIHNob3dcbiAgICAgICAgICAgICAgICBpZiAoIHJ1bGVzUmVzdWx0ID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXRzIGEgc3RyaW5nIGZpbHAgdGhlIHJlc3VsdC4gdGF4IGFuZCBzaGlwcGluZyBydWxlcyBzZXRzIGFyZSBmdW5jc1xuICAgICAgICAgICAgICAgICAgICBpZiAoICQudHlwZSggb3V0Y29tZS5hY3Rpb24gKSA9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb3V0Y29tZS5hY3Rpb24gPT0gJ3Nob3cnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9ICdoaWRlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0RXZlbnQ6ICdibHVyIGNoYW5nZScsXG4gICAgICAgICAgICBjb25kaXRpb25zOiBbXVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBmb3JtIGN1cnJlbmN5IHNldHRpbmdzLlxuICAgICAgICBpZiAoIG9wLmN1cnJlbmN5U2V0dGluZ3MgJiYgb3AuY3VycmVuY3lTZXR0aW5ncyAhPT0gJ1tjdXJyZW5jeV9zZXR0aW5nc10nICkge1xuICAgICAgICAgICAgJHYzRm9ybS5maW5kKCAnb250cmFwb3J0LW9yZGVyLXN1bW1hcnknICkuYXR0ciggJ2N1cnJlbmN5LXNldHRpbmdzJywgb3AuY3VycmVuY3lTZXR0aW5ncyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hpcHBpbmcgZmllbGRzIHNhbWUgYXMgYmlsbGluZyB0b2dnbGUuXG4gICAgICAgIHZhciBzaGlwcGluZ0NoZWNrID0gJHYzRm9ybS5maW5kKCAnW25hbWU9XCJzaGlwcGluZ19zYW1lX2FzX2JpbGxpbmdcIl0nICk7XG4gICAgICAgIGlmICggc2hpcHBpbmdDaGVjay5sZW5ndGggKSB7XG4gICAgICAgICAgICAvLyBHZXQgYWxsIHRoZSBzaGlwcGluZyBlbGVtZW50cyBmcm9tIHRoZSBzYW1lIGJsb2NrIGFuZCBzaG93IG9yIGhpZGUgdGhlbSBkZXBlbmRpbmcgb24gdGhlICdzYW1lIGFzIGJpbGxpbmcnIGNoZWNrYm94IHN0YXR1cy5cbiAgICAgICAgICAgIC8vIElmIGhpZGluZyB0aGVtLCBhbHNvIHJldHJpZXZlIHRoZSB2YWx1ZXMgZnJvbSB0aGUgYmlsbGluZyBmaWVsZCBzbyB0aGF0IHRheCBydWxlcyBzdGlsbCBmdW5jdGlvbiBwcm9wZXJseVxuICAgICAgICAgICAgc2hpcHBpbmdDaGVjay5jaGFuZ2UoIGZ1bmN0aW9uKCBldiApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hpcHBpbmdJbnB1dFdyYXBwZXJzID0gdGhpcy5jbG9zZXN0KCAnLmNvbnRhaW5lcicgKS5xdWVyeVNlbGVjdG9yQWxsKCAnLm9wdC1zaGlwcGluZy1pbnB1dCcgKSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcbiAgICAgICAgICAgICAgICBzaGlwcGluZ0lucHV0V3JhcHBlcnMuZm9yRWFjaCggZnVuY3Rpb24oIGlucHV0ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGNoZWNrZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCAnb3B0LXNoaXBwaW5nLWlucHV0LS1zaG93JyApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSggJ29wdC1zaGlwcGluZy1pbnB1dC0tc2hvdycgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzRHJvcGRvd24gPSBpbnB1dC5maXJzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucyggJ29wdC1pbnB1dC0tZHJvcGRvd24nICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0RWwgPSAkKCBpbnB1dCApLmZpbmQoICggaXNEcm9wZG93biApID8gJ3NlbGVjdCcgOiAnaW5wdXQnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggJGlucHV0RWwubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVsYXRlZCBiaWxsaW5nIGZpZWxkJ3MgdmFsdWUgYW5kIHNldCBpdCBvbiB0aGUgc2hpcHBpbmcgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmlsbGluZ1ZhbCA9ICRpbnB1dEVsLmNsb3Nlc3QoICdmb3JtJyApLmZpbmQoICdbbmFtZT0nICsgJGlucHV0RWwuYXR0ciggJ25hbWUnICkucmVwbGFjZSggJ3NoaXBwaW5nXycsICdiaWxsaW5nXycgKSArICddJyApLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Auc2V0U2hpcHBpbmdGaWVsZFZhbHVlKCAkaW5wdXRFbCwgYmlsbGluZ1ZhbCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXRFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBUaGlzIGNhbiBjYXVzZSBhIGJ1ZyB3aXRoIGR5bmFtaWMgYmxvY2tzXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoICdvcHQtc2hpcHBpbmctaW5wdXQtLXNob3cnICk7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBAYnJpZWYgQmluZCBmb3JtIGlucHV0cyBrZXl1cCB0byBjaGVjayBmb3IgXCJlbnRlclwiIGJ0biBjbGlja3MuIElmIHRoZXkgY2xpY2sgZW50ZXIgc3VibWl0IHRoZSBmb3JtLlxuICAgICAgICAgKi9cbiAgICAgICAgJHYzRm9ybS5maW5kKCAnLm9wdC1pbnB1dF9fZmllbGQnICkub24oICdrZXl1cCcsIGZ1bmN0aW9uKCAkZXYgKSB7XG4gICAgICAgICAgICAvLyBTdWJtaXQgb24gZW50ZXIsIGJ1dCBhbGxvdyBuZXdsaW5lcyB0byBiZSBtYWRlIGluIGxvbmcgdGV4dCBmaWVsZHMuXG4gICAgICAgICAgICBpZiAoICRldi5rZXkgPT09ICdFbnRlcicgJiYgJGV2LnRhcmdldC5ub2RlTmFtZSAhPT0gJ1RFWFRBUkVBJyApIHtcbiAgICAgICAgICAgICAgICAkKCB0aGlzLmNsb3Nlc3QoICdmb3JtJyApICkudHJpZ2dlciggJ3N1Ym1pdCcsICdzdWJtaXRCdG4nICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBiaWxsaW5nIGZpZWxkcyBhcmUgdXBkYXRlZCwgdXBkYXRlIHNoaXBwaW5nIGZpZWxkcyBpZiBcImRpZmZlcmVudCBzaGlwcGluZ1wiIGNoZWNrYm94IGlzIHByZXNlbnQgYnV0IHVuY2hlY2tlZFxuICAgICAgICAgKiBUaGlzIGlzIG5lZWRlZCBmb3IgdGF4IHJ1bGVzIHRoYXQgZGVwZW5kIG9uIHNoaXBwaW5nIGZpZWxkc1xuICAgICAgICAgKi9cbiAgICAgICAgJHYzRm9ybS5maW5kKCAnW25hbWVePWJpbGxpbmdfXScgKS5vbiggJ2NoYW5nZScsIGZ1bmN0aW9uKCBldiApIHtcbiAgICAgICAgICAgIGxldCAkZm9ybSA9ICQoIGV2LnRhcmdldCApLmNsb3Nlc3QoICdmb3JtJyApLFxuICAgICAgICAgICAgICAgICRkaWZmZXJlbnRTaGlwcGluZ0NoZWNrYm94ID0gJGZvcm0uZmluZCggJ1tuYW1lPXNoaXBwaW5nX3NhbWVfYXNfYmlsbGluZ10nICk7XG5cbiAgICAgICAgICAgIC8vIElmIFwiZGlmZmVyZW50IHNoaXBwaW5nXCIgY2hlY2tib3ggaXMgcHJlc2VudCBhbmQgdW5jaGVja2VkLCB1cGRhdGUgc2hpcHBpbmcgZmllbGRcbiAgICAgICAgICAgIGlmICggJGRpZmZlcmVudFNoaXBwaW5nQ2hlY2tib3gubGVuZ3RoICYmICRkaWZmZXJlbnRTaGlwcGluZ0NoZWNrYm94LnByb3AoICdjaGVja2VkJyApID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICBsZXQgJHJlbGF0ZWRTaGlwcGluZ0ZpZWxkID0gJGZvcm0uZmluZCggJ1sgbmFtZT0nICsgZXYudGFyZ2V0Lm5hbWUucmVwbGFjZSggJ2JpbGxpbmdfJywgJ3NoaXBwaW5nXycgKSArICcgXScgKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gZXYudGFyZ2V0LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAkcmVsYXRlZFNoaXBwaW5nRmllbGQubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICBvcC5zZXRTaGlwcGluZ0ZpZWxkVmFsdWUoICRyZWxhdGVkU2hpcHBpbmdGaWVsZCwgbmV3VmFsICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBAYnJpZWYgU29tZXRoaW5nIGdvdCBjbGlja2VkIGFuZCBpcyB0cnlpbmcgdG8gc3VibWl0IHRoZSBmcm9tLiBGaWd1cmUgb3V0IHdoYXQgZ290IGNsaWNrZWQgYW5kIHRyaWdnZXIgYSBmb3JtIHN1Ym1pc3Npb24gYW5kIHNlbmQgd2hvIGNsaWNrZWQgaXQgYWxvbmcuXG4gICAgICAgICAqL1xuICAgICAgICAkdjNGb3JtLmZpbmQoICcub3B0LWJ1dHRvbi0tc3VibWl0LCAub3B0LWJ1dHRvbi0tcGF5cGFsLCAub3B0LWJ1dHRvbi0tdXBzZWxsLXllcywgLm9wdC1idXR0b24tLXVwc2VsbC1ubycgKS5vbiggJ2NsaWNrJywgZnVuY3Rpb24oIGV2ICkge1xuICAgICAgICAgICAgdmFyICRmb3JtID0gJCggdGhpcy5jbG9zZXN0KCAnZm9ybScgKSApLFxuICAgICAgICAgICAgICAgIHN1Ym1pdFRyaWdnZXI7XG5cbiAgICAgICAgICAgIGlmICggZXYuZGVsZWdhdGVUYXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCAnb3B0LWJ1dHRvbi0tc3VibWl0JyApICkge1xuICAgICAgICAgICAgICAgIHN1Ym1pdFRyaWdnZXIgPSAnc3VibWl0QnRuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGV2LmRlbGVnYXRlVGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyggJ29wdC1idXR0b24tLXBheXBhbCcgKSApIHtcbiAgICAgICAgICAgICAgICBzdWJtaXRUcmlnZ2VyID0gJ3BheXBhbEJ0bic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBldi5kZWxlZ2F0ZVRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoICdvcHQtYnV0dG9uLS11cHNlbGwteWVzJyApICkge1xuICAgICAgICAgICAgICAgIHN1Ym1pdFRyaWdnZXIgPSAndXBzZWxsWWVzJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGV2LmRlbGVnYXRlVGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyggJ29wdC1idXR0b24tLXVwc2VsbC1ubycgKSApIHtcbiAgICAgICAgICAgICAgICBzdWJtaXRUcmlnZ2VyID0gJ3Vwc2VsbE5vJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJGZvcm0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW50ZXJlc3Rpbmcgbm90ZSB3aGlsZSB3b3JraW5nIG9uIE9OVFJBLTE3ODAzLlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIG5vdCB0cmlnZ2VyIHRoZSBmb3JtU3VibWl0SGFuZGxlciBmdW5jdGlvbiBpbiBPTlRSQUZPUk1TLmpzLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgcHJlbG9hZGluZ1xuICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBmb3JtcyBhbmQgdXBkYXRpbmcgcmVtZW1iZXJGaWVsZHMuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBpZiB5b3UgcHJlc3MgZW50ZXIgdG8gc3VibWl0IHRoZSBmb3JtLCB0aGVuIGZvcm1TdWJtaXRIYW5kbGVyIGRvZXMgZ2V0IGZpcmVkLlxuICAgICAgICAgICAgLy8gSSBjb3VsZCBuZXZlciBmaWd1cmUgb3V0IHdoeSwgYnV0IHVsdGltYXRlbHksIGl0IHdhc24ndCBlc3NlbnRpYWwgdG8gbWFrZSB0aGluZ3Mgd29yayBzaW5jZSBmb3JtcyBvblxuICAgICAgICAgICAgLy8gbGFuZGluZyBwYWdlcyBhcmUgc3BlYydkIHRvIG5vdCBwcmVmaWxsIGZpZWxkcyBvbiBwcm9ncmVzc2l2ZSBmb3Jtcy5cbiAgICAgICAgICAgICRmb3JtLnRyaWdnZXIoICdzdWJtaXQnLCBzdWJtaXRUcmlnZ2VyICk7XG4gICAgICAgICAgICAkZm9ybSA9IG51bGw7XG4gICAgICAgIH0gKTtcblxuICAgICAgICAvLyBUZXh0YXJlYSBhdXRvZ3Jvd1xuICAgICAgICAkdjNGb3JtLmZpbmQoICdbb3B0LWlucHV0LXR5cGU9XCJsb25ndGV4dFwiXVtvcHQtaW5wdXQtc3R5bGU9XCJjdXN0b21cIl1bb3B0LXRleHRhcmVhLWF1dG9ncm93PVwidHJ1ZVwiXScgKS5lYWNoKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyICR0ZXh0YXJlYSA9ICQoIHRoaXMgKS5maW5kKCAndGV4dGFyZWEnICksXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IHBhcnNlSW50KCAkdGV4dGFyZWEuY3NzKCAnbGluZUhlaWdodCcgKSApLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3AgPSBwYXJzZUludCggJHRleHRhcmVhLmNzcyggJ3BhZGRpbmctdG9wJyApICksXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KCAkdGV4dGFyZWEuY3NzKCAncGFkZGluZy1ib3R0b20nICkgKTtcblxuICAgICAgICAgICAgJHRleHRhcmVhLm9uKCAna2V5dXAnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtUm93cyA9IHBhcnNlSW50KCAkdGV4dGFyZWEuYXR0ciggJ3Jvd3MnICkgKSxcbiAgICAgICAgICAgICAgICAgICAgbWluUm93cyA9IHBhcnNlSW50KCAkdGV4dGFyZWEuYXR0ciggJ29wdC1taW4tcm93cycgKSApLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSAkdGV4dGFyZWFbIDAgXS5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRydWVIZWlnaHQgPSBzY3JvbGxIZWlnaHQgLSBwYWRkaW5nVG9wIC0gcGFkZGluZ0JvdHRvbSxcbiAgICAgICAgICAgICAgICAgICAgcm93SGVpZ2h0ID0gbnVtUm93cyAqIGxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG1heFJvd3MgPSAxMCxcbiAgICAgICAgICAgICAgICAgICAgbmV3Um93cyxcbiAgICAgICAgICAgICAgICAgICAgbmV3Um93VG90YWw7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRydWVIZWlnaHQgPiByb3dIZWlnaHQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3Um93cyA9ICggdHJ1ZUhlaWdodCAtIHJvd0hlaWdodCApIC8gbGluZUhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICBuZXdSb3dUb3RhbCA9IG51bVJvd3MgKyBuZXdSb3dzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggbmV3Um93VG90YWwgPD0gbWF4Um93cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoIHRoaXMgKS5hdHRyKCAncm93cycsIG5ld1Jvd1RvdGFsICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCB0aGlzICkuYXR0ciggJ3Jvd3MnLCBtYXhSb3dzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG51bVJvd3MgPiBtaW5Sb3dzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICQoIHRoaXMgKS5hdHRyKCAncm93cycsIG1pblJvd3MgKTtcblxuICAgICAgICAgICAgICAgICAgICB0cnVlSGVpZ2h0ID0gJHRleHRhcmVhWyAwIF0uc2Nyb2xsSGVpZ2h0IC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG5cbiAgICAgICAgICAgICAgICAgICAgcm93SGVpZ2h0ID0gbWluUm93cyAqIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0cnVlSGVpZ2h0ID4gcm93SGVpZ2h0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3dzID0gKCB0cnVlSGVpZ2h0IC0gcm93SGVpZ2h0ICkgLyBsaW5lSGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3dUb3RhbCA9IG1pblJvd3MgKyBuZXdSb3dzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCB0aGlzICkuYXR0ciggJ3Jvd3MnLCBuZXdSb3dUb3RhbCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICB9ICk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogQGJyaWVmIEFwcGx5IGN1c3RvbSBjbGFzc2VzIGFuZCBpbmxpbmUgc3R5bGVzIHRvIGEgbWF0ZXJpYWxpemUgZHJvcCBkb3duIGZpZWxkLlxuICAgICAgICAgKiAgICAgICAgVGhlIGN1c3RvbWl6YXRpb24gaXMgc3RvcmVkIG9uIGRlZmF1bHQgPHNlbGVjdD4gbWFya3VwIGFzIGFuIG9wdC0gYXR0cmlidXRlLlxuICAgICAgICAgKiAgICAgICAgQWZ0ZXIgdGhlIG1hdGVyaWFsaXplIGRyb3Bkb3ducyBhcmUgaW5pdGlhbGl6ZWQgdGhpcyBmdW5jdGlvbiBydW5zIGFnYWlucyBhbGxcbiAgICAgICAgICogICAgICAgIG9mIHRoZW0gcGFyc2luZyBpbiB0aGUgY3VzdG9taXphdGlvbiBhbmQgYWRkaW5nIHRoZSBjbGFzc2VzIGFuZCBpbmxpbmUgc3R5bGUgaXQgY29udGFpbnMuXG4gICAgICAgICAqL1xuICAgICAgICAkdjNGb3JtLmZpbmQoICdbb3B0LWRyb3Bkb3duLXN0eWxlc10nICkuZWFjaCggZnVuY3Rpb24oIGluZGV4LCBlbCApIHtcblxuICAgICAgICAgICAgLy8gU3R5bGVTZWxlY3QgZGVmaW5lZCBpbiBvcHQuY29tbW9uLmpzXG4gICAgICAgICAgICBvcC5zdHlsZVNlbGVjdCggJCggdGhpcyApICk7XG5cbiAgICAgICAgfSApO1xuXG4gICAgICAgIC8vIEBUT0RPOiBDaGVjayB0aGlzIHdvcmtzXG4gICAgICAgIC8vIEluaXQgdmFsaWRhdGlvblxuICAgICAgICAkdjNGb3JtLnZhbGlkYXRvcigge1xuICAgICAgICAgICAgZXJyb3JDbGFzczogJ21vb25yYXktZm9ybS1zdGF0ZS1lcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlQ2xhc3M6ICdtb29ucmF5LWZvcm0tZXJyb3ItbWVzc2FnZSBtb29ucmF5LWZvcm0tc3RhdGUtZXJyb3InLFxuICAgICAgICAgICAgb2Zmc2V0OiBbIDAsIDEzIF0sXG4gICAgICAgICAgICBlcnJvcklucHV0RXZlbnQ6ICdpbnB1dCcsXG4gICAgICAgICAgICBpbnB1dEV2ZW50OiAnYmx1cicsXG4gICAgICAgICAgICBmb3JtRXZlbnQ6IG51bGwsXG4gICAgICAgICAgICBlZmZlY3Q6ICdvcHQtdjMnLFxuICAgICAgICAgICAgZ3JvdXBlZDogJ3RydWUnXG4gICAgICAgIH0gKTtcblxuICAgICAgICAvLyBTb21ldGltZXMgZHJvcGRvd25zIHdpbGwgb3BlbiB1cHdhcmRzLiBUaGlzIGxvZ2ljIHdpbGwgbWFrZSBzdXJlIHRoZSBibG9jayB0aGF0IGNvbnRhaW5zIHRoZSBkcm9wZG93biBoYXMgYVxuICAgICAgICAvLyBoaWdoZXIgei1pbmRleCB0aGFuIHRoZSByb3cgYWJvdmUgaXQgdG8gZW5zdXJlIHRoYXQgdGhlIGRyb3Bkb3duIGlzIG5vdCBjb3ZlcmVkLlxuICAgICAgICAkdjNGb3JtLmZpbmQoICdmb3JtIC5vcHQtaW5wdXQtLWRyb3Bkb3duIHVsLmRyb3Bkb3duLWNvbnRlbnQnICkuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbXV0YXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBtdXRhdGlvbnNMaXN0ICkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZU11dGF0aW9ucyA9IG11dGF0aW9uc0xpc3QuZmlsdGVyKCBmdW5jdGlvbiggbXV0YXRpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJyAmJiBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSAnc3R5bGUnICk7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gdGhpcyBmdW5jdGlvbmFsaXR5IG9uY2UsIGFuZCBvbmx5IGlmIGl0IGlzIGEgc3R5bGUgbXV0YXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKCBzdHlsZU11dGF0aW9ucy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uID0gc3R5bGVNdXRhdGlvbnNbIDAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSA9IG11dGF0aW9uLnRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCAnZGlzcGxheScgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEJsb2NrID0gbXV0YXRpb24udGFyZ2V0LmNsb3Nlc3QoICcub3B0LXJvdycgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3BsYXlWYWx1ZSA9PT0gJ2Jsb2NrJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1lbnUgc2hvd1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBwYXJlbnQgYmxvY2sgei1pbmRleCByZWFsbHkgaGlnaCBzbyB0aGUgbWVudXMgc2hvdyBvbiB0b3Agb2YgZXZlcnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFpJbmRleCA9IHBhcmVudEJsb2NrLnN0eWxlLnpJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvbGRaSW5kZXggIT0gOTk5OSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRCbG9jay5zZXRBdHRyaWJ1dGUoICdkYXRhLW9sZC16SW5kZXgnLCBvbGRaSW5kZXggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEJsb2NrLnN0eWxlLnpJbmRleCA9IDk5OTk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1lbnUgaGlkZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29wIG92ZXIgYWxsIGRyb3Bkb3duIGxpc3RzIGluIGJsb2NrLiBJZiBvbmUgaXMgc3RpbGwgb3BlbiwgZG8gbm90IHVuc2V0IHotaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcm9wZG93bkxpc3RzID0gcGFyZW50QmxvY2sucXVlcnlTZWxlY3RvckFsbCggJy5kcm9wZG93bi1jb250ZW50JyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZHJvcGRvd25MaXN0cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkcm9wZG93bkxpc3RzWyBpIF0uc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSggJ2Rpc3BsYXknICkgPT09ICdibG9jaycgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgcGFyZW50IHotaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEJsb2NrLnN0eWxlLnpJbmRleCA9IHBhcmVudEJsb2NrLmdldEF0dHJpYnV0ZSggJ2RhdGEtb2xkLXpJbmRleCcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEJsb2NrLnJlbW92ZUF0dHJpYnV0ZSggJ2RhdGEtb2xkLXpJbmRleCcgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gT3B0aW9ucyBmb3IgdGhlIG9ic2VydmVyICh3aGljaCBtdXRhdGlvbnMgdG8gb2JzZXJ2ZSlcbiAgICAgICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgbGlua2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoIG11dGF0aW9uQ2FsbGJhY2sgKTtcblxuICAgICAgICAgICAgLy8gU3RhcnQgb2JzZXJ2aW5nIHRoZSB0YXJnZXQgbm9kZSBmb3IgY29uZmlndXJlZCBtdXRhdGlvbnNcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoIHRoaXMsIGNvbmZpZyApO1xuICAgICAgICB9ICk7XG5cbiAgICAgICAgLy8gQFRPRE86IENoZWNrIHRoaXMgd29ya3NcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHJlY2FwdGNoYSBlbGVtZW50cyBhbmQgZG8gYW4gaW5pdGlhbCByZWNhcHRjaGEgc2NhbGluZ1xuICAgICAgICAkdjNGb3JtLmZpbmQoICcuZy1yZWNhcHRjaGEnICkuZWFjaCggKCBpLCByZUNhcCApID0+IHtcbiAgICAgICAgICAgIG9wLnJlc2NhbGVDYXB0Y2hhKCByZUNhcCApO1xuICAgICAgICB9ICk7XG5cbiAgICAgICAgJHYzRm9ybS5hZGRDbGFzcyggJ29wdC1mb3JtLS1pbml0aWFsaXplZCcgKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBAYnJpZWYgTW9vbnJheSBmb3JtIGRlcGVuZGFuY3lcbiAgICAgKi9cbiAgICBvcC5yZWFkQ29va2llID0gZnVuY3Rpb24oIG5hbWUgKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gbmV3IFJlZ0V4cCggJyhefDtcXFxccyopJyArIG5hbWUgKyAnPShbXjtdKikoJHw7KScgKTtcbiAgICAgICAgdmFyIG1hdGNoID0gcGF0dGVybi5leGVjKCBkb2N1bWVudC5jb29raWUgKTtcbiAgICAgICAgaWYgKCBtYXRjaCApIHtcbiAgICAgICAgICAgIGxldCByZXQ7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZGVjb2RlLCBpZiBpdCBmYWlscyBpdCBpcyBhbHJlYWR5IGRlY29kZWQgc28ganVzdCB1c2UgdGhhdCBtYXRjaFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXQgPSBkZWNvZGVVUklDb21wb25lbnQoIG1hdGNoWyAyIF0gKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKCBlcnIgKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbWF0Y2hbIDIgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFJlc2NhbGUgYSByZWNhcHRjaGEgZWxlbWVudCB0byBmaXQgaXRzIHBhcmVudCBlbGVtZW50LiBCZWNhdXNlIG91ciBncmlkIGlzIHJlc3BvbnNpdmUsIGFuZCBnb29nZ2xlIGRpZG50XG4gICAgICogbWFrZSByZWNhcHRjaGEgcmVzcG9uc2l2ZS5cbiAgICAgKi9cbiAgICBvcC5yZXNjYWxlQ2FwdGNoYSA9IGZ1bmN0aW9uKCByZUNhcCApIHtcbiAgICAgICAgaWYgKCAhcmVDYXAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgd2lkdGggPSByZUNhcC5wYXJlbnROb2RlLm9mZnNldFdpZHRoO1xuICAgICAgICBsZXQgc2NhbGU7XG4gICAgICAgIGlmICggd2lkdGggPCAzMDIgJiYgd2luZG93LmlubmVyV2lkdGggPiA2MDAgKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHdpZHRoIC8gMzAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NhbGUgPSAxLjA7XG4gICAgICAgIH1cblxuICAgICAgICByZUNhcC5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoJyArIHNjYWxlICsgJyknO1xuICAgICAgICByZUNhcC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAwJztcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBUaGUgcGFnZSBoYXMgYmVlbiByZXNpemVkIHRha2UgYWN0aW9uLlxuICAgICAqL1xuICAgIG9wLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIENoZWNrIGZvciByZWNhcHRjaGEgZWxlbWVudHNcbiAgICAgICAgcmVDYXB0Y2hhQXJyYXkuZm9yRWFjaCggcmVDYXAgPT4gb3AucmVzY2FsZUNhcHRjaGEoIHJlQ2FwICkgKTtcblxuICAgICAgICAvLyBBZHVqc3Qgc3RpY2t5QmxvY2tzXG4gICAgICAgIGlmICggd2luZG93LnN0aWNreUJsb2NrcyApIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBpbiBwb3J0cmFpdCBtb2RlXG4gICAgICAgICAgICBpZiAoIG9wLnByZXZpb3VzV2luZG93SGVpZ2h0ID4gb3AucHJldmlvdXNXaW5kb3dXaWR0aCApIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycldpZHRoID0gTWF0aC5tYXgoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCApLFxuICAgICAgICAgICAgICAgICAgICBjdXJySGVpZ2h0ID0gTWF0aC5tYXgoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwICk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgY2hhbmdlIGluIHdpbmRvdyBzaXplIGlzIHNtYWxsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBwcm9iYWJseSB0aGUgYWRkcmVzcyBiYXIgb24gYSBtb2JpbGUgZGV2aWNlIGhpZGluZy9zaG93aW5nXG4gICAgICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggb3AucHJldmlvdXNXaW5kb3dIZWlnaHQgLSBjdXJySGVpZ2h0ICkgPCAxMDAgJiYgb3AucHJldmlvdXNXaW5kb3dXaWR0aCA9PSBjdXJyV2lkdGggKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wLnByZXZpb3VzV2luZG93SGVpZ2h0ID0gTWF0aC5tYXgoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwICk7XG4gICAgICAgICAgICBvcC5wcmV2aW91c1dpbmRvd1dpZHRoID0gTWF0aC5tYXgoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCApO1xuXG4gICAgICAgICAgICBvcC5idWlsZFN0aWNreUJsb2Nrcyggc3RpY2t5QmxvY2tzICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93Lk9QQ2FwY2hhX2ZpbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBPUHJlQ2FwdGNoYUFsbG93U3VibWl0ID0gdHJ1ZTtcbiAgICAgICAgJCggJy5nLXJlY2FwdGNoYScgKS5yZW1vdmVDbGFzcyggJ21vb25yYXktZm9ybS1zdGF0ZS1lcnJvcicgKTtcbiAgICB9O1xuXG4gICAgd2luZG93Lk9QQ2FwY2hhX2V4cGlyZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgT1ByZUNhcHRjaGFBbGxvd1N1Ym1pdCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEBicmllZlxuICAgICAqIEB0b2RvIENhbiB3ZSBnZXQgcmlkIG9mIHRoZSAkY2xpY2tlZFN1Ym1pdCBzdHVmZiBpbiB2Mz8gTW9vbnJheSBmb3JtIGRlcGVuZGFuY3lcbiAgICAgKi9cbiAgICBvcC5zZXJpYWxpemVGb3JtVG9PYmplY3QgPSBmdW5jdGlvbiggJGZvcm0gKSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSB7fSxcbiAgICAgICAgICAgICRjbGlja2VkU3VibWl0ID0gJGZvcm0uZmluZCggJ1tkYXRhLXN1Ym1pdC1jbGlja2VkXScgKTtcblxuICAgICAgICAkLmVhY2goICRmb3JtLnNlcmlhbGl6ZUFycmF5KCksIGZ1bmN0aW9uKCBpLCBmaWVsZCApIHtcbiAgICAgICAgICAgIGZpZWxkc1sgZmllbGQubmFtZSBdID0gZmllbGQudmFsdWU7XG4gICAgICAgIH0gKTtcblxuICAgICAgICAvLyBQaWNrIHVwIHRoZSBzdWJtaXQgYnV0dG9uIHRoYXQgd2FzIGNsaWNrZWQuIG5lZWRlZCBmb3IgbW9zdGx5IHVwc2VsbFxuICAgICAgICBpZiAoICRjbGlja2VkU3VibWl0Lmxlbmd0aCAmJiAkY2xpY2tlZFN1Ym1pdC5hdHRyKCAnbmFtZScgKSApIHtcbiAgICAgICAgICAgIGZpZWxkc1sgJGNsaWNrZWRTdWJtaXQuYXR0ciggJ25hbWUnICkgXSA9ICRjbGlja2VkU3VibWl0LnZhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9O1xuXG4gICAgLypcbiAgICogU3VwZXIgc21hbGwgdGVtcGxhdGluZyBlbmdpbmVcbiAgICogaHR0cDovL21pci5hY3Vsby51cy8yMDExLzAzLzA5L2xpdHRsZS1oZWxwZXJzLWEtdHdlZXQtc2l6ZWQtamF2YXNjcmlwdC10ZW1wbGF0aW5nLWVuZ2luZS9cbiAgICpcbiAgICogdXNlZCB0byBkaXNwbGF5IHRoZSBzdGF0dXMgbWVzc2FnZXMgd2hlbiBjb250YWN0aW5nIHRoZSBzZXJ2ZXJcbiAgICovXG4gICAgb3AudCA9IGZ1bmN0aW9uKCBzLCBkICkge1xuICAgICAgICBmb3IgKCB2YXIgcCBpbiBkICkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSggbmV3IFJlZ0V4cCggJ3snICsgcCArICd9JywgJ2cnICksIGRbIHAgXSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG5cbiAgICBvcC5wcmV2aW91c1dpbmRvd0hlaWdodCA9IE1hdGgubWF4KCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCApO1xuICAgIG9wLnByZXZpb3VzV2luZG93V2lkdGggPSBNYXRoLm1heCggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwICk7XG5cbiAgICAvLyBCaW5kIGFuIG9wIGdsb2JhbCByZXNpemUgZXZlbnQuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCBvcC5kZWJvdW5jZSggb3AucmVzaXplLCAyNTAgKSApO1xuXG4gICAgLypcbiAgICAgKiBAYnJpZWYgU3R1ZmYgdG8gbWFrZSBmb3JtIGNvbmRpdGlvbnMgd29yay5cbiAgICAgICAgICAgICAgT3ZlcnJpZGUgb3V0Y29tZXMsIHdpdGggb25lcyB0aGF0IGRldGVjdCBpZiB0aGUgaW5wdXQgaXMgcmVxdWlyZWQgYW5kIHRvZ2dsZSB0aGUgcmVxdWlyZWRuZXNzXG4gICAgICovXG4gICAgaWYgKCAkLmpiICkge1xuICAgICAgICAkLmV4dGVuZCggJC5qYi5mb3JtQ29uZGl0aW9ucy5wcm90b3R5cGUub3V0Y29tZUFjdGlvbnMsIHtcbiAgICAgICAgICAgIHNob3c6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHZhciByZXF1aXJlZCA9IGVsZW0uYXR0ciggJ2RhdGEtcmVxdWlyZWQnICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHJlcXVpcmVkID09ICd0cnVlJyApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5hdHRyKCAncmVxdWlyZWQnLCAncmVxdWlyZWQnICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbS5wYXJlbnQoKS5zaG93KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZTogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVpcmVkID0gZWxlbS5hdHRyKCAnZGF0YS1yZXF1aXJlZCcgKTtcblxuICAgICAgICAgICAgICAgIGlmICggcmVxdWlyZWQgPT0gJ3RydWUnICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHIoICdyZXF1aXJlZCcgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbGVtLnBhcmVudCgpLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQGJyaWVmIE1ha2UgdjMgZm9ybSBzbWFydFxuICAgICAqL1xuICAgICQuZm4ubW9vbnJheVNtYXJ0Rm9ybSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG4gICAgICAgICQuZXh0ZW5kKCAkLmZuLm1vb25yYXlTbWFydEZvcm0sIHtcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgICAgZGVidWc6IElOX0RFQlVHX01PREVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgICRkb2N1bWVudEJvZHkubW9vbnJheVVJTG9ja2VyVjIoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBhbmQgaW50ZXJlc3RpbmcgdXNlIGNhc2Ugd2hlcmUgbW96aWxsYSByZXVzZXMgYSByZW5kZXJlZCBwYWdlIG9uIGhpc3RvcnkuZ28oIC0xICkuXG4gICAgICAgICAqIFRoZSB1aUxvY2tlck1lc3NhZ2Ugd291bGQgc3RpbGwgYmUgb24gdGhlIHBhZ2UgKGFzIHRob3VnaCB0aGUgZm9ybSB3YXMgc3RpbGwgcHJvY2Vzc2luZykuXG4gICAgICAgICAqIFNvIGJlZm9yZSB0aGUgd2luZG93IHVubG9hZHMsIHR1cm4gb2ZmIHRoZSB1aUxvY2tlciBcIlByb2Nlc3NpbmdcIiBkaWFsb2cuXG4gICAgICAgICAqL1xuICAgICAgICAkKCB3aW5kb3cgKS5vbiggJ3VubG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCggZG9jdW1lbnQuYm9keSApLnRyaWdnZXIoICdtb29ucmF5LnVpTG9ja2VyVjInICk7XG4gICAgICAgIH0gKTtcblxuICAgICAgICAvLyBUT09EOiBhZGQgaW4gZGVidWcgc2V0dGluZ3NcbiAgICAgICAgLy8gdGhpcyByZWZlcnMgdG8gdGhlIGZvcm0gb24gdGhlIHBhZ2VcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciBncmlkQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAkdGhpcyA9ICQoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICAkZm9ybSA9ICR0aGlzLFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGVsZW1lbnQgaXMgcHJlc2VudFxuICAgICAgICAgICAgICAgIFVJRCA9ICRmb3JtLmZpbmQoICdbbmFtZT1cInVpZFwiXScgKS52YWwoKSxcbiAgICAgICAgICAgICAgICBsb2dfa2V5ID0gJGZvcm0uZmluZCggJ1tuYW1lPVwibW9wYmVsZ1wiXScgKS52YWwoKSxcblxuICAgICAgICAgICAgICAgIC8vIFVzZWQgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgQkUgZm9yICBjcmVkaXQgY2FyZCBwcm9jZXNzaW5nLCBjYXB0Y2hhLCBjb3Vwb24gY29kZXMgYW5kIHVwc2VsbCBmb3JtcyB3aXRoIG9udHJhZm9ybXNcbiAgICAgICAgICAgICAgICAkaWZyYW1lID0gJCggJzxpZnJhbWUvPicgKSxcblxuICAgICAgICAgICAgICAgIF9sb2cgPSBmdW5jdGlvbiggbmFtZSwgZGF0YSwgbGV2ZWwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggb3AgJiYgb3AubG9nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AubG9nKCBsb2dfa2V5LCBuYW1lLCBkYXRhLCBsZXZlbCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIF9mbHVzaERlYnVnTG9ncyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG9wICYmIG9wLmZsdXNoRGVidWdMb2dzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AuZmx1c2hEZWJ1Z0xvZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBfZGVidWdMb2cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvZyggJ2NjX3ZlcmlmeV9mZScsIHsgYXJnczogYXJndW1lbnRzIH0sIHdpbmRvdy5MT0dfTEVWRUxfREVCVUcgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvcC5kZWJ1ZyB8fCBJTl9ERUJVR19NT0RFICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgYW4gaW1wb3J0YW50IHZhcmlhYmxlLiBXZSBzZXQgdGhpcyB0byBmYWxzZSBqdXN0IGJlZm9yZSB3ZSBsb2FkIGEgbmV3IGlmcmFtZS4gV2hlbiBpdCBmaW5hbGx5XG4gICAgICAgICAgICAgICAgICogbG9hZHMsIHRoZW4gd2Ugc2V0IHRoaXMgdmFyIHRvIHRydWUuIEl0J3MgbW9zdGx5IHVzZWQgdG8gY29udHJvbCB3aGV0aGVyIHRvIGtlZXAgZGlzcGxheWluZyB0aGVcbiAgICAgICAgICAgICAgICAgKiBcImZvcm0gaXMgcHJvY2Vzc2luZ1wiIGRpYWxvZy5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZnJhbWVfZG9uZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoICQuZm4ubW9vbnJheVNtYXJ0Rm9ybS5zZXR0aW5ncy5kZWJ1ZyApIHtcbiAgICAgICAgICAgICAgICAvLyBMZXRzIG1ha2UgaXQgZWFzeSB0byBzZWUgd2hhdHMgZ29pbmcgaW4gdGhlIGZvcm0gcHJvY2Vzc29yXG4gICAgICAgICAgICAgICAgJGlmcmFtZS5hdHRyKCB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMDBweCdcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRpZnJhbWUuaGlkZSgpLmF0dHIoIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGlmcmFtZS5hdHRyKCB7XG4gICAgICAgICAgICAgICAgZnJhbWVib3JkZXI6IDAsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Bvc3RtZXNzYWdlLScgKyBVSURcbiAgICAgICAgICAgIH0gKS5hcHBlbmRUbyggZG9jdW1lbnQuYm9keSApO1xuXG4gICAgICAgICAgICAvLyBUaGVzZSAzIHZhcnMgYXJlIHVzZWQgZm9yIHN3YXBwaW5nIHRoZSB1aSBsb2NrZXIgcHJvY2Vzc2luZyBkaWFsb2dcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSAxODAwMDAsXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50ZXIgPSAxMDAwO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcblxuICAgICAgICAgICAgbGV0IHByb2Nlc3NpbmdTdGF0ZU1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgIHsgdGl0bGU6ICdTdGlsbCBwcm9jZXNzaW5nLi4uJyB9LFxuICAgICAgICAgICAgICAgIHsgdGl0bGU6ICdTdGlsbCB3b3JraW5nLi4uJyB9LFxuICAgICAgICAgICAgICAgIHsgdGl0bGU6ICdUYWtpbmcgYSBsaXR0bGUgbG9uZ2VyIHRoYW4gZXhwZWN0ZWQuLi4nIH1cbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBwYWdlIGR1bXBzIHNvbWUgY3VzdG9tIGluZm9ybWF0aW9uIG9uIHRoZSBwYWdlLCB0aGVuIHVzZSB0aGF0IGRhdGEgaW5zdGVhZC5cbiAgICAgICAgICAgIC8vIG11bHRpcGxlRGF0YSBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBpbiB0aGUgcHJvY2Vzc2luZyBkaWFsb2cuXG4gICAgICAgICAgICAvLyBXZSBzcGVjaWZ5IHRoaXMgZGF0YSByaWdodCB3aGVuIHRoZSBmb3JtIGlzIGluaXRpYWxpemVkIHNvIHRoYXQgdGhlIF9wcm9jZXNzaW5nU3RhdGVNZXNzYWdlcyBhcmd1bWVudFxuICAgICAgICAgICAgLy8gZm9yIHRoZSB1aUxvY2tlclN3YXBNZXNzYWdlIElJRkUgY2FuIGJlIGNhcHR1cmVkLlxuICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzeXN0ZW0gb25seSBhbGxvd3MgZm9yIE9ORSBzZXQgb2YgY3VzdG9tIGZvcm0gcHJvY2Vzc2luZyBkYXRhIHBlciBwYWdlLlxuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgd291bGQgd2FudCB0byBoYXZlIGN1c3RvbSBmb3IgcHJvY2Vzc2luZyBkYXRhIGZvciBlYWNoIGZvcm0gb24gdGhlIHBhZ2UsXG4gICAgICAgICAgICAvLyB0aGVuIHdlIHdvdWxkIG5lZWQgdG8gY29tZSB1cCB3aXRoIGEgc3lzdGVtIHRvIG9yZ2FuaXplIHRoYXQuXG4gICAgICAgICAgICBpZiAoIHdpbmRvdy5vcCAmJlxuICAgICAgICAgICAgICAgICB3aW5kb3cub3AuY3VzdG9tRm9ybVByb2Nlc3NpbmdEYXRhICYmXG4gICAgICAgICAgICAgICAgIHdpbmRvdy5vcC5jdXN0b21Gb3JtUHJvY2Vzc2luZ0RhdGEudGhlbWUgPT09ICdtdWx0aXBsZScgJiZcbiAgICAgICAgICAgICAgICAgd2luZG93Lm9wLmN1c3RvbUZvcm1Qcm9jZXNzaW5nRGF0YS5tdWx0aXBsZURhdGEgJiZcbiAgICAgICAgICAgICAgICAgd2luZG93Lm9wLmN1c3RvbUZvcm1Qcm9jZXNzaW5nRGF0YS5tdWx0aXBsZURhdGEubGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdTdGF0ZU1lc3NhZ2VzID0gd2luZG93Lm9wLmN1c3RvbUZvcm1Qcm9jZXNzaW5nRGF0YS5tdWx0aXBsZURhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdpbGwgaXRlcmF0ZSB0aHJvdWdoIGFuZCBkaXNwbGF5IHRoZSBfcHJvY2Vzc2luZ1N0YXRlTWVzc2FnZXNcbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIGhhdmUgdGhlIHByb2Nlc3NpbmcgZGlhbG9nIHNob3cgZGlmZmVyZW50IGNvbnRlbnRcbiAgICAgICAgICAgIGNvbnN0IHVpTG9ja2VyU3dhcE1lc3NhZ2UgPSAoIGZ1bmN0aW9uKCBfcHJvY2Vzc2luZ1N0YXRlTWVzc2FnZXMsIF8kZG9jdW1lbnRCb2R5ICkge1xuXG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2VJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHNob3dNZXNzYWdlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjdXJyZW50IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgXyRkb2N1bWVudEJvZHkudHJpZ2dlciggJ21vb25yYXkudWlMb2NrZXJWMicgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNob3dNZXNzYWdlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93TWVzc2FnZSA9IF9wcm9jZXNzaW5nU3RhdGVNZXNzYWdlc1sgbWVzc2FnZUluZGV4ICUgX3Byb2Nlc3NpbmdTdGF0ZU1lc3NhZ2VzLmxlbmd0aCBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1lc3NhZ2VJbmRleCA+IDMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjAgc2Vjb25kcyBoYXMgZWxhcHNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNZXNzYWdlLnRoZW1lID0gJ3dhcm5pbmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNyZW1lbnQgdGhlIG1lc3NhZ2VJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTaG93IG5ldyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIF8kZG9jdW1lbnRCb2R5LnRyaWdnZXIoICdtb29ucmF5LnVpTG9ja2VyVjInLCBzaG93TWVzc2FnZSApO1xuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gKSggcHJvY2Vzc2luZ1N0YXRlTWVzc2FnZXMsICRkb2N1bWVudEJvZHkgKTtcblxuICAgICAgICAgICAgLy8gQ29udGludWFsbHkgY2FsbCBpdHNlbGYgYW5kIHVpTG9ja2VyU3dhcE1lc3NhZ2UgdG8gc2hvdyBkaWZmZXJlbnQgY29udGVudCBpbiB0aGUgcHJvY2Vzc2luZyBkaWFsb2dcbiAgICAgICAgICAgIGNvbnN0IHVpTG9ja2VyU3dhcENvbnRlbnRDaGVja2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBpZnJhbWVfZG9uZSA9PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBpbmNyZW1lbnRlcjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICggY291bnQgJSA1MDAwICkgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeSA1IHNlY29uZHMsIHVwZGF0ZSB0aGUgcHJvY2Vzc2luZyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB1aUxvY2tlclN3YXBNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvdW50ID09IDQwMDAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZsdXNoRGVidWdMb2dzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvdW50ID49IHRpbWVvdXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc3QgdGhlIG5ldyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB1aUxvY2tlclN3YXBNZXNzYWdlKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUcmFuc2FjdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdQbGVhc2UgdHJ5IGFnYWluIGxhdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZTogJ2Vycm9yJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVidWdMb2coICdwcm9jZXNzaW5nIHRpbWVkIG91dC4gaWZyYW1lIGRvbmUgaXMgdHJ1ZS4nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVfZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZmx1c2hEZWJ1Z0xvZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRmb3JtLnJlbW92ZUF0dHIoICdsb2NrZWQnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaWZyYW1lLmNzcyggeyBkaXNwbGF5OiAnbm9uZScgfSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCB1aUxvY2tlclN3YXBDb250ZW50Q2hlY2tlciwgaW5jcmVtZW50ZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGlmcmFtZV9kb25lID09PSB0cnVlICkge1xuICAgICAgICAgICAgICAgICAgICBfZGVidWdMb2coICdpZnJhbWUgZG9uZSBpcyB0cnVlIGluIHN3YXAgY29udGVudCBjaGVja2VyJyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBVc2VkIGFzIG91ciBDT1JTXG4gICAgICAgICAgICAgKiBhbHNvIGhhbmRsZXMgdGhlIGZlZWQgYmFjayBvZiB3ZXJlIHRoZSByZXF1ZXN0IGlzIGdldHRpbmcgc2VudFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqID8gaXMgYXBwZW5kZWQgdG8gZWFjaCB1cmwgLSAgbWFrZXMgaXQgZWFzeSB0byB3b3JrIHdpdGggcGFyYW1zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBjaGFuZ2VJZnJhbWVVcmwgPSBmdW5jdGlvbiBjaGFuZ2VJZnJhbWVVcmwoIHVybCwgcGFyYW1zLCBkaXNhYmxlQ2hlY2tlciwgaGFzaCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZnJhbWVfZG9uZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVybCA9PSAnIycgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZm9ybS5yZW1vdmVBdHRyKCAnbG9ja2VkJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlmcmFtZS5jc3MoIHsgZGlzcGxheTogJ25vbmUnIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIERvaW5nIG1ha2VzIHNzbCBwYWdlcyB1bnNlY3VyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogaWZyYW1lLnJlbW92ZUF0dHIoJ3NyYycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICRpZnJhbWVbIDAgXS5jb250ZW50V2luZG93LmxvY2F0aW9uLnJlcGxhY2UoICdhYm91dDpibGFuaycgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhY2sgdGhlIG51bWJlciBvZiB0aW1lcyB0aGlzIGRpYWxvZyBwb3BzIHVwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIF9zdWJtaXRBdHRlbXB0c1sgVUlEIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3VibWl0QXR0ZW1wdHNbIFVJRCBdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgX3N1Ym1pdEF0dGVtcHRzWyBVSUQgXSsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHJhbmRvbSBzbyBpZiB3ZSBjaGFuZ2UgdGhlIHVybCB0byB0aGUgc2FtZSB1cmwgaXQgd2lsbCByZWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5tcl9yYW5kID0gKCBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogOTk5OTk5MSApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIHVpZCBvZiB0aGlzIGZvcm0gc28gdGhlIGRvY3VtZW50LnBvc3RNZXNzYWdlIGhhbmRsZXIga25vd3Mgd2hhdCBmb3JtIHRoZSByZXNwb25zZSBpcyBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy51aWQgPSBVSUQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zdWJtaXRBdHRlbXB0cyA9IF9zdWJtaXRBdHRlbXB0c1sgVUlEIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmloYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNoID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJpaGFzaCA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVyaWhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wYXJlbnRfdXJsID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVyaWhhc2ggPSBlbmNvZGVVUklDb21wb25lbnQoIHVyaWhhc2ggKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gJC5wYXJhbSggcGFyYW1zICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9kZWJ1Z0xvZyggJ2lmcmFtZSBjaGFuZ2luZyB1cmwgdG8gJywgdXJsICsgJz8nICsgcGFyYW1zICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICRpZnJhbWVbIDAgXS5jb250ZW50V2luZG93LmxvY2F0aW9uLnJlcGxhY2UoIHVybCArICc/JyArIHBhcmFtcyArICcjJyArIHVyaWhhc2ggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRpZnJhbWVbIDAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBvbmxvYWQgaW5zdGVhZCBvZiAubG9hZCBjYXVzZSB0aGUgbG9hZCBmdW5jdGlvbiBlbmRzIHVwIGdldHRpbmcgY2FsbGVkIHRoZSAjIG9mIHRpbWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN1Ym1pdCBidXR0b24gZ2V0cyBjYWxsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZWJ1Z0xvZyggJ2lmcmFtZSBsb2FkZWQnLCB1cmwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNoID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN0b3AgdGhlIGNoZWNrZXIgaWYgdGhlcmUncyBubyBoYXNoLiBPdGhlcndpc2UsIHdlIHJlbHkgb24gZXh0ZXJuYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyB0byBkZWNpZGUgaWYgd2UncmUgZG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZWJ1Z0xvZyggJ3NldHRpbmcgaWZyYW1lX2RvbmUgdG8gdHJ1ZSB3aGVuIG5vIGhhc2gnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVfZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFkaXNhYmxlQ2hlY2tlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aUxvY2tlclN3YXBDb250ZW50Q2hlY2tlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgQ2FsbGVkIG9uIGZvcm0gc3VibWl0LCBuZWVkZWQgdG8gdmVyaWZ5IHdpdGggdGhlIHNlcnZlciBhbmQgb3IgcG9zdCBkYXRhIHRvIHRoZSBzZXJ2ZXIgdG8gdmVyaWZ5IGV2ZXJ5dGhpbmcgaXMgYWxsc2V0XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBQUk9DRVNTT1JTID0ge1xuICAgICAgICAgICAgICAgICAgICBjY192ZXJpZnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAkZm9ybS5maW5kKCAnaW5wdXRbbmFtZT1wYXltZW50X251bWJlcl0nICkubGVuZ3RoID09IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IGFyZSBwYXlpbmcgd2l0aCBwYXlwYWwgc28gd2UgZG9uJ3QgbmVlZCB0byBoaXQgdXAgY2MgdmVyaWZ5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggJGZvcm0uZmluZCggJ2lucHV0W25hbWU9cGF5cGFsXScgKS52YWwoKSA9PT0gJ3llcycgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBmaWVsZHMgZ2V0IGluamVjdGVkIGludG8gdGhlIGZvcm0gaWYgdGhlIGNyZWRpdCBjYXJkIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggJGZvcm0uZmluZCggJzppbnB1dFtuYW1lPXBheWVyX2lkXSwgOmlucHV0W25hbWU9dHJhbnNhY3Rpb25faWRdJyApLmxlbmd0aCAhPSAyICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSBvcC5zZXJpYWxpemVGb3JtVG9PYmplY3QoICRmb3JtICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjb250YWN0IC8gY2lkIG91dCBvZiB0aGUgYWN0aW9uIHVybCBpZiBhbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjaWQgdG8gcG9zdCBmaWVsZHMgc28gd2UgdXNlIHRoZSBzYW1lIGNvbnRhY3QgaWQgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZBY3Rpb24gPSAkZm9ybS5hdHRyKCAnYWN0aW9uJyApLnNwbGl0KCAnZm9ybV9wcm9jZXNzb3IucGhwPycgKVsgMSBdLnNwbGl0KCAnJicgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBmQWN0aW9uLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZkFjdGlvblsgaSBdLm1hdGNoKCAvY2lkPS8gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHMuY2lkID0gZkFjdGlvblsgaSBdLnJlcGxhY2UoICdjaWQ9JywgJycgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcG9vZiB0aGUgbHBpZCBmb3IgY2MgdmVyZml5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB3aW5kb3cubXJfbHBfaWQgPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHMubHBpZCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkcy5scGlkID0gd2luZG93Lm1yX2xwX2lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc09OVFJBZm9ybSA9IHdpbmRvdy5pc09OVFJBZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9OVFJBZm9ybUlEID0gaXNPTlRSQWZvcm0gJiYgaXNPTlRSQWZvcm0uZm9ybVVJRC5zcGxpdCggJ2YnIClbIDEgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlzT05UUkFmb3JtICYmIE9OVFJBZm9ybUlEICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzLmxpZ2h0X2Zvcm1faWQgPSBPTlRSQWZvcm1JRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCBvcmRlciBmb3JtIGtub3cgaWYgdGhleSBhcmUgZHluYW1pYyBwYWdlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvcC5pc0R5bmFtaWNQYWdlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzLmlzRHluYW1pY1BhZ2UgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBzcGFjZXMgYW5kIGRhc2hlcyBpbiBjYyBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzLnBheW1lbnRfbnVtYmVyID0gZmllbGRzLnBheW1lbnRfbnVtYmVyLnJlcGxhY2UoIC9bIC1dL2csICcnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSWZyYW1lVXJsKCBDQ19WRVJJRllfRE9NQUlOLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ1RvSGV4KCBkZXMoICdVbjFjT3JucycsIHVuZXNjYXBlKCBlbmNvZGVVUklDb21wb25lbnQoIEpTT04uc3RyaW5naWZ5KCBmaWVsZHMgKSApICksIDEgKSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gcGF5bWVudCBmaWVsZHMsIHBhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwc2VsbHMgYXJlIGdldHRpbmcgZmFuY3lcbiAgICAgICAgICAgICAgICAgICAgaXNVcHNlbGxGb3JtOiBmdW5jdGlvbiggZXYsIHN1Ym1pdFRyaWdnZXIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc3Vwc2VsbCA9ICRmb3JtLmZpbmQoICcub3B0LWJ1dHRvbi0tdXBzZWxsJyApLmxlbmd0aCA9PT0gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uID0gJGZvcm0uYXR0ciggJ2FjdGlvbicgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc09OVFJBZm9ybSA9IHdpbmRvdy5pc09OVFJBZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPTlRSQWZvcm1JRCA9IGlzT05UUkFmb3JtICYmIGlzT05UUkFmb3JtLmZvcm1VSUQuc3BsaXQoICdmJyApWyAxIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGNvdWxkIGVuZCB1cCB3aXRoIGFuIG9udHJhZm9ybSBwb3B1cFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc3Vwc2VsbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE5lZWQgdG8gcGFyc2Ugb3V0IHRoZSBmb3JtIGFjdGlvbiB0aGlzIGZvcm0gd2FzIHN1Ym1pdHRlZCB3aXRoIGFuZCBsb29rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZm9yIHNwZWNpZmljIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMb2dpYyBwdWxsZWQgZnJvbSBPTlRSQUZPUk1TLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IG9wLnNlcmlhbGl6ZUZvcm1Ub09iamVjdCggJGZvcm0gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1TdHJpbmcgPSBmb3JtQWN0aW9uLnNwbGl0KCAnPycgKVsgMSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRGb3JtQWN0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwYXJhbVN0cmluZyAmJiBwYXJhbVN0cmluZy5yZXBsYWNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbVN0cmluZy5yZXBsYWNlKCAvKFtePSZdezEsfSk9KFteJl17MSx9KS9nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGtleVZhbHVlUGFpciwga2V5LCB2YWx1ZSwgaW5kZXgsIHNvdXJjZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRGb3JtQWN0aW9uc1sga2V5IF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDaWQsIGxpZ2h0X2Zvcm1faWQgYW5kIF9saWdodFJlc3BvbnNlIGFyZSBuZWVkZWQgYnkgdGhlIEJFIGluIGZvcm1fcHJvY2Vzc29yLnBocC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBmaWVsZHMgaW4gdGhlIGZvcm0sIGJ1dCB0aGV5IGFyZSBwYXJ0IG9mIHRoZSBmb3JtIGFjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvIGxldCdzIG1ha2Ugc3VyZSB0aGVzZSBhcmUgcGFydCBvZiB0aGUgZGF0YSB3ZSBzZW5kIG92ZXIgdG8gdGhlIEJFLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaWQgPSBwYXJzZWRGb3JtQWN0aW9ucy5jaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpZ2h0X2Zvcm1faWQgPSBwYXJzZWRGb3JtQWN0aW9ucy5saWdodF9mb3JtX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWdodFJlc3BvbnNlID0gcGFyc2VkRm9ybUFjdGlvbnMuX2xpZ2h0UmVzcG9uc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNpZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzLmNpZCA9IGNpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxpZ2h0X2Zvcm1faWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkcy5saWdodF9mb3JtX2lkID0gbGlnaHRfZm9ybV9pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBPTlRSQWZvcm1JRCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzLmxpZ2h0X2Zvcm1faWQgPSBPTlRSQWZvcm1JRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxpZ2h0UmVzcG9uc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkcy5fbGlnaHRSZXNwb25zZSA9IGxpZ2h0UmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgcG9zc2libHkgaGF2ZSBhbiBPTlRSQUZPUk1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzLl9saWdodFJlc3BvbnNlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHN1Ym1pdCB1cHNlbGwgZmllbGQgdG8gdGhlIGZpZWxkcyBzbyB0aGUgQkUga25vd3MgaXRzIGFuIHVwc2VsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3VibWl0VHJpZ2dlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdWJtaXRUcmlnZ2VyID09PSAndXBzZWxsWWVzJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkcy51cHNlbGxfZm9ybV9hY3Rpb25feWVzID0gJ3llcyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHMudXBzZWxsX2Zvcm1fYWN0aW9uX25vID0gJ25vJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUlmcmFtZVVybCggZm9ybUFjdGlvbi5zcGxpdCggJz8nIClbIDAgXSwgZmllbGRzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gSW50ZXJhY3Rpb24gcXVldWUgY2xhc3Nlcy5cbiAgICAgICAgICAgICRmb3JtLmRlbGVnYXRlKCAnaW5wdXQ6bm90KDpzdWJtaXQpLCBzZWxlY3QsIHRleHRhcmVhJywgJ2ZvY3VzIGJsdXInLCBmdW5jdGlvbiggZXYgKSB7XG5cbiAgICAgICAgICAgICAgICAkKCB0aGlzICkudG9nZ2xlQ2xhc3MoICdtb29ucmF5LWZvcm0tc3RhdGUtYWN0aXZlJyApO1xuXG5cbiAgICAgICAgICAgICAgICAvLyBGb3JjZSB0aGUgb3JkZXIgc3VtbWFyeSB0byB1cGRhdGUgc3R5bGVzIGlmIHRoZSBudW1iZXIgaXMgdG9nZ2xlZCwgY2hhbmdpbmcgdGhlIHF1YW50aXR5IHRyaWdnZXJzIHRoZSBjaGFuZ2UgY2FsbGJhY2sgaGFuZGxlciBpbiB0aGUgb3JkZXIgc3VtbWFyeSB0byBmaXJlLlxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoICdvbnRyYXBvcnRfZ3JpZGNlbGxfaW5wdXRfbnVtYmVyLS1lZGl0LXF1YW50aXR5JyApICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3MgPSB0aGlzLmNsb3Nlc3QoICdvbnRyYXBvcnQtb3JkZXItc3VtbWFyeScgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF0eSA9IG9zLmdldEF0dHJpYnV0ZSggJ3VwZGF0ZS1zdW1tYXJ5LXN0eWxlJyApO1xuXG4gICAgICAgICAgICAgICAgICAgIG9zLnNldEF0dHJpYnV0ZSggJ3VwZGF0ZS1zdW1tYXJ5LXN0eWxlJywgK3F0eSArIDEgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgLy8gTmVlZCB0byBrbm93IHdoYXQgc3VibWl0IGJ1dHRvbiB3YXMgY2xpY2tlZCwgdGhpcyBpcyBlc3BlY2lhbGx5IHRoZSBjYXNlIGZvciB1cHNlbGwgZm9ybXMuXG4gICAgICAgICAgICAkZm9ybS5kZWxlZ2F0ZSggJ2lucHV0W3R5cGU9XCJzdWJtaXRcIl0sIGlucHV0W3R5cGU9XCJpbWFnZVwiXScsICdjbGljaycsIGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgICAgICQoIHRoaXMgKS5hdHRyKCAnZGF0YS1zdWJtaXQtY2xpY2tlZCcsIHRydWUgKTtcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEZpbmQgYWxsIG9mIHRoZSByZXF1aXJlZCBpbnB1dHMgYW5kIGFkZCBjcmVhdGUgYSBkYXRhLXJlcXVpcmVkIGZsYWdcbiAgICAgICAgICAgICAqIHRoaXMgd2F5IGNvbmRpdGlvbnMgY2FuIHBpY2t1cCBvbiB0aGVtXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogbWFrZSBzdXJlIHRoaXMgZ2V0cyBzZXQgb24gdGhlIHNoaXBwaW5nIHNlbGVjdCBhbmQgcGF5bWVudCBwbGFuIHJhZGlvc1xuICAgICAgICAgICAgICogICAgICBub3Qgc3VyZSB0aGlzIGlzIG5lZWRlZCBiZWNhdXNlLCB3ZSB3aWxsIG5ldmVyIGhpZGUgdGhlc2UgaW5wdXRzLCB0aHVzIG5ldmVyIG1ha2UgdGhlbSB1bnJlcXVpcmVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICRmb3JtLmZpbmQoICdbcmVxdWlyZWRdJyApLmF0dHIoICdkYXRhLXJlcXVpcmVkJywgJ3RydWUnICk7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzVXNpbmdPcHREYXRlVGltZVBpY2tlcklucHV0cyA9ICRmb3JtLmZpbmQoICcub3B0LWRhdGUtdGltZS1maWVsZF9faGlkZGVuLWZpZWxkLm9wdC1kYXRlLWZpZWxkW3R5cGU9XCJoaWRkZW5cIl0nICkubGVuZ3RoID4gMCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGRhdGUgZmllbGRzIGFuZCByZXN0b3JlIHRoZSBpbnB1dCB0eXBlIHNvIHdlIGNhbiBoYXZlIGRhdGUgcGxhY2Vob2xkZXJzIG9uIElPUyBkZXZpY2VzLlxuICAgICAgICAgICAgaWYgKCAhaXNVc2luZ09wdERhdGVUaW1lUGlja2VySW5wdXRzICkge1xuXG4gICAgICAgICAgICAgICAgJGZvcm0uZmluZCggJ2lucHV0W3R5cGU9ZGF0ZV0sIGlucHV0Lm9wdC1kYXRlLXRpbWUtZmllbGQnICkuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggL2lQYWR8aVBob25lfGlQb2QvLnRlc3QoIG5hdmlnYXRvci51c2VyQWdlbnQgKSAmJiAhd2luZG93Lk1TU3RyZWFtICYmICF0aGlzLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgZGF0ZSBpbnB1dHMgdG8gdXNlIHRoZSBkYXRlIHR5cGUgb24gaU9TXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnZGF0ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uYmx1ciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvdXBvbiBjb2RlIGhhbmRsZXIsIGFuZCBldmVudCBiaW5kaW5nc1xuICAgICAgICAgICAgLy8gZGVib3VjZSB0aGlzIGJlY2F1c2UgdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkIGZyb20gdGhlIHVzZXIgY2xpY2sgYW5kIHRyaWdnZXJlZCBpbiB0aGUgZ3JpZCBjZWxsIGNvbnRyb2xsZXJcbiAgICAgICAgICAgIC8vIHRoaXMga2VlcHMgdXMgZnJvbSBoaXR0aW5nIHRoZSBiYWNrIGVuZCB0d2ljZSBmb3IgdGhlIHNhbWUgcmVxdWVzdC5cbiAgICAgICAgICAgIGNvbnN0IF9jb3Vwb25FdmVudEhhbmRsZXIgPSBvcC5kZWJvdW5jZSAoIGZ1bmN0aW9uIF9jb3Vwb25FdmVudEhhbmRsZXIoIGZhbHNseWNoZWNrICkge1xuXG5cbiAgICAgICAgICAgICAgICB2YXIgY291cG9uVmFsdWUgPSAkZm9ybS5maW5kKCAnaW5wdXRbbmFtZT1cImNvdXBvbkNvZGVcIl0nICkudmFsKCk7XG4gICAgICAgICAgICAgICAgaWYgKCBjb3Vwb25WYWx1ZSA9PSAnJyAmJiBmYWxzbHljaGVjayA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdyaWRDb250cm9sbGVyID0gJGZvcm0uZmluZCggJy5tb29ucmF5LWZyb20tb2ZmZXItZ3JpZCcgKS5jb250cm9sbGVyKCk7XG4gICAgICAgICAgICAgICAgdmFyIG9mZmVyTW9kZWwgPSBncmlkQ29udHJvbGxlci5vZmZlckNvcHk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RyaWdnZXJDb3Vwb25DaGFuZ2UoIGNvdXBvblZhbHVlLCBvZmZlck1vZGVsICk7XG4gICAgICAgICAgICAgICAgfSwgNTAgKTtcblxuICAgICAgICAgICAgfSwxMDAgKTtcblxuICAgICAgICAgICAgb3AuX2NvdXBvbkV2ZW50SGFuZGxlciA9IF9jb3Vwb25FdmVudEhhbmRsZXIgO1xuXG4gICAgICAgICAgICAkZm9ybS5kZWxlZ2F0ZSggJ2lucHV0W25hbWUqPVxcJ3BheW1lbnRfcGxhblxcJ10nLCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICBfY291cG9uRXZlbnRIYW5kbGVyKCB0cnVlICk7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICRmb3JtLmRlbGVnYXRlKCAndGQub250cmFwb3J0X2dyaWRjZWxsX2lucHV0X251bWJlcicsICdjbGljaycsIGZ1bmN0aW9uKCBldiwgZWwgKSB7XG5cbiAgICAgICAgICAgICAgICBfY291cG9uRXZlbnRIYW5kbGVyKCB0cnVlICk7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICRmb3JtLmRlbGVnYXRlKCAnaW5wdXRbbmFtZT1cImNvdXBvbkNvZGVcIl0nLCAnY2hhbmdlJywgX2NvdXBvbkV2ZW50SGFuZGxlciApO1xuXG4gICAgICAgICAgICAkZm9ybS5kZWxlZ2F0ZSggJy5jb3Vwb24tY29kZS1zdWJtaXQtYnRuJywgJ2NsaWNrJywgX2NvdXBvbkV2ZW50SGFuZGxlciApO1xuXG4gICAgICAgICAgICAvLyBDYXB0dXJlIGVudGVyIGtleSBpbiB0aGUgY291cG9uIGlucHV0LCBzbyB3ZSBjYW4gcHJldmVudCBpdCBmcm9tIHN1Ym1pdHRpbmcgdGhlIGZvcm1cbiAgICAgICAgICAgICRmb3JtLmRlbGVnYXRlKCAnLmdyaWQtc3VtbWFyeS1jb3Vwb24taW5wdXQnLCAna2V5ZG93bicsIGZ1bmN0aW9uKCBldiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGV2LmtleUNvZGUgPT09IDEzICkge1xuICAgICAgICAgICAgICAgICAgICBfY291cG9uRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIHZhciBfdHJpZ2dlckNvdXBvbkNoYW5nZSA9IGZ1bmN0aW9uIF90cmlnZ2VyQ291cG9uQ2hhbmdlKCBjb3Vwb25Db2RlVmFsLCBvZmZlck1vZGVsICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCAkZm9ybVsgMCBdLmhhc0F0dHJpYnV0ZSggJ2xvY2tlZCcgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgX2RlYnVnTG9nKCAnVGhlIGZvcm0gaXMgbG9ja2VkLCBkbyBub3QgdmFsaWRhdGUgY291cG9uLicgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb3VwRXJyb3IgPSAkZm9ybS5maW5kKCAnLmNvdXBvbi1lcnJvcicgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGNvdXBFcnJvci5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICAgICAgICBjb3VwRXJyb3IucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICRmb3JtLmZpbmQoICcuZ3JpZC1zdW1tYXJ5X2NvdXBvbi1pbnB1dF9faW5wdXQnICkucmVtb3ZlQ2xhc3MoICdncmlkLXN1bW1hcnktY291cG9uLWlucHV0LS1lcnJvcicgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGZvcm0uZmluZCggJy5ncmlkLXN1bW1hcnktY291cG9uLWlucHV0IC5sYWJlbCcgKS5jc3MoICdwYWRkaW5nQm90dG9tJywgJzAnICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFjb3Vwb25Db2RlVmFsICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2lsbCBuZWVkIHRvIGFsdGVyIHRoaXMgdG8gcGFzcyBhbG9uZyB0aGUgbmV3IFBBWU1FTlRTLTIuMS4xIHF1YW50aXR5IGNoYW5nZSAuLi4gZm9yIG5vdyBpIGp1c3QgZ3JhYmJlZCBpdCBmcm9tIG9mZmVyIGRhdGEuLi5cbiAgICAgICAgICAgICAgICB2YXIgbW9kZWwgPSBvZmZlck1vZGVsLFxuICAgICAgICAgICAgICAgICAgICBhcmdzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291cG9uX2NvZGU6IGNvdXBvbkNvZGVWYWxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvZHVjdCA9IHt9O1xuXG4gICAgICAgICAgICAgICAgJC5lYWNoKCBtb2RlbC5wcm9kdWN0cywgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RbICdwcm9kdWN0WycgKyB2YWx1ZS5pZCArICddJyBdID0gdmFsdWUucXVhbnRpdHk7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RbICdwcmljZVsnICsgdmFsdWUuaWQgKyAnXScgXSA9IHZhbHVlLnByaWNlWyAwIF0ucHJpY2U7XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICQuZXh0ZW5kKCBhcmdzLCBwcm9kdWN0ICk7XG5cbiAgICAgICAgICAgICAgICBjaGFuZ2VJZnJhbWVVcmwoIENPVVBPTl9QUk9DRVNTX0RPTUFJTiArICcvdjIuNC9jb3Vwb25fdmFsaWRhdG9yLnBocCcsIGFyZ3MsIHRydWUgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcyOTMzMC9qcXVlcnktdHJpZ2dlcnN1Ym1pdC1icmVha2luZ1xuICAgICAgICAgICAgICogc2luY2Ugd2UgdHJpZ2dlciBzdWJtaXQgYWdhaW4gYWZ0ZXIgdGhlIGZvcm0gaXMgc3VibWl0dGVkLCB3ZSBjYW50IGhhdmUgYW4gZWxlbWVudCBuYW1lZCBzdWJtaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJGZvcm0uZmluZCggJ2lucHV0W25hbWU9c3VibWl0XScgKS5hdHRyKCAnbmFtZScsICdtci1uYW1lLWNoYW5nZWQtZnJvbS1zdWJtaXQnICk7XG5cbiAgICAgICAgICAgIC8vIEFsc28gZG8gdGhpcyBvbiBzdWJtaXQgcmVnYXJkbGVzcyBvZiBjYXB0Y2hhXG4gICAgICAgICAgICAkZm9ybS5zdWJtaXQoIGZ1bmN0aW9uKCBlLCBzdWJtaXRUcmlnZ2VyICkge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgYWxyZWFkeSBwcm9jZXNzaW5nLCBiYWlsLlxuICAgICAgICAgICAgICAgIGlmICggKCAkZm9ybSApWyAwIF0uaGFzQXR0cmlidXRlKCAnbG9ja2VkJyApICkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGlzRHluYW1pY1BhZ2UgdmFyIHRvIHF1ZXJ5IHN0cmluZ1xuICAgICAgICAgICAgICAgICRmb3JtWyAwIF0uYWN0aW9uID0gJGZvcm1bIDAgXS5hY3Rpb24gKyBgJmlzRHluYW1pY1BhZ2U9JHsoIG9wLmlzRHluYW1pY1BhZ2UgKT8xOjB9YDtcblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB0cmlnZ2VyIGNsaWVudCBzaWRlIHZhbGlkYXRpb24gYmVmb3JlIGRvaW5nIGFueSBzZXJ2ZXIgc2lkZSBzdHVmZi5cbiAgICAgICAgICAgICAgICAvLyBQYXNzIGluIGlmIHRoZSBmb3JtIHdhcyBzdWJtaXR0ZWQgYnkgdGhlIHBheXBhbCBidXR0b24uIElmIGl0cyBhIHBheXBhbCBidXR0b24gd2UgYnlwYXNzIHRoZSBjcmVkaXQgY2FyZCB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgICAgIHZhciBpc1BheVBhbEJ0blN1Ym1pdCA9ICggc3VibWl0VHJpZ2dlciA9PT0gJ3BheXBhbEJ0bicgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGlzUGF5UGFsQnRuU3VibWl0ICkge1xuICAgICAgICAgICAgICAgICAgICAkZm9ybS5maW5kKCAnW25hbWU9XCJwYXlwYWxfdG9nZ2xlXCJdJyApLnZhbCggJ3llcycgKTtcbiAgICAgICAgICAgICAgICAgICAgJGZvcm0uZmluZCggJ1tuYW1lPVwicGF5cGFsXCJdJyApLnZhbCggJ3llcycgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGcm9udGVuZCBpbnB1dCB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCAkZm9ybS5kYXRhKCAndmFsaWRhdG9yJyApLmNoZWNrVmFsaWRpdHkoIGZhbHNlLCBmYWxzZSwgaXNQYXlQYWxCdG5TdWJtaXQgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPcmRlciBidW1wc1xuICAgICAgICAgICAgICAgIG9wLmdldE9yZGVyQnVtcHMoICRmb3JtICk7XG5cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmV2aWV3IGZyb20gZG9uJ3QgbmVlZCB0byBkbyBhbnkgdGhpbmcgYnV0IHNob3cgYSBmb3JtIHByb2Nlc3NpbmcgZGlhbG9nIHByZXZpZXcuXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmdldEF0dHJpYnV0ZSggJ2FjdGlvbicgKSA9PT0gJ1tzeXN0ZW1fZm9ybV9wcm9jZXNzb3JdJyApIHtcbiAgICAgICAgICAgICAgICAgICAgJGRvY3VtZW50Qm9keS50cmlnZ2VyKCAnbW9vbnJheS51aUxvY2tlclYyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdQcm9jZXNzaW5nLi4uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdZb3UgY2FuXFwndCBzdWJtaXQgYSBmb3JtIG9uIGEgcHJldmlldyBwYWdlLiBUaGlzIGRpYWxvZyBzaG93cyBhbiBleGFtcGxlIG9mIHdoYXQgeW91ciB2aXNpdG9ycyB3aWxsIHNlZSB3aGVuIHN1Ym1pdHRpbmcgZm9ybXMgb24geW91ciBwYWdlLiBZb3UgY2FuIGNsb3NlIGl0IGJ5IGNsaWNraW5nIHRoZSBYIGljb24gaW4gdGhlIHVwcGVyIHJpZ2h0IGNvcm5lci4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VCdXR0b246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVtZTogJ2Vycm9yJ1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoICRmb3JtLmZpbmQoICcuZy1yZWNhcHRjaGEnICkubGVuZ3RoID49IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkZyA9ICQoICcuZy1yZWNhcHRjaGEnICk7XG4gICAgICAgICAgICAgICAgICAgICRnLnJlbW92ZUNsYXNzKCAnb3B0LXJlY2FwdGNoYS0tZXJyb3InICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIU9QcmVDYXB0Y2hhQWxsb3dTdWJtaXQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZy5hZGRDbGFzcyggJ29wdC1yZWNhcHRjaGEtLWVycm9yJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRnID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIG91ciBoaWRkZW4gc3BhbSBibG9ja2VyIGZpZWxkLCBjcmVhdGluZyBpdCBpZiBuZWNlc3NzYXJ5LlxuICAgICAgICAgICAgICAgIHZhciAkc2IgPSAkZm9ybS5maW5kKCAnI21yX29wc2JsY2snICk7XG4gICAgICAgICAgICAgICAgaWYgKCAhJHNiLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgJHNiID0gJCggJzxpbnB1dD4nICkuYXR0cigge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ21yX29wc2JsY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21yX29wc2JsY2snXG4gICAgICAgICAgICAgICAgICAgIH0gKS5hcHBlbmRUbyggJGZvcm0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoICRzYiApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jcnlwdCB0aGUgZm9ybSdzIFVJRCBhbmQgY3VycmVudCB0aW1lc3RhbXAgYW5kIHBhc3MgYXMgYSBoaWRkZW4gZmllbGQuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1aWQgPSAkZm9ybS5maW5kKCAnW25hbWU9XCJ1aWRcIl0nICkudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBlbmNyeXB0aW9uIGtleSBiYXNlZCBvbiB0aGUgdWlkLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZWtleSA9IFsgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXVpZCA9ICdhZjhjZGU4MDBmYmM0MWU5ODllNjY4ZjkxYmU4ZWNiMCcgKyB1aWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1aWRsZW4gPSBldWlkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdWlkbGVuOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBla2V5WyBpICUgOCBdID0gKCBla2V5WyBpICUgOCBdIF4gZXVpZC5jaGFyQ29kZUF0KCBpICkgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBla2V5Lmxlbmd0aDsgKytpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGVrZXlbIGkgXSAmIDB4N2YgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHNibGNrID0gc3RyaW5nVG9IZXgoIGRlcygga2V5LCB1aWQgKyAnOicgKyBEYXRlLm5vdygpICsgJzonLCAxICkgKTtcbiAgICAgICAgICAgICAgICAgICAgJHNiLnZhbCggb3BzYmxjayApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRzYiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAkZm9ybS5hdHRyKCAnbG9ja2VkJywgJycgKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYW55IGN1c3RvbUZvcm1Qcm9jZXNzaW5nRGF0YSwgdGhlbiBraWNrb2ZmIHRoZSBjeWNsZSBvZiBzd2FwcGluZyB0aGUgY29udGVudCBvdXRcbiAgICAgICAgICAgICAgICBpZiAoIHdpbmRvdy5vcCAmJlxuICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wLmN1c3RvbUZvcm1Qcm9jZXNzaW5nRGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wLmN1c3RvbUZvcm1Qcm9jZXNzaW5nRGF0YS50aGVtZSA9PT0gJ211bHRpcGxlJyAmJlxuICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wLmN1c3RvbUZvcm1Qcm9jZXNzaW5nRGF0YS5tdWx0aXBsZURhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcC5jdXN0b21Gb3JtUHJvY2Vzc2luZ0RhdGEubXVsdGlwbGVEYXRhLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdWlMb2NrZXJTd2FwTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICB1aUxvY2tlclN3YXBDb250ZW50Q2hlY2tlcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRkb2N1bWVudEJvZHkudHJpZ2dlciggJ21vb25yYXkudWlMb2NrZXJWMicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnUHJvY2Vzc2luZy4uLidcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogVHJhY2tpbmcgZmllbGRzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygd2luZG93Ll9tcmkgIT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGlkZGVuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRhY3RfaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FmZnRfJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhZmZfJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWZfJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvd25fJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZXNzXycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXRtX3NvdXJjZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXRtX21lZGl1bScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXRtX3Rlcm0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3V0bV9jb250ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1dG1fY2FtcGFpZ24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmVycmFsX3BhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wcmlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdfb3BfZ2NsaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ19mYmMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ19mYnAnXG4gICAgICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBfY29va2llOyBoaWRkZW4ubGVuZ3RoID4gaTsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Nvb2tpZSA9IG9wLnJlYWRDb29raWUoIGhpZGRlblsgaSBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggX2Nvb2tpZSAhPSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGZvcm0uZmluZCggJ1tuYW1lPVwiJyArIGhpZGRlblsgaSBdICsgJ1wiXScgKS52YWwoIF9jb29raWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggd2luZG93LmdhICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmdhKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2tlcnMgPSB3aW5kb3cuZ2EuZ2V0QWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tlcnMuZm9yRWFjaCggZnVuY3Rpb24oIHRyYWNrZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRmb3JtLmZpbmQoICdbbmFtZT1fb3BfZ2NpZF0nICkudmFsKCB0cmFja2VyLmdldCggJ2NsaWVudElkJyApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBDaGVjayBhbmQgcHJvY2VzcyBjYXB0Y2hhLCBwYXltZW50cyBhbmQgdXBzZWxscyB0aGF0IGhhdmUgYSBvbnRyYWZvcm0gcG9wdXBcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoIFBST0NFU1NPUlMuY2NfdmVyaWZ5KCBlICkgPT09IGZhbHNlIHx8IFBST0NFU1NPUlMuaXNVcHNlbGxGb3JtKCBlLCBzdWJtaXRUcmlnZ2VyICkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gKTsgLy8gRW5kICRmb3JtLnN1Ym1pdFxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSGFuZGxlIHJ1bm5pbmcgaW4gYW4gaWZyYW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICggdG9wICE9PSBzZWxmICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZSApIHtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRS5kYXRhIGNvdWxkIG5vdCBiZSB2YWxpZCBqc29uLCBkYXRhIGNvdWxkIGJlIGZyb20gYW5vdGhlciBzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZSggZS5kYXRhICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaCggZGF0YSwgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbW9vbnJheUpTLnJlYWRDb29raWUoIGtleSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhkYXRlLnNldERhdGUoIGV4ZGF0ZS5nZXREYXRlKCkgKyAzNjUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0ga2V5ICsgJz0nICsgZXNjYXBlKCB2YWx1ZSApICsgJzsgZXhwaXJlcz0nICsgZXhkYXRlLnRvVVRDU3RyaW5nKCkgKyAnOyBwYXRoPS8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICggd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbWVzc2FnZScsIGhhbmRsZXIsIGZhbHNlICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCAnb25tZXNzYWdlJywgaGFuZGxlciApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdoZW4gd2Ugc3VibWl0IHRoZSBmb3JtIHdlIGNoYW5nZSB0aGUgcGFyZW50IHBhZ2UgdXJsXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1UYXJnZXRBdHRyID0gJGZvcm0uYXR0ciggJ3RhcmdldCcgKSxcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVPcGZUYXJnZXQgPSBmb3JtVGFyZ2V0QXR0ciAmJiAoIGZvcm1UYXJnZXRBdHRyLmluZGV4T2YoICdvcGZGb3JtVHJpZ2dlci0nICkgIT09IC0xIHx8IGZvcm1UYXJnZXRBdHRyLmluZGV4T2YoICdjb25kaXRpb25hbFJlZGlyZWN0VHJpZ2dlci0nICkgIT09IC0xICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFwb3NzaWJsZU9wZlRhcmdldCApIHtcblxuICAgICAgICAgICAgICAgICAgICAkZm9ybS5hdHRyKCAndGFyZ2V0JywgJ190b3AnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT250cmFmb3JtcyBtYW5hZ2UgdGhlaXIgZGltLCBubyBuZWVkIHRvIHNlbmRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFdpbmRvdyA9IHBhcmVudC5wb3N0TWVzc2FnZSA/IHBhcmVudCA6ICggcGFyZW50LmRvY3VtZW50LnBvc3RNZXNzYWdlID8gcGFyZW50LmRvY3VtZW50IDogdW5kZWZpbmVkICksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kRGltID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogVUlELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJGRvY3VtZW50Qm9keS5vdXRlcldpZHRoKCB0cnVlICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJGRvY3VtZW50Qm9keS5vdXRlckhlaWdodCggdHJ1ZSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFdpbmRvdy5wb3N0TWVzc2FnZSggSlNPTi5zdHJpbmdpZnkoIG1lc3NhZ2UgKSwgJyonICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIGNhbiBkZWxlZ2F0ZSB0aGUgbG9hZCBldmVudCBvbiB0aGUgY2FwdGFjaCBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhpcyBpbiBhIGxvb3AsIHRoaXMgd2F5IHRoZSBoZWlnaHQgd2lsbCBhbHdheXMgYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFsc28gY2F0Y2hlcyBmb3JtcyBjb25kaXRpb25zIHRoYXQgYXJlIHNsb3cgbG9hZGluZywgc29tZXRpbWVzIHRoZSBmb3IgZ2V0cyBcImNob3BwZWRcIiBiZWNhdXNlIG9mIHRoZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIHNlbmREaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW50ZXJ2YWwoIHNlbmREaW0sIDEwMDAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIG9uIGV2ZW50LCB1c2VkIGZvciBmb3JtQ29uZGl0aW9uc1xuICAgICAgICAgICAgICAgICAgICAkZm9ybS5kZWxlZ2F0ZSggJzppbnB1dCcsICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmREaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBOZWVkIHRvIGNoZWNrIGNhcHRjaGEsIHZhbGlkYXRlIHRoYXRcbiAgICAgICAgICAgICAqIHRoZW4gY2hlY2sgZm9yIHNhbGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFhELnJlY2VpdmVNZXNzYWdlKCBmdW5jdGlvbiggbWVzc2FnZSApIHtcblxuICAgICAgICAgICAgICAgIF9kZWJ1Z0xvZyggJ3JlY2VpdmVkIG1lc3NhZ2UgJywgbWVzc2FnZSApO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBJZiBtZXNzYWdlIGRhdGEgPT0gJ2ZhbHNlJyBzdHJpbmcgaXMgY2FwdGNoYSwgdHJ1ZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogaWYgbWVzc2FnZS5kYXRhIGhhcyBwcm9wZXJ0eSByZXN1bHRfY29kZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGRhdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBtZXNzYWdlLmRhdGEgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPTlRSQWZvcm1zIHBhc3NlcyBhcm91bmQgb2JqZWN0cywgbm90IHN0cmluZ3MuXG5cbiAgICAgICAgICAgICAgICAgICAgLypcblxuICAgICAgICAgICAgICAgICAgICAgICAgQnV0IG5vdyB1cHNlbGxzIGFyZSBmYW5jeSwgc28gd2UgbmVlZCB0byBkbyBzbyBzb21ldGhpbmcgd2l0aCB0aGVtXG4gICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG1lc3NhZ2UuZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEudHlwZSA9PSAnZm9ybVByb2Nlc3Nvck1lc3NhZ2UnICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgZm9yd2FyZHMgdGhlIHVzZXIgb24gdG8gdGhlIG5leHQgcGFnZSwgd2hlbiBvbmUgb2YgdGhlIHllcyAvIG5vIC8gdGltZW91dCBwYWdlcyBpcyBwb3AgYW5kIG9udHJhZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dCB0aGUgY2xpY2tlZCBhY3Rpb24gLyBidXR0b24gaXMgbm90IGFuZCBvbnRyYWZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVzcG9uc2Ugb25seSBvY2N1cnMgZm9yIHVwc2VsbCBibG9ja3Mgb24gb250cmFmb3Jtc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzT05UUkFmb3JtUGFyZW50ID0gKCB0eXBlb2YoIF9fT1BGICkgIT09ICd1bmRlZmluZWQnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEuZGF0YS50eXBlID09ICdzY3JpcHQnICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlYnVnTG9nKCAnc2NyaXB0IHR5cGUnLCBkYXRhLmRhdGEubWVzc2FnZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVwZW5kaW5nIG9uIHRoZSBvcmRlciBpbiB3aGljaCB0aGUgdXNlciBnb3QgdG8gdGhlIGZvcm0gd2UgbmVlZCB0byBkZXRlY3QgaWYgb250cmFmb3Jtcy5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYmVlbiBsb2FkZWQgb24gdGhlIHBhZ2UuIElmIGl0cyBjdXJyZW50bHkgdGhlcmUsIHBvcCB0aGUgZm9ybSBvcGVuLCBvdGhlcndpc2UgZmV0Y2ggaXQgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgc2VydmVyIGFuZCBvcGVuIHRoZSBmb3JtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcmlwdEF0dHJzID0gSlNPTi5wYXJzZSggZGF0YS5kYXRhLm1lc3NhZ2UgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX29wZk9wZW4gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIG9yaWdpbmFsIGZvcm0gcHJvY2Vzc2luZyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnRCb2R5LnRyaWdnZXIoICdtb29ucmF5LnVpTG9ja2VyVjInICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX09QRi5vcGVuKCBzY3JpcHRBdHRycy51aWQsIHRydWUgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc09OVFJBZm9ybVBhcmVudCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3BmT3BlbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmdldFNjcmlwdCggc2NyaXB0QXR0cnMuc3JjLCBfb3BmT3BlbiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGlzYWJsZSBhbGwgb2YgdGhlIHN1Ym1pdCBidXR0b25zIG9uIHRoZSBvcmlnaW5hbCB1cHNlbGwgZm9ybSwgcHJldmVudHMgdGhlIHVzZXIgZnJvbSBiZWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYmxlIHRvIFwic3VibWl0XCIgLyBjeWNsZSB0aHJvdWdoIHRoZSBjaGFpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyggJ29wYWNpdHknLCAnLjMnIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlIHRoZSBub3RlcyBhYm91dCBkaXNhYmxlZCBpbiBmb3JtLmRlZmF1bHQuY3NzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCAnZGlzYWJsZWQnLCB0cnVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGRhdGEuZGF0YS50eXBlID09ICdyb3V0ZScgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgaXMgYSByZWRpcmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZWJ1Z0xvZyggJ1NlbmRpbmcgdGhlIHVzZXIgdG8gdGhpcyBVUkw6ICcsIGRhdGEuZGF0YS5tZXNzYWdlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVpY2sgbm90ZSwgSUUgNiBhbmQgNyB3b250IGhhdmUgdGhlIHJlZmZlciBoZWFkZXIgc2V0LCBub3Qgd29ycnlpbmcgYWJvdXQgdGhhdCBzaW5jZSBULVJleCBpcyB5b3VuZ2VyIHRoYW4gdGhleSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24gPSBkYXRhLmRhdGEubWVzc2FnZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZGF0YS5kYXRhLnR5cGUgPT09ICdjb25kaXRpb25hbFJlZGlyZWN0JyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGF0YS5kYXRhLnJlZGlyZWN0VHlwZSA9PT0gJ2Jsb2NrX2xpbmsnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnRCb2R5LnRyaWdnZXIoICdtb29ucmF5LnVpTG9ja2VyVjInICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoIGRhdGEuZGF0YS51cmwgKS5zY3JvbGxUb0Jsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV2ZXJ5dGhpbmcgZWxzZSBiZXNpZGVzIE9OVFJBZm9ybS4gU286IGN1c3RvbSBVUkwsIExhbmRpbmcgUGFnZSwgSG9zdGVkIEZpbGUsIG9yIFRyYWNrZWQgTGlua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGRhdGEuZGF0YS5yZWRpcmVjdFR5cGUgIT09ICdvbnRyYWZvcm0nICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZW4gaW4gbmV3IHdpbmRvdyBpZiBmbGFnIHNldCBvciBpZiB0eXBlIGlzIGhvc3RlZCBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGF0YS5kYXRhLm5ld1dpbmRvdyB8fCBkYXRhLmRhdGEucmVkaXJlY3RUeXBlID09PSAnaG9zdGVkX2ZpbGUnICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cub3BlbiggZGF0YS5kYXRhLnVybCwgJ19ibGFuaycgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGRvY3VtZW50Qm9keS50cmlnZ2VyKCAnbW9vbnJheS51aUxvY2tlclYyJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gZGF0YS5kYXRhLnVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIC8gYmxhbmsgdGhlIGlmcmFtZSBVUkwgb3RoZXJ3aXNlIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGJhY2sgdGhleSB3aWxsIGdldCBzdHVjayBpbiBhIHJlZGlyZWN0IGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUlmcmFtZVVybCggJyMnICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YSA9IGV2YWwoICcoJyArIHVuZXNjYXBlKCBtZXNzYWdlLmRhdGEgKSArICcpJyApO1xuXG5cbiAgICAgICAgICAgICAgICAvLyBNb3ZlIGhhbmRsaW5nIG9mIENvdXBvbiBpbnRvIHRoZSBzYW1lIHByb2Nlc3NpbmcgZG9tYWluXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLnR5cGUgIT09IHVuZGVmaW5lZCAmJiBkYXRhLnR5cGUgPT0gJ2NvdXBvbi12YWxpZGF0aW9uJyAmJiBkYXRhLnVpZCA9PSBVSUQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VwRXJyb3IgPSAkZm9ybS5maW5kKCAnLmNvdXBvbi1lcnJvcicgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb3VwRXJyb3IubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdXBFcnJvci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciAkY291cG9uUm93ID0gJGZvcm0uZmluZCggJy5ncmlkLXN1bW1hcnktY291cG9uLWlucHV0JyApLFxuICAgICAgICAgICAgICAgICAgICAgICAgJGNvdXBvbklucHV0ID0gJGZvcm0uZmluZCggJ2lucHV0W25hbWU9XFwnY291cG9uQ29kZVxcJ10nICk7XG5cbiAgICAgICAgICAgICAgICAgICAgJGNvdXBvblJvdy5maW5kKCAnLmxhYmVsJyApLmNzcyggJ3BhZGRpbmdCb3R0b20nLCAnMCcgKTtcblxuICAgICAgICAgICAgICAgICAgICBncmlkQ29udHJvbGxlciA9ICRmb3JtLmZpbmQoICcubW9vbnJheS1mcm9tLW9mZmVyLWdyaWQnICkuY29udHJvbGxlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyaWRDb250cm9sbGVyLmFwcGx5Q291cG9uKCBkYXRhICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhLnJlc3VsdF9jb2RlICE9IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291cG9uVmFsID0gJGNvdXBvbklucHV0LnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHNob3cgYW4gZXJyb3IgaWYgdGhlcmUgaXMgYSB2YWx1ZSBpbiB0aGUgY291cG9uIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvdXBvblZhbCAhPSAnJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY291cG9uUm93LmZpbmQoICcubGFiZWwnICkuY3NzKCAncGFkZGluZ0JvdHRvbScsICcxZW0nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yRG9tID0gJCggb3AudCggJzxkaXYgY2xhc3M9XCJjb3Vwb24tZXJyb3IgZ3JpZC1zdW1tYXJ5LWNvdXBvbi0tZXJyb3JcIj48c3Bhbj57bWVzc2FnZX08L3NwYW4+PC9kaXY+JywgZGF0YSApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoICcuZ3JpZC1zdW1tYXJ5X2NvdXBvbi1pbnB1dF9faW5wdXQnIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCAnZ3JpZC1zdW1tYXJ5LWNvdXBvbi1pbnB1dC0tZXJyb3InIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZnRlciggZXJyb3JEb20gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXZSBhbHNvIHJlY2VpdmUgaW50ZXJuYWwgbWVzc2FnZXMgZnJvbSBPTlRSQWZvcm1zLmpzLiBUaGlzIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgd2hlbiBPTlRSQWZvcm1zIGlzIGRvbmVcbiAgICAgICAgICAgICAgICAgKiBsb2FkaW5nIGl0cyBmb3Jtcy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFdlIHdlcmUgZW5jb3VudGVyaW5nIHJhY2UgY29uZGl0aW9ucyB3aXRoIHByb2dyZXNzaXZlIGZvcm0gY2hhaW5zIHdoZXJlIHRoZSBpbml0aWFsIGZvcm0gcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgICAqIHRvb2sgYWJvdXQgNSBzZWNvbmRzIHRvIGxvYWQsIHdoaWNoIGlzIHRoZSBpbnRlcnZhbCBmb3Igc3dhcHBpbmcgbWVzc2FnZXMgaW4gdGhlIGZvcm0gcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgICAqIGRpYWxvZy4gVGhlIHN1YnNlcXVlbnQgZm9ybSB3b3VsZCBsb2FkLCBidXQgaXQgd291bGQgYmUgY292ZXJlZCBieSB0aGUgZm9ybSBwcm9jZXNzaW5nIGRpYWxvZyBhbmRcbiAgICAgICAgICAgICAgICAgKiB0aGUgdXNlciBjb3VsZCBub3QgaW50ZXJhY3Qgd2l0aCB0aGUgZm9ybSB0byBwcm9jZWVkLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogVGhlIGZvcm0gcHJvY2Vzc2luZyBkaWFsb2cgd2FzIGluIHRoZSBtaWRkbGUgb2Ygc3dhcHBpbmcgbWVzc2FnZXMgd2hlbiB0aGUgc3Vic2VxdWVudCBmb3JtIHdhc1xuICAgICAgICAgICAgICAgICAqIGxvYWRpbmcuIFRoaXMgd291bGQgY2F1c2UgdGhlIG1lc3NhZ2Ugc3dhcHBpbmcgdG8gc3RhcnQgYWdhaW4gYW5kIHNpbmNlIHRoZSBmb3JtIGFscmVhZHkgbG9hZGVkLFxuICAgICAgICAgICAgICAgICAqIHRoZSBzd2FwcGluZyBuZXZlciBlbmRlZC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFNvIGV4cGxpY2l0bHkgc2V0IGlmcmFtZV9kb25lIHRvIHRydWUgdG8gYXZvaWQgdGhpcyBjb25kaXRpb24uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLnR5cGUgIT09IHVuZGVmaW5lZCAmJiBkYXRhLnR5cGUgPT09ICdpbnRlcm5hbE1lc3NhZ2UnICkge1xuICAgICAgICAgICAgICAgICAgICBfZGVidWdMb2coICdyZWNlaXZlZCBtZXNzYWdlIGZyb20gb250cmFmb3JtcycgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhLmRhdGEgJiYgZGF0YS5kYXRhLmZpbiA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZV9kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICQoICc8aW5wdXQgdHlwZT1cImhpZGRlblwiPicgKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3N1Ym1pdFBhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICcxJ1xuICAgICAgICAgICAgICAgICAgICB9IClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKCAkZm9ybSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhID09PSBmYWxzZSB8fCBkYXRhID09PSB0cnVlICkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VJZnJhbWVVcmwoICcjJyApO1xuXG4gICAgICAgICAgICAgICAgICAgIF9kZWJ1Z0xvZyggJ3Byb2Nlc3NpbmcgY2FwdGNoYScgKTtcblxuICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnRCb2R5LnRyaWdnZXIoICdtb29ucmF5LnVpTG9ja2VyVjInICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlY2FwdGNoYS5yZWxvYWQoKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCggJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCI+JyApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ19jYXBiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICcxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyggJGZvcm0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyB3b3JrcyBncmVhdCB3aGVuIHRoZXJlIGlzbid0IGEgZ3JpZCBvbiB0aGUgc2FtZSBmb3JtLCBpdCBqdXN0IGJ5IHBhc3NlcyBjY192ZXJpZnkgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmluZyBpdCBoZXJlIHNvIHlvdSAvIG1lIGRvbid0IHJlIGludHJvZHVjZSB0aGF0IGJ1Z1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyRmb3JtWzBdLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICRmb3JtLmZpbmQoICc6aW5wdXRbbmFtZT1zdWJtaXRQYXRoXScgKS5hdHRyKCB7IHZhbHVlOiAyIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJGZvcm0udHJpZ2dlciggJ3N1Ym1pdCcgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICBOb24gY2FwdGNoYSByZXNwb25zZXMgaGF2ZSBhIHJlc3VsdCBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHNvIHdlIG9ubHkgd2FudCB0byBmaXJlIHRoaXMgZXZlbnQgZm9yIHRoaXMgZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucG9zdG1lc3NhZ2UgaGFuZGxlcnMgZmlyZSBldmVyeSB0aW1lIGEgbWVzc2FnZSBpcyBmaXJlZCwgd2Ugb25seSB3YW50IHRvIGhhbmRsZSB0aGlzIHJlc3BvbnNlIGlmIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS51aWQgaXMgdGhlIHNhbWUgYXMgdGhpcyBmb3Jtc1xuICAgICAgICAgICAgICAgICAgICAgICAgTk9URTogWEQgaXMgYSBnbG9iYWwgdmFyaWFibGUgZGVmaW5lZCBpbiB0aGUgXCJwb3N0bWVzc2FnZS5qc1wiIHNjcmlwdC4gSXQgd2lsbCBvbmx5IGJlIGluY2x1ZGVkIGlmIGZvcm0gc2NyaXB0cyBhcmUgaW5jbHVkZWRcbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBkYXRhLnJlc3VsdF9jb2RlICE9IHVuZGVmaW5lZCAmJiBkYXRhLnVpZCA9PSBVSUQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGF0YS5yZXN1bHRfY29kZSA9IDJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhLnJlc3VsdF9jb2RlID09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VJZnJhbWVVcmwoICcjJyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVidWdMb2coICdzZXR0aW5nIGlmcmFtZV9kb25lIHRvIHRydWUgYWZ0ZXIgcmVzdWx0X2NvZGUgMScgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZV9kb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2RlYnVnTG9nKCAncHJvY2Vzc2luZyBjcmVkaXQgY2FyZCcsICdzdWNjZXNzJyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEuY2lkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRjaWRfaW5wdXQgPSAkZm9ybS5maW5kKCAnOmlucHV0W25hbWU9Y2lkXScgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICRjaWRfaW5wdXQubGVuZ3RoID09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGZvcm0uYXBwZW5kKCBvcC50KCAnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwiY2lkXCIgdmFsdWU9XCJ7Y2lkfVwiPicsIGRhdGEgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNpZF9pbnB1dC52YWwoIGRhdGEuY2lkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAkZm9ybS5hcHBlbmQoIG9wLnQoICc8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJwYXllcl9pZFwiIHZhbHVlPVwie3BheWVyX2lkfVwiPjxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cInRyYW5zYWN0aW9uX2lkXCIgdmFsdWU9XCJ7dHJhbnNhY3Rpb25faWR9XCI+JywgZGF0YSApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JtQWN0aW9uID0gJGZvcm0uYXR0ciggJ2FjdGlvbicgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaWRSZWdleCA9IC8oY2lkPVswLTldKikvZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaWRQYXJhbSA9ICggJ2NpZD0nICsgZGF0YS5jaWQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdGb3JtQWN0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNpZFJlZ2V4LnRlc3QoIGZvcm1BY3Rpb24gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdGb3JtQWN0aW9uID0gZm9ybUFjdGlvbi5yZXBsYWNlKCBjaWRSZWdleCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwbGljZSBpbiB0aGUgQ0lEIGludG8gdGhlIGZvcm0gYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaWRQYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Zvcm1BY3Rpb24gPSAoIGZvcm1BY3Rpb24gKyAnJicgKyBjaWRQYXJhbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAkZm9ybS5hdHRyKCAnYWN0aW9uJywgbmV3Rm9ybUFjdGlvbiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGZvcm0uZmluZCggJzppbnB1dFtuYW1lPXN1Ym1pdFBhdGhdJyApLmF0dHIoIHsgdmFsdWU6IDMgfSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkZm9ybVsgMCBdLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBkYXRhLnJlc3VsdF9jb2RlID09IENDX1ZFUklGWV9QT1NUICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBzZW50IGJ5IHRoZSBmaXJzdCBjY192ZXJpZnkgY2FsbC4gV2UgY29udGludWUgYW5kIHdhaXQgZm9yIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uc2Ugb2YgdGhlIHNlY29uZCBvbmUuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGRhdGEucmVzdWx0X2NvZGUgPT0gQ0NfVkVSSUZZX1NIT1dfSUZSQU1FICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVidWdMb2coICdyZXN1bHRfY29kZSBpcyBjYyB2ZXJpZnkgc2hvdyBpZnJhbWUnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhpZGUgdGhlIGxvY2tlciwgc2hvdyB0aGUgaWZyYW1lIGFuZCBjZW50ZXIgaXQgb3ZlciBvdXIgd2luZG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgJGRvY3VtZW50Qm9keS50cmlnZ2VyKCAnbW9vbnJheS51aUxvY2tlclYyJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lX2RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlmcmFtZS5jc3MoIHsgZGlzcGxheTogJ2Jsb2NrJywgcG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogMCwgbGVmdDogMCwgd2lkdGg6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCwgaGVpZ2h0OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LCAnei1pbmRleCc6IDk5OTk5OSB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZGF0YS5yZXN1bHRfY29kZSA9PSBDQ19WRVJJRllfSElERV9JRlJBTUUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhpZGUgdGhlIGlmcmFtZSBhbmQgcmV0cmlnZ2VyIHRoZSBsb2NrZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAkaWZyYW1lLmNzcyggeyBkaXNwbGF5OiAnbm9uZScgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lX2RvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRkb2N1bWVudEJvZHkudHJpZ2dlciggJ21vb25yYXkudWlMb2NrZXJWMicse1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnUHJvY2Vzc2luZy4uLidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBkYXRhLnJlc3VsdF9jb2RlID09IENDX1ZFUklGWV9HRVRfQ0NfREFUQSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJGlmcmFtZVsgMCBdLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoIG9wLnNlcmlhbGl6ZUZvcm1Ub09iamVjdCggJGZvcm0gKSwgQ0NfVkVSSUZZX0RPTUFJTiApO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICRmb3JtLmhhc0NsYXNzKCAnb3BmLWlnbm9yZS1mb3JtJyApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgKiBAVE9ETzogQ29tZSB1cCB3aXRoIGEgYmV0dGVyIGZpeCBmb3IgdGhpcywgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHJlcXVpcmUgY3VzdG9tZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAqIHRvIGFkZCB0aGlzIGNsYXNzLiBJU1NVRTogV2hlbiBjcmVhdGluZyBhbiBPTlRSQXBhZ2UsIGlmIHlvdSBhZGQgYSBzbWFydGZvcm0gYmxvY2sgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKiBhbiBPTlRSQWZvcm0gcG9wIHVwIGFzIHRoZSB0aGFuayB5b3UgcGFnZSwgdGhlbiBhZGQgYSBjbGljayB0byBwb3AgT05UUkFmb3JtIGluIGEgY3VzdG9tIEhUTUxcbiAgICAgICAgICAgICAgICAgICAgICAgICogYmxvY2ssIGFuZCBUSEVOIGFkZCBqdXN0IGEgcmVndWxhciBIVE1MIGZvcm0gdG8gdGhlIHBhZ2UgKG5vdCBhc3NvY2lhdGVkIHdpdGggb250cmFwb3J0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICogYW5kIG1ha2Ugc3VyZSB0aGUgSFRNTCBmb3JtIGlzIHRoZSBmaXJzdCBmb3JtIG9uIHRoZSBwYWdlLCB0aGUgcGFnZSBnZXRzIGNvdmVyZWQgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAqIHVpTG9ja2VyVjIgb3ZlcmxheSBhbmQgaW5maW5pdGVseSBsb2FkcyBvcGYuanMuIEZvciBzb21lIHJlYXNvbiB0aGUgcmVndWxhciBIVE1MIGZvcm0gaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICogYXV0b21hdGljYWxseSBzdWJtaXR0ZWQsIGFuZCBpdCBmYWxscyBpbnRvIHRoZSBlbHNlIHN0YXRlbWVudCBiZWxvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VJZnJhbWVVcmwoICcjJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lX2RvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVidWdMb2coICdwcm9jZXNzaW5nIGNyZWRpdCBjYXJkJywgJ2Vycm9yJyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICRkb2N1bWVudEJvZHkudHJpZ2dlciggJ21vb25yYXkudWlMb2NrZXJWMicgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGl0bGUgPSAoIGRhdGEucmVzdWx0X2NvZGUgPT0gd2luZG93LkFDQ09VTlRfU0lHTlVQX0VSUk9SICkgPyAnU2lnbiB1cCBlcnJvcicgOiAnVHJhbnNhY3Rpb24gZmFpbGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIG1lc3NhZ2UgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICRkb2N1bWVudEJvZHkudHJpZ2dlciggJ21vb25yYXkudWlMb2NrZXJWMicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKCBkYXRhLmVycm9yIHx8IGRhdGEubWVzc2FnZSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQnV0dG9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lOiAnZXJyb3InXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBGT1JNX1BST0NFU1NfRE9NQUlOICk7XG5cbiAgICAgICAgfSApO1xuICAgIH07XG5cbn0gKSggalF1ZXJ5LCB3aW5kb3cgKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWFBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBakJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUEE7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2ZEE7QUFDQTtBQXlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFIQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFIQTtBQUFBO0FBVUE7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUZBO0FBVkE7QUFBQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUJBO0FBK0JBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkNBO0FBMENBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsRUE7QUFxRUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBUkE7QUFVQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFDQTtBQTZDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQVFBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUE1QkE7QUFDQTtBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBWUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUpBO0FBQUE7QUFRQTtBQVJBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFuSUE7QUFDQTtBQUNBO0FBcUlBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQURBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.materialize.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.materialize.slideshowdependancies.js":
/*!********************************************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.materialize.slideshowdependancies.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * @brief These are the dependancies left over from the opt overload of the materialize slide show. These should only get pulled\n *        in if a slide show is present on the page. When we update the slide show lets nuke these bad boys.\n */\n\n/* STICKY BLOCK DEPENDANCIES -----------------------------------------------------------------------------------------------------------------*/\nwindow.Materialize = {}; // Unique Random ID\n\nMaterialize.guid = function () {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n\n  return function () {\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n  };\n}();\n/* SLIDE SHOW DEPENDANCIES--------------------------------------------------------------------------------------------------------------------*/\n\n/* ! VelocityJS.org (1.5.0). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */\n\n/* ! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */\n\n\n!function (a) {\n  'use strict';\n\n  function b(a) {\n    var b = a.length,\n        d = c.type(a);\n    return 'function' !== d && !c.isWindow(a) && (!(1 !== a.nodeType || !b) || 'array' === d || 0 === b || 'number' == typeof b && b > 0 && b - 1 in a);\n  }\n\n  if (!a.jQuery) {\n    var c = function (a, b) {\n      return new c.fn.init(a, b);\n    };\n\n    c.isWindow = function (a) {\n      return a && a === a.window;\n    }, c.type = function (a) {\n      return a ? 'object' == typeof a || 'function' == typeof a ? e[g.call(a)] || 'object' : typeof a : a + '';\n    }, c.isArray = Array.isArray || function (a) {\n      return 'array' === c.type(a);\n    }, c.isPlainObject = function (a) {\n      var b;\n\n      if (!a || 'object' !== c.type(a) || a.nodeType || c.isWindow(a)) {\n        return !1;\n      }\n\n      try {\n        if (a.constructor && !f.call(a, 'constructor') && !f.call(a.constructor.prototype, 'isPrototypeOf')) {\n          return !1;\n        }\n      } catch (d) {\n        return !1;\n      }\n\n      for (b in a) {}\n\n      return b === undefined || f.call(a, b);\n    }, c.each = function (a, c, d) {\n      var e = 0,\n          f = a.length,\n          g = b(a);\n\n      if (d) {\n        if (g) {\n          for (; e < f && !1 !== c.apply(a[e], d); e++) {}\n        } else {\n          for (e in a) {\n            if (a.hasOwnProperty(e) && !1 === c.apply(a[e], d)) {\n              break;\n            }\n          }\n        }\n      } else if (g) {\n        for (; e < f && !1 !== c.call(a[e], e, a[e]); e++) {}\n      } else {\n        for (e in a) {\n          if (a.hasOwnProperty(e) && !1 === c.call(a[e], e, a[e])) {\n            break;\n          }\n        }\n      }\n\n      return a;\n    }, c.data = function (a, b, e) {\n      if (e === undefined) {\n        var f = a[c.expando],\n            g = f && d[f];\n\n        if (b === undefined) {\n          return g;\n        }\n\n        if (g && b in g) {\n          return g[b];\n        }\n      } else if (b !== undefined) {\n        var h = a[c.expando] || (a[c.expando] = ++c.uuid);\n        return d[h] = d[h] || {}, d[h][b] = e, e;\n      }\n    }, c.removeData = function (a, b) {\n      var e = a[c.expando],\n          f = e && d[e];\n      f && (b ? c.each(b, function (a, b) {\n        delete f[b];\n      }) : delete d[e]);\n    }, c.extend = function () {\n      var a,\n          b,\n          d,\n          e,\n          f,\n          g,\n          h = arguments[0] || {},\n          i = 1,\n          j = arguments.length,\n          k = !1;\n\n      for ('boolean' == typeof h && (k = h, h = arguments[i] || {}, i++), 'object' != typeof h && 'function' !== c.type(h) && (h = {}), i === j && (h = this, i--); i < j; i++) {\n        if (f = arguments[i]) {\n          for (e in f) {\n            f.hasOwnProperty(e) && (a = h[e], d = f[e], h !== d && (k && d && (c.isPlainObject(d) || (b = c.isArray(d))) ? (b ? (b = !1, g = a && c.isArray(a) ? a : []) : g = a && c.isPlainObject(a) ? a : {}, h[e] = c.extend(k, g, d)) : d !== undefined && (h[e] = d)));\n          }\n        }\n      }\n\n      return h;\n    }, c.queue = function (a, d, e) {\n      if (a) {\n        d = (d || 'fx') + 'queue';\n        var f = c.data(a, d);\n        return e ? (!f || c.isArray(e) ? f = c.data(a, d, function (a, c) {\n          var d = c || [];\n          return a && (b(Object(a)) ? function (a, b) {\n            for (var c = +b.length, d = 0, e = a.length; d < c;) {\n              a[e++] = b[d++];\n            }\n\n            if (c !== c) {\n              for (; b[d] !== undefined;) {\n                a[e++] = b[d++];\n              }\n            }\n\n            a.length = e;\n          }(d, 'string' == typeof a ? [a] : a) : [].push.call(d, a)), d;\n        }(e)) : f.push(e), f) : f || [];\n      }\n    }, c.dequeue = function (a, b) {\n      c.each(a.nodeType ? [a] : a, function (a, d) {\n        b = b || 'fx';\n        var e = c.queue(d, b),\n            f = e.shift();\n        'inprogress' === f && (f = e.shift()), f && ('fx' === b && e.unshift('inprogress'), f.call(d, function () {\n          c.dequeue(d, b);\n        }));\n      });\n    }, c.fn = c.prototype = {\n      init: function (a) {\n        if (a.nodeType) {\n          return this[0] = a, this;\n        }\n\n        throw new Error('Not a DOM node.');\n      },\n      offset: function () {\n        var b = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : {\n          top: 0,\n          left: 0\n        };\n        return {\n          top: b.top + (a.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0),\n          left: b.left + (a.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0)\n        };\n      },\n      position: function () {\n        var a = this[0],\n            b = function (a) {\n          for (var b = a.offsetParent; b && 'html' !== b.nodeName.toLowerCase() && b.style && 'static' === b.style.position.toLowerCase();) {\n            b = b.offsetParent;\n          }\n\n          return b || document;\n        }(a),\n            d = this.offset(),\n            e = /^(?:body|html)$/i.test(b.nodeName) ? {\n          top: 0,\n          left: 0\n        } : c(b).offset();\n\n        return d.top -= parseFloat(a.style.marginTop) || 0, d.left -= parseFloat(a.style.marginLeft) || 0, b.style && (e.top += parseFloat(b.style.borderTopWidth) || 0, e.left += parseFloat(b.style.borderLeftWidth) || 0), {\n          top: d.top - e.top,\n          left: d.left - e.left\n        };\n      }\n    };\n    var d = {};\n    c.expando = 'velocity' + new Date().getTime(), c.uuid = 0;\n\n    for (var e = {}, f = e.hasOwnProperty, g = e.toString, h = 'Boolean Number String Function Array Date RegExp Object Error'.split(' '), i = 0; i < h.length; i++) {\n      e['[object ' + h[i] + ']'] = h[i].toLowerCase();\n    }\n\n    c.fn.init.prototype = c.fn, a.Velocity = {\n      Utilities: c\n    };\n  }\n}(window), function (a) {\n  'use strict';\n\n   true && 'object' == typeof module.exports ? module.exports = a() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (a),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n}(function () {\n  'use strict';\n\n  return function (a, b, c, d) {\n    function e(a) {\n      for (var b = -1, c = a ? a.length : 0, d = []; ++b < c;) {\n        var e = a[b];\n        e && d.push(e);\n      }\n\n      return d;\n    }\n\n    function f(a) {\n      return u.isWrapped(a) ? a = s.call(a) : u.isNode(a) && (a = [a]), a;\n    }\n\n    function g(a) {\n      var b = o.data(a, 'velocity');\n      return null === b ? d : b;\n    }\n\n    function h(a, b) {\n      var c = g(a);\n      c && c.delayTimer && !c.delayPaused && (c.delayRemaining = c.delay - b + c.delayBegin, c.delayPaused = !0, clearTimeout(c.delayTimer.setTimeout));\n    }\n\n    function i(a, b) {\n      var c = g(a);\n      c && c.delayTimer && c.delayPaused && (c.delayPaused = !1, c.delayTimer.setTimeout = setTimeout(c.delayTimer.next, c.delayRemaining));\n    }\n\n    function j(a) {\n      return function (b) {\n        return Math.round(b * a) * (1 / a);\n      };\n    }\n\n    function k(a, c, d, e) {\n      function f(a, b) {\n        return 1 - 3 * b + 3 * a;\n      }\n\n      function g(a, b) {\n        return 3 * b - 6 * a;\n      }\n\n      function h(a) {\n        return 3 * a;\n      }\n\n      function i(a, b, c) {\n        return ((f(b, c) * a + g(b, c)) * a + h(b)) * a;\n      }\n\n      function j(a, b, c) {\n        return 3 * f(b, c) * a * a + 2 * g(b, c) * a + h(b);\n      }\n\n      function k(b, c) {\n        for (var e = 0; e < p; ++e) {\n          var f = j(c, a, d);\n\n          if (0 === f) {\n            return c;\n          }\n\n          c -= (i(c, a, d) - b) / f;\n        }\n\n        return c;\n      }\n\n      function l() {\n        for (var b = 0; b < t; ++b) {\n          x[b] = i(b * u, a, d);\n        }\n      }\n\n      function m(b, c, e) {\n        var f,\n            g,\n            h = 0;\n\n        do {\n          g = c + (e - c) / 2, f = i(g, a, d) - b, f > 0 ? e = g : c = g;\n        } while (Math.abs(f) > r && ++h < s);\n\n        return g;\n      }\n\n      function n(b) {\n        for (var c = 0, e = 1, f = t - 1; e !== f && x[e] <= b; ++e) {\n          c += u;\n        }\n\n        --e;\n        var g = (b - x[e]) / (x[e + 1] - x[e]),\n            h = c + g * u,\n            i = j(h, a, d);\n        return i >= q ? k(b, h) : 0 === i ? h : m(b, c, c + u);\n      }\n\n      function o() {\n        y = !0, a === c && d === e || l();\n      }\n\n      var p = 4,\n          q = .001,\n          r = 1e-7,\n          s = 10,\n          t = 11,\n          u = 1 / (t - 1),\n          v = ('Float32Array' in b);\n\n      if (4 !== arguments.length) {\n        return !1;\n      }\n\n      for (var w = 0; w < 4; ++w) {\n        if ('number' != typeof arguments[w] || isNaN(arguments[w]) || !isFinite(arguments[w])) {\n          return !1;\n        }\n      }\n\n      a = Math.min(a, 1), d = Math.min(d, 1), a = Math.max(a, 0), d = Math.max(d, 0);\n\n      var x = v ? new Float32Array(t) : new Array(t),\n          y = !1,\n          z = function (b) {\n        return y || o(), a === c && d === e ? b : 0 === b ? 0 : 1 === b ? 1 : i(n(b), c, e);\n      };\n\n      z.getControlPoints = function () {\n        return [{\n          x: a,\n          y: c\n        }, {\n          x: d,\n          y: e\n        }];\n      };\n\n      var A = 'generateBezier(' + [a, c, d, e] + ')';\n      return z.toString = function () {\n        return A;\n      }, z;\n    }\n\n    function l(a, b) {\n      var c = a;\n      return u.isString(a) ? y.Easings[a] || (c = !1) : c = u.isArray(a) && 1 === a.length ? j.apply(null, a) : u.isArray(a) && 2 === a.length ? z.apply(null, a.concat([b])) : !(!u.isArray(a) || 4 !== a.length) && k.apply(null, a), !1 === c && (c = y.Easings[y.defaults.easing] ? y.defaults.easing : x), c;\n    }\n\n    function m(a) {\n      if (a) {\n        var b = y.timestamp && !0 !== a ? a : r.now(),\n            c = y.State.calls.length;\n        c > 1e4 && (y.State.calls = e(y.State.calls), c = y.State.calls.length);\n\n        for (var f = 0; f < c; f++) {\n          if (y.State.calls[f]) {\n            var h = y.State.calls[f],\n                i = h[0],\n                j = h[2],\n                k = h[3],\n                l = !k,\n                q = null,\n                s = h[5],\n                t = h[6];\n\n            if (k || (k = y.State.calls[f][3] = b - 16), s) {\n              if (!0 !== s.resume) {\n                continue;\n              }\n\n              k = h[3] = Math.round(b - t - 16), h[5] = null;\n            }\n\n            t = h[6] = b - k;\n\n            for (var v = Math.min(t / j.duration, 1), w = 0, x = i.length; w < x; w++) {\n              var z = i[w],\n                  B = z.element;\n\n              if (g(B)) {\n                var D = !1;\n\n                if (j.display !== d && null !== j.display && 'none' !== j.display) {\n                  if ('flex' === j.display) {\n                    var E = ['-webkit-box', '-moz-box', '-ms-flexbox', '-webkit-flex'];\n                    o.each(E, function (a, b) {\n                      A.setPropertyValue(B, 'display', b);\n                    });\n                  }\n\n                  A.setPropertyValue(B, 'display', j.display);\n                }\n\n                j.visibility !== d && 'hidden' !== j.visibility && A.setPropertyValue(B, 'visibility', j.visibility);\n\n                for (var F in z) {\n                  if (z.hasOwnProperty(F) && 'element' !== F) {\n                    var G,\n                        H = z[F],\n                        I = u.isString(H.easing) ? y.Easings[H.easing] : H.easing;\n\n                    if (u.isString(H.pattern)) {\n                      var J = 1 === v ? function (a, b, c) {\n                        var d = H.endValue[b];\n                        return c ? Math.round(d) : d;\n                      } : function (a, b, c) {\n                        var d = H.startValue[b],\n                            e = H.endValue[b] - d,\n                            f = d + e * I(v, j, e);\n                        return c ? Math.round(f) : f;\n                      };\n                      G = H.pattern.replace(/{(\\d+)(!)?}/g, J);\n                    } else if (1 === v) {\n                      G = H.endValue;\n                    } else {\n                      var K = H.endValue - H.startValue;\n                      G = H.startValue + K * I(v, j, K);\n                    }\n\n                    if (!l && G === H.currentValue) {\n                      continue;\n                    }\n\n                    if (H.currentValue = G, 'tween' === F) {\n                      q = G;\n                    } else {\n                      var L;\n\n                      if (A.Hooks.registered[F]) {\n                        L = A.Hooks.getRoot(F);\n                        var M = g(B).rootPropertyValueCache[L];\n                        M && (H.rootPropertyValue = M);\n                      }\n\n                      var N = A.setPropertyValue(B, F, H.currentValue + (p < 9 && 0 === parseFloat(G) ? '' : H.unitType), H.rootPropertyValue, H.scrollData);\n                      A.Hooks.registered[F] && (A.Normalizations.registered[L] ? g(B).rootPropertyValueCache[L] = A.Normalizations.registered[L]('extract', null, N[1]) : g(B).rootPropertyValueCache[L] = N[1]), 'transform' === N[0] && (D = !0);\n                    }\n                  }\n                }\n\n                j.mobileHA && g(B).transformCache.translate3d === d && (g(B).transformCache.translate3d = '(0px, 0px, 0px)', D = !0), D && A.flushTransformCache(B);\n              }\n            }\n\n            j.display !== d && 'none' !== j.display && (y.State.calls[f][2].display = !1), j.visibility !== d && 'hidden' !== j.visibility && (y.State.calls[f][2].visibility = !1), j.progress && j.progress.call(h[1], h[1], v, Math.max(0, k + j.duration - b), k, q), 1 === v && n(f);\n          }\n        }\n      }\n\n      y.State.isTicking && C(m);\n    }\n\n    function n(a, b) {\n      if (!y.State.calls[a]) {\n        return !1;\n      }\n\n      for (var c = y.State.calls[a][0], e = y.State.calls[a][1], f = y.State.calls[a][2], h = y.State.calls[a][4], i = !1, j = 0, k = c.length; j < k; j++) {\n        var l = c[j].element;\n        b || f.loop || ('none' === f.display && A.setPropertyValue(l, 'display', f.display), 'hidden' === f.visibility && A.setPropertyValue(l, 'visibility', f.visibility));\n        var m = g(l);\n\n        if (!0 !== f.loop && (o.queue(l)[1] === d || !/\\.velocityQueueEntryFlag/i.test(o.queue(l)[1])) && m) {\n          m.isAnimating = !1, m.rootPropertyValueCache = {};\n          var n = !1;\n          o.each(A.Lists.transforms3D, function (a, b) {\n            var c = /^scale/.test(b) ? 1 : 0,\n                e = m.transformCache[b];\n            m.transformCache[b] !== d && new RegExp('^\\\\(' + c + '[^.]').test(e) && (n = !0, delete m.transformCache[b]);\n          }), f.mobileHA && (n = !0, delete m.transformCache.translate3d), n && A.flushTransformCache(l), A.Values.removeClass(l, 'velocity-animating');\n        }\n\n        if (!b && f.complete && !f.loop && j === k - 1) {\n          try {\n            f.complete.call(e, e);\n          } catch (r) {\n            setTimeout(function () {\n              throw r;\n            }, 1);\n          }\n        }\n\n        h && !0 !== f.loop && h(e), m && !0 === f.loop && !b && (o.each(m.tweensContainer, function (a, b) {\n          if (/^rotate/.test(a) && (parseFloat(b.startValue) - parseFloat(b.endValue)) % 360 == 0) {\n            var c = b.startValue;\n            b.startValue = b.endValue, b.endValue = c;\n          }\n\n          /^backgroundPosition/.test(a) && 100 === parseFloat(b.endValue) && '%' === b.unitType && (b.endValue = 0, b.startValue = 100);\n        }), y(l, 'reverse', {\n          loop: !0,\n          delay: f.delay\n        })), !1 !== f.queue && o.dequeue(l, f.queue);\n      }\n\n      y.State.calls[a] = !1;\n\n      for (var p = 0, q = y.State.calls.length; p < q; p++) {\n        if (!1 !== y.State.calls[p]) {\n          i = !0;\n          break;\n        }\n      }\n\n      !1 === i && (y.State.isTicking = !1, delete y.State.calls, y.State.calls = []);\n    }\n\n    var o,\n        p = function () {\n      if (c.documentMode) {\n        return c.documentMode;\n      }\n\n      for (var a = 7; a > 4; a--) {\n        var b = c.createElement('div');\n\n        if (b.innerHTML = '\\x3c!--[if IE ' + a + ']><span></span><![endif]--\\x3e', b.getElementsByTagName('span').length) {\n          return b = null, a;\n        }\n      }\n\n      return d;\n    }(),\n        q = function () {\n      var a = 0;\n      return b.webkitRequestAnimationFrame || b.mozRequestAnimationFrame || function (b) {\n        var c,\n            d = new Date().getTime();\n        return c = Math.max(0, 16 - (d - a)), a = d + c, setTimeout(function () {\n          b(d + c);\n        }, c);\n      };\n    }(),\n        r = function () {\n      var a = b.performance || {};\n\n      if ('function' != typeof a.now) {\n        var c = a.timing && a.timing.navigationStart ? a.timing.navigationStart : new Date().getTime();\n\n        a.now = function () {\n          return new Date().getTime() - c;\n        };\n      }\n\n      return a;\n    }(),\n        s = function () {\n      var a = Array.prototype.slice;\n\n      try {\n        return a.call(c.documentElement), a;\n      } catch (b) {\n        return function (b, c) {\n          var d = this.length;\n\n          if ('number' != typeof b && (b = 0), 'number' != typeof c && (c = d), this.slice) {\n            return a.call(this, b, c);\n          }\n\n          var e,\n              f = [],\n              g = b >= 0 ? b : Math.max(0, d + b),\n              h = c < 0 ? d + c : Math.min(c, d),\n              i = h - g;\n\n          if (i > 0) {\n            if (f = new Array(i), this.charAt) {\n              for (e = 0; e < i; e++) {\n                f[e] = this.charAt(g + e);\n              }\n            } else {\n              for (e = 0; e < i; e++) {\n                f[e] = this[g + e];\n              }\n            }\n          }\n\n          return f;\n        };\n      }\n    }(),\n        t = function () {\n      return Array.prototype.includes ? function (a, b) {\n        return a.includes(b);\n      } : Array.prototype.indexOf ? function (a, b) {\n        return a.indexOf(b) >= 0;\n      } : function (a, b) {\n        for (var c = 0; c < a.length; c++) {\n          if (a[c] === b) {\n            return !0;\n          }\n        }\n\n        return !1;\n      };\n    },\n        u = {\n      isNumber: function (a) {\n        return 'number' == typeof a;\n      },\n      isString: function (a) {\n        return 'string' == typeof a;\n      },\n      isArray: Array.isArray || function (a) {\n        return '[object Array]' === Object.prototype.toString.call(a);\n      },\n      isFunction: function (a) {\n        return '[object Function]' === Object.prototype.toString.call(a);\n      },\n      isNode: function (a) {\n        return a && a.nodeType;\n      },\n      isWrapped: function (a) {\n        return a && a !== b && u.isNumber(a.length) && !u.isString(a) && !u.isFunction(a) && !u.isNode(a) && (0 === a.length || u.isNode(a[0]));\n      },\n      isSVG: function (a) {\n        return b.SVGElement && a instanceof b.SVGElement;\n      },\n      isEmptyObject: function (a) {\n        for (var b in a) {\n          if (a.hasOwnProperty(b)) {\n            return !1;\n          }\n        }\n\n        return !0;\n      }\n    },\n        v = !1;\n\n    if (a.fn && a.fn.jquery ? (o = a, v = !0) : o = b.Velocity.Utilities, p <= 8 && !v) {\n      throw new Error('Velocity: IE8 and below require jQuery to be loaded before Velocity.');\n    }\n\n    if (p <= 7) {\n      return void (jQuery.fn.velocity = jQuery.fn.animate);\n    }\n\n    var w = 400,\n        x = 'swing',\n        y = {\n      State: {\n        isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(b.navigator.userAgent),\n        isAndroid: /Android/i.test(b.navigator.userAgent),\n        isGingerbread: /Android 2\\.3\\.[3-7]/i.test(b.navigator.userAgent),\n        isChrome: b.chrome,\n        isFirefox: /Firefox/i.test(b.navigator.userAgent),\n        prefixElement: c.createElement('div'),\n        prefixMatches: {},\n        scrollAnchor: null,\n        scrollPropertyLeft: null,\n        scrollPropertyTop: null,\n        isTicking: !1,\n        calls: [],\n        delayedElements: {\n          count: 0\n        }\n      },\n      CSS: {},\n      Utilities: o,\n      Redirects: {},\n      Easings: {},\n      Promise: b.Promise,\n      defaults: {\n        queue: '',\n        duration: w,\n        easing: x,\n        begin: d,\n        complete: d,\n        progress: d,\n        display: d,\n        visibility: d,\n        loop: !1,\n        delay: !1,\n        mobileHA: !0,\n        _cacheValues: !0,\n        promiseRejectEmpty: !0\n      },\n      init: function (a) {\n        o.data(a, 'velocity', {\n          isSVG: u.isSVG(a),\n          isAnimating: !1,\n          computedStyle: null,\n          tweensContainer: null,\n          rootPropertyValueCache: {},\n          transformCache: {}\n        });\n      },\n      hook: null,\n      mock: !1,\n      version: {\n        major: 1,\n        minor: 5,\n        patch: 1\n      },\n      debug: !1,\n      timestamp: !0,\n      pauseAll: function (a) {\n        var b = new Date().getTime();\n        o.each(y.State.calls, function (b, c) {\n          if (c) {\n            if (a !== d && (c[2].queue !== a || !1 === c[2].queue)) {\n              return !0;\n            }\n\n            c[5] = {\n              resume: !1\n            };\n          }\n        }), o.each(y.State.delayedElements, function (a, c) {\n          c && h(c, b);\n        });\n      },\n      resumeAll: function (a) {\n        var b = new Date().getTime();\n        o.each(y.State.calls, function (b, c) {\n          if (c) {\n            if (a !== d && (c[2].queue !== a || !1 === c[2].queue)) {\n              return !0;\n            }\n\n            c[5] && (c[5].resume = !0);\n          }\n        }), o.each(y.State.delayedElements, function (a, c) {\n          c && i(c, b);\n        });\n      }\n    };\n    b.pageYOffset !== d ? (y.State.scrollAnchor = b, y.State.scrollPropertyLeft = 'pageXOffset', y.State.scrollPropertyTop = 'pageYOffset') : (y.State.scrollAnchor = c.documentElement || c.body.parentNode || c.body, y.State.scrollPropertyLeft = 'scrollLeft', y.State.scrollPropertyTop = 'scrollTop');\n\n    var z = function () {\n      function a(a) {\n        return -a.tension * a.x - a.friction * a.v;\n      }\n\n      function b(b, c, d) {\n        var e = {\n          x: b.x + d.dx * c,\n          v: b.v + d.dv * c,\n          tension: b.tension,\n          friction: b.friction\n        };\n        return {\n          dx: e.v,\n          dv: a(e)\n        };\n      }\n\n      function c(c, d) {\n        var e = {\n          dx: c.v,\n          dv: a(c)\n        },\n            f = b(c, .5 * d, e),\n            g = b(c, .5 * d, f),\n            h = b(c, d, g),\n            i = 1 / 6 * (e.dx + 2 * (f.dx + g.dx) + h.dx),\n            j = 1 / 6 * (e.dv + 2 * (f.dv + g.dv) + h.dv);\n        return c.x = c.x + i * d, c.v = c.v + j * d, c;\n      }\n\n      return function d(a, b, e) {\n        var f,\n            g,\n            h,\n            i = {\n          x: -1,\n          v: 0,\n          tension: null,\n          friction: null\n        },\n            j = [0],\n            k = 0;\n\n        for (a = parseFloat(a) || 500, b = parseFloat(b) || 20, e = e || null, i.tension = a, i.friction = b, f = null !== e, f ? (k = d(a, b), g = k / e * .016) : g = .016;;) {\n          if (h = c(h || i, g), j.push(1 + h.x), k += 16, !(Math.abs(h.x) > 1e-4 && Math.abs(h.v) > 1e-4)) {\n            break;\n          }\n        }\n\n        return f ? function (a) {\n          return j[a * (j.length - 1) | 0];\n        } : k;\n      };\n    }();\n\n    y.Easings = {\n      linear: function (a) {\n        return a;\n      },\n      swing: function (a) {\n        return .5 - Math.cos(a * Math.PI) / 2;\n      },\n      spring: function (a) {\n        return 1 - Math.cos(4.5 * a * Math.PI) * Math.exp(6 * -a);\n      }\n    }, o.each([['ease', [.25, .1, .25, 1]], ['ease-in', [.42, 0, 1, 1]], ['ease-out', [0, 0, .58, 1]], ['ease-in-out', [.42, 0, .58, 1]], ['easeInSine', [.47, 0, .745, .715]], ['easeOutSine', [.39, .575, .565, 1]], ['easeInOutSine', [.445, .05, .55, .95]], ['easeInQuad', [.55, .085, .68, .53]], ['easeOutQuad', [.25, .46, .45, .94]], ['easeInOutQuad', [.455, .03, .515, .955]], ['easeInCubic', [.55, .055, .675, .19]], ['easeOutCubic', [.215, .61, .355, 1]], ['easeInOutCubic', [.645, .045, .355, 1]], ['easeInQuart', [.895, .03, .685, .22]], ['easeOutQuart', [.165, .84, .44, 1]], ['easeInOutQuart', [.77, 0, .175, 1]], ['easeInQuint', [.755, .05, .855, .06]], ['easeOutQuint', [.23, 1, .32, 1]], ['easeInOutQuint', [.86, 0, .07, 1]], ['easeInExpo', [.95, .05, .795, .035]], ['easeOutExpo', [.19, 1, .22, 1]], ['easeInOutExpo', [1, 0, 0, 1]], ['easeInCirc', [.6, .04, .98, .335]], ['easeOutCirc', [.075, .82, .165, 1]], ['easeInOutCirc', [.785, .135, .15, .86]]], function (a, b) {\n      y.Easings[b[0]] = k.apply(null, b[1]);\n    });\n    var A = y.CSS = {\n      RegEx: {\n        isHex: /^#([A-f\\d]{3}){1,2}$/i,\n        valueUnwrap: /^[A-z]+\\((.*)\\)$/i,\n        wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,\n        valueSplit: /([A-z]+\\(.+\\))|(([A-z0-9#-.]+?)(?=\\s|$))/gi\n      },\n      Lists: {\n        colors: ['fill', 'stroke', 'stopColor', 'color', 'backgroundColor', 'borderColor', 'borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor', 'outlineColor'],\n        transformsBase: ['translateX', 'translateY', 'scale', 'scaleX', 'scaleY', 'skewX', 'skewY', 'rotateZ'],\n        transforms3D: ['transformPerspective', 'translateZ', 'scaleZ', 'rotateX', 'rotateY'],\n        units: ['%', 'em', 'ex', 'ch', 'rem', 'vw', 'vh', 'vmin', 'vmax', 'cm', 'mm', 'Q', 'in', 'pc', 'pt', 'px', 'deg', 'grad', 'rad', 'turn', 's', 'ms'],\n        colorNames: {\n          aliceblue: '240,248,255',\n          antiquewhite: '250,235,215',\n          aquamarine: '127,255,212',\n          aqua: '0,255,255',\n          azure: '240,255,255',\n          beige: '245,245,220',\n          bisque: '255,228,196',\n          black: '0,0,0',\n          blanchedalmond: '255,235,205',\n          blueviolet: '138,43,226',\n          blue: '0,0,255',\n          brown: '165,42,42',\n          burlywood: '222,184,135',\n          cadetblue: '95,158,160',\n          chartreuse: '127,255,0',\n          chocolate: '210,105,30',\n          coral: '255,127,80',\n          cornflowerblue: '100,149,237',\n          cornsilk: '255,248,220',\n          crimson: '220,20,60',\n          cyan: '0,255,255',\n          darkblue: '0,0,139',\n          darkcyan: '0,139,139',\n          darkgoldenrod: '184,134,11',\n          darkgray: '169,169,169',\n          darkgrey: '169,169,169',\n          darkgreen: '0,100,0',\n          darkkhaki: '189,183,107',\n          darkmagenta: '139,0,139',\n          darkolivegreen: '85,107,47',\n          darkorange: '255,140,0',\n          darkorchid: '153,50,204',\n          darkred: '139,0,0',\n          darksalmon: '233,150,122',\n          darkseagreen: '143,188,143',\n          darkslateblue: '72,61,139',\n          darkslategray: '47,79,79',\n          darkturquoise: '0,206,209',\n          darkviolet: '148,0,211',\n          deeppink: '255,20,147',\n          deepskyblue: '0,191,255',\n          dimgray: '105,105,105',\n          dimgrey: '105,105,105',\n          dodgerblue: '30,144,255',\n          firebrick: '178,34,34',\n          floralwhite: '255,250,240',\n          forestgreen: '34,139,34',\n          fuchsia: '255,0,255',\n          gainsboro: '220,220,220',\n          ghostwhite: '248,248,255',\n          gold: '255,215,0',\n          goldenrod: '218,165,32',\n          gray: '128,128,128',\n          grey: '128,128,128',\n          greenyellow: '173,255,47',\n          green: '0,128,0',\n          honeydew: '240,255,240',\n          hotpink: '255,105,180',\n          indianred: '205,92,92',\n          indigo: '75,0,130',\n          ivory: '255,255,240',\n          khaki: '240,230,140',\n          lavenderblush: '255,240,245',\n          lavender: '230,230,250',\n          lawngreen: '124,252,0',\n          lemonchiffon: '255,250,205',\n          lightblue: '173,216,230',\n          lightcoral: '240,128,128',\n          lightcyan: '224,255,255',\n          lightgoldenrodyellow: '250,250,210',\n          lightgray: '211,211,211',\n          lightgrey: '211,211,211',\n          lightgreen: '144,238,144',\n          lightpink: '255,182,193',\n          lightsalmon: '255,160,122',\n          lightseagreen: '32,178,170',\n          lightskyblue: '135,206,250',\n          lightslategray: '119,136,153',\n          lightsteelblue: '176,196,222',\n          lightyellow: '255,255,224',\n          limegreen: '50,205,50',\n          lime: '0,255,0',\n          linen: '250,240,230',\n          magenta: '255,0,255',\n          maroon: '128,0,0',\n          mediumaquamarine: '102,205,170',\n          mediumblue: '0,0,205',\n          mediumorchid: '186,85,211',\n          mediumpurple: '147,112,219',\n          mediumseagreen: '60,179,113',\n          mediumslateblue: '123,104,238',\n          mediumspringgreen: '0,250,154',\n          mediumturquoise: '72,209,204',\n          mediumvioletred: '199,21,133',\n          midnightblue: '25,25,112',\n          mintcream: '245,255,250',\n          mistyrose: '255,228,225',\n          moccasin: '255,228,181',\n          navajowhite: '255,222,173',\n          navy: '0,0,128',\n          oldlace: '253,245,230',\n          olivedrab: '107,142,35',\n          olive: '128,128,0',\n          orangered: '255,69,0',\n          orange: '255,165,0',\n          orchid: '218,112,214',\n          palegoldenrod: '238,232,170',\n          palegreen: '152,251,152',\n          paleturquoise: '175,238,238',\n          palevioletred: '219,112,147',\n          papayawhip: '255,239,213',\n          peachpuff: '255,218,185',\n          peru: '205,133,63',\n          pink: '255,192,203',\n          plum: '221,160,221',\n          powderblue: '176,224,230',\n          purple: '128,0,128',\n          red: '255,0,0',\n          rosybrown: '188,143,143',\n          royalblue: '65,105,225',\n          saddlebrown: '139,69,19',\n          salmon: '250,128,114',\n          sandybrown: '244,164,96',\n          seagreen: '46,139,87',\n          seashell: '255,245,238',\n          sienna: '160,82,45',\n          silver: '192,192,192',\n          skyblue: '135,206,235',\n          slateblue: '106,90,205',\n          slategray: '112,128,144',\n          snow: '255,250,250',\n          springgreen: '0,255,127',\n          steelblue: '70,130,180',\n          tan: '210,180,140',\n          teal: '0,128,128',\n          thistle: '216,191,216',\n          tomato: '255,99,71',\n          turquoise: '64,224,208',\n          violet: '238,130,238',\n          wheat: '245,222,179',\n          whitesmoke: '245,245,245',\n          white: '255,255,255',\n          yellowgreen: '154,205,50',\n          yellow: '255,255,0'\n        }\n      },\n      Hooks: {\n        templates: {\n          textShadow: ['Color X Y Blur', 'black 0px 0px 0px'],\n          boxShadow: ['Color X Y Blur Spread', 'black 0px 0px 0px 0px'],\n          clip: ['Top Right Bottom Left', '0px 0px 0px 0px'],\n          backgroundPosition: ['X Y', '0% 0%'],\n          transformOrigin: ['X Y Z', '50% 50% 0px'],\n          perspectiveOrigin: ['X Y', '50% 50%']\n        },\n        registered: {},\n        register: function () {\n          for (var a = 0; a < A.Lists.colors.length; a++) {\n            var b = 'color' === A.Lists.colors[a] ? '0 0 0 1' : '255 255 255 1';\n            A.Hooks.templates[A.Lists.colors[a]] = ['Red Green Blue Alpha', b];\n          }\n\n          var c, d, e;\n\n          if (p) {\n            for (c in A.Hooks.templates) {\n              if (A.Hooks.templates.hasOwnProperty(c)) {\n                d = A.Hooks.templates[c], e = d[0].split(' ');\n                var f = d[1].match(A.RegEx.valueSplit);\n                'Color' === e[0] && (e.push(e.shift()), f.push(f.shift()), A.Hooks.templates[c] = [e.join(' '), f.join(' ')]);\n              }\n            }\n          }\n\n          for (c in A.Hooks.templates) {\n            if (A.Hooks.templates.hasOwnProperty(c)) {\n              d = A.Hooks.templates[c], e = d[0].split(' ');\n\n              for (var g in e) {\n                if (e.hasOwnProperty(g)) {\n                  var h = c + e[g],\n                      i = g;\n                  A.Hooks.registered[h] = [c, i];\n                }\n              }\n            }\n          }\n        },\n        getRoot: function (a) {\n          var b = A.Hooks.registered[a];\n          return b ? b[0] : a;\n        },\n        getUnit: function (a, b) {\n          var c = (a.substr(b || 0, 5).match(/^[a-z%]+/) || [])[0] || '';\n          return c && t(A.Lists.units, c) ? c : '';\n        },\n        fixColors: function (a) {\n          return a.replace(/(rgba?\\(\\s*)?(\\b[a-z]+\\b)/g, function (a, b, c) {\n            return A.Lists.colorNames.hasOwnProperty(c) ? (b || 'rgba(') + A.Lists.colorNames[c] + (b ? '' : ',1)') : b + c;\n          });\n        },\n        cleanRootPropertyValue: function (a, b) {\n          return A.RegEx.valueUnwrap.test(b) && (b = b.match(A.RegEx.valueUnwrap)[1]), A.Values.isCSSNullValue(b) && (b = A.Hooks.templates[a][1]), b;\n        },\n        extractValue: function (a, b) {\n          var c = A.Hooks.registered[a];\n\n          if (c) {\n            var d = c[0],\n                e = c[1];\n            return b = A.Hooks.cleanRootPropertyValue(d, b), b.toString().match(A.RegEx.valueSplit)[e];\n          }\n\n          return b;\n        },\n        injectValue: function (a, b, c) {\n          var d = A.Hooks.registered[a];\n\n          if (d) {\n            var e,\n                f = d[0],\n                g = d[1];\n            return c = A.Hooks.cleanRootPropertyValue(f, c), e = c.toString().match(A.RegEx.valueSplit), e[g] = b, e.join(' ');\n          }\n\n          return c;\n        }\n      },\n      Normalizations: {\n        registered: {\n          clip: function (a, b, c) {\n            switch (a) {\n              case 'name':\n                return 'clip';\n\n              case 'extract':\n                var d;\n                return A.RegEx.wrappedValueAlreadyExtracted.test(c) ? d = c : (d = c.toString().match(A.RegEx.valueUnwrap), d = d ? d[1].replace(/,(\\s+)?/g, ' ') : c), d;\n\n              case 'inject':\n                return 'rect(' + c + ')';\n            }\n          },\n          blur: function (a, b, c) {\n            switch (a) {\n              case 'name':\n                return y.State.isFirefox ? 'filter' : '-webkit-filter';\n\n              case 'extract':\n                var d = parseFloat(c);\n\n                if (!d && 0 !== d) {\n                  var e = c.toString().match(/blur\\(([0-9]+[A-z]+)\\)/i);\n                  d = e ? e[1] : 0;\n                }\n\n                return d;\n\n              case 'inject':\n                return parseFloat(c) ? 'blur(' + c + ')' : 'none';\n            }\n          },\n          opacity: function (a, b, c) {\n            if (p <= 8) {\n              switch (a) {\n                case 'name':\n                  return 'filter';\n\n                case 'extract':\n                  var d = c.toString().match(/alpha\\(opacity=(.*)\\)/i);\n                  return c = d ? d[1] / 100 : 1;\n\n                case 'inject':\n                  return b.style.zoom = 1, parseFloat(c) >= 1 ? '' : 'alpha(opacity=' + parseInt(100 * parseFloat(c), 10) + ')';\n              }\n            } else {\n              switch (a) {\n                case 'name':\n                  return 'opacity';\n\n                case 'extract':\n                case 'inject':\n                  return c;\n              }\n            }\n          }\n        },\n        register: function () {\n          function a(a, b, c) {\n            if ('border-box' === A.getPropertyValue(b, 'boxSizing').toString().toLowerCase() === (c || !1)) {\n              var d,\n                  e,\n                  f = 0,\n                  g = 'width' === a ? ['Left', 'Right'] : ['Top', 'Bottom'],\n                  h = ['padding' + g[0], 'padding' + g[1], 'border' + g[0] + 'Width', 'border' + g[1] + 'Width'];\n\n              for (d = 0; d < h.length; d++) {\n                e = parseFloat(A.getPropertyValue(b, h[d])), isNaN(e) || (f += e);\n              }\n\n              return c ? -f : f;\n            }\n\n            return 0;\n          }\n\n          function b(b, c) {\n            return function (d, e, f) {\n              switch (d) {\n                case 'name':\n                  return b;\n\n                case 'extract':\n                  return parseFloat(f) + a(b, e, c);\n\n                case 'inject':\n                  return parseFloat(f) - a(b, e, c) + 'px';\n              }\n            };\n          }\n\n          p && !(p > 9) || y.State.isGingerbread || (A.Lists.transformsBase = A.Lists.transformsBase.concat(A.Lists.transforms3D));\n\n          for (var c = 0; c < A.Lists.transformsBase.length; c++) {\n            !function () {\n              var a = A.Lists.transformsBase[c];\n\n              A.Normalizations.registered[a] = function (b, c, e) {\n                switch (b) {\n                  case 'name':\n                    return 'transform';\n\n                  case 'extract':\n                    return g(c) === d || g(c).transformCache[a] === d ? /^scale/i.test(a) ? 1 : 0 : g(c).transformCache[a].replace(/[()]/g, '');\n\n                  case 'inject':\n                    var f = !1;\n\n                    switch (a.substr(0, a.length - 1)) {\n                      case 'translate':\n                        f = !/(%|px|em|rem|vw|vh|\\d)$/i.test(e);\n                        break;\n\n                      case 'scal':\n                      case 'scale':\n                        y.State.isAndroid && g(c).transformCache[a] === d && e < 1 && (e = 1), f = !/(\\d)$/i.test(e);\n                        break;\n\n                      case 'skew':\n                      case 'rotate':\n                        f = !/(deg|\\d)$/i.test(e);\n                    }\n\n                    return f || (g(c).transformCache[a] = '(' + e + ')'), g(c).transformCache[a];\n                }\n              };\n            }();\n          }\n\n          for (var e = 0; e < A.Lists.colors.length; e++) {\n            !function () {\n              var a = A.Lists.colors[e];\n\n              A.Normalizations.registered[a] = function (b, c, e) {\n                switch (b) {\n                  case 'name':\n                    return a;\n\n                  case 'extract':\n                    var f;\n\n                    if (A.RegEx.wrappedValueAlreadyExtracted.test(e)) {\n                      f = e;\n                    } else {\n                      var g,\n                          h = {\n                        black: 'rgb(0, 0, 0)',\n                        blue: 'rgb(0, 0, 255)',\n                        gray: 'rgb(128, 128, 128)',\n                        green: 'rgb(0, 128, 0)',\n                        red: 'rgb(255, 0, 0)',\n                        white: 'rgb(255, 255, 255)'\n                      };\n                      /^[A-z]+$/i.test(e) ? g = h[e] !== d ? h[e] : h.black : A.RegEx.isHex.test(e) ? g = 'rgb(' + A.Values.hexToRgb(e).join(' ') + ')' : /^rgba?\\(/i.test(e) || (g = h.black), f = (g || e).toString().match(A.RegEx.valueUnwrap)[1].replace(/,(\\s+)?/g, ' ');\n                    }\n\n                    return (!p || p > 8) && 3 === f.split(' ').length && (f += ' 1'), f;\n\n                  case 'inject':\n                    return /^rgb/.test(e) ? e : (p <= 8 ? 4 === e.split(' ').length && (e = e.split(/\\s+/).slice(0, 3).join(' ')) : 3 === e.split(' ').length && (e += ' 1'), (p <= 8 ? 'rgb' : 'rgba') + '(' + e.replace(/\\s+/g, ',').replace(/\\.(\\d)+(?=,)/g, '') + ')');\n                }\n              };\n            }();\n          }\n\n          A.Normalizations.registered.innerWidth = b('width', !0), A.Normalizations.registered.innerHeight = b('height', !0), A.Normalizations.registered.outerWidth = b('width'), A.Normalizations.registered.outerHeight = b('height');\n        }\n      },\n      Names: {\n        camelCase: function (a) {\n          return a.replace(/-(\\w)/g, function (a, b) {\n            return b.toUpperCase();\n          });\n        },\n        SVGAttribute: function (a) {\n          var b = 'width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2';\n          return (p || y.State.isAndroid && !y.State.isChrome) && (b += '|transform'), new RegExp('^(' + b + ')$', 'i').test(a);\n        },\n        prefixCheck: function (a) {\n          if (y.State.prefixMatches[a]) {\n            return [y.State.prefixMatches[a], !0];\n          }\n\n          for (var b = ['', 'Webkit', 'Moz', 'ms', 'O'], c = 0, d = b.length; c < d; c++) {\n            var e;\n\n            if (e = 0 === c ? a : b[c] + a.replace(/^\\w/, function (a) {\n              return a.toUpperCase();\n            }), u.isString(y.State.prefixElement.style[e])) {\n              return y.State.prefixMatches[a] = e, [e, !0];\n            }\n          }\n\n          return [a, !1];\n        }\n      },\n      Values: {\n        hexToRgb: function (a) {\n          var b,\n              c = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,\n              d = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n          return a = a.replace(c, function (a, b, c, d) {\n            return b + b + c + c + d + d;\n          }), b = d.exec(a), b ? [parseInt(b[1], 16), parseInt(b[2], 16), parseInt(b[3], 16)] : [0, 0, 0];\n        },\n        isCSSNullValue: function (a) {\n          return !a || /^(none|auto|transparent|(rgba\\(0, ?0, ?0, ?0\\)))$/i.test(a);\n        },\n        getUnitType: function (a) {\n          return /^(rotate|skew)/i.test(a) ? 'deg' : /(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(a) ? '' : 'px';\n        },\n        getDisplayType: function (a) {\n          var b = a && a.tagName.toString().toLowerCase();\n          return /^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(b) ? 'inline' : /^(li)$/i.test(b) ? 'list-item' : /^(tr)$/i.test(b) ? 'table-row' : /^(table)$/i.test(b) ? 'table' : /^(tbody)$/i.test(b) ? 'table-row-group' : 'block';\n        },\n        addClass: function (a, b) {\n          if (a) {\n            if (a.classList) {\n              a.classList.add(b);\n            } else if (u.isString(a.className)) {\n              a.className += (a.className.length ? ' ' : '') + b;\n            } else {\n              var c = a.getAttribute(p <= 7 ? 'className' : 'class') || '';\n              a.setAttribute('class', c + (c ? ' ' : '') + b);\n            }\n          }\n        },\n        removeClass: function (a, b) {\n          if (a) {\n            if (a.classList) {\n              a.classList.remove(b);\n            } else if (u.isString(a.className)) {\n              a.className = a.className.toString().replace(new RegExp('(^|\\\\s)' + b.split(' ').join('|') + '(\\\\s|$)', 'gi'), ' ');\n            } else {\n              var c = a.getAttribute(p <= 7 ? 'className' : 'class') || '';\n              a.setAttribute('class', c.replace(new RegExp('(^|s)' + b.split(' ').join('|') + '(s|$)', 'gi'), ' '));\n            }\n          }\n        }\n      },\n      getPropertyValue: function (a, c, e, f) {\n        function h(a, c) {\n          var e = 0;\n\n          if (p <= 8) {\n            e = o.css(a, c);\n          } else {\n            var i = !1;\n            /^(width|height)$/.test(c) && 0 === A.getPropertyValue(a, 'display') && (i = !0, A.setPropertyValue(a, 'display', A.Values.getDisplayType(a)));\n\n            var j = function () {\n              i && A.setPropertyValue(a, 'display', 'none');\n            };\n\n            if (!f) {\n              if ('height' === c && 'border-box' !== A.getPropertyValue(a, 'boxSizing').toString().toLowerCase()) {\n                var k = a.offsetHeight - (parseFloat(A.getPropertyValue(a, 'borderTopWidth')) || 0) - (parseFloat(A.getPropertyValue(a, 'borderBottomWidth')) || 0) - (parseFloat(A.getPropertyValue(a, 'paddingTop')) || 0) - (parseFloat(A.getPropertyValue(a, 'paddingBottom')) || 0);\n                return j(), k;\n              }\n\n              if ('width' === c && 'border-box' !== A.getPropertyValue(a, 'boxSizing').toString().toLowerCase()) {\n                var l = a.offsetWidth - (parseFloat(A.getPropertyValue(a, 'borderLeftWidth')) || 0) - (parseFloat(A.getPropertyValue(a, 'borderRightWidth')) || 0) - (parseFloat(A.getPropertyValue(a, 'paddingLeft')) || 0) - (parseFloat(A.getPropertyValue(a, 'paddingRight')) || 0);\n                return j(), l;\n              }\n            }\n\n            var m;\n            m = g(a) === d ? b.getComputedStyle(a, null) : g(a).computedStyle ? g(a).computedStyle : g(a).computedStyle = b.getComputedStyle(a, null), 'borderColor' === c && (c = 'borderTopColor'), e = 9 === p && 'filter' === c ? m.getPropertyValue(c) : m[c], '' !== e && null !== e || (e = a.style[c]), j();\n          }\n\n          if ('auto' === e && /^(top|right|bottom|left)$/i.test(c)) {\n            var n = h(a, 'position');\n            ('fixed' === n || 'absolute' === n && /top|left/i.test(c)) && (e = o(a).position()[c] + 'px');\n          }\n\n          return e;\n        }\n\n        var i;\n\n        if (A.Hooks.registered[c]) {\n          var j = c,\n              k = A.Hooks.getRoot(j);\n          e === d && (e = A.getPropertyValue(a, A.Names.prefixCheck(k)[0])), A.Normalizations.registered[k] && (e = A.Normalizations.registered[k]('extract', a, e)), i = A.Hooks.extractValue(j, e);\n        } else if (A.Normalizations.registered[c]) {\n          var l, m;\n          l = A.Normalizations.registered[c]('name', a), 'transform' !== l && (m = h(a, A.Names.prefixCheck(l)[0]), A.Values.isCSSNullValue(m) && A.Hooks.templates[c] && (m = A.Hooks.templates[c][1])), i = A.Normalizations.registered[c]('extract', a, m);\n        }\n\n        if (!/^[\\d-]/.test(i)) {\n          var n = g(a);\n\n          if (n && n.isSVG && A.Names.SVGAttribute(c)) {\n            if (/^(height|width)$/i.test(c)) {\n              try {\n                i = a.getBBox()[c];\n              } catch (q) {\n                i = 0;\n              }\n            } else {\n              i = a.getAttribute(c);\n            }\n          } else {\n            i = h(a, A.Names.prefixCheck(c)[0]);\n          }\n        }\n\n        return A.Values.isCSSNullValue(i) && (i = 0), y.debug >= 2 && console.log('Get ' + c + ': ' + i), i;\n      },\n      setPropertyValue: function (a, c, d, e, f) {\n        var h = c;\n\n        if ('scroll' === c) {\n          f.container ? f.container['scroll' + f.direction] = d : 'Left' === f.direction ? b.scrollTo(d, f.alternateValue) : b.scrollTo(f.alternateValue, d);\n        } else if (A.Normalizations.registered[c] && 'transform' === A.Normalizations.registered[c]('name', a)) {\n          A.Normalizations.registered[c]('inject', a, d), h = 'transform', d = g(a).transformCache[c];\n        } else {\n          if (A.Hooks.registered[c]) {\n            var i = c,\n                j = A.Hooks.getRoot(c);\n            e = e || A.getPropertyValue(a, j), d = A.Hooks.injectValue(i, d, e), c = j;\n          }\n\n          if (A.Normalizations.registered[c] && (d = A.Normalizations.registered[c]('inject', a, d), c = A.Normalizations.registered[c]('name', a)), h = A.Names.prefixCheck(c)[0], p <= 8) {\n            try {\n              a.style[h] = d;\n            } catch (l) {\n              y.debug && console.log('Browser does not support [' + d + '] for [' + h + ']');\n            }\n          } else {\n            var k = g(a);\n            k && k.isSVG && A.Names.SVGAttribute(c) ? a.setAttribute(c, d) : a.style[h] = d;\n          }\n\n          y.debug >= 2 && console.log('Set ' + c + ' (' + h + '): ' + d);\n        }\n\n        return [h, d];\n      },\n      flushTransformCache: function (a) {\n        var b = '',\n            c = g(a);\n\n        if ((p || y.State.isAndroid && !y.State.isChrome) && c && c.isSVG) {\n          var d = function (b) {\n            return parseFloat(A.getPropertyValue(a, b));\n          },\n              e = {\n            translate: [d('translateX'), d('translateY')],\n            skewX: [d('skewX')],\n            skewY: [d('skewY')],\n            scale: 1 !== d('scale') ? [d('scale'), d('scale')] : [d('scaleX'), d('scaleY')],\n            rotate: [d('rotateZ'), 0, 0]\n          };\n\n          o.each(g(a).transformCache, function (a) {\n            /^translate/i.test(a) ? a = 'translate' : /^scale/i.test(a) ? a = 'scale' : /^rotate/i.test(a) && (a = 'rotate'), e[a] && (b += a + '(' + e[a].join(' ') + ') ', delete e[a]);\n          });\n        } else {\n          var f, h;\n          o.each(g(a).transformCache, function (c) {\n            if (f = g(a).transformCache[c], 'transformPerspective' === c) {\n              return h = f, !0;\n            }\n\n            9 === p && 'rotateZ' === c && (c = 'rotate'), b += c + f + ' ';\n          }), h && (b = 'perspective' + h + ' ' + b);\n        }\n\n        A.setPropertyValue(a, 'transform', b);\n      }\n    };\n    A.Hooks.register(), A.Normalizations.register(), y.hook = function (a, b, c) {\n      var e;\n      return a = f(a), o.each(a, function (a, f) {\n        if (g(f) === d && y.init(f), c === d) {\n          e === d && (e = A.getPropertyValue(f, b));\n        } else {\n          var h = A.setPropertyValue(f, b, c);\n          'transform' === h[0] && y.CSS.flushTransformCache(f), e = h;\n        }\n      }), e;\n    };\n\n    var B = function () {\n      function a() {\n        return k ? z.promise || null : p;\n      }\n\n      function e(a, e) {\n        function f(f) {\n          var k, n;\n\n          if (i.begin && 0 === D) {\n            try {\n              i.begin.call(r, r);\n            } catch (V) {\n              setTimeout(function () {\n                throw V;\n              }, 1);\n            }\n          }\n\n          if ('scroll' === G) {\n            var p,\n                q,\n                w,\n                x = /^x$/i.test(i.axis) ? 'Left' : 'Top',\n                B = parseFloat(i.offset) || 0;\n            i.container ? u.isWrapped(i.container) || u.isNode(i.container) ? (i.container = i.container[0] || i.container, p = i.container['scroll' + x], w = p + o(a).position()[x.toLowerCase()] + B) : i.container = null : (p = y.State.scrollAnchor[y.State['scrollProperty' + x]], q = y.State.scrollAnchor[y.State['scrollProperty' + ('Left' === x ? 'Top' : 'Left')]], w = o(a).offset()[x.toLowerCase()] + B), j = {\n              scroll: {\n                rootPropertyValue: !1,\n                startValue: p,\n                currentValue: p,\n                endValue: w,\n                unitType: '',\n                easing: i.easing,\n                scrollData: {\n                  container: i.container,\n                  direction: x,\n                  alternateValue: q\n                }\n              },\n              element: a\n            }, y.debug && console.log('tweensContainer (scroll): ', j.scroll, a);\n          } else if ('reverse' === G) {\n            if (!(k = g(a))) {\n              return;\n            }\n\n            if (!k.tweensContainer) {\n              return void o.dequeue(a, i.queue);\n            }\n\n            'none' === k.opts.display && (k.opts.display = 'auto'), 'hidden' === k.opts.visibility && (k.opts.visibility = 'visible'), k.opts.loop = !1, k.opts.begin = null, k.opts.complete = null, v.easing || delete i.easing, v.duration || delete i.duration, i = o.extend({}, k.opts, i), n = o.extend(!0, {}, k ? k.tweensContainer : null);\n\n            for (var E in n) {\n              if (n.hasOwnProperty(E) && 'element' !== E) {\n                var F = n[E].startValue;\n                n[E].startValue = n[E].currentValue = n[E].endValue, n[E].endValue = F, u.isEmptyObject(v) || (n[E].easing = i.easing), y.debug && console.log('reverse tweensContainer (' + E + '): ' + JSON.stringify(n[E]), a);\n              }\n            }\n\n            j = n;\n          } else if ('start' === G) {\n            k = g(a), k && k.tweensContainer && !0 === k.isAnimating && (n = k.tweensContainer);\n\n            var H = function (e, f) {\n              var g,\n                  l = A.Hooks.getRoot(e),\n                  m = !1,\n                  p = f[0],\n                  q = f[1],\n                  r = f[2];\n\n              if (!(k && k.isSVG || 'tween' === l || !1 !== A.Names.prefixCheck(l)[1] || A.Normalizations.registered[l] !== d)) {\n                return void (y.debug && console.log('Skipping [' + l + '] due to a lack of browser support.'));\n              }\n\n              (i.display !== d && null !== i.display && 'none' !== i.display || i.visibility !== d && 'hidden' !== i.visibility) && /opacity|filter/.test(e) && !r && 0 !== p && (r = 0), i._cacheValues && n && n[e] ? (r === d && (r = n[e].endValue + n[e].unitType), m = k.rootPropertyValueCache[l]) : A.Hooks.registered[e] ? r === d ? (m = A.getPropertyValue(a, l), r = A.getPropertyValue(a, e, m)) : m = A.Hooks.templates[l][1] : r === d && (r = A.getPropertyValue(a, e));\n\n              var s,\n                  t,\n                  v,\n                  w = !1,\n                  x = function (a, b) {\n                var c, d;\n                return d = (b || '0').toString().toLowerCase().replace(/[%A-z]+$/, function (a) {\n                  return c = a, '';\n                }), c || (c = A.Values.getUnitType(a)), [d, c];\n              };\n\n              if (r !== p && u.isString(r) && u.isString(p)) {\n                g = '';\n                var z = 0,\n                    B = 0,\n                    C = [],\n                    D = [],\n                    E = 0,\n                    F = 0,\n                    G = 0;\n\n                for (r = A.Hooks.fixColors(r), p = A.Hooks.fixColors(p); z < r.length && B < p.length;) {\n                  var H = r[z],\n                      I = p[B];\n\n                  if (/[\\d\\.-]/.test(H) && /[\\d\\.-]/.test(I)) {\n                    for (var J = H, K = I, L = '.', N = '.'; ++z < r.length;) {\n                      if ((H = r[z]) === L) {\n                        L = '..';\n                      } else if (!/\\d/.test(H)) {\n                        break;\n                      }\n\n                      J += H;\n                    }\n\n                    for (; ++B < p.length;) {\n                      if ((I = p[B]) === N) {\n                        N = '..';\n                      } else if (!/\\d/.test(I)) {\n                        break;\n                      }\n\n                      K += I;\n                    }\n\n                    var O = A.Hooks.getUnit(r, z),\n                        P = A.Hooks.getUnit(p, B);\n\n                    if (z += O.length, B += P.length, O === P) {\n                      J === K ? g += J + O : (g += '{' + C.length + (F ? '!' : '') + '}' + O, C.push(parseFloat(J)), D.push(parseFloat(K)));\n                    } else {\n                      var Q = parseFloat(J),\n                          R = parseFloat(K);\n                      g += (E < 5 ? 'calc' : '') + '(' + (Q ? '{' + C.length + (F ? '!' : '') + '}' : '0') + O + ' + ' + (R ? '{' + (C.length + (Q ? 1 : 0)) + (F ? '!' : '') + '}' : '0') + P + ')', Q && (C.push(Q), D.push(0)), R && (C.push(0), D.push(R));\n                    }\n                  } else {\n                    if (H !== I) {\n                      E = 0;\n                      break;\n                    }\n\n                    g += H, z++, B++, 0 === E && 'c' === H || 1 === E && 'a' === H || 2 === E && 'l' === H || 3 === E && 'c' === H || E >= 4 && '(' === H ? E++ : (E && E < 5 || E >= 4 && ')' === H && --E < 5) && (E = 0), 0 === F && 'r' === H || 1 === F && 'g' === H || 2 === F && 'b' === H || 3 === F && 'a' === H || F >= 3 && '(' === H ? (3 === F && 'a' === H && (G = 1), F++) : G && ',' === H ? ++G > 3 && (F = G = 0) : (G && F < (G ? 5 : 4) || F >= (G ? 4 : 3) && ')' === H && --F < (G ? 5 : 4)) && (F = G = 0);\n                  }\n                }\n\n                z === r.length && B === p.length || (y.debug && console.error('Trying to pattern match mis-matched strings [\"' + p + '\", \"' + r + '\"]'), g = d), g && (C.length ? (y.debug && console.log('Pattern found \"' + g + '\" -> ', C, D, '[' + r + ',' + p + ']'), r = C, p = D, t = v = '') : g = d);\n              }\n\n              g || (s = x(e, r), r = s[0], v = s[1], s = x(e, p), p = s[0].replace(/^([+-\\/*])=/, function (a, b) {\n                return w = b, '';\n              }), t = s[1], r = parseFloat(r) || 0, p = parseFloat(p) || 0, '%' === t && (/^(fontSize|lineHeight)$/.test(e) ? (p /= 100, t = 'em') : /^scale/.test(e) ? (p /= 100, t = '') : /(Red|Green|Blue)$/i.test(e) && (p = p / 100 * 255, t = '')));\n\n              if (/[\\/*]/.test(w)) {\n                t = v;\n              } else if (v !== t && 0 !== r) {\n                if (0 === p) {\n                  t = v;\n                } else {\n                  h = h || function () {\n                    var d = {\n                      myParent: a.parentNode || c.body,\n                      position: A.getPropertyValue(a, 'position'),\n                      fontSize: A.getPropertyValue(a, 'fontSize')\n                    },\n                        e = d.position === M.lastPosition && d.myParent === M.lastParent,\n                        f = d.fontSize === M.lastFontSize;\n                    M.lastParent = d.myParent, M.lastPosition = d.position, M.lastFontSize = d.fontSize;\n                    var g = {};\n\n                    if (f && e) {\n                      g.emToPx = M.lastEmToPx, g.percentToPxWidth = M.lastPercentToPxWidth, g.percentToPxHeight = M.lastPercentToPxHeight;\n                    } else {\n                      var h = k && k.isSVG ? c.createElementNS('http://www.w3.org/2000/svg', 'rect') : c.createElement('div');\n                      y.init(h), d.myParent.appendChild(h), o.each(['overflow', 'overflowX', 'overflowY'], function (a, b) {\n                        y.CSS.setPropertyValue(h, b, 'hidden');\n                      }), y.CSS.setPropertyValue(h, 'position', d.position), y.CSS.setPropertyValue(h, 'fontSize', d.fontSize), y.CSS.setPropertyValue(h, 'boxSizing', 'content-box'), o.each(['minWidth', 'maxWidth', 'width', 'minHeight', 'maxHeight', 'height'], function (a, b) {\n                        y.CSS.setPropertyValue(h, b, '100%');\n                      }), y.CSS.setPropertyValue(h, 'paddingLeft', '100em'), g.percentToPxWidth = M.lastPercentToPxWidth = (parseFloat(A.getPropertyValue(h, 'width', null, !0)) || 1) / 100, g.percentToPxHeight = M.lastPercentToPxHeight = (parseFloat(A.getPropertyValue(h, 'height', null, !0)) || 1) / 100, g.emToPx = M.lastEmToPx = (parseFloat(A.getPropertyValue(h, 'paddingLeft')) || 1) / 100, d.myParent.removeChild(h);\n                    }\n\n                    return null === M.remToPx && (M.remToPx = parseFloat(A.getPropertyValue(c.body, 'fontSize')) || 16), null === M.vwToPx && (M.vwToPx = parseFloat(b.innerWidth) / 100, M.vhToPx = parseFloat(b.innerHeight) / 100), g.remToPx = M.remToPx, g.vwToPx = M.vwToPx, g.vhToPx = M.vhToPx, y.debug >= 1 && console.log('Unit ratios: ' + JSON.stringify(g), a), g;\n                  }();\n\n                  var S = /margin|padding|left|right|width|text|word|letter/i.test(e) || /X$/.test(e) || 'x' === e ? 'x' : 'y';\n\n                  switch (v) {\n                    case '%':\n                      r *= 'x' === S ? h.percentToPxWidth : h.percentToPxHeight;\n                      break;\n\n                    case 'px':\n                      break;\n\n                    default:\n                      r *= h[v + 'ToPx'];\n                  }\n\n                  switch (t) {\n                    case '%':\n                      r *= 1 / ('x' === S ? h.percentToPxWidth : h.percentToPxHeight);\n                      break;\n\n                    case 'px':\n                      break;\n\n                    default:\n                      r *= 1 / h[t + 'ToPx'];\n                  }\n                }\n              }\n\n              switch (w) {\n                case '+':\n                  p = r + p;\n                  break;\n\n                case '-':\n                  p = r - p;\n                  break;\n\n                case '*':\n                  p *= r;\n                  break;\n\n                case '/':\n                  p = r / p;\n              }\n\n              j[e] = {\n                rootPropertyValue: m,\n                startValue: r,\n                currentValue: r,\n                endValue: p,\n                unitType: t,\n                easing: q\n              }, g && (j[e].pattern = g), y.debug && console.log('tweensContainer (' + e + '): ' + JSON.stringify(j[e]), a);\n            };\n\n            for (var I in s) {\n              if (s.hasOwnProperty(I)) {\n                var J = A.Names.camelCase(I),\n                    K = function (b, c) {\n                  var d, f, g;\n                  return u.isFunction(b) && (b = b.call(a, e, C)), u.isArray(b) ? (d = b[0], !u.isArray(b[1]) && /^[\\d-]/.test(b[1]) || u.isFunction(b[1]) || A.RegEx.isHex.test(b[1]) ? g = b[1] : u.isString(b[1]) && !A.RegEx.isHex.test(b[1]) && y.Easings[b[1]] || u.isArray(b[1]) ? (f = c ? b[1] : l(b[1], i.duration), g = b[2]) : g = b[1] || b[2]) : d = b, c || (f = f || i.easing), u.isFunction(d) && (d = d.call(a, e, C)), u.isFunction(g) && (g = g.call(a, e, C)), [d || 0, f, g];\n                }(s[I]);\n\n                if (t(A.Lists.colors, J)) {\n                  var L = K[0],\n                      O = K[1],\n                      P = K[2];\n\n                  if (A.RegEx.isHex.test(L)) {\n                    for (var Q = ['Red', 'Green', 'Blue'], R = A.Values.hexToRgb(L), S = P ? A.Values.hexToRgb(P) : d, T = 0; T < Q.length; T++) {\n                      var U = [R[T]];\n                      O && U.push(O), S !== d && U.push(S[T]), H(J + Q[T], U);\n                    }\n\n                    continue;\n                  }\n                }\n\n                H(J, K);\n              }\n            }\n\n            j.element = a;\n          }\n\n          j.element && (A.Values.addClass(a, 'velocity-animating'), N.push(j), k = g(a), k && ('' === i.queue && (k.tweensContainer = j, k.opts = i), k.isAnimating = !0), D === C - 1 ? (y.State.calls.push([N, r, i, null, z.resolver, null, 0]), !1 === y.State.isTicking && (y.State.isTicking = !0, m())) : D++);\n        }\n\n        var h,\n            i = o.extend({}, y.defaults, v),\n            j = {};\n\n        switch (g(a) === d && y.init(a), parseFloat(i.delay) && !1 !== i.queue && o.queue(a, i.queue, function (b, c) {\n          if (!0 === c) {\n            return !0;\n          }\n\n          y.velocityQueueEntryFlag = !0;\n          var d = y.State.delayedElements.count++;\n          y.State.delayedElements[d] = a;\n\n          var e = function (a) {\n            return function () {\n              y.State.delayedElements[a] = !1, b();\n            };\n          }(d);\n\n          g(a).delayBegin = new Date().getTime(), g(a).delay = parseFloat(i.delay), g(a).delayTimer = {\n            setTimeout: setTimeout(b, parseFloat(i.delay)),\n            next: e\n          };\n        }), i.duration.toString().toLowerCase()) {\n          case 'fast':\n            i.duration = 200;\n            break;\n\n          case 'normal':\n            i.duration = w;\n            break;\n\n          case 'slow':\n            i.duration = 600;\n            break;\n\n          default:\n            i.duration = parseFloat(i.duration) || 1;\n        }\n\n        if (!1 !== y.mock && (!0 === y.mock ? i.duration = i.delay = 1 : (i.duration *= parseFloat(y.mock) || 1, i.delay *= parseFloat(y.mock) || 1)), i.easing = l(i.easing, i.duration), i.begin && !u.isFunction(i.begin) && (i.begin = null), i.progress && !u.isFunction(i.progress) && (i.progress = null), i.complete && !u.isFunction(i.complete) && (i.complete = null), i.display !== d && null !== i.display && (i.display = i.display.toString().toLowerCase(), 'auto' === i.display && (i.display = y.CSS.Values.getDisplayType(a))), i.visibility !== d && null !== i.visibility && (i.visibility = i.visibility.toString().toLowerCase()), i.mobileHA = i.mobileHA && y.State.isMobile && !y.State.isGingerbread, !1 === i.queue) {\n          if (i.delay) {\n            var k = y.State.delayedElements.count++;\n            y.State.delayedElements[k] = a;\n\n            var n = function (a) {\n              return function () {\n                y.State.delayedElements[a] = !1, f();\n              };\n            }(k);\n\n            g(a).delayBegin = new Date().getTime(), g(a).delay = parseFloat(i.delay), g(a).delayTimer = {\n              setTimeout: setTimeout(f, parseFloat(i.delay)),\n              next: n\n            };\n          } else {\n            f();\n          }\n        } else {\n          o.queue(a, i.queue, function (a, b) {\n            if (!0 === b) {\n              return z.promise && z.resolver(r), !0;\n            }\n\n            y.velocityQueueEntryFlag = !0, f(a);\n          });\n        }\n\n        '' !== i.queue && 'fx' !== i.queue || 'inprogress' === o.queue(a)[0] || o.dequeue(a);\n      }\n\n      var j,\n          k,\n          p,\n          q,\n          r,\n          s,\n          v,\n          x = arguments[0] && (arguments[0].p || o.isPlainObject(arguments[0].properties) && !arguments[0].properties.names || u.isString(arguments[0].properties));\n      u.isWrapped(this) ? (k = !1, q = 0, r = this, p = this) : (k = !0, q = 1, r = x ? arguments[0].elements || arguments[0].e : arguments[0]);\n      var z = {\n        promise: null,\n        resolver: null,\n        rejecter: null\n      };\n\n      if (k && y.Promise && (z.promise = new y.Promise(function (a, b) {\n        z.resolver = a, z.rejecter = b;\n      })), x ? (s = arguments[0].properties || arguments[0].p, v = arguments[0].options || arguments[0].o) : (s = arguments[q], v = arguments[q + 1]), !(r = f(r))) {\n        return void (z.promise && (s && v && !1 === v.promiseRejectEmpty ? z.resolver() : z.rejecter()));\n      }\n\n      var C = r.length,\n          D = 0;\n\n      if (!/^(stop|finish|finishAll|pause|resume)$/i.test(s) && !o.isPlainObject(v)) {\n        var E = q + 1;\n        v = {};\n\n        for (var F = E; F < arguments.length; F++) {\n          u.isArray(arguments[F]) || !/^(fast|normal|slow)$/i.test(arguments[F]) && !/^\\d/.test(arguments[F]) ? u.isString(arguments[F]) || u.isArray(arguments[F]) ? v.easing = arguments[F] : u.isFunction(arguments[F]) && (v.complete = arguments[F]) : v.duration = arguments[F];\n        }\n      }\n\n      var G;\n\n      switch (s) {\n        case 'scroll':\n          G = 'scroll';\n          break;\n\n        case 'reverse':\n          G = 'reverse';\n          break;\n\n        case 'pause':\n          var H = new Date().getTime();\n          return o.each(r, function (a, b) {\n            h(b, H);\n          }), o.each(y.State.calls, function (a, b) {\n            var c = !1;\n            b && o.each(b[1], function (a, e) {\n              var f = v === d ? '' : v;\n              return !0 !== f && b[2].queue !== f && (v !== d || !1 !== b[2].queue) || (o.each(r, function (a, d) {\n                if (d === e) {\n                  return b[5] = {\n                    resume: !1\n                  }, c = !0, !1;\n                }\n              }), !c && void 0);\n            });\n          }), a();\n\n        case 'resume':\n          return o.each(r, function (a, b) {\n            i(b, H);\n          }), o.each(y.State.calls, function (a, b) {\n            var c = !1;\n            b && o.each(b[1], function (a, e) {\n              var f = v === d ? '' : v;\n              return !0 !== f && b[2].queue !== f && (v !== d || !1 !== b[2].queue) || !b[5] || (o.each(r, function (a, d) {\n                if (d === e) {\n                  return b[5].resume = !0, c = !0, !1;\n                }\n              }), !c && void 0);\n            });\n          }), a();\n\n        case 'finish':\n        case 'finishAll':\n        case 'stop':\n          o.each(r, function (a, b) {\n            g(b) && g(b).delayTimer && (clearTimeout(g(b).delayTimer.setTimeout), g(b).delayTimer.next && g(b).delayTimer.next(), delete g(b).delayTimer), 'finishAll' !== s || !0 !== v && !u.isString(v) || (o.each(o.queue(b, u.isString(v) ? v : ''), function (a, b) {\n              u.isFunction(b) && b();\n            }), o.queue(b, u.isString(v) ? v : '', []));\n          });\n          var I = [];\n          return o.each(y.State.calls, function (a, b) {\n            b && o.each(b[1], function (c, e) {\n              var f = v === d ? '' : v;\n\n              if (!0 !== f && b[2].queue !== f && (v !== d || !1 !== b[2].queue)) {\n                return !0;\n              }\n\n              o.each(r, function (c, d) {\n                if (d === e) {\n                  if ((!0 === v || u.isString(v)) && (o.each(o.queue(d, u.isString(v) ? v : ''), function (a, b) {\n                    u.isFunction(b) && b(null, !0);\n                  }), o.queue(d, u.isString(v) ? v : '', [])), 'stop' === s) {\n                    var h = g(d);\n                    h && h.tweensContainer && !1 !== f && o.each(h.tweensContainer, function (a, b) {\n                      b.endValue = b.currentValue;\n                    }), I.push(a);\n                  } else {\n                    'finish' !== s && 'finishAll' !== s || (b[2].duration = 1);\n                  }\n                }\n              });\n            });\n          }), 'stop' === s && (o.each(I, function (a, b) {\n            n(b, !0);\n          }), z.promise && z.resolver(r)), a();\n\n        default:\n          if (!o.isPlainObject(s) || u.isEmptyObject(s)) {\n            if (u.isString(s) && y.Redirects[s]) {\n              j = o.extend({}, v);\n              var J = j.duration,\n                  K = j.delay || 0;\n              return !0 === j.backwards && (r = o.extend(!0, [], r).reverse()), o.each(r, function (a, b) {\n                parseFloat(j.stagger) ? j.delay = K + parseFloat(j.stagger) * a : u.isFunction(j.stagger) && (j.delay = K + j.stagger.call(b, a, C)), j.drag && (j.duration = parseFloat(J) || (/^(callout|transition)/.test(s) ? 1e3 : w), j.duration = Math.max(j.duration * (j.backwards ? 1 - a / C : (a + 1) / C), .75 * j.duration, 200)), y.Redirects[s].call(b, b, j || {}, a, C, r, z.promise ? z : d);\n              }), a();\n            }\n\n            var L = 'Velocity: First argument (' + s + ') was not a property map, a known action, or a registered redirect. Aborting.';\n            return z.promise ? z.rejecter(new Error(L)) : b.console && console.log(L), a();\n          }\n\n          G = 'start';\n      }\n\n      var M = {\n        lastParent: null,\n        lastPosition: null,\n        lastFontSize: null,\n        lastPercentToPxWidth: null,\n        lastPercentToPxHeight: null,\n        lastEmToPx: null,\n        remToPx: null,\n        vwToPx: null,\n        vhToPx: null\n      },\n          N = [];\n      o.each(r, function (a, b) {\n        u.isNode(b) && e(b, a);\n      }), j = o.extend({}, y.defaults, v), j.loop = parseInt(j.loop, 10);\n      var O = 2 * j.loop - 1;\n\n      if (j.loop) {\n        for (var P = 0; P < O; P++) {\n          var Q = {\n            delay: j.delay,\n            progress: j.progress\n          };\n          P === O - 1 && (Q.display = j.display, Q.visibility = j.visibility, Q.complete = j.complete), B(r, 'reverse', Q);\n        }\n      }\n\n      return a();\n    };\n\n    y = o.extend(B, y), y.animate = B;\n    var C = b.requestAnimationFrame || q;\n\n    if (!y.State.isMobile && c.hidden !== d) {\n      var D = function () {\n        c.hidden ? (C = function (a) {\n          return setTimeout(function () {\n            a(!0);\n          }, 16);\n        }, m()) : C = b.requestAnimationFrame || q;\n      };\n\n      D(), c.addEventListener('visibilitychange', D);\n    }\n\n    return a.Velocity = y, a !== b && (a.fn.velocity = B, a.fn.velocity.defaults = y.defaults), o.each(['Down', 'Up'], function (a, b) {\n      y.Redirects['slide' + b] = function (a, c, e, f, g, h) {\n        var i = o.extend({}, c),\n            j = i.begin,\n            k = i.complete,\n            l = {},\n            m = {\n          height: '',\n          marginTop: '',\n          marginBottom: '',\n          paddingTop: '',\n          paddingBottom: ''\n        };\n        i.display === d && (i.display = 'Down' === b ? 'inline' === y.CSS.Values.getDisplayType(a) ? 'inline-block' : 'block' : 'none'), i.begin = function () {\n          0 === e && j && j.call(g, g);\n\n          for (var c in m) {\n            if (m.hasOwnProperty(c)) {\n              l[c] = a.style[c];\n              var d = A.getPropertyValue(a, c);\n              m[c] = 'Down' === b ? [d, 0] : [0, d];\n            }\n          }\n\n          l.overflow = a.style.overflow, a.style.overflow = 'hidden';\n        }, i.complete = function () {\n          for (var b in l) {\n            l.hasOwnProperty(b) && (a.style[b] = l[b]);\n          }\n\n          e === f - 1 && (k && k.call(g, g), h && h.resolver(g));\n        }, y(a, m, i);\n      };\n    }), o.each(['In', 'Out'], function (a, b) {\n      y.Redirects['fade' + b] = function (a, c, e, f, g, h) {\n        var i = o.extend({}, c),\n            j = i.complete,\n            k = {\n          opacity: 'In' === b ? 1 : 0\n        };\n        0 !== e && (i.begin = null), i.complete = e !== f - 1 ? null : function () {\n          j && j.call(g, g), h && h.resolver(g);\n        }, i.display === d && (i.display = 'In' === b ? 'auto' : 'none'), y(this, k, i);\n      };\n    }), y;\n  }(window.jQuery || window.Zepto || window, window, window ? window.document : undefined);\n});\n/* ! Hammer.JS - v2.0.8 - 2016-04-23\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n\n!function (a, b, c, d) {\n  'use strict';\n\n  function e(a, b, c) {\n    return setTimeout(j(a, c), b);\n  }\n\n  function f(a, b, c) {\n    return Array.isArray(a) ? (g(a, c[b], c), !0) : !1;\n  }\n\n  function g(a, b, c) {\n    var e;\n\n    if (a) {\n      if (a.forEach) {\n        a.forEach(b, c);\n      } else if (a.length !== d) {\n        for (e = 0; e < a.length;) {\n          b.call(c, a[e], e, a), e++;\n        }\n      } else {\n        for (e in a) {\n          a.hasOwnProperty(e) && b.call(c, a[e], e, a);\n        }\n      }\n    }\n  }\n\n  function h(b, c, d) {\n    var e = 'DEPRECATED METHOD: ' + c + '\\n' + d + ' AT \\n';\n    return function () {\n      var c = new Error('get-stack-trace'),\n          d = c && c.stack ? c.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace',\n          f = a.console && (a.console.warn || a.console.log);\n      return f && f.call(a.console, e, d), b.apply(this, arguments);\n    };\n  }\n\n  function i(a, b, c) {\n    var d,\n        e = b.prototype;\n    d = a.prototype = Object.create(e), d.constructor = a, d._super = e, c && la(d, c);\n  }\n\n  function j(a, b) {\n    return function () {\n      return a.apply(b, arguments);\n    };\n  }\n\n  function k(a, b) {\n    return typeof a == oa ? a.apply(b ? b[0] || d : d, b) : a;\n  }\n\n  function l(a, b) {\n    return a === d ? b : a;\n  }\n\n  function m(a, b, c) {\n    g(q(b), function (b) {\n      a.addEventListener(b, c, !1);\n    });\n  }\n\n  function n(a, b, c) {\n    g(q(b), function (b) {\n      a.removeEventListener(b, c, !1);\n    });\n  }\n\n  function o(a, b) {\n    for (; a;) {\n      if (a == b) {\n        return !0;\n      }\n\n      a = a.parentNode;\n    }\n\n    return !1;\n  }\n\n  function p(a, b) {\n    return a.indexOf(b) > -1;\n  }\n\n  function q(a) {\n    return a.trim().split(/\\s+/g);\n  }\n\n  function r(a, b, c) {\n    if (a.indexOf && !c) {\n      return a.indexOf(b);\n    }\n\n    for (var d = 0; d < a.length;) {\n      if (c && a[d][c] == b || !c && a[d] === b) {\n        return d;\n      }\n\n      d++;\n    }\n\n    return -1;\n  }\n\n  function s(a) {\n    return Array.prototype.slice.call(a, 0);\n  }\n\n  function t(a, b, c) {\n    for (var d = [], e = [], f = 0; f < a.length;) {\n      var g = b ? a[f][b] : a[f];\n      r(e, g) < 0 && d.push(a[f]), e[f] = g, f++;\n    }\n\n    return c && (d = b ? d.sort(function (a, c) {\n      return a[b] > c[b];\n    }) : d.sort()), d;\n  }\n\n  function u(a, b) {\n    for (var c, e, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ma.length;) {\n      if (c = ma[g], e = c ? c + f : b, e in a) {\n        return e;\n      }\n\n      g++;\n    }\n\n    return d;\n  }\n\n  function v() {\n    return ua++;\n  }\n\n  function w(b) {\n    var c = b.ownerDocument || b;\n    return c.defaultView || c.parentWindow || a;\n  }\n\n  function x(a, b) {\n    var c = this;\n    this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, this.domHandler = function (b) {\n      k(a.options.enable, [a]) && c.handler(b);\n    }, this.init();\n  }\n\n  function y(a) {\n    var b,\n        c = a.options.inputClass;\n    return new (b = c ? c : xa ? M : ya ? P : wa ? R : L)(a, z);\n  }\n\n  function z(a, b, c) {\n    var d = c.pointers.length,\n        e = c.changedPointers.length,\n        f = b & Ea && d - e === 0,\n        g = b & (Ga | Ha) && d - e === 0;\n    c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, A(a, c), a.emit('hammer.input', c), a.recognize(c), a.session.prevInput = c;\n  }\n\n  function A(a, b) {\n    var c = a.session,\n        d = b.pointers,\n        e = d.length;\n    c.firstInput || (c.firstInput = D(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = D(b) : 1 === e && (c.firstMultiple = !1);\n    var f = c.firstInput,\n        g = c.firstMultiple,\n        h = g ? g.center : f.center,\n        i = b.center = E(d);\n    b.timeStamp = ra(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = I(h, i), b.distance = H(h, i), B(c, b), b.offsetDirection = G(b.deltaX, b.deltaY);\n    var j = F(b.deltaTime, b.deltaX, b.deltaY);\n    b.overallVelocityX = j.x, b.overallVelocityY = j.y, b.overallVelocity = qa(j.x) > qa(j.y) ? j.x : j.y, b.scale = g ? K(g.pointers, d) : 1, b.rotation = g ? J(g.pointers, d) : 0, b.maxPointers = c.prevInput ? b.pointers.length > c.prevInput.maxPointers ? b.pointers.length : c.prevInput.maxPointers : b.pointers.length, C(c, b);\n    var k = a.element;\n    o(b.srcEvent.target, k) && (k = b.srcEvent.target), b.target = k;\n  }\n\n  function B(a, b) {\n    var c = b.center,\n        d = a.offsetDelta || {},\n        e = a.prevDelta || {},\n        f = a.prevInput || {};\n    b.eventType !== Ea && f.eventType !== Ga || (e = a.prevDelta = {\n      x: f.deltaX || 0,\n      y: f.deltaY || 0\n    }, d = a.offsetDelta = {\n      x: c.x,\n      y: c.y\n    }), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y);\n  }\n\n  function C(a, b) {\n    var c,\n        e,\n        f,\n        g,\n        h = a.lastInterval || b,\n        i = b.timeStamp - h.timeStamp;\n\n    if (b.eventType != Ha && (i > Da || h.velocity === d)) {\n      var j = b.deltaX - h.deltaX,\n          k = b.deltaY - h.deltaY,\n          l = F(i, j, k);\n      e = l.x, f = l.y, c = qa(l.x) > qa(l.y) ? l.x : l.y, g = G(j, k), a.lastInterval = b;\n    } else {\n      c = h.velocity, e = h.velocityX, f = h.velocityY, g = h.direction;\n    }\n\n    b.velocity = c, b.velocityX = e, b.velocityY = f, b.direction = g;\n  }\n\n  function D(a) {\n    for (var b = [], c = 0; c < a.pointers.length;) {\n      b[c] = {\n        clientX: pa(a.pointers[c].clientX),\n        clientY: pa(a.pointers[c].clientY)\n      }, c++;\n    }\n\n    return {\n      timeStamp: ra(),\n      pointers: b,\n      center: E(b),\n      deltaX: a.deltaX,\n      deltaY: a.deltaY\n    };\n  }\n\n  function E(a) {\n    var b = a.length;\n\n    if (1 === b) {\n      return {\n        x: pa(a[0].clientX),\n        y: pa(a[0].clientY)\n      };\n    }\n\n    for (var c = 0, d = 0, e = 0; b > e;) {\n      c += a[e].clientX, d += a[e].clientY, e++;\n    }\n\n    return {\n      x: pa(c / b),\n      y: pa(d / b)\n    };\n  }\n\n  function F(a, b, c) {\n    return {\n      x: b / a || 0,\n      y: c / a || 0\n    };\n  }\n\n  function G(a, b) {\n    return a === b ? Ia : qa(a) >= qa(b) ? 0 > a ? Ja : Ka : 0 > b ? La : Ma;\n  }\n\n  function H(a, b, c) {\n    c || (c = Qa);\n    var d = b[c[0]] - a[c[0]],\n        e = b[c[1]] - a[c[1]];\n    return Math.sqrt(d * d + e * e);\n  }\n\n  function I(a, b, c) {\n    c || (c = Qa);\n    var d = b[c[0]] - a[c[0]],\n        e = b[c[1]] - a[c[1]];\n    return 180 * Math.atan2(e, d) / Math.PI;\n  }\n\n  function J(a, b) {\n    return I(b[1], b[0], Ra) + I(a[1], a[0], Ra);\n  }\n\n  function K(a, b) {\n    return H(b[0], b[1], Ra) / H(a[0], a[1], Ra);\n  }\n\n  function L() {\n    this.evEl = Ta, this.evWin = Ua, this.pressed = !1, x.apply(this, arguments);\n  }\n\n  function M() {\n    this.evEl = Xa, this.evWin = Ya, x.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];\n  }\n\n  function N() {\n    this.evTarget = $a, this.evWin = _a, this.started = !1, x.apply(this, arguments);\n  }\n\n  function O(a, b) {\n    var c = s(a.touches),\n        d = s(a.changedTouches);\n    return b & (Ga | Ha) && (c = t(c.concat(d), 'identifier', !0)), [c, d];\n  }\n\n  function P() {\n    this.evTarget = bb, this.targetIds = {}, x.apply(this, arguments);\n  }\n\n  function Q(a, b) {\n    var c = s(a.touches),\n        d = this.targetIds;\n\n    if (b & (Ea | Fa) && 1 === c.length) {\n      return d[c[0].identifier] = !0, [c, c];\n    }\n\n    var e,\n        f,\n        g = s(a.changedTouches),\n        h = [],\n        i = this.target;\n\n    if (f = c.filter(function (a) {\n      return o(a.target, i);\n    }), b === Ea) {\n      for (e = 0; e < f.length;) {\n        d[f[e].identifier] = !0, e++;\n      }\n    }\n\n    for (e = 0; e < g.length;) {\n      d[g[e].identifier] && h.push(g[e]), b & (Ga | Ha) && delete d[g[e].identifier], e++;\n    }\n\n    return h.length ? [t(f.concat(h), 'identifier', !0), h] : void 0;\n  }\n\n  function R() {\n    x.apply(this, arguments);\n    var a = j(this.handler, this);\n    this.touch = new P(this.manager, a), this.mouse = new L(this.manager, a), this.primaryTouch = null, this.lastTouches = [];\n  }\n\n  function S(a, b) {\n    a & Ea ? (this.primaryTouch = b.changedPointers[0].identifier, T.call(this, b)) : a & (Ga | Ha) && T.call(this, b);\n  }\n\n  function T(a) {\n    var b = a.changedPointers[0];\n\n    if (b.identifier === this.primaryTouch) {\n      var c = {\n        x: b.clientX,\n        y: b.clientY\n      };\n      this.lastTouches.push(c);\n\n      var d = this.lastTouches,\n          e = function () {\n        var a = d.indexOf(c);\n        a > -1 && d.splice(a, 1);\n      };\n\n      setTimeout(e, cb);\n    }\n  }\n\n  function U(a) {\n    for (var b = a.srcEvent.clientX, c = a.srcEvent.clientY, d = 0; d < this.lastTouches.length; d++) {\n      var e = this.lastTouches[d],\n          f = Math.abs(b - e.x),\n          g = Math.abs(c - e.y);\n\n      if (db >= f && db >= g) {\n        return !0;\n      }\n    }\n\n    return !1;\n  }\n\n  function V(a, b) {\n    this.manager = a, this.set(b);\n  }\n\n  function W(a) {\n    if (p(a, jb)) {\n      return jb;\n    }\n\n    var b = p(a, kb),\n        c = p(a, lb);\n    return b && c ? jb : b || c ? b ? kb : lb : p(a, ib) ? ib : hb;\n  }\n\n  function X() {\n    if (!fb) {\n      return !1;\n    }\n\n    var b = {},\n        c = a.CSS && a.CSS.supports;\n    return ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (d) {\n      b[d] = c ? a.CSS.supports('touch-action', d) : !0;\n    }), b;\n  }\n\n  function Y(a) {\n    this.options = la({}, this.defaults, a || {}), this.id = v(), this.manager = null, this.options.enable = l(this.options.enable, !0), this.state = nb, this.simultaneous = {}, this.requireFail = [];\n  }\n\n  function Z(a) {\n    return a & sb ? 'cancel' : a & qb ? 'end' : a & pb ? 'move' : a & ob ? 'start' : '';\n  }\n\n  function $(a) {\n    return a == Ma ? 'down' : a == La ? 'up' : a == Ja ? 'left' : a == Ka ? 'right' : '';\n  }\n\n  function _(a, b) {\n    var c = b.manager;\n    return c ? c.get(a) : a;\n  }\n\n  function aa() {\n    Y.apply(this, arguments);\n  }\n\n  function ba() {\n    aa.apply(this, arguments), this.pX = null, this.pY = null;\n  }\n\n  function ca() {\n    aa.apply(this, arguments);\n  }\n\n  function da() {\n    Y.apply(this, arguments), this._timer = null, this._input = null;\n  }\n\n  function ea() {\n    aa.apply(this, arguments);\n  }\n\n  function fa() {\n    aa.apply(this, arguments);\n  }\n\n  function ga() {\n    Y.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;\n  }\n\n  function ha(a, b) {\n    return b = b || {}, b.recognizers = l(b.recognizers, ha.defaults.preset), new ia(a, b);\n  }\n\n  function ia(a, b) {\n    this.options = la({}, ha.defaults, b || {}), this.options.inputTarget = this.options.inputTarget || a, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = a, this.input = y(this), this.touchAction = new V(this, this.options.touchAction), ja(this, !0), g(this.options.recognizers, function (a) {\n      var b = this.add(new a[0](a[1]));\n      a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3]);\n    }, this);\n  }\n\n  function ja(a, b) {\n    var c = a.element;\n\n    if (c.style) {\n      var d;\n      g(a.options.cssProps, function (e, f) {\n        d = u(c.style, f), b ? (a.oldCssProps[d] = c.style[d], c.style[d] = e) : c.style[d] = a.oldCssProps[d] || '';\n      }), b || (a.oldCssProps = {});\n    }\n  }\n\n  function ka(a, c) {\n    var d = b.createEvent('Event');\n    d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d);\n  }\n\n  var la,\n      ma = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'],\n      na = b.createElement('div'),\n      oa = 'function',\n      pa = Math.round,\n      qa = Math.abs,\n      ra = Date.now;\n  la = 'function' != typeof Object.assign ? function (a) {\n    if (a === d || null === a) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    for (var b = Object(a), c = 1; c < arguments.length; c++) {\n      var e = arguments[c];\n\n      if (e !== d && null !== e) {\n        for (var f in e) {\n          e.hasOwnProperty(f) && (b[f] = e[f]);\n        }\n      }\n    }\n\n    return b;\n  } : Object.assign;\n  var sa = h(function (a, b, c) {\n    for (var e = Object.keys(b), f = 0; f < e.length;) {\n      (!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++;\n    }\n\n    return a;\n  }, 'extend', 'Use `assign`.'),\n      ta = h(function (a, b) {\n    return sa(a, b, !0);\n  }, 'merge', 'Use `assign`.'),\n      ua = 1,\n      va = /mobile|tablet|ip(ad|hone|od)|android/i,\n      wa = ('ontouchstart' in a),\n      xa = u(a, 'PointerEvent') !== d,\n      ya = wa && va.test(navigator.userAgent),\n      za = 'touch',\n      Aa = 'pen',\n      Ba = 'mouse',\n      Ca = 'kinect',\n      Da = 25,\n      Ea = 1,\n      Fa = 2,\n      Ga = 4,\n      Ha = 8,\n      Ia = 1,\n      Ja = 2,\n      Ka = 4,\n      La = 8,\n      Ma = 16,\n      Na = Ja | Ka,\n      Oa = La | Ma,\n      Pa = Na | Oa,\n      Qa = ['x', 'y'],\n      Ra = ['clientX', 'clientY'];\n  x.prototype = {\n    handler: function () {},\n    init: function () {\n      this.evEl && m(this.element, this.evEl, this.domHandler), this.evTarget && m(this.target, this.evTarget, this.domHandler), this.evWin && m(w(this.element), this.evWin, this.domHandler);\n    },\n    destroy: function () {\n      this.evEl && n(this.element, this.evEl, this.domHandler), this.evTarget && n(this.target, this.evTarget, this.domHandler), this.evWin && n(w(this.element), this.evWin, this.domHandler);\n    }\n  };\n  var Sa = {\n    mousedown: Ea,\n    mousemove: Fa,\n    mouseup: Ga\n  },\n      Ta = 'mousedown',\n      Ua = 'mousemove mouseup';\n  i(L, x, {\n    handler: function (a) {\n      var b = Sa[a.type];\n      b & Ea && 0 === a.button && (this.pressed = !0), b & Fa && 1 !== a.which && (b = Ga), this.pressed && (b & Ga && (this.pressed = !1), this.callback(this.manager, b, {\n        pointers: [a],\n        changedPointers: [a],\n        pointerType: Ba,\n        srcEvent: a\n      }));\n    }\n  });\n  var Va = {\n    pointerdown: Ea,\n    pointermove: Fa,\n    pointerup: Ga,\n    pointercancel: Ha,\n    pointerout: Ha\n  },\n      Wa = {\n    2: za,\n    3: Aa,\n    4: Ba,\n    5: Ca\n  },\n      Xa = 'pointerdown',\n      Ya = 'pointermove pointerup pointercancel';\n  a.MSPointerEvent && !a.PointerEvent && (Xa = 'MSPointerDown', Ya = 'MSPointerMove MSPointerUp MSPointerCancel'), i(M, x, {\n    handler: function (a) {\n      var b = this.store,\n          c = !1,\n          d = a.type.toLowerCase().replace('ms', ''),\n          e = Va[d],\n          f = Wa[a.pointerType] || a.pointerType,\n          g = f == za,\n          h = r(b, a.pointerId, 'pointerId');\n      e & Ea && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Ga | Ha) && (c = !0), 0 > h || (b[h] = a, this.callback(this.manager, e, {\n        pointers: b,\n        changedPointers: [a],\n        pointerType: f,\n        srcEvent: a\n      }), c && b.splice(h, 1));\n    }\n  });\n  var Za = {\n    touchstart: Ea,\n    touchmove: Fa,\n    touchend: Ga,\n    touchcancel: Ha\n  },\n      $a = 'touchstart',\n      _a = 'touchstart touchmove touchend touchcancel';\n  i(N, x, {\n    handler: function (a) {\n      var b = Za[a.type];\n\n      if (b === Ea && (this.started = !0), this.started) {\n        var c = O.call(this, a, b);\n        b & (Ga | Ha) && c[0].length - c[1].length === 0 && (this.started = !1), this.callback(this.manager, b, {\n          pointers: c[0],\n          changedPointers: c[1],\n          pointerType: za,\n          srcEvent: a\n        });\n      }\n    }\n  });\n  var ab = {\n    touchstart: Ea,\n    touchmove: Fa,\n    touchend: Ga,\n    touchcancel: Ha\n  },\n      bb = 'touchstart touchmove touchend touchcancel';\n  i(P, x, {\n    handler: function (a) {\n      var b = ab[a.type],\n          c = Q.call(this, a, b);\n      c && this.callback(this.manager, b, {\n        pointers: c[0],\n        changedPointers: c[1],\n        pointerType: za,\n        srcEvent: a\n      });\n    }\n  });\n  var cb = 2500,\n      db = 25;\n  i(R, x, {\n    handler: function (a, b, c) {\n      var d = c.pointerType == za,\n          e = c.pointerType == Ba;\n\n      if (!(e && c.sourceCapabilities && c.sourceCapabilities.firesTouchEvents)) {\n        if (d) {\n          S.call(this, b, c);\n        } else if (e && U.call(this, c)) {\n          return;\n        }\n\n        this.callback(a, b, c);\n      }\n    },\n    destroy: function () {\n      this.touch.destroy(), this.mouse.destroy();\n    }\n  });\n  var eb = u(na.style, 'touchAction'),\n      fb = eb !== d,\n      gb = 'compute',\n      hb = 'auto',\n      ib = 'manipulation',\n      jb = 'none',\n      kb = 'pan-x',\n      lb = 'pan-y',\n      mb = X();\n  V.prototype = {\n    set: function (a) {\n      a == gb && (a = this.compute()), fb && this.manager.element.style && mb[a] && (this.manager.element.style[eb] = a), this.actions = a.toLowerCase().trim();\n    },\n    update: function () {\n      this.set(this.manager.options.touchAction);\n    },\n    compute: function () {\n      var a = [];\n      return g(this.manager.recognizers, function (b) {\n        k(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()));\n      }), W(a.join(' '));\n    },\n    preventDefaults: function (a) {\n      var b = a.srcEvent,\n          c = a.offsetDirection;\n\n      if (this.manager.session.prevented) {\n        return void b.preventDefault();\n      }\n\n      var d = this.actions,\n          e = p(d, jb) && !mb[jb],\n          f = p(d, lb) && !mb[lb],\n          g = p(d, kb) && !mb[kb];\n\n      if (e) {\n        var h = 1 === a.pointers.length,\n            i = a.distance < 2,\n            j = a.deltaTime < 250;\n\n        if (h && i && j) {\n          return;\n        }\n      }\n\n      return g && f ? void 0 : e || f && c & Na || g && c & Oa ? this.preventSrc(b) : void 0;\n    },\n    preventSrc: function (a) {\n      this.manager.session.prevented = !0, a.preventDefault();\n    }\n  };\n  var nb = 1,\n      ob = 2,\n      pb = 4,\n      qb = 8,\n      rb = qb,\n      sb = 16,\n      tb = 32;\n  Y.prototype = {\n    defaults: {},\n    set: function (a) {\n      return la(this.options, a), this.manager && this.manager.touchAction.update(), this;\n    },\n    recognizeWith: function (a) {\n      if (f(a, 'recognizeWith', this)) {\n        return this;\n      }\n\n      var b = this.simultaneous;\n      return a = _(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this;\n    },\n    dropRecognizeWith: function (a) {\n      return f(a, 'dropRecognizeWith', this) ? this : (a = _(a, this), delete this.simultaneous[a.id], this);\n    },\n    requireFailure: function (a) {\n      if (f(a, 'requireFailure', this)) {\n        return this;\n      }\n\n      var b = this.requireFail;\n      return a = _(a, this), -1 === r(b, a) && (b.push(a), a.requireFailure(this)), this;\n    },\n    dropRequireFailure: function (a) {\n      if (f(a, 'dropRequireFailure', this)) {\n        return this;\n      }\n\n      a = _(a, this);\n      var b = r(this.requireFail, a);\n      return b > -1 && this.requireFail.splice(b, 1), this;\n    },\n    hasRequireFailures: function () {\n      return this.requireFail.length > 0;\n    },\n    canRecognizeWith: function (a) {\n      return !!this.simultaneous[a.id];\n    },\n    emit: function (a) {\n      function b(b) {\n        c.manager.emit(b, a);\n      }\n\n      var c = this,\n          d = this.state;\n      qb > d && b(c.options.event + Z(d)), b(c.options.event), a.additionalEvent && b(a.additionalEvent), d >= qb && b(c.options.event + Z(d));\n    },\n    tryEmit: function (a) {\n      return this.canEmit() ? this.emit(a) : void (this.state = tb);\n    },\n    canEmit: function () {\n      for (var a = 0; a < this.requireFail.length;) {\n        if (!(this.requireFail[a].state & (tb | nb))) {\n          return !1;\n        }\n\n        a++;\n      }\n\n      return !0;\n    },\n    recognize: function (a) {\n      var b = la({}, a);\n      return k(this.options.enable, [this, b]) ? (this.state & (rb | sb | tb) && (this.state = nb), this.state = this.process(b), void (this.state & (ob | pb | qb | sb) && this.tryEmit(b))) : (this.reset(), void (this.state = tb));\n    },\n    process: function (a) {},\n    getTouchAction: function () {},\n    reset: function () {}\n  }, i(aa, Y, {\n    defaults: {\n      pointers: 1\n    },\n    attrTest: function (a) {\n      var b = this.options.pointers;\n      return 0 === b || a.pointers.length === b;\n    },\n    process: function (a) {\n      var b = this.state,\n          c = a.eventType,\n          d = b & (ob | pb),\n          e = this.attrTest(a);\n      return d && (c & Ha || !e) ? b | sb : d || e ? c & Ga ? b | qb : b & ob ? b | pb : ob : tb;\n    }\n  }), i(ba, aa, {\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: Pa\n    },\n    getTouchAction: function () {\n      var a = this.options.direction,\n          b = [];\n      return a & Na && b.push(lb), a & Oa && b.push(kb), b;\n    },\n    directionTest: function (a) {\n      var b = this.options,\n          c = !0,\n          d = a.distance,\n          e = a.direction,\n          f = a.deltaX,\n          g = a.deltaY;\n      return e & b.direction || (b.direction & Na ? (e = 0 === f ? Ia : 0 > f ? Ja : Ka, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? Ia : 0 > g ? La : Ma, c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction;\n    },\n    attrTest: function (a) {\n      return aa.prototype.attrTest.call(this, a) && (this.state & ob || !(this.state & ob) && this.directionTest(a));\n    },\n    emit: function (a) {\n      this.pX = a.deltaX, this.pY = a.deltaY;\n      var b = $(a.direction);\n      b && (a.additionalEvent = this.options.event + b), this._super.emit.call(this, a);\n    }\n  }), i(ca, aa, {\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [jb];\n    },\n    attrTest: function (a) {\n      return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & ob);\n    },\n    emit: function (a) {\n      if (1 !== a.scale) {\n        var b = a.scale < 1 ? 'in' : 'out';\n        a.additionalEvent = this.options.event + b;\n      }\n\n      this._super.emit.call(this, a);\n    }\n  }), i(da, Y, {\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      threshold: 9\n    },\n    getTouchAction: function () {\n      return [hb];\n    },\n    process: function (a) {\n      var b = this.options,\n          c = a.pointers.length === b.pointers,\n          d = a.distance < b.threshold,\n          f = a.deltaTime > b.time;\n\n      if (this._input = a, !d || !c || a.eventType & (Ga | Ha) && !f) {\n        this.reset();\n      } else if (a.eventType & Ea) {\n        this.reset(), this._timer = e(function () {\n          this.state = rb, this.tryEmit();\n        }, b.time, this);\n      } else if (a.eventType & Ga) {\n        return rb;\n      }\n\n      return tb;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function (a) {\n      this.state === rb && (a && a.eventType & Ga ? this.manager.emit(this.options.event + 'up', a) : (this._input.timeStamp = ra(), this.manager.emit(this.options.event, this._input)));\n    }\n  }), i(ea, aa, {\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [jb];\n    },\n    attrTest: function (a) {\n      return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & ob);\n    }\n  }), i(fa, aa, {\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: .3,\n      direction: Na | Oa,\n      pointers: 1\n    },\n    getTouchAction: function () {\n      return ba.prototype.getTouchAction.call(this);\n    },\n    attrTest: function (a) {\n      var b,\n          c = this.options.direction;\n      return c & (Na | Oa) ? b = a.overallVelocity : c & Na ? b = a.overallVelocityX : c & Oa && (b = a.overallVelocityY), this._super.attrTest.call(this, a) && c & a.offsetDirection && a.distance > this.options.threshold && a.maxPointers == this.options.pointers && qa(b) > this.options.velocity && a.eventType & Ga;\n    },\n    emit: function (a) {\n      var b = $(a.offsetDirection);\n      b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a);\n    }\n  }), i(ga, Y, {\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      time: 250,\n      threshold: 9,\n      posThreshold: 10\n    },\n    getTouchAction: function () {\n      return [ib];\n    },\n    process: function (a) {\n      var b = this.options,\n          c = a.pointers.length === b.pointers,\n          d = a.distance < b.threshold,\n          f = a.deltaTime < b.time;\n\n      if (this.reset(), a.eventType & Ea && 0 === this.count) {\n        return this.failTimeout();\n      }\n\n      if (d && f && c) {\n        if (a.eventType != Ga) {\n          return this.failTimeout();\n        }\n\n        var g = this.pTime ? a.timeStamp - this.pTime < b.interval : !0,\n            h = !this.pCenter || H(this.pCenter, a.center) < b.posThreshold;\n        this.pTime = a.timeStamp, this.pCenter = a.center, h && g ? this.count += 1 : this.count = 1, this._input = a;\n        var i = this.count % b.taps;\n\n        if (0 === i) {\n          return this.hasRequireFailures() ? (this._timer = e(function () {\n            this.state = rb, this.tryEmit();\n          }, b.interval, this), ob) : rb;\n        }\n      }\n\n      return tb;\n    },\n    failTimeout: function () {\n      return this._timer = e(function () {\n        this.state = tb;\n      }, this.options.interval, this), tb;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function () {\n      this.state == rb && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));\n    }\n  }), ha.VERSION = '2.0.8', ha.defaults = {\n    domEvents: !1,\n    touchAction: gb,\n    enable: !0,\n    inputTarget: null,\n    inputClass: null,\n    preset: [[ea, {\n      enable: !1\n    }], [ca, {\n      enable: !1\n    }, ['rotate']], [fa, {\n      direction: Na\n    }], [ba, {\n      direction: Na\n    }, ['swipe']], [ga], [ga, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [da]],\n    cssProps: {\n      userSelect: 'none',\n      touchSelect: 'none',\n      touchCallout: 'none',\n      contentZooming: 'none',\n      userDrag: 'none',\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var ub = 1,\n      vb = 2;\n  ia.prototype = {\n    set: function (a) {\n      return la(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()), this;\n    },\n    stop: function (a) {\n      this.session.stopped = a ? vb : ub;\n    },\n    recognize: function (a) {\n      var b = this.session;\n\n      if (!b.stopped) {\n        this.touchAction.preventDefaults(a);\n        var c,\n            d = this.recognizers,\n            e = b.curRecognizer;\n        (!e || e && e.state & rb) && (e = b.curRecognizer = null);\n\n        for (var f = 0; f < d.length;) {\n          c = d[f], b.stopped === vb || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (ob | pb | qb) && (e = b.curRecognizer = c), f++;\n        }\n      }\n    },\n    get: function (a) {\n      if (a instanceof Y) {\n        return a;\n      }\n\n      for (var b = this.recognizers, c = 0; c < b.length; c++) {\n        if (b[c].options.event == a) {\n          return b[c];\n        }\n      }\n\n      return null;\n    },\n    add: function (a) {\n      if (f(a, 'add', this)) {\n        return this;\n      }\n\n      var b = this.get(a.options.event);\n      return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), a;\n    },\n    remove: function (a) {\n      if (f(a, 'remove', this)) {\n        return this;\n      }\n\n      if (a = this.get(a)) {\n        var b = this.recognizers,\n            c = r(b, a);\n        -1 !== c && (b.splice(c, 1), this.touchAction.update());\n      }\n\n      return this;\n    },\n    on: function (a, b) {\n      if (a !== d && b !== d) {\n        var c = this.handlers;\n        return g(q(a), function (a) {\n          c[a] = c[a] || [], c[a].push(b);\n        }), this;\n      }\n    },\n    off: function (a, b) {\n      if (a !== d) {\n        var c = this.handlers;\n        return g(q(a), function (a) {\n          b ? c[a] && c[a].splice(r(c[a], b), 1) : delete c[a];\n        }), this;\n      }\n    },\n    emit: function (a, b) {\n      this.options.domEvents && ka(a, b);\n      var c = this.handlers[a] && this.handlers[a].slice();\n\n      if (c && c.length) {\n        b.type = a, b.preventDefault = function () {\n          b.srcEvent.preventDefault();\n        };\n\n        for (var d = 0; d < c.length;) {\n          c[d](b), d++;\n        }\n      }\n    },\n    destroy: function () {\n      this.element && ja(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;\n    }\n  }, la(ha, {\n    INPUT_START: Ea,\n    INPUT_MOVE: Fa,\n    INPUT_END: Ga,\n    INPUT_CANCEL: Ha,\n    STATE_POSSIBLE: nb,\n    STATE_BEGAN: ob,\n    STATE_CHANGED: pb,\n    STATE_ENDED: qb,\n    STATE_RECOGNIZED: rb,\n    STATE_CANCELLED: sb,\n    STATE_FAILED: tb,\n    DIRECTION_NONE: Ia,\n    DIRECTION_LEFT: Ja,\n    DIRECTION_RIGHT: Ka,\n    DIRECTION_UP: La,\n    DIRECTION_DOWN: Ma,\n    DIRECTION_HORIZONTAL: Na,\n    DIRECTION_VERTICAL: Oa,\n    DIRECTION_ALL: Pa,\n    Manager: ia,\n    Input: x,\n    TouchAction: V,\n    TouchInput: P,\n    MouseInput: L,\n    PointerEventInput: M,\n    TouchMouseInput: R,\n    SingleTouchInput: N,\n    Recognizer: Y,\n    AttrRecognizer: aa,\n    Tap: ga,\n    Pan: ba,\n    Swipe: fa,\n    Pinch: ca,\n    Rotate: ea,\n    Press: da,\n    on: m,\n    off: n,\n    each: g,\n    merge: ta,\n    extend: sa,\n    assign: la,\n    inherit: i,\n    bindFn: j,\n    prefixed: u\n  });\n  var wb = 'undefined' != typeof a ? a : 'undefined' != typeof self ? self : {};\n  wb.Hammer = ha,  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return ha;\n  }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n}(window, document, 'Hammer'); // # sourceMappingURL=hammer.min.js.map\n\n(function (factory) {\n  // Commented out the if/else-if/else for our webpack build since these dependencies are right here in the file\n  // And do not need to be loaded as external dependencies\n  //    If ( typeof define === 'function' && define.amd ) {\n  //        Define( [ 'jquery', 'hammerjs' ], factory );\n  //    }\n  //    Else if ( typeof exports === 'object' ) {\n  //        Factory( require( 'jquery' ), require( 'hammerjs' ) );\n  //    }\n  //    Else {\n  //        Factory( jQuery, Hammer );\n  //    }\n  // Load these two dependencies from their declaration in this file\n  factory(jQuery, Hammer);\n})(function ($, Hammer) {\n  function hammerify(el, options) {\n    var $el = $(el);\n\n    if (!$el.data('hammer')) {\n      $el.data('hammer', new Hammer($el[0], options));\n    }\n  }\n\n  $.fn.hammer = function (options) {\n    return this.each(function () {\n      hammerify(this, options);\n    });\n  }; // Extend the emit method to also trigger jQuery events\n\n\n  Hammer.Manager.prototype.emit = function (originalEmit) {\n    return function (type, data) {\n      originalEmit.call(this, type, data);\n      $(this.element).trigger({\n        type: type,\n        gesture: data\n      });\n    };\n  }(Hammer.Manager.prototype.emit);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9vcHQubWF0ZXJpYWxpemUuc2xpZGVzaG93ZGVwZW5kYW5jaWVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vd3d3L2pzLTMuMi4yL29udHJhcG9ydC9vcHRfYXNzZXRzL29wdF9ib2lsZXJwbGF0ZXMvdjMvb3B0Lm1hdGVyaWFsaXplLnNsaWRlc2hvd2RlcGVuZGFuY2llcy5qcz9jZjZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBAYnJpZWYgVGhlc2UgYXJlIHRoZSBkZXBlbmRhbmNpZXMgbGVmdCBvdmVyIGZyb20gdGhlIG9wdCBvdmVybG9hZCBvZiB0aGUgbWF0ZXJpYWxpemUgc2xpZGUgc2hvdy4gVGhlc2Ugc2hvdWxkIG9ubHkgZ2V0IHB1bGxlZFxuICogICAgICAgIGluIGlmIGEgc2xpZGUgc2hvdyBpcyBwcmVzZW50IG9uIHRoZSBwYWdlLiBXaGVuIHdlIHVwZGF0ZSB0aGUgc2xpZGUgc2hvdyBsZXRzIG51a2UgdGhlc2UgYmFkIGJveXMuXG4gKi9cblxuXG4vKiBTVElDS1kgQkxPQ0sgREVQRU5EQU5DSUVTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbndpbmRvdy5NYXRlcmlhbGl6ZSA9IHt9O1xuLy8gVW5pcXVlIFJhbmRvbSBJRFxuTWF0ZXJpYWxpemUuZ3VpZCA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzNCgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vciggKCAxICsgTWF0aC5yYW5kb20oKSApICogMHgxMDAwMCApLnRvU3RyaW5nKCAxNiApLnN1YnN0cmluZyggMSApO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gIH07XG59KCk7XG5cbi8qIFNMSURFIFNIT1cgREVQRU5EQU5DSUVTLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKiAhIFZlbG9jaXR5SlMub3JnICgxLjUuMCkuIChDKSAyMDE0IEp1bGlhbiBTaGFwaXJvLiBNSVQgQGxpY2Vuc2U6IGVuLndpa2lwZWRpYS5vcmcvd2lraS9NSVRfTGljZW5zZSAqL1xuLyogISBWZWxvY2l0eUpTLm9yZyBqUXVlcnkgU2hpbSAoMS4wLjEpLiAoQykgMjAxNCBUaGUgalF1ZXJ5IEZvdW5kYXRpb24uIE1JVCBAbGljZW5zZTogZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlLiAqL1xuIWZ1bmN0aW9uKCBhICkge1xuJ3VzZSBzdHJpY3QnO2Z1bmN0aW9uIGIoIGEgKSB7XG52YXIgYj1hLmxlbmd0aCxkPWMudHlwZSggYSApO3JldHVybiAnZnVuY3Rpb24nIT09ZCYmIWMuaXNXaW5kb3coIGEgKSYmKCAhKCAxIT09YS5ub2RlVHlwZXx8IWIgKXx8KCAnYXJyYXknPT09ZHx8MD09PWJ8fCdudW1iZXInPT10eXBlb2YgYiYmYj4wJiZiLTEgaW4gYSApICk7XG59IGlmICggIWEualF1ZXJ5ICkge1xudmFyIGM9ZnVuY3Rpb24oIGEsYiApIHtcbnJldHVybiBuZXcgYy5mbi5pbml0KCBhLGIgKTtcbn07Yy5pc1dpbmRvdz1mdW5jdGlvbiggYSApIHtcbnJldHVybiBhJiZhPT09YS53aW5kb3c7XG59LGMudHlwZT1mdW5jdGlvbiggYSApIHtcbnJldHVybiBhPydvYmplY3QnPT10eXBlb2YgYXx8J2Z1bmN0aW9uJz09dHlwZW9mIGE/ZVsgZy5jYWxsKCBhICkgXXx8J29iamVjdCc6dHlwZW9mIGE6YSsnJztcbn0sYy5pc0FycmF5PUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKCBhICkge1xucmV0dXJuICdhcnJheSc9PT1jLnR5cGUoIGEgKTtcbn0sYy5pc1BsYWluT2JqZWN0PWZ1bmN0aW9uKCBhICkge1xudmFyIGI7aWYgKCAhYXx8J29iamVjdCchPT1jLnR5cGUoIGEgKXx8YS5ub2RlVHlwZXx8Yy5pc1dpbmRvdyggYSApICkge1xucmV0dXJuICExO1xufSB0cnkge1xuaWYgKCBhLmNvbnN0cnVjdG9yJiYhZi5jYWxsKCBhLCdjb25zdHJ1Y3RvcicgKSYmIWYuY2FsbCggYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsJ2lzUHJvdG90eXBlT2YnICkgKSB7XG5yZXR1cm4gITE7XG59XG59IGNhdGNoICggZCApIHtcbnJldHVybiAhMTtcbn0gZm9yICggYiBpbiBhICkge1xuXG59IHJldHVybiBiPT09dW5kZWZpbmVkfHxmLmNhbGwoIGEsYiApO1xufSxjLmVhY2g9ZnVuY3Rpb24oIGEsYyxkICkge1xudmFyIGU9MCxmPWEubGVuZ3RoLGc9YiggYSApO2lmICggZCApIHtcbmlmICggZyApIHtcbmZvciAoIDtlPGYmJiExIT09Yy5hcHBseSggYVsgZSBdLGQgKTtlKysgKSB7XG5cbn1cbn0gZWxzZSB7XG5mb3IgKCBlIGluIGEgKSB7XG5pZiAoIGEuaGFzT3duUHJvcGVydHkoIGUgKSYmITE9PT1jLmFwcGx5KCBhWyBlIF0sZCApICkge1xuYnJlYWs7XG59XG59XG59XG59IGVsc2UgaWYgKCBnICkge1xuZm9yICggO2U8ZiYmITEhPT1jLmNhbGwoIGFbIGUgXSxlLGFbIGUgXSApO2UrKyApIHtcblxufVxufSBlbHNlIHtcbmZvciAoIGUgaW4gYSApIHtcbmlmICggYS5oYXNPd25Qcm9wZXJ0eSggZSApJiYhMT09PWMuY2FsbCggYVsgZSBdLGUsYVsgZSBdICkgKSB7XG5icmVhaztcbn1cbn1cbn0gcmV0dXJuIGE7XG59LGMuZGF0YT1mdW5jdGlvbiggYSxiLGUgKSB7XG5pZiAoIGU9PT11bmRlZmluZWQgKSB7XG52YXIgZj1hWyBjLmV4cGFuZG8gXSxnPWYmJmRbIGYgXTtpZiAoIGI9PT11bmRlZmluZWQgKSB7XG5yZXR1cm4gZztcbn0gaWYgKCBnJiZiIGluIGcgKSB7XG5yZXR1cm4gZ1sgYiBdO1xufVxufSBlbHNlIGlmICggYiE9PXVuZGVmaW5lZCApIHtcbnZhciBoPWFbIGMuZXhwYW5kbyBdfHwoIGFbIGMuZXhwYW5kbyBdPSsrYy51dWlkICk7cmV0dXJuIGRbIGggXT1kWyBoIF18fHt9LGRbIGggXVsgYiBdPWUsZTtcbn1cbn0sYy5yZW1vdmVEYXRhPWZ1bmN0aW9uKCBhLGIgKSB7XG52YXIgZT1hWyBjLmV4cGFuZG8gXSxmPWUmJmRbIGUgXTtmJiYoIGI/Yy5lYWNoKCBiLGZ1bmN0aW9uKCBhLGIgKSB7XG5kZWxldGUgZlsgYiBdO1xufSApOmRlbGV0ZSBkWyBlIF0gKTtcbn0sYy5leHRlbmQ9ZnVuY3Rpb24oKSB7XG52YXIgYSxiLGQsZSxmLGcsaD1hcmd1bWVudHNbIDAgXXx8e30saT0xLGo9YXJndW1lbnRzLmxlbmd0aCxrPSExO2ZvciAoICdib29sZWFuJz09dHlwZW9mIGgmJiggaz1oLGg9YXJndW1lbnRzWyBpIF18fHt9LGkrKyApLCdvYmplY3QnIT10eXBlb2YgaCYmJ2Z1bmN0aW9uJyE9PWMudHlwZSggaCApJiYoIGg9e30gKSxpPT09aiYmKCBoPXRoaXMsaS0tICk7aTxqO2krKyApIHtcbmlmICggZj1hcmd1bWVudHNbIGkgXSApIHtcbmZvciAoIGUgaW4gZiApIHtcbmYuaGFzT3duUHJvcGVydHkoIGUgKSYmKCBhPWhbIGUgXSxkPWZbIGUgXSxoIT09ZCYmKCBrJiZkJiYoIGMuaXNQbGFpbk9iamVjdCggZCApfHwoIGI9Yy5pc0FycmF5KCBkICkgKSApPyggYj8oIGI9ITEsZz1hJiZjLmlzQXJyYXkoIGEgKT9hOltdICk6Zz1hJiZjLmlzUGxhaW5PYmplY3QoIGEgKT9hOnt9LGhbIGUgXT1jLmV4dGVuZCggayxnLGQgKSApOmQhPT11bmRlZmluZWQmJiggaFsgZSBdPWQgKSApICk7XG59XG59XG59IHJldHVybiBoO1xufSxjLnF1ZXVlPWZ1bmN0aW9uKCBhLGQsZSApIHtcbmlmICggYSApIHtcbmQ9KCBkfHwnZngnICkrJ3F1ZXVlJzt2YXIgZj1jLmRhdGEoIGEsZCApO3JldHVybiBlPyggIWZ8fGMuaXNBcnJheSggZSApP2Y9Yy5kYXRhKCBhLGQsZnVuY3Rpb24oIGEsYyApIHtcbnZhciBkPWN8fFtdO3JldHVybiBhJiYoIGIoIE9iamVjdCggYSApICk/ZnVuY3Rpb24oIGEsYiApIHtcbmZvciAoIHZhciBjPStiLmxlbmd0aCxkPTAsZT1hLmxlbmd0aDtkPGM7ICkge1xuYVsgZSsrIF09YlsgZCsrIF07XG59IGlmICggYyE9PWMgKSB7XG5mb3IgKCA7YlsgZCBdIT09dW5kZWZpbmVkOyApIHtcbmFbIGUrKyBdPWJbIGQrKyBdO1xufVxufWEubGVuZ3RoPWU7XG59KCBkLCdzdHJpbmcnPT10eXBlb2YgYT9bIGEgXTphICk6W10ucHVzaC5jYWxsKCBkLGEgKSApLGQ7XG59KCBlICkgKTpmLnB1c2goIGUgKSxmICk6Znx8W107XG59XG59LGMuZGVxdWV1ZT1mdW5jdGlvbiggYSxiICkge1xuYy5lYWNoKCBhLm5vZGVUeXBlP1sgYSBdOmEsZnVuY3Rpb24oIGEsZCApIHtcbmI9Ynx8J2Z4Jzt2YXIgZT1jLnF1ZXVlKCBkLGIgKSxmPWUuc2hpZnQoKTsnaW5wcm9ncmVzcyc9PT1mJiYoIGY9ZS5zaGlmdCgpICksZiYmKCAnZngnPT09YiYmZS51bnNoaWZ0KCAnaW5wcm9ncmVzcycgKSxmLmNhbGwoIGQsZnVuY3Rpb24oKSB7XG5jLmRlcXVldWUoIGQsYiApO1xufSApICk7XG59ICk7XG59LGMuZm49Yy5wcm90b3R5cGU9e2luaXQ6IGZ1bmN0aW9uKCBhICkge1xuaWYgKCBhLm5vZGVUeXBlICkge1xucmV0dXJuIHRoaXNbIDAgXT1hLHRoaXM7XG59IHRocm93IG5ldyBFcnJvciggJ05vdCBhIERPTSBub2RlLicgKTtcbn0sb2Zmc2V0OiBmdW5jdGlvbigpIHtcbnZhciBiPXRoaXNbIDAgXS5nZXRCb3VuZGluZ0NsaWVudFJlY3Q/dGhpc1sgMCBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOnt0b3A6IDAsbGVmdDogMH07cmV0dXJuIHt0b3A6IGIudG9wKyggYS5wYWdlWU9mZnNldHx8ZG9jdW1lbnQuc2Nyb2xsVG9wfHwwICktKCBkb2N1bWVudC5jbGllbnRUb3B8fDAgKSxsZWZ0OiBiLmxlZnQrKCBhLnBhZ2VYT2Zmc2V0fHxkb2N1bWVudC5zY3JvbGxMZWZ0fHwwICktKCBkb2N1bWVudC5jbGllbnRMZWZ0fHwwICl9O1xufSxwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG52YXIgYT10aGlzWyAwIF0sYj1mdW5jdGlvbiggYSApIHtcbmZvciAoIHZhciBiPWEub2Zmc2V0UGFyZW50O2ImJidodG1sJyE9PWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmYi5zdHlsZSYmJ3N0YXRpYyc9PT1iLnN0eWxlLnBvc2l0aW9uLnRvTG93ZXJDYXNlKCk7ICkge1xuYj1iLm9mZnNldFBhcmVudDtcbn0gcmV0dXJuIGJ8fGRvY3VtZW50O1xufSggYSApLGQ9dGhpcy5vZmZzZXQoKSxlPS9eKD86Ym9keXxodG1sKSQvaS50ZXN0KCBiLm5vZGVOYW1lICk/e3RvcDogMCxsZWZ0OiAwfTpjKCBiICkub2Zmc2V0KCk7cmV0dXJuIGQudG9wLT1wYXJzZUZsb2F0KCBhLnN0eWxlLm1hcmdpblRvcCApfHwwLGQubGVmdC09cGFyc2VGbG9hdCggYS5zdHlsZS5tYXJnaW5MZWZ0ICl8fDAsYi5zdHlsZSYmKCBlLnRvcCs9cGFyc2VGbG9hdCggYi5zdHlsZS5ib3JkZXJUb3BXaWR0aCApfHwwLGUubGVmdCs9cGFyc2VGbG9hdCggYi5zdHlsZS5ib3JkZXJMZWZ0V2lkdGggKXx8MCApLHt0b3A6IGQudG9wLWUudG9wLGxlZnQ6IGQubGVmdC1lLmxlZnR9O1xufX07dmFyIGQ9e307Yy5leHBhbmRvPSd2ZWxvY2l0eScrKCBuZXcgRGF0ZSApLmdldFRpbWUoKSxjLnV1aWQ9MDtmb3IgKCB2YXIgZT17fSxmPWUuaGFzT3duUHJvcGVydHksZz1lLnRvU3RyaW5nLGg9J0Jvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3InLnNwbGl0KCAnICcgKSxpPTA7aTxoLmxlbmd0aDtpKysgKSB7XG5lWyAnW29iamVjdCAnK2hbIGkgXSsnXScgXT1oWyBpIF0udG9Mb3dlckNhc2UoKTtcbn1jLmZuLmluaXQucHJvdG90eXBlPWMuZm4sYS5WZWxvY2l0eT17VXRpbGl0aWVzOiBjfTtcbn1cbn0oIHdpbmRvdyApLGZ1bmN0aW9uKCBhICkge1xuJ3VzZSBzdHJpY3QnOydvYmplY3QnPT10eXBlb2YgbW9kdWxlJiYnb2JqZWN0Jz09dHlwZW9mIG1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWEoKTonZnVuY3Rpb24nPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSggYSApOmEoKTtcbn0oIGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO3JldHVybiBmdW5jdGlvbiggYSxiLGMsZCApIHtcbmZ1bmN0aW9uIGUoIGEgKSB7XG5mb3IgKCB2YXIgYj0tMSxjPWE/YS5sZW5ndGg6MCxkPVtdOysrYjxjOyApIHtcbnZhciBlPWFbIGIgXTtlJiZkLnB1c2goIGUgKTtcbn0gcmV0dXJuIGQ7XG59IGZ1bmN0aW9uIGYoIGEgKSB7XG5yZXR1cm4gdS5pc1dyYXBwZWQoIGEgKT9hPXMuY2FsbCggYSApOnUuaXNOb2RlKCBhICkmJiggYT1bIGEgXSApLGE7XG59IGZ1bmN0aW9uIGcoIGEgKSB7XG52YXIgYj1vLmRhdGEoIGEsJ3ZlbG9jaXR5JyApO3JldHVybiBudWxsPT09Yj9kOmI7XG59IGZ1bmN0aW9uIGgoIGEsYiApIHtcbnZhciBjPWcoIGEgKTtjJiZjLmRlbGF5VGltZXImJiFjLmRlbGF5UGF1c2VkJiYoIGMuZGVsYXlSZW1haW5pbmc9Yy5kZWxheS1iK2MuZGVsYXlCZWdpbixjLmRlbGF5UGF1c2VkPSEwLGNsZWFyVGltZW91dCggYy5kZWxheVRpbWVyLnNldFRpbWVvdXQgKSApO1xufSBmdW5jdGlvbiBpKCBhLGIgKSB7XG52YXIgYz1nKCBhICk7YyYmYy5kZWxheVRpbWVyJiZjLmRlbGF5UGF1c2VkJiYoIGMuZGVsYXlQYXVzZWQ9ITEsYy5kZWxheVRpbWVyLnNldFRpbWVvdXQ9c2V0VGltZW91dCggYy5kZWxheVRpbWVyLm5leHQsYy5kZWxheVJlbWFpbmluZyApICk7XG59IGZ1bmN0aW9uIGooIGEgKSB7XG5yZXR1cm4gZnVuY3Rpb24oIGIgKSB7XG5yZXR1cm4gTWF0aC5yb3VuZCggYiphICkqKCAxL2EgKTtcbn07XG59IGZ1bmN0aW9uIGsoIGEsYyxkLGUgKSB7XG5mdW5jdGlvbiBmKCBhLGIgKSB7XG5yZXR1cm4gMS0zKmIrMyphO1xufSBmdW5jdGlvbiBnKCBhLGIgKSB7XG5yZXR1cm4gMypiLTYqYTtcbn0gZnVuY3Rpb24gaCggYSApIHtcbnJldHVybiAzKmE7XG59IGZ1bmN0aW9uIGkoIGEsYixjICkge1xucmV0dXJuICggKCBmKCBiLGMgKSphK2coIGIsYyApICkqYStoKCBiICkgKSphO1xufSBmdW5jdGlvbiBqKCBhLGIsYyApIHtcbnJldHVybiAzKmYoIGIsYyApKmEqYSsyKmcoIGIsYyApKmEraCggYiApO1xufSBmdW5jdGlvbiBrKCBiLGMgKSB7XG5mb3IgKCB2YXIgZT0wO2U8cDsrK2UgKSB7XG52YXIgZj1qKCBjLGEsZCApO2lmICggMD09PWYgKSB7XG5yZXR1cm4gYztcbn1jLT0oIGkoIGMsYSxkICktYiApL2Y7XG59IHJldHVybiBjO1xufSBmdW5jdGlvbiBsKCkge1xuZm9yICggdmFyIGI9MDtiPHQ7KytiICkge1xueFsgYiBdPWkoIGIqdSxhLGQgKTtcbn1cbn0gZnVuY3Rpb24gbSggYixjLGUgKSB7XG52YXIgZixnLGg9MDtkbyB7XG5nPWMrKCBlLWMgKS8yLGY9aSggZyxhLGQgKS1iLGY+MD9lPWc6Yz1nO1xufSB3aGlsZSAoIE1hdGguYWJzKCBmICk+ciYmKytoPHMgKTtyZXR1cm4gZztcbn0gZnVuY3Rpb24gbiggYiApIHtcbmZvciAoIHZhciBjPTAsZT0xLGY9dC0xO2UhPT1mJiZ4WyBlIF08PWI7KytlICkge1xuYys9dTtcbn0tLWU7dmFyIGc9KCBiLXhbIGUgXSApLyggeFsgZSsxIF0teFsgZSBdICksaD1jK2cqdSxpPWooIGgsYSxkICk7cmV0dXJuIGk+PXE/ayggYixoICk6MD09PWk/aDptKCBiLGMsYyt1ICk7XG59IGZ1bmN0aW9uIG8oKSB7XG55PSEwLGE9PT1jJiZkPT09ZXx8bCgpO1xufSB2YXIgcD00LHE9LjAwMSxyPTFlLTcscz0xMCx0PTExLHU9MS8oIHQtMSApLHY9J0Zsb2F0MzJBcnJheSdpbiBiO2lmICggNCE9PWFyZ3VtZW50cy5sZW5ndGggKSB7XG5yZXR1cm4gITE7XG59IGZvciAoIHZhciB3PTA7dzw0OysrdyApIHtcbmlmICggJ251bWJlcichPXR5cGVvZiBhcmd1bWVudHNbIHcgXXx8aXNOYU4oIGFyZ3VtZW50c1sgdyBdICl8fCFpc0Zpbml0ZSggYXJndW1lbnRzWyB3IF0gKSApIHtcbnJldHVybiAhMTtcbn1cbn1hPU1hdGgubWluKCBhLDEgKSxkPU1hdGgubWluKCBkLDEgKSxhPU1hdGgubWF4KCBhLDAgKSxkPU1hdGgubWF4KCBkLDAgKTt2YXIgeD12P25ldyBGbG9hdDMyQXJyYXkoIHQgKTpuZXcgQXJyYXkoIHQgKSx5PSExLHo9ZnVuY3Rpb24oIGIgKSB7XG5yZXR1cm4geXx8bygpLGE9PT1jJiZkPT09ZT9iOjA9PT1iPzA6MT09PWI/MTppKCBuKCBiICksYyxlICk7XG59O3ouZ2V0Q29udHJvbFBvaW50cz1mdW5jdGlvbigpIHtcbnJldHVybiBbIHt4OiBhLHk6IGN9LHt4OiBkLHk6IGV9IF07XG59O3ZhciBBPSdnZW5lcmF0ZUJlemllcignK1sgYSxjLGQsZSBdKycpJztyZXR1cm4gei50b1N0cmluZz1mdW5jdGlvbigpIHtcbnJldHVybiBBO1xufSx6O1xufSBmdW5jdGlvbiBsKCBhLGIgKSB7XG52YXIgYz1hO3JldHVybiB1LmlzU3RyaW5nKCBhICk/eS5FYXNpbmdzWyBhIF18fCggYz0hMSApOmM9dS5pc0FycmF5KCBhICkmJjE9PT1hLmxlbmd0aD9qLmFwcGx5KCBudWxsLGEgKTp1LmlzQXJyYXkoIGEgKSYmMj09PWEubGVuZ3RoP3ouYXBwbHkoIG51bGwsYS5jb25jYXQoIFsgYiBdICkgKTohKCAhdS5pc0FycmF5KCBhICl8fDQhPT1hLmxlbmd0aCApJiZrLmFwcGx5KCBudWxsLGEgKSwhMT09PWMmJiggYz15LkVhc2luZ3NbIHkuZGVmYXVsdHMuZWFzaW5nIF0/eS5kZWZhdWx0cy5lYXNpbmc6eCApLGM7XG59IGZ1bmN0aW9uIG0oIGEgKSB7XG5pZiAoIGEgKSB7XG52YXIgYj15LnRpbWVzdGFtcCYmITAhPT1hP2E6ci5ub3coKSxjPXkuU3RhdGUuY2FsbHMubGVuZ3RoO2M+MWU0JiYoIHkuU3RhdGUuY2FsbHM9ZSggeS5TdGF0ZS5jYWxscyApLGM9eS5TdGF0ZS5jYWxscy5sZW5ndGggKTtmb3IgKCB2YXIgZj0wO2Y8YztmKysgKSB7XG5pZiAoIHkuU3RhdGUuY2FsbHNbIGYgXSApIHtcbnZhciBoPXkuU3RhdGUuY2FsbHNbIGYgXSxpPWhbIDAgXSxqPWhbIDIgXSxrPWhbIDMgXSxsPSFrLHE9bnVsbCxzPWhbIDUgXSx0PWhbIDYgXTtpZiAoIGt8fCggaz15LlN0YXRlLmNhbGxzWyBmIF1bIDMgXT1iLTE2ICkscyApIHtcbmlmICggITAhPT1zLnJlc3VtZSApIHtcbmNvbnRpbnVlO1xufWs9aFsgMyBdPU1hdGgucm91bmQoIGItdC0xNiApLGhbIDUgXT1udWxsO1xufXQ9aFsgNiBdPWItaztmb3IgKCB2YXIgdj1NYXRoLm1pbiggdC9qLmR1cmF0aW9uLDEgKSx3PTAseD1pLmxlbmd0aDt3PHg7dysrICkge1xudmFyIHo9aVsgdyBdLEI9ei5lbGVtZW50O2lmICggZyggQiApICkge1xudmFyIEQ9ITE7aWYgKCBqLmRpc3BsYXkhPT1kJiZudWxsIT09ai5kaXNwbGF5JiYnbm9uZSchPT1qLmRpc3BsYXkgKSB7XG5pZiAoICdmbGV4Jz09PWouZGlzcGxheSApIHtcbnZhciBFPVsgJy13ZWJraXQtYm94JywnLW1vei1ib3gnLCctbXMtZmxleGJveCcsJy13ZWJraXQtZmxleCcgXTtvLmVhY2goIEUsZnVuY3Rpb24oIGEsYiApIHtcbkEuc2V0UHJvcGVydHlWYWx1ZSggQiwnZGlzcGxheScsYiApO1xufSApO1xufUEuc2V0UHJvcGVydHlWYWx1ZSggQiwnZGlzcGxheScsai5kaXNwbGF5ICk7XG59ai52aXNpYmlsaXR5IT09ZCYmJ2hpZGRlbichPT1qLnZpc2liaWxpdHkmJkEuc2V0UHJvcGVydHlWYWx1ZSggQiwndmlzaWJpbGl0eScsai52aXNpYmlsaXR5ICk7Zm9yICggdmFyIEYgaW4geiApIHtcbmlmICggei5oYXNPd25Qcm9wZXJ0eSggRiApJiYnZWxlbWVudCchPT1GICkge1xudmFyIEcsSD16WyBGIF0sST11LmlzU3RyaW5nKCBILmVhc2luZyApP3kuRWFzaW5nc1sgSC5lYXNpbmcgXTpILmVhc2luZztpZiAoIHUuaXNTdHJpbmcoIEgucGF0dGVybiApICkge1xudmFyIEo9MT09PXY/ZnVuY3Rpb24oIGEsYixjICkge1xudmFyIGQ9SC5lbmRWYWx1ZVsgYiBdO3JldHVybiBjP01hdGgucm91bmQoIGQgKTpkO1xufTpmdW5jdGlvbiggYSxiLGMgKSB7XG52YXIgZD1ILnN0YXJ0VmFsdWVbIGIgXSxlPUguZW5kVmFsdWVbIGIgXS1kLGY9ZCtlKkkoIHYsaixlICk7cmV0dXJuIGM/TWF0aC5yb3VuZCggZiApOmY7XG59O0c9SC5wYXR0ZXJuLnJlcGxhY2UoIC97KFxcZCspKCEpP30vZyxKICk7XG59IGVsc2UgaWYgKCAxPT09diApIHtcbkc9SC5lbmRWYWx1ZTtcbn0gZWxzZSB7XG52YXIgSz1ILmVuZFZhbHVlLUguc3RhcnRWYWx1ZTtHPUguc3RhcnRWYWx1ZStLKkkoIHYsaixLICk7XG59IGlmICggIWwmJkc9PT1ILmN1cnJlbnRWYWx1ZSApIHtcbmNvbnRpbnVlO1xufSBpZiAoIEguY3VycmVudFZhbHVlPUcsJ3R3ZWVuJz09PUYgKSB7XG5xPUc7XG59IGVsc2Uge1xudmFyIEw7aWYgKCBBLkhvb2tzLnJlZ2lzdGVyZWRbIEYgXSApIHtcbkw9QS5Ib29rcy5nZXRSb290KCBGICk7dmFyIE09ZyggQiApLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGVbIEwgXTtNJiYoIEgucm9vdFByb3BlcnR5VmFsdWU9TSApO1xufSB2YXIgTj1BLnNldFByb3BlcnR5VmFsdWUoIEIsRixILmN1cnJlbnRWYWx1ZSsoIHA8OSYmMD09PXBhcnNlRmxvYXQoIEcgKT8nJzpILnVuaXRUeXBlICksSC5yb290UHJvcGVydHlWYWx1ZSxILnNjcm9sbERhdGEgKTtBLkhvb2tzLnJlZ2lzdGVyZWRbIEYgXSYmKCBBLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbIEwgXT9nKCBCICkucm9vdFByb3BlcnR5VmFsdWVDYWNoZVsgTCBdPUEuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFsgTCBdKCAnZXh0cmFjdCcsbnVsbCxOWyAxIF0gKTpnKCBCICkucm9vdFByb3BlcnR5VmFsdWVDYWNoZVsgTCBdPU5bIDEgXSApLCd0cmFuc2Zvcm0nPT09TlsgMCBdJiYoIEQ9ITAgKTtcbn1cbn1cbn1qLm1vYmlsZUhBJiZnKCBCICkudHJhbnNmb3JtQ2FjaGUudHJhbnNsYXRlM2Q9PT1kJiYoIGcoIEIgKS50cmFuc2Zvcm1DYWNoZS50cmFuc2xhdGUzZD0nKDBweCwgMHB4LCAwcHgpJyxEPSEwICksRCYmQS5mbHVzaFRyYW5zZm9ybUNhY2hlKCBCICk7XG59XG59ai5kaXNwbGF5IT09ZCYmJ25vbmUnIT09ai5kaXNwbGF5JiYoIHkuU3RhdGUuY2FsbHNbIGYgXVsgMiBdLmRpc3BsYXk9ITEgKSxqLnZpc2liaWxpdHkhPT1kJiYnaGlkZGVuJyE9PWoudmlzaWJpbGl0eSYmKCB5LlN0YXRlLmNhbGxzWyBmIF1bIDIgXS52aXNpYmlsaXR5PSExICksai5wcm9ncmVzcyYmai5wcm9ncmVzcy5jYWxsKCBoWyAxIF0saFsgMSBdLHYsTWF0aC5tYXgoIDAsaytqLmR1cmF0aW9uLWIgKSxrLHEgKSwxPT09diYmbiggZiApO1xufVxufVxufXkuU3RhdGUuaXNUaWNraW5nJiZDKCBtICk7XG59IGZ1bmN0aW9uIG4oIGEsYiApIHtcbmlmICggIXkuU3RhdGUuY2FsbHNbIGEgXSApIHtcbnJldHVybiAhMTtcbn0gZm9yICggdmFyIGM9eS5TdGF0ZS5jYWxsc1sgYSBdWyAwIF0sZT15LlN0YXRlLmNhbGxzWyBhIF1bIDEgXSxmPXkuU3RhdGUuY2FsbHNbIGEgXVsgMiBdLGg9eS5TdGF0ZS5jYWxsc1sgYSBdWyA0IF0saT0hMSxqPTAsaz1jLmxlbmd0aDtqPGs7aisrICkge1xudmFyIGw9Y1sgaiBdLmVsZW1lbnQ7Ynx8Zi5sb29wfHwoICdub25lJz09PWYuZGlzcGxheSYmQS5zZXRQcm9wZXJ0eVZhbHVlKCBsLCdkaXNwbGF5JyxmLmRpc3BsYXkgKSwnaGlkZGVuJz09PWYudmlzaWJpbGl0eSYmQS5zZXRQcm9wZXJ0eVZhbHVlKCBsLCd2aXNpYmlsaXR5JyxmLnZpc2liaWxpdHkgKSApO3ZhciBtPWcoIGwgKTtpZiAoICEwIT09Zi5sb29wJiYoIG8ucXVldWUoIGwgKVsgMSBdPT09ZHx8IS9cXC52ZWxvY2l0eVF1ZXVlRW50cnlGbGFnL2kudGVzdCggby5xdWV1ZSggbCApWyAxIF0gKSApJiZtICkge1xubS5pc0FuaW1hdGluZz0hMSxtLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGU9e307dmFyIG49ITE7by5lYWNoKCBBLkxpc3RzLnRyYW5zZm9ybXMzRCxmdW5jdGlvbiggYSxiICkge1xudmFyIGM9L15zY2FsZS8udGVzdCggYiApPzE6MCxlPW0udHJhbnNmb3JtQ2FjaGVbIGIgXTttLnRyYW5zZm9ybUNhY2hlWyBiIF0hPT1kJiZuZXcgUmVnRXhwKCAnXlxcXFwoJytjKydbXi5dJyApLnRlc3QoIGUgKSYmKCBuPSEwLGRlbGV0ZSBtLnRyYW5zZm9ybUNhY2hlWyBiIF0gKTtcbn0gKSxmLm1vYmlsZUhBJiYoIG49ITAsZGVsZXRlIG0udHJhbnNmb3JtQ2FjaGUudHJhbnNsYXRlM2QgKSxuJiZBLmZsdXNoVHJhbnNmb3JtQ2FjaGUoIGwgKSxBLlZhbHVlcy5yZW1vdmVDbGFzcyggbCwndmVsb2NpdHktYW5pbWF0aW5nJyApO1xufSBpZiAoICFiJiZmLmNvbXBsZXRlJiYhZi5sb29wJiZqPT09ay0xICkge1xudHJ5IHtcbmYuY29tcGxldGUuY2FsbCggZSxlICk7XG59IGNhdGNoICggciApIHtcbnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xudGhyb3cgcjtcbn0sMSApO1xufVxufWgmJiEwIT09Zi5sb29wJiZoKCBlICksbSYmITA9PT1mLmxvb3AmJiFiJiYoIG8uZWFjaCggbS50d2VlbnNDb250YWluZXIsZnVuY3Rpb24oIGEsYiApIHtcbmlmICggL15yb3RhdGUvLnRlc3QoIGEgKSYmKCBwYXJzZUZsb2F0KCBiLnN0YXJ0VmFsdWUgKS1wYXJzZUZsb2F0KCBiLmVuZFZhbHVlICkgKSUzNjA9PTAgKSB7XG52YXIgYz1iLnN0YXJ0VmFsdWU7Yi5zdGFydFZhbHVlPWIuZW5kVmFsdWUsYi5lbmRWYWx1ZT1jO1xufS9eYmFja2dyb3VuZFBvc2l0aW9uLy50ZXN0KCBhICkmJjEwMD09PXBhcnNlRmxvYXQoIGIuZW5kVmFsdWUgKSYmJyUnPT09Yi51bml0VHlwZSYmKCBiLmVuZFZhbHVlPTAsYi5zdGFydFZhbHVlPTEwMCApO1xufSApLHkoIGwsJ3JldmVyc2UnLHtsb29wOiAhMCxkZWxheTogZi5kZWxheX0gKSApLCExIT09Zi5xdWV1ZSYmby5kZXF1ZXVlKCBsLGYucXVldWUgKTtcbn15LlN0YXRlLmNhbGxzWyBhIF09ITE7Zm9yICggdmFyIHA9MCxxPXkuU3RhdGUuY2FsbHMubGVuZ3RoO3A8cTtwKysgKSB7XG5pZiAoICExIT09eS5TdGF0ZS5jYWxsc1sgcCBdICkge1xuaT0hMDticmVhaztcbn1cbn0hMT09PWkmJiggeS5TdGF0ZS5pc1RpY2tpbmc9ITEsZGVsZXRlIHkuU3RhdGUuY2FsbHMseS5TdGF0ZS5jYWxscz1bXSApO1xufSB2YXIgbyxwPWZ1bmN0aW9uKCkge1xuaWYgKCBjLmRvY3VtZW50TW9kZSApIHtcbnJldHVybiBjLmRvY3VtZW50TW9kZTtcbn0gZm9yICggdmFyIGE9NzthPjQ7YS0tICkge1xudmFyIGI9Yy5jcmVhdGVFbGVtZW50KCAnZGl2JyApO2lmICggYi5pbm5lckhUTUw9J1xceDNjIS0tW2lmIElFICcrYSsnXT48c3Bhbj48L3NwYW4+PCFbZW5kaWZdLS1cXHgzZScsYi5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ3NwYW4nICkubGVuZ3RoICkge1xucmV0dXJuIGI9bnVsbCxhO1xufVxufSByZXR1cm4gZDtcbn0oKSxxPWZ1bmN0aW9uKCkge1xudmFyIGE9MDtyZXR1cm4gYi53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGIubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbiggYiApIHtcbnZhciBjLGQ9KCBuZXcgRGF0ZSApLmdldFRpbWUoKTtyZXR1cm4gYz1NYXRoLm1heCggMCwxNi0oIGQtYSApICksYT1kK2Msc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5iKCBkK2MgKTtcbn0sYyApO1xufTtcbn0oKSxyPWZ1bmN0aW9uKCkge1xudmFyIGE9Yi5wZXJmb3JtYW5jZXx8e307aWYgKCAnZnVuY3Rpb24nIT10eXBlb2YgYS5ub3cgKSB7XG52YXIgYz1hLnRpbWluZyYmYS50aW1pbmcubmF2aWdhdGlvblN0YXJ0P2EudGltaW5nLm5hdmlnYXRpb25TdGFydDooIG5ldyBEYXRlICkuZ2V0VGltZSgpO2Eubm93PWZ1bmN0aW9uKCkge1xucmV0dXJuICggbmV3IERhdGUgKS5nZXRUaW1lKCktYztcbn07XG59IHJldHVybiBhO1xufSgpLHM9ZnVuY3Rpb24oKSB7XG52YXIgYT1BcnJheS5wcm90b3R5cGUuc2xpY2U7dHJ5IHtcbnJldHVybiBhLmNhbGwoIGMuZG9jdW1lbnRFbGVtZW50ICksYTtcbn0gY2F0Y2ggKCBiICkge1xucmV0dXJuIGZ1bmN0aW9uKCBiLGMgKSB7XG52YXIgZD10aGlzLmxlbmd0aDtpZiAoICdudW1iZXInIT10eXBlb2YgYiYmKCBiPTAgKSwnbnVtYmVyJyE9dHlwZW9mIGMmJiggYz1kICksdGhpcy5zbGljZSApIHtcbnJldHVybiBhLmNhbGwoIHRoaXMsYixjICk7XG59IHZhciBlLGY9W10sZz1iPj0wP2I6TWF0aC5tYXgoIDAsZCtiICksaD1jPDA/ZCtjOk1hdGgubWluKCBjLGQgKSxpPWgtZztpZiAoIGk+MCApIHtcbmlmICggZj1uZXcgQXJyYXkoIGkgKSx0aGlzLmNoYXJBdCApIHtcbmZvciAoIGU9MDtlPGk7ZSsrICkge1xuZlsgZSBdPXRoaXMuY2hhckF0KCBnK2UgKTtcbn1cbn0gZWxzZSB7XG5mb3IgKCBlPTA7ZTxpO2UrKyApIHtcbmZbIGUgXT10aGlzWyBnK2UgXTtcbn1cbn1cbn0gcmV0dXJuIGY7XG59O1xufVxufSgpLHQ9ZnVuY3Rpb24oKSB7XG5yZXR1cm4gQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzP2Z1bmN0aW9uKCBhLGIgKSB7XG5yZXR1cm4gYS5pbmNsdWRlcyggYiApO1xufTpBcnJheS5wcm90b3R5cGUuaW5kZXhPZj9mdW5jdGlvbiggYSxiICkge1xucmV0dXJuIGEuaW5kZXhPZiggYiApPj0wO1xufTpmdW5jdGlvbiggYSxiICkge1xuZm9yICggdmFyIGM9MDtjPGEubGVuZ3RoO2MrKyApIHtcbmlmICggYVsgYyBdPT09YiApIHtcbnJldHVybiAhMDtcbn1cbn0gcmV0dXJuICExO1xufTtcbn0sdT17aXNOdW1iZXI6IGZ1bmN0aW9uKCBhICkge1xucmV0dXJuICdudW1iZXInPT10eXBlb2YgYTtcbn0saXNTdHJpbmc6IGZ1bmN0aW9uKCBhICkge1xucmV0dXJuICdzdHJpbmcnPT10eXBlb2YgYTtcbn0saXNBcnJheTogQXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oIGEgKSB7XG5yZXR1cm4gJ1tvYmplY3QgQXJyYXldJz09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggYSApO1xufSxpc0Z1bmN0aW9uOiBmdW5jdGlvbiggYSApIHtcbnJldHVybiAnW29iamVjdCBGdW5jdGlvbl0nPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCBhICk7XG59LGlzTm9kZTogZnVuY3Rpb24oIGEgKSB7XG5yZXR1cm4gYSYmYS5ub2RlVHlwZTtcbn0saXNXcmFwcGVkOiBmdW5jdGlvbiggYSApIHtcbnJldHVybiBhJiZhIT09YiYmdS5pc051bWJlciggYS5sZW5ndGggKSYmIXUuaXNTdHJpbmcoIGEgKSYmIXUuaXNGdW5jdGlvbiggYSApJiYhdS5pc05vZGUoIGEgKSYmKCAwPT09YS5sZW5ndGh8fHUuaXNOb2RlKCBhWyAwIF0gKSApO1xufSxpc1NWRzogZnVuY3Rpb24oIGEgKSB7XG5yZXR1cm4gYi5TVkdFbGVtZW50JiZhIGluc3RhbmNlb2YgYi5TVkdFbGVtZW50O1xufSxpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggYSApIHtcbmZvciAoIHZhciBiIGluIGEgKSB7XG5pZiAoIGEuaGFzT3duUHJvcGVydHkoIGIgKSApIHtcbnJldHVybiAhMTtcbn1cbn0gcmV0dXJuICEwO1xufX0sdj0hMTtpZiAoIGEuZm4mJmEuZm4uanF1ZXJ5Pyggbz1hLHY9ITAgKTpvPWIuVmVsb2NpdHkuVXRpbGl0aWVzLHA8PTgmJiF2ICkge1xudGhyb3cgbmV3IEVycm9yKCAnVmVsb2NpdHk6IElFOCBhbmQgYmVsb3cgcmVxdWlyZSBqUXVlcnkgdG8gYmUgbG9hZGVkIGJlZm9yZSBWZWxvY2l0eS4nICk7XG59IGlmICggcDw9NyApIHtcbnJldHVybiB2b2lkKCBqUXVlcnkuZm4udmVsb2NpdHk9alF1ZXJ5LmZuLmFuaW1hdGUgKTtcbn0gdmFyIHc9NDAwLHg9J3N3aW5nJyx5PXtTdGF0ZToge2lzTW9iaWxlOiAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QoIGIubmF2aWdhdG9yLnVzZXJBZ2VudCApLGlzQW5kcm9pZDogL0FuZHJvaWQvaS50ZXN0KCBiLm5hdmlnYXRvci51c2VyQWdlbnQgKSxpc0dpbmdlcmJyZWFkOiAvQW5kcm9pZCAyXFwuM1xcLlszLTddL2kudGVzdCggYi5uYXZpZ2F0b3IudXNlckFnZW50ICksaXNDaHJvbWU6IGIuY2hyb21lLGlzRmlyZWZveDogL0ZpcmVmb3gvaS50ZXN0KCBiLm5hdmlnYXRvci51c2VyQWdlbnQgKSxwcmVmaXhFbGVtZW50OiBjLmNyZWF0ZUVsZW1lbnQoICdkaXYnICkscHJlZml4TWF0Y2hlczoge30sc2Nyb2xsQW5jaG9yOiBudWxsLHNjcm9sbFByb3BlcnR5TGVmdDogbnVsbCxzY3JvbGxQcm9wZXJ0eVRvcDogbnVsbCxpc1RpY2tpbmc6ICExLGNhbGxzOiBbXSxkZWxheWVkRWxlbWVudHM6IHtjb3VudDogMH19LENTUzoge30sVXRpbGl0aWVzOiBvLFJlZGlyZWN0czoge30sRWFzaW5nczoge30sUHJvbWlzZTogYi5Qcm9taXNlLGRlZmF1bHRzOiB7cXVldWU6ICcnLGR1cmF0aW9uOiB3LGVhc2luZzogeCxiZWdpbjogZCxjb21wbGV0ZTogZCxwcm9ncmVzczogZCxkaXNwbGF5OiBkLHZpc2liaWxpdHk6IGQsbG9vcDogITEsZGVsYXk6ICExLG1vYmlsZUhBOiAhMCxfY2FjaGVWYWx1ZXM6ICEwLHByb21pc2VSZWplY3RFbXB0eTogITB9LGluaXQ6IGZ1bmN0aW9uKCBhICkge1xuby5kYXRhKCBhLCd2ZWxvY2l0eScse2lzU1ZHOiB1LmlzU1ZHKCBhICksaXNBbmltYXRpbmc6ICExLGNvbXB1dGVkU3R5bGU6IG51bGwsdHdlZW5zQ29udGFpbmVyOiBudWxsLHJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGU6IHt9LHRyYW5zZm9ybUNhY2hlOiB7fX0gKTtcbn0saG9vazogbnVsbCxtb2NrOiAhMSx2ZXJzaW9uOiB7bWFqb3I6IDEsbWlub3I6IDUscGF0Y2g6IDF9LGRlYnVnOiAhMSx0aW1lc3RhbXA6ICEwLHBhdXNlQWxsOiBmdW5jdGlvbiggYSApIHtcbnZhciBiPSggbmV3IERhdGUgKS5nZXRUaW1lKCk7by5lYWNoKCB5LlN0YXRlLmNhbGxzLGZ1bmN0aW9uKCBiLGMgKSB7XG5pZiAoIGMgKSB7XG5pZiAoIGEhPT1kJiYoIGNbIDIgXS5xdWV1ZSE9PWF8fCExPT09Y1sgMiBdLnF1ZXVlICkgKSB7XG5yZXR1cm4gITA7XG59Y1sgNSBdPXtyZXN1bWU6ICExfTtcbn1cbn0gKSxvLmVhY2goIHkuU3RhdGUuZGVsYXllZEVsZW1lbnRzLGZ1bmN0aW9uKCBhLGMgKSB7XG5jJiZoKCBjLGIgKTtcbn0gKTtcbn0scmVzdW1lQWxsOiBmdW5jdGlvbiggYSApIHtcbnZhciBiPSggbmV3IERhdGUgKS5nZXRUaW1lKCk7by5lYWNoKCB5LlN0YXRlLmNhbGxzLGZ1bmN0aW9uKCBiLGMgKSB7XG5pZiAoIGMgKSB7XG5pZiAoIGEhPT1kJiYoIGNbIDIgXS5xdWV1ZSE9PWF8fCExPT09Y1sgMiBdLnF1ZXVlICkgKSB7XG5yZXR1cm4gITA7XG59Y1sgNSBdJiYoIGNbIDUgXS5yZXN1bWU9ITAgKTtcbn1cbn0gKSxvLmVhY2goIHkuU3RhdGUuZGVsYXllZEVsZW1lbnRzLGZ1bmN0aW9uKCBhLGMgKSB7XG5jJiZpKCBjLGIgKTtcbn0gKTtcbn19O2IucGFnZVlPZmZzZXQhPT1kPyggeS5TdGF0ZS5zY3JvbGxBbmNob3I9Yix5LlN0YXRlLnNjcm9sbFByb3BlcnR5TGVmdD0ncGFnZVhPZmZzZXQnLHkuU3RhdGUuc2Nyb2xsUHJvcGVydHlUb3A9J3BhZ2VZT2Zmc2V0JyApOiggeS5TdGF0ZS5zY3JvbGxBbmNob3I9Yy5kb2N1bWVudEVsZW1lbnR8fGMuYm9keS5wYXJlbnROb2RlfHxjLmJvZHkseS5TdGF0ZS5zY3JvbGxQcm9wZXJ0eUxlZnQ9J3Njcm9sbExlZnQnLHkuU3RhdGUuc2Nyb2xsUHJvcGVydHlUb3A9J3Njcm9sbFRvcCcgKTt2YXIgej1mdW5jdGlvbigpIHtcbmZ1bmN0aW9uIGEoIGEgKSB7XG5yZXR1cm4gLWEudGVuc2lvbiphLngtYS5mcmljdGlvbiphLnY7XG59IGZ1bmN0aW9uIGIoIGIsYyxkICkge1xudmFyIGU9e3g6IGIueCtkLmR4KmMsdjogYi52K2QuZHYqYyx0ZW5zaW9uOiBiLnRlbnNpb24sZnJpY3Rpb246IGIuZnJpY3Rpb259O3JldHVybiB7ZHg6IGUudixkdjogYSggZSApfTtcbn0gZnVuY3Rpb24gYyggYyxkICkge1xudmFyIGU9e2R4OiBjLnYsZHY6IGEoIGMgKX0sZj1iKCBjLC41KmQsZSApLGc9YiggYywuNSpkLGYgKSxoPWIoIGMsZCxnICksaT0xLzYqKCBlLmR4KzIqKCBmLmR4K2cuZHggKStoLmR4ICksaj0xLzYqKCBlLmR2KzIqKCBmLmR2K2cuZHYgKStoLmR2ICk7cmV0dXJuIGMueD1jLngraSpkLGMudj1jLnYraipkLGM7XG59IHJldHVybiBmdW5jdGlvbiBkKCBhLGIsZSApIHtcbnZhciBmLGcsaCxpPXt4OiAtMSx2OiAwLHRlbnNpb246IG51bGwsZnJpY3Rpb246IG51bGx9LGo9WyAwIF0saz0wO2ZvciAoIGE9cGFyc2VGbG9hdCggYSApfHw1MDAsYj1wYXJzZUZsb2F0KCBiICl8fDIwLGU9ZXx8bnVsbCxpLnRlbnNpb249YSxpLmZyaWN0aW9uPWIsZj1udWxsIT09ZSxmPyggaz1kKCBhLGIgKSxnPWsvZSouMDE2ICk6Zz0uMDE2OzsgKSB7XG5pZiAoIGg9YyggaHx8aSxnICksai5wdXNoKCAxK2gueCApLGsrPTE2LCEoIE1hdGguYWJzKCBoLnggKT4xZS00JiZNYXRoLmFicyggaC52ICk+MWUtNCApICkge1xuYnJlYWs7XG59XG59IHJldHVybiBmP2Z1bmN0aW9uKCBhICkge1xucmV0dXJuIGpbIGEqKCBqLmxlbmd0aC0xICl8MCBdO1xufTprO1xufTtcbn0oKTt5LkVhc2luZ3M9e2xpbmVhcjogZnVuY3Rpb24oIGEgKSB7XG5yZXR1cm4gYTtcbn0sc3dpbmc6IGZ1bmN0aW9uKCBhICkge1xucmV0dXJuLjUtTWF0aC5jb3MoIGEqTWF0aC5QSSApLzI7XG59LHNwcmluZzogZnVuY3Rpb24oIGEgKSB7XG5yZXR1cm4gMS1NYXRoLmNvcyggNC41KmEqTWF0aC5QSSApKk1hdGguZXhwKCA2Ki1hICk7XG59fSxvLmVhY2goIFsgWyAnZWFzZScsWyAuMjUsLjEsLjI1LDEgXSBdLFsgJ2Vhc2UtaW4nLFsgLjQyLDAsMSwxIF0gXSxbICdlYXNlLW91dCcsWyAwLDAsLjU4LDEgXSBdLFsgJ2Vhc2UtaW4tb3V0JyxbIC40MiwwLC41OCwxIF0gXSxbICdlYXNlSW5TaW5lJyxbIC40NywwLC43NDUsLjcxNSBdIF0sWyAnZWFzZU91dFNpbmUnLFsgLjM5LC41NzUsLjU2NSwxIF0gXSxbICdlYXNlSW5PdXRTaW5lJyxbIC40NDUsLjA1LC41NSwuOTUgXSBdLFsgJ2Vhc2VJblF1YWQnLFsgLjU1LC4wODUsLjY4LC41MyBdIF0sWyAnZWFzZU91dFF1YWQnLFsgLjI1LC40NiwuNDUsLjk0IF0gXSxbICdlYXNlSW5PdXRRdWFkJyxbIC40NTUsLjAzLC41MTUsLjk1NSBdIF0sWyAnZWFzZUluQ3ViaWMnLFsgLjU1LC4wNTUsLjY3NSwuMTkgXSBdLFsgJ2Vhc2VPdXRDdWJpYycsWyAuMjE1LC42MSwuMzU1LDEgXSBdLFsgJ2Vhc2VJbk91dEN1YmljJyxbIC42NDUsLjA0NSwuMzU1LDEgXSBdLFsgJ2Vhc2VJblF1YXJ0JyxbIC44OTUsLjAzLC42ODUsLjIyIF0gXSxbICdlYXNlT3V0UXVhcnQnLFsgLjE2NSwuODQsLjQ0LDEgXSBdLFsgJ2Vhc2VJbk91dFF1YXJ0JyxbIC43NywwLC4xNzUsMSBdIF0sWyAnZWFzZUluUXVpbnQnLFsgLjc1NSwuMDUsLjg1NSwuMDYgXSBdLFsgJ2Vhc2VPdXRRdWludCcsWyAuMjMsMSwuMzIsMSBdIF0sWyAnZWFzZUluT3V0UXVpbnQnLFsgLjg2LDAsLjA3LDEgXSBdLFsgJ2Vhc2VJbkV4cG8nLFsgLjk1LC4wNSwuNzk1LC4wMzUgXSBdLFsgJ2Vhc2VPdXRFeHBvJyxbIC4xOSwxLC4yMiwxIF0gXSxbICdlYXNlSW5PdXRFeHBvJyxbIDEsMCwwLDEgXSBdLFsgJ2Vhc2VJbkNpcmMnLFsgLjYsLjA0LC45OCwuMzM1IF0gXSxbICdlYXNlT3V0Q2lyYycsWyAuMDc1LC44MiwuMTY1LDEgXSBdLFsgJ2Vhc2VJbk91dENpcmMnLFsgLjc4NSwuMTM1LC4xNSwuODYgXSBdIF0sZnVuY3Rpb24oIGEsYiApIHtcbnkuRWFzaW5nc1sgYlsgMCBdIF09ay5hcHBseSggbnVsbCxiWyAxIF0gKTtcbn0gKTt2YXIgQT15LkNTUz17UmVnRXg6IHtpc0hleDogL14jKFtBLWZcXGRdezN9KXsxLDJ9JC9pLHZhbHVlVW53cmFwOiAvXltBLXpdK1xcKCguKilcXCkkL2ksd3JhcHBlZFZhbHVlQWxyZWFkeUV4dHJhY3RlZDogL1swLTkuXSsgWzAtOS5dKyBbMC05Ll0rKCBbMC05Ll0rKT8vLHZhbHVlU3BsaXQ6IC8oW0Etel0rXFwoLitcXCkpfCgoW0EtejAtOSMtLl0rPykoPz1cXHN8JCkpL2dpfSxMaXN0czoge2NvbG9yczogWyAnZmlsbCcsJ3N0cm9rZScsJ3N0b3BDb2xvcicsJ2NvbG9yJywnYmFja2dyb3VuZENvbG9yJywnYm9yZGVyQ29sb3InLCdib3JkZXJUb3BDb2xvcicsJ2JvcmRlclJpZ2h0Q29sb3InLCdib3JkZXJCb3R0b21Db2xvcicsJ2JvcmRlckxlZnRDb2xvcicsJ291dGxpbmVDb2xvcicgXSx0cmFuc2Zvcm1zQmFzZTogWyAndHJhbnNsYXRlWCcsJ3RyYW5zbGF0ZVknLCdzY2FsZScsJ3NjYWxlWCcsJ3NjYWxlWScsJ3NrZXdYJywnc2tld1knLCdyb3RhdGVaJyBdLHRyYW5zZm9ybXMzRDogWyAndHJhbnNmb3JtUGVyc3BlY3RpdmUnLCd0cmFuc2xhdGVaJywnc2NhbGVaJywncm90YXRlWCcsJ3JvdGF0ZVknIF0sdW5pdHM6IFsgJyUnLCdlbScsJ2V4JywnY2gnLCdyZW0nLCd2dycsJ3ZoJywndm1pbicsJ3ZtYXgnLCdjbScsJ21tJywnUScsJ2luJywncGMnLCdwdCcsJ3B4JywnZGVnJywnZ3JhZCcsJ3JhZCcsJ3R1cm4nLCdzJywnbXMnIF0sY29sb3JOYW1lczoge2FsaWNlYmx1ZTogJzI0MCwyNDgsMjU1JyxhbnRpcXVld2hpdGU6ICcyNTAsMjM1LDIxNScsYXF1YW1hcmluZTogJzEyNywyNTUsMjEyJyxhcXVhOiAnMCwyNTUsMjU1JyxhenVyZTogJzI0MCwyNTUsMjU1JyxiZWlnZTogJzI0NSwyNDUsMjIwJyxiaXNxdWU6ICcyNTUsMjI4LDE5NicsYmxhY2s6ICcwLDAsMCcsYmxhbmNoZWRhbG1vbmQ6ICcyNTUsMjM1LDIwNScsYmx1ZXZpb2xldDogJzEzOCw0MywyMjYnLGJsdWU6ICcwLDAsMjU1Jyxicm93bjogJzE2NSw0Miw0MicsYnVybHl3b29kOiAnMjIyLDE4NCwxMzUnLGNhZGV0Ymx1ZTogJzk1LDE1OCwxNjAnLGNoYXJ0cmV1c2U6ICcxMjcsMjU1LDAnLGNob2NvbGF0ZTogJzIxMCwxMDUsMzAnLGNvcmFsOiAnMjU1LDEyNyw4MCcsY29ybmZsb3dlcmJsdWU6ICcxMDAsMTQ5LDIzNycsY29ybnNpbGs6ICcyNTUsMjQ4LDIyMCcsY3JpbXNvbjogJzIyMCwyMCw2MCcsY3lhbjogJzAsMjU1LDI1NScsZGFya2JsdWU6ICcwLDAsMTM5JyxkYXJrY3lhbjogJzAsMTM5LDEzOScsZGFya2dvbGRlbnJvZDogJzE4NCwxMzQsMTEnLGRhcmtncmF5OiAnMTY5LDE2OSwxNjknLGRhcmtncmV5OiAnMTY5LDE2OSwxNjknLGRhcmtncmVlbjogJzAsMTAwLDAnLGRhcmtraGFraTogJzE4OSwxODMsMTA3JyxkYXJrbWFnZW50YTogJzEzOSwwLDEzOScsZGFya29saXZlZ3JlZW46ICc4NSwxMDcsNDcnLGRhcmtvcmFuZ2U6ICcyNTUsMTQwLDAnLGRhcmtvcmNoaWQ6ICcxNTMsNTAsMjA0JyxkYXJrcmVkOiAnMTM5LDAsMCcsZGFya3NhbG1vbjogJzIzMywxNTAsMTIyJyxkYXJrc2VhZ3JlZW46ICcxNDMsMTg4LDE0MycsZGFya3NsYXRlYmx1ZTogJzcyLDYxLDEzOScsZGFya3NsYXRlZ3JheTogJzQ3LDc5LDc5JyxkYXJrdHVycXVvaXNlOiAnMCwyMDYsMjA5JyxkYXJrdmlvbGV0OiAnMTQ4LDAsMjExJyxkZWVwcGluazogJzI1NSwyMCwxNDcnLGRlZXBza3libHVlOiAnMCwxOTEsMjU1JyxkaW1ncmF5OiAnMTA1LDEwNSwxMDUnLGRpbWdyZXk6ICcxMDUsMTA1LDEwNScsZG9kZ2VyYmx1ZTogJzMwLDE0NCwyNTUnLGZpcmVicmljazogJzE3OCwzNCwzNCcsZmxvcmFsd2hpdGU6ICcyNTUsMjUwLDI0MCcsZm9yZXN0Z3JlZW46ICczNCwxMzksMzQnLGZ1Y2hzaWE6ICcyNTUsMCwyNTUnLGdhaW5zYm9ybzogJzIyMCwyMjAsMjIwJyxnaG9zdHdoaXRlOiAnMjQ4LDI0OCwyNTUnLGdvbGQ6ICcyNTUsMjE1LDAnLGdvbGRlbnJvZDogJzIxOCwxNjUsMzInLGdyYXk6ICcxMjgsMTI4LDEyOCcsZ3JleTogJzEyOCwxMjgsMTI4JyxncmVlbnllbGxvdzogJzE3MywyNTUsNDcnLGdyZWVuOiAnMCwxMjgsMCcsaG9uZXlkZXc6ICcyNDAsMjU1LDI0MCcsaG90cGluazogJzI1NSwxMDUsMTgwJyxpbmRpYW5yZWQ6ICcyMDUsOTIsOTInLGluZGlnbzogJzc1LDAsMTMwJyxpdm9yeTogJzI1NSwyNTUsMjQwJyxraGFraTogJzI0MCwyMzAsMTQwJyxsYXZlbmRlcmJsdXNoOiAnMjU1LDI0MCwyNDUnLGxhdmVuZGVyOiAnMjMwLDIzMCwyNTAnLGxhd25ncmVlbjogJzEyNCwyNTIsMCcsbGVtb25jaGlmZm9uOiAnMjU1LDI1MCwyMDUnLGxpZ2h0Ymx1ZTogJzE3MywyMTYsMjMwJyxsaWdodGNvcmFsOiAnMjQwLDEyOCwxMjgnLGxpZ2h0Y3lhbjogJzIyNCwyNTUsMjU1JyxsaWdodGdvbGRlbnJvZHllbGxvdzogJzI1MCwyNTAsMjEwJyxsaWdodGdyYXk6ICcyMTEsMjExLDIxMScsbGlnaHRncmV5OiAnMjExLDIxMSwyMTEnLGxpZ2h0Z3JlZW46ICcxNDQsMjM4LDE0NCcsbGlnaHRwaW5rOiAnMjU1LDE4MiwxOTMnLGxpZ2h0c2FsbW9uOiAnMjU1LDE2MCwxMjInLGxpZ2h0c2VhZ3JlZW46ICczMiwxNzgsMTcwJyxsaWdodHNreWJsdWU6ICcxMzUsMjA2LDI1MCcsbGlnaHRzbGF0ZWdyYXk6ICcxMTksMTM2LDE1MycsbGlnaHRzdGVlbGJsdWU6ICcxNzYsMTk2LDIyMicsbGlnaHR5ZWxsb3c6ICcyNTUsMjU1LDIyNCcsbGltZWdyZWVuOiAnNTAsMjA1LDUwJyxsaW1lOiAnMCwyNTUsMCcsbGluZW46ICcyNTAsMjQwLDIzMCcsbWFnZW50YTogJzI1NSwwLDI1NScsbWFyb29uOiAnMTI4LDAsMCcsbWVkaXVtYXF1YW1hcmluZTogJzEwMiwyMDUsMTcwJyxtZWRpdW1ibHVlOiAnMCwwLDIwNScsbWVkaXVtb3JjaGlkOiAnMTg2LDg1LDIxMScsbWVkaXVtcHVycGxlOiAnMTQ3LDExMiwyMTknLG1lZGl1bXNlYWdyZWVuOiAnNjAsMTc5LDExMycsbWVkaXVtc2xhdGVibHVlOiAnMTIzLDEwNCwyMzgnLG1lZGl1bXNwcmluZ2dyZWVuOiAnMCwyNTAsMTU0JyxtZWRpdW10dXJxdW9pc2U6ICc3MiwyMDksMjA0JyxtZWRpdW12aW9sZXRyZWQ6ICcxOTksMjEsMTMzJyxtaWRuaWdodGJsdWU6ICcyNSwyNSwxMTInLG1pbnRjcmVhbTogJzI0NSwyNTUsMjUwJyxtaXN0eXJvc2U6ICcyNTUsMjI4LDIyNScsbW9jY2FzaW46ICcyNTUsMjI4LDE4MScsbmF2YWpvd2hpdGU6ICcyNTUsMjIyLDE3MycsbmF2eTogJzAsMCwxMjgnLG9sZGxhY2U6ICcyNTMsMjQ1LDIzMCcsb2xpdmVkcmFiOiAnMTA3LDE0MiwzNScsb2xpdmU6ICcxMjgsMTI4LDAnLG9yYW5nZXJlZDogJzI1NSw2OSwwJyxvcmFuZ2U6ICcyNTUsMTY1LDAnLG9yY2hpZDogJzIxOCwxMTIsMjE0JyxwYWxlZ29sZGVucm9kOiAnMjM4LDIzMiwxNzAnLHBhbGVncmVlbjogJzE1MiwyNTEsMTUyJyxwYWxldHVycXVvaXNlOiAnMTc1LDIzOCwyMzgnLHBhbGV2aW9sZXRyZWQ6ICcyMTksMTEyLDE0NycscGFwYXlhd2hpcDogJzI1NSwyMzksMjEzJyxwZWFjaHB1ZmY6ICcyNTUsMjE4LDE4NScscGVydTogJzIwNSwxMzMsNjMnLHBpbms6ICcyNTUsMTkyLDIwMycscGx1bTogJzIyMSwxNjAsMjIxJyxwb3dkZXJibHVlOiAnMTc2LDIyNCwyMzAnLHB1cnBsZTogJzEyOCwwLDEyOCcscmVkOiAnMjU1LDAsMCcscm9zeWJyb3duOiAnMTg4LDE0MywxNDMnLHJveWFsYmx1ZTogJzY1LDEwNSwyMjUnLHNhZGRsZWJyb3duOiAnMTM5LDY5LDE5JyxzYWxtb246ICcyNTAsMTI4LDExNCcsc2FuZHlicm93bjogJzI0NCwxNjQsOTYnLHNlYWdyZWVuOiAnNDYsMTM5LDg3JyxzZWFzaGVsbDogJzI1NSwyNDUsMjM4JyxzaWVubmE6ICcxNjAsODIsNDUnLHNpbHZlcjogJzE5MiwxOTIsMTkyJyxza3libHVlOiAnMTM1LDIwNiwyMzUnLHNsYXRlYmx1ZTogJzEwNiw5MCwyMDUnLHNsYXRlZ3JheTogJzExMiwxMjgsMTQ0Jyxzbm93OiAnMjU1LDI1MCwyNTAnLHNwcmluZ2dyZWVuOiAnMCwyNTUsMTI3JyxzdGVlbGJsdWU6ICc3MCwxMzAsMTgwJyx0YW46ICcyMTAsMTgwLDE0MCcsdGVhbDogJzAsMTI4LDEyOCcsdGhpc3RsZTogJzIxNiwxOTEsMjE2Jyx0b21hdG86ICcyNTUsOTksNzEnLHR1cnF1b2lzZTogJzY0LDIyNCwyMDgnLHZpb2xldDogJzIzOCwxMzAsMjM4Jyx3aGVhdDogJzI0NSwyMjIsMTc5Jyx3aGl0ZXNtb2tlOiAnMjQ1LDI0NSwyNDUnLHdoaXRlOiAnMjU1LDI1NSwyNTUnLHllbGxvd2dyZWVuOiAnMTU0LDIwNSw1MCcseWVsbG93OiAnMjU1LDI1NSwwJ319LEhvb2tzOiB7dGVtcGxhdGVzOiB7dGV4dFNoYWRvdzogWyAnQ29sb3IgWCBZIEJsdXInLCdibGFjayAwcHggMHB4IDBweCcgXSxib3hTaGFkb3c6IFsgJ0NvbG9yIFggWSBCbHVyIFNwcmVhZCcsJ2JsYWNrIDBweCAwcHggMHB4IDBweCcgXSxjbGlwOiBbICdUb3AgUmlnaHQgQm90dG9tIExlZnQnLCcwcHggMHB4IDBweCAwcHgnIF0sYmFja2dyb3VuZFBvc2l0aW9uOiBbICdYIFknLCcwJSAwJScgXSx0cmFuc2Zvcm1PcmlnaW46IFsgJ1ggWSBaJywnNTAlIDUwJSAwcHgnIF0scGVyc3BlY3RpdmVPcmlnaW46IFsgJ1ggWScsJzUwJSA1MCUnIF19LHJlZ2lzdGVyZWQ6IHt9LHJlZ2lzdGVyOiBmdW5jdGlvbigpIHtcbmZvciAoIHZhciBhPTA7YTxBLkxpc3RzLmNvbG9ycy5sZW5ndGg7YSsrICkge1xudmFyIGI9J2NvbG9yJz09PUEuTGlzdHMuY29sb3JzWyBhIF0/JzAgMCAwIDEnOicyNTUgMjU1IDI1NSAxJztBLkhvb2tzLnRlbXBsYXRlc1sgQS5MaXN0cy5jb2xvcnNbIGEgXSBdPVsgJ1JlZCBHcmVlbiBCbHVlIEFscGhhJyxiIF07XG59IHZhciBjLGQsZTtpZiAoIHAgKSB7XG5mb3IgKCBjIGluIEEuSG9va3MudGVtcGxhdGVzICkge1xuaWYgKCBBLkhvb2tzLnRlbXBsYXRlcy5oYXNPd25Qcm9wZXJ0eSggYyApICkge1xuZD1BLkhvb2tzLnRlbXBsYXRlc1sgYyBdLGU9ZFsgMCBdLnNwbGl0KCAnICcgKTt2YXIgZj1kWyAxIF0ubWF0Y2goIEEuUmVnRXgudmFsdWVTcGxpdCApOydDb2xvcic9PT1lWyAwIF0mJiggZS5wdXNoKCBlLnNoaWZ0KCkgKSxmLnB1c2goIGYuc2hpZnQoKSApLEEuSG9va3MudGVtcGxhdGVzWyBjIF09WyBlLmpvaW4oICcgJyApLGYuam9pbiggJyAnICkgXSApO1xufVxufVxufSBmb3IgKCBjIGluIEEuSG9va3MudGVtcGxhdGVzICkge1xuaWYgKCBBLkhvb2tzLnRlbXBsYXRlcy5oYXNPd25Qcm9wZXJ0eSggYyApICkge1xuZD1BLkhvb2tzLnRlbXBsYXRlc1sgYyBdLGU9ZFsgMCBdLnNwbGl0KCAnICcgKTtmb3IgKCB2YXIgZyBpbiBlICkge1xuaWYgKCBlLmhhc093blByb3BlcnR5KCBnICkgKSB7XG52YXIgaD1jK2VbIGcgXSxpPWc7QS5Ib29rcy5yZWdpc3RlcmVkWyBoIF09WyBjLGkgXTtcbn1cbn1cbn1cbn1cbn0sZ2V0Um9vdDogZnVuY3Rpb24oIGEgKSB7XG52YXIgYj1BLkhvb2tzLnJlZ2lzdGVyZWRbIGEgXTtyZXR1cm4gYj9iWyAwIF06YTtcbn0sZ2V0VW5pdDogZnVuY3Rpb24oIGEsYiApIHtcbnZhciBjPSggYS5zdWJzdHIoIGJ8fDAsNSApLm1hdGNoKCAvXlthLXolXSsvICl8fFtdIClbIDAgXXx8Jyc7cmV0dXJuIGMmJnQoIEEuTGlzdHMudW5pdHMsYyApP2M6Jyc7XG59LGZpeENvbG9yczogZnVuY3Rpb24oIGEgKSB7XG5yZXR1cm4gYS5yZXBsYWNlKCAvKHJnYmE/XFwoXFxzKik/KFxcYlthLXpdK1xcYikvZyxmdW5jdGlvbiggYSxiLGMgKSB7XG5yZXR1cm4gQS5MaXN0cy5jb2xvck5hbWVzLmhhc093blByb3BlcnR5KCBjICk/KCBifHwncmdiYSgnICkrQS5MaXN0cy5jb2xvck5hbWVzWyBjIF0rKCBiPycnOicsMSknICk6YitjO1xufSApO1xufSxjbGVhblJvb3RQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbiggYSxiICkge1xucmV0dXJuIEEuUmVnRXgudmFsdWVVbndyYXAudGVzdCggYiApJiYoIGI9Yi5tYXRjaCggQS5SZWdFeC52YWx1ZVVud3JhcCApWyAxIF0gKSxBLlZhbHVlcy5pc0NTU051bGxWYWx1ZSggYiApJiYoIGI9QS5Ib29rcy50ZW1wbGF0ZXNbIGEgXVsgMSBdICksYjtcbn0sZXh0cmFjdFZhbHVlOiBmdW5jdGlvbiggYSxiICkge1xudmFyIGM9QS5Ib29rcy5yZWdpc3RlcmVkWyBhIF07aWYgKCBjICkge1xudmFyIGQ9Y1sgMCBdLGU9Y1sgMSBdO3JldHVybiBiPUEuSG9va3MuY2xlYW5Sb290UHJvcGVydHlWYWx1ZSggZCxiICksYi50b1N0cmluZygpLm1hdGNoKCBBLlJlZ0V4LnZhbHVlU3BsaXQgKVsgZSBdO1xufSByZXR1cm4gYjtcbn0saW5qZWN0VmFsdWU6IGZ1bmN0aW9uKCBhLGIsYyApIHtcbnZhciBkPUEuSG9va3MucmVnaXN0ZXJlZFsgYSBdO2lmICggZCApIHtcbnZhciBlLGY9ZFsgMCBdLGc9ZFsgMSBdO3JldHVybiBjPUEuSG9va3MuY2xlYW5Sb290UHJvcGVydHlWYWx1ZSggZixjICksZT1jLnRvU3RyaW5nKCkubWF0Y2goIEEuUmVnRXgudmFsdWVTcGxpdCApLGVbIGcgXT1iLGUuam9pbiggJyAnICk7XG59IHJldHVybiBjO1xufX0sTm9ybWFsaXphdGlvbnM6IHtyZWdpc3RlcmVkOiB7Y2xpcDogZnVuY3Rpb24oIGEsYixjICkge1xuc3dpdGNoICggYSApIHtcbmNhc2UgJ25hbWUnOiByZXR1cm4gJ2NsaXAnO2Nhc2UgJ2V4dHJhY3QnOiB2YXIgZDtyZXR1cm4gQS5SZWdFeC53cmFwcGVkVmFsdWVBbHJlYWR5RXh0cmFjdGVkLnRlc3QoIGMgKT9kPWM6KCBkPWMudG9TdHJpbmcoKS5tYXRjaCggQS5SZWdFeC52YWx1ZVVud3JhcCApLGQ9ZD9kWyAxIF0ucmVwbGFjZSggLywoXFxzKyk/L2csJyAnICk6YyApLGQ7Y2FzZSAnaW5qZWN0JzogcmV0dXJuICdyZWN0KCcrYysnKSc7XG59XG59LGJsdXI6IGZ1bmN0aW9uKCBhLGIsYyApIHtcbnN3aXRjaCAoIGEgKSB7XG5jYXNlICduYW1lJzogcmV0dXJuIHkuU3RhdGUuaXNGaXJlZm94PydmaWx0ZXInOictd2Via2l0LWZpbHRlcic7Y2FzZSAnZXh0cmFjdCc6IHZhciBkPXBhcnNlRmxvYXQoIGMgKTtpZiAoICFkJiYwIT09ZCApIHtcbnZhciBlPWMudG9TdHJpbmcoKS5tYXRjaCggL2JsdXJcXCgoWzAtOV0rW0Etel0rKVxcKS9pICk7ZD1lP2VbIDEgXTowO1xufSByZXR1cm4gZDtjYXNlICdpbmplY3QnOiByZXR1cm4gcGFyc2VGbG9hdCggYyApPydibHVyKCcrYysnKSc6J25vbmUnO1xufVxufSxvcGFjaXR5OiBmdW5jdGlvbiggYSxiLGMgKSB7XG5pZiAoIHA8PTggKSB7XG5zd2l0Y2ggKCBhICkge1xuY2FzZSAnbmFtZSc6IHJldHVybiAnZmlsdGVyJztjYXNlICdleHRyYWN0JzogdmFyIGQ9Yy50b1N0cmluZygpLm1hdGNoKCAvYWxwaGFcXChvcGFjaXR5PSguKilcXCkvaSApO3JldHVybiBjPWQ/ZFsgMSBdLzEwMDoxO2Nhc2UgJ2luamVjdCc6IHJldHVybiBiLnN0eWxlLnpvb209MSxwYXJzZUZsb2F0KCBjICk+PTE/Jyc6J2FscGhhKG9wYWNpdHk9JytwYXJzZUludCggMTAwKnBhcnNlRmxvYXQoIGMgKSwxMCApKycpJztcbn1cbn0gZWxzZSB7XG5zd2l0Y2ggKCBhICkge1xuY2FzZSAnbmFtZSc6IHJldHVybiAnb3BhY2l0eSc7Y2FzZSAnZXh0cmFjdCc6IGNhc2UgJ2luamVjdCc6IHJldHVybiBjO1xufVxufVxufX0scmVnaXN0ZXI6IGZ1bmN0aW9uKCkge1xuZnVuY3Rpb24gYSggYSxiLGMgKSB7XG5pZiAoICdib3JkZXItYm94Jz09PUEuZ2V0UHJvcGVydHlWYWx1ZSggYiwnYm94U2l6aW5nJyApLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKT09PSggY3x8ITEgKSApIHtcbnZhciBkLGUsZj0wLGc9J3dpZHRoJz09PWE/WyAnTGVmdCcsJ1JpZ2h0JyBdOlsgJ1RvcCcsJ0JvdHRvbScgXSxoPVsgJ3BhZGRpbmcnK2dbIDAgXSwncGFkZGluZycrZ1sgMSBdLCdib3JkZXInK2dbIDAgXSsnV2lkdGgnLCdib3JkZXInK2dbIDEgXSsnV2lkdGgnIF07Zm9yICggZD0wO2Q8aC5sZW5ndGg7ZCsrICkge1xuZT1wYXJzZUZsb2F0KCBBLmdldFByb3BlcnR5VmFsdWUoIGIsaFsgZCBdICkgKSxpc05hTiggZSApfHwoIGYrPWUgKTtcbn0gcmV0dXJuIGM/LWY6Zjtcbn0gcmV0dXJuIDA7XG59IGZ1bmN0aW9uIGIoIGIsYyApIHtcbnJldHVybiBmdW5jdGlvbiggZCxlLGYgKSB7XG5zd2l0Y2ggKCBkICkge1xuY2FzZSAnbmFtZSc6IHJldHVybiBiO2Nhc2UgJ2V4dHJhY3QnOiByZXR1cm4gcGFyc2VGbG9hdCggZiApK2EoIGIsZSxjICk7Y2FzZSAnaW5qZWN0JzogcmV0dXJuIHBhcnNlRmxvYXQoIGYgKS1hKCBiLGUsYyApKydweCc7XG59XG59O1xufXAmJiEoIHA+OSApfHx5LlN0YXRlLmlzR2luZ2VyYnJlYWR8fCggQS5MaXN0cy50cmFuc2Zvcm1zQmFzZT1BLkxpc3RzLnRyYW5zZm9ybXNCYXNlLmNvbmNhdCggQS5MaXN0cy50cmFuc2Zvcm1zM0QgKSApO2ZvciAoIHZhciBjPTA7YzxBLkxpc3RzLnRyYW5zZm9ybXNCYXNlLmxlbmd0aDtjKysgKSB7XG4hZnVuY3Rpb24oKSB7XG52YXIgYT1BLkxpc3RzLnRyYW5zZm9ybXNCYXNlWyBjIF07QS5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkWyBhIF09ZnVuY3Rpb24oIGIsYyxlICkge1xuc3dpdGNoICggYiApIHtcbmNhc2UgJ25hbWUnOiByZXR1cm4gJ3RyYW5zZm9ybSc7Y2FzZSAnZXh0cmFjdCc6IHJldHVybiBnKCBjICk9PT1kfHxnKCBjICkudHJhbnNmb3JtQ2FjaGVbIGEgXT09PWQ/L15zY2FsZS9pLnRlc3QoIGEgKT8xOjA6ZyggYyApLnRyYW5zZm9ybUNhY2hlWyBhIF0ucmVwbGFjZSggL1soKV0vZywnJyApO2Nhc2UgJ2luamVjdCc6IHZhciBmPSExO3N3aXRjaCAoIGEuc3Vic3RyKCAwLGEubGVuZ3RoLTEgKSApIHtcbmNhc2UgJ3RyYW5zbGF0ZSc6IGY9IS8oJXxweHxlbXxyZW18dnd8dmh8XFxkKSQvaS50ZXN0KCBlICk7YnJlYWs7Y2FzZSAnc2NhbCc6IGNhc2UgJ3NjYWxlJzogeS5TdGF0ZS5pc0FuZHJvaWQmJmcoIGMgKS50cmFuc2Zvcm1DYWNoZVsgYSBdPT09ZCYmZTwxJiYoIGU9MSApLGY9IS8oXFxkKSQvaS50ZXN0KCBlICk7YnJlYWs7Y2FzZSAnc2tldyc6IGNhc2UgJ3JvdGF0ZSc6IGY9IS8oZGVnfFxcZCkkL2kudGVzdCggZSApO1xufSByZXR1cm4gZnx8KCBnKCBjICkudHJhbnNmb3JtQ2FjaGVbIGEgXT0nKCcrZSsnKScgKSxnKCBjICkudHJhbnNmb3JtQ2FjaGVbIGEgXTtcbn1cbn07XG59KCk7XG59IGZvciAoIHZhciBlPTA7ZTxBLkxpc3RzLmNvbG9ycy5sZW5ndGg7ZSsrICkge1xuIWZ1bmN0aW9uKCkge1xudmFyIGE9QS5MaXN0cy5jb2xvcnNbIGUgXTtBLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbIGEgXT1mdW5jdGlvbiggYixjLGUgKSB7XG5zd2l0Y2ggKCBiICkge1xuY2FzZSAnbmFtZSc6IHJldHVybiBhO2Nhc2UgJ2V4dHJhY3QnOiB2YXIgZjtpZiAoIEEuUmVnRXgud3JhcHBlZFZhbHVlQWxyZWFkeUV4dHJhY3RlZC50ZXN0KCBlICkgKSB7XG5mPWU7XG59IGVsc2Uge1xudmFyIGcsaD17YmxhY2s6ICdyZ2IoMCwgMCwgMCknLGJsdWU6ICdyZ2IoMCwgMCwgMjU1KScsZ3JheTogJ3JnYigxMjgsIDEyOCwgMTI4KScsZ3JlZW46ICdyZ2IoMCwgMTI4LCAwKScscmVkOiAncmdiKDI1NSwgMCwgMCknLHdoaXRlOiAncmdiKDI1NSwgMjU1LCAyNTUpJ307L15bQS16XSskL2kudGVzdCggZSApP2c9aFsgZSBdIT09ZD9oWyBlIF06aC5ibGFjazpBLlJlZ0V4LmlzSGV4LnRlc3QoIGUgKT9nPSdyZ2IoJytBLlZhbHVlcy5oZXhUb1JnYiggZSApLmpvaW4oICcgJyApKycpJzovXnJnYmE/XFwoL2kudGVzdCggZSApfHwoIGc9aC5ibGFjayApLGY9KCBnfHxlICkudG9TdHJpbmcoKS5tYXRjaCggQS5SZWdFeC52YWx1ZVVud3JhcCApWyAxIF0ucmVwbGFjZSggLywoXFxzKyk/L2csJyAnICk7XG59IHJldHVybiAoICFwfHxwPjggKSYmMz09PWYuc3BsaXQoICcgJyApLmxlbmd0aCYmKCBmKz0nIDEnICksZjtjYXNlICdpbmplY3QnOiByZXR1cm4gL15yZ2IvLnRlc3QoIGUgKT9lOiggcDw9OD80PT09ZS5zcGxpdCggJyAnICkubGVuZ3RoJiYoIGU9ZS5zcGxpdCggL1xccysvICkuc2xpY2UoIDAsMyApLmpvaW4oICcgJyApICk6Mz09PWUuc3BsaXQoICcgJyApLmxlbmd0aCYmKCBlKz0nIDEnICksKCBwPD04PydyZ2InOidyZ2JhJyApKycoJytlLnJlcGxhY2UoIC9cXHMrL2csJywnICkucmVwbGFjZSggL1xcLihcXGQpKyg/PSwpL2csJycgKSsnKScgKTtcbn1cbn07XG59KCk7XG59QS5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkLmlubmVyV2lkdGg9YiggJ3dpZHRoJywhMCApLEEuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZC5pbm5lckhlaWdodD1iKCAnaGVpZ2h0JywhMCApLEEuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZC5vdXRlcldpZHRoPWIoICd3aWR0aCcgKSxBLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWQub3V0ZXJIZWlnaHQ9YiggJ2hlaWdodCcgKTtcbn19LE5hbWVzOiB7Y2FtZWxDYXNlOiBmdW5jdGlvbiggYSApIHtcbnJldHVybiBhLnJlcGxhY2UoIC8tKFxcdykvZyxmdW5jdGlvbiggYSxiICkge1xucmV0dXJuIGIudG9VcHBlckNhc2UoKTtcbn0gKTtcbn0sU1ZHQXR0cmlidXRlOiBmdW5jdGlvbiggYSApIHtcbnZhciBiPSd3aWR0aHxoZWlnaHR8eHx5fGN4fGN5fHJ8cnh8cnl8eDF8eDJ8eTF8eTInO3JldHVybiAoIHB8fHkuU3RhdGUuaXNBbmRyb2lkJiYheS5TdGF0ZS5pc0Nocm9tZSApJiYoIGIrPSd8dHJhbnNmb3JtJyApLG5ldyBSZWdFeHAoICdeKCcrYisnKSQnLCdpJyApLnRlc3QoIGEgKTtcbn0scHJlZml4Q2hlY2s6IGZ1bmN0aW9uKCBhICkge1xuaWYgKCB5LlN0YXRlLnByZWZpeE1hdGNoZXNbIGEgXSApIHtcbnJldHVybiBbIHkuU3RhdGUucHJlZml4TWF0Y2hlc1sgYSBdLCEwIF07XG59IGZvciAoIHZhciBiPVsgJycsJ1dlYmtpdCcsJ01veicsJ21zJywnTycgXSxjPTAsZD1iLmxlbmd0aDtjPGQ7YysrICkge1xudmFyIGU7aWYgKCBlPTA9PT1jP2E6YlsgYyBdK2EucmVwbGFjZSggL15cXHcvLGZ1bmN0aW9uKCBhICkge1xucmV0dXJuIGEudG9VcHBlckNhc2UoKTtcbn0gKSx1LmlzU3RyaW5nKCB5LlN0YXRlLnByZWZpeEVsZW1lbnQuc3R5bGVbIGUgXSApICkge1xucmV0dXJuIHkuU3RhdGUucHJlZml4TWF0Y2hlc1sgYSBdPWUsWyBlLCEwIF07XG59XG59IHJldHVybiBbIGEsITEgXTtcbn19LFZhbHVlczoge2hleFRvUmdiOiBmdW5jdGlvbiggYSApIHtcbnZhciBiLGM9L14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaSxkPS9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7cmV0dXJuIGE9YS5yZXBsYWNlKCBjLGZ1bmN0aW9uKCBhLGIsYyxkICkge1xucmV0dXJuIGIrYitjK2MrZCtkO1xufSApLGI9ZC5leGVjKCBhICksYj9bIHBhcnNlSW50KCBiWyAxIF0sMTYgKSxwYXJzZUludCggYlsgMiBdLDE2ICkscGFyc2VJbnQoIGJbIDMgXSwxNiApIF06WyAwLDAsMCBdO1xufSxpc0NTU051bGxWYWx1ZTogZnVuY3Rpb24oIGEgKSB7XG5yZXR1cm4gIWF8fC9eKG5vbmV8YXV0b3x0cmFuc3BhcmVudHwocmdiYVxcKDAsID8wLCA/MCwgPzBcXCkpKSQvaS50ZXN0KCBhICk7XG59LGdldFVuaXRUeXBlOiBmdW5jdGlvbiggYSApIHtcbnJldHVybiAvXihyb3RhdGV8c2tldykvaS50ZXN0KCBhICk/J2RlZyc6LyheKHNjYWxlfHNjYWxlWHxzY2FsZVl8c2NhbGVafGFscGhhfGZsZXhHcm93fGZsZXhIZWlnaHR8ekluZGV4fGZvbnRXZWlnaHQpJCl8KChvcGFjaXR5fHJlZHxncmVlbnxibHVlfGFscGhhKSQpL2kudGVzdCggYSApPycnOidweCc7XG59LGdldERpc3BsYXlUeXBlOiBmdW5jdGlvbiggYSApIHtcbnZhciBiPWEmJmEudGFnTmFtZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7cmV0dXJuIC9eKGJ8YmlnfGl8c21hbGx8dHR8YWJicnxhY3JvbnltfGNpdGV8Y29kZXxkZm58ZW18a2JkfHN0cm9uZ3xzYW1wfHZhcnxhfGJkb3xicnxpbWd8bWFwfG9iamVjdHxxfHNjcmlwdHxzcGFufHN1YnxzdXB8YnV0dG9ufGlucHV0fGxhYmVsfHNlbGVjdHx0ZXh0YXJlYSkkL2kudGVzdCggYiApPydpbmxpbmUnOi9eKGxpKSQvaS50ZXN0KCBiICk/J2xpc3QtaXRlbSc6L14odHIpJC9pLnRlc3QoIGIgKT8ndGFibGUtcm93JzovXih0YWJsZSkkL2kudGVzdCggYiApPyd0YWJsZSc6L14odGJvZHkpJC9pLnRlc3QoIGIgKT8ndGFibGUtcm93LWdyb3VwJzonYmxvY2snO1xufSxhZGRDbGFzczogZnVuY3Rpb24oIGEsYiApIHtcbmlmICggYSApIHtcbmlmICggYS5jbGFzc0xpc3QgKSB7XG5hLmNsYXNzTGlzdC5hZGQoIGIgKTtcbn0gZWxzZSBpZiAoIHUuaXNTdHJpbmcoIGEuY2xhc3NOYW1lICkgKSB7XG5hLmNsYXNzTmFtZSs9KCBhLmNsYXNzTmFtZS5sZW5ndGg/JyAnOicnICkrYjtcbn0gZWxzZSB7XG52YXIgYz1hLmdldEF0dHJpYnV0ZSggcDw9Nz8nY2xhc3NOYW1lJzonY2xhc3MnICl8fCcnO2Euc2V0QXR0cmlidXRlKCAnY2xhc3MnLGMrKCBjPycgJzonJyApK2IgKTtcbn1cbn1cbn0scmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCBhLGIgKSB7XG5pZiAoIGEgKSB7XG5pZiAoIGEuY2xhc3NMaXN0ICkge1xuYS5jbGFzc0xpc3QucmVtb3ZlKCBiICk7XG59IGVsc2UgaWYgKCB1LmlzU3RyaW5nKCBhLmNsYXNzTmFtZSApICkge1xuYS5jbGFzc05hbWU9YS5jbGFzc05hbWUudG9TdHJpbmcoKS5yZXBsYWNlKCBuZXcgUmVnRXhwKCAnKF58XFxcXHMpJytiLnNwbGl0KCAnICcgKS5qb2luKCAnfCcgKSsnKFxcXFxzfCQpJywnZ2knICksJyAnICk7XG59IGVsc2Uge1xudmFyIGM9YS5nZXRBdHRyaWJ1dGUoIHA8PTc/J2NsYXNzTmFtZSc6J2NsYXNzJyApfHwnJzthLnNldEF0dHJpYnV0ZSggJ2NsYXNzJyxjLnJlcGxhY2UoIG5ldyBSZWdFeHAoICcoXnxzKScrYi5zcGxpdCggJyAnICkuam9pbiggJ3wnICkrJyhzfCQpJywnZ2knICksJyAnICkgKTtcbn1cbn1cbn19LGdldFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uKCBhLGMsZSxmICkge1xuZnVuY3Rpb24gaCggYSxjICkge1xudmFyIGU9MDtpZiAoIHA8PTggKSB7XG5lPW8uY3NzKCBhLGMgKTtcbn0gZWxzZSB7XG52YXIgaT0hMTsvXih3aWR0aHxoZWlnaHQpJC8udGVzdCggYyApJiYwPT09QS5nZXRQcm9wZXJ0eVZhbHVlKCBhLCdkaXNwbGF5JyApJiYoIGk9ITAsQS5zZXRQcm9wZXJ0eVZhbHVlKCBhLCdkaXNwbGF5JyxBLlZhbHVlcy5nZXREaXNwbGF5VHlwZSggYSApICkgKTt2YXIgaj1mdW5jdGlvbigpIHtcbmkmJkEuc2V0UHJvcGVydHlWYWx1ZSggYSwnZGlzcGxheScsJ25vbmUnICk7XG59O2lmICggIWYgKSB7XG5pZiAoICdoZWlnaHQnPT09YyYmJ2JvcmRlci1ib3gnIT09QS5nZXRQcm9wZXJ0eVZhbHVlKCBhLCdib3hTaXppbmcnICkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpICkge1xudmFyIGs9YS5vZmZzZXRIZWlnaHQtKCBwYXJzZUZsb2F0KCBBLmdldFByb3BlcnR5VmFsdWUoIGEsJ2JvcmRlclRvcFdpZHRoJyApICl8fDAgKS0oIHBhcnNlRmxvYXQoIEEuZ2V0UHJvcGVydHlWYWx1ZSggYSwnYm9yZGVyQm90dG9tV2lkdGgnICkgKXx8MCApLSggcGFyc2VGbG9hdCggQS5nZXRQcm9wZXJ0eVZhbHVlKCBhLCdwYWRkaW5nVG9wJyApICl8fDAgKS0oIHBhcnNlRmxvYXQoIEEuZ2V0UHJvcGVydHlWYWx1ZSggYSwncGFkZGluZ0JvdHRvbScgKSApfHwwICk7cmV0dXJuIGooKSxrO1xufSBpZiAoICd3aWR0aCc9PT1jJiYnYm9yZGVyLWJveCchPT1BLmdldFByb3BlcnR5VmFsdWUoIGEsJ2JveFNpemluZycgKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgKSB7XG52YXIgbD1hLm9mZnNldFdpZHRoLSggcGFyc2VGbG9hdCggQS5nZXRQcm9wZXJ0eVZhbHVlKCBhLCdib3JkZXJMZWZ0V2lkdGgnICkgKXx8MCApLSggcGFyc2VGbG9hdCggQS5nZXRQcm9wZXJ0eVZhbHVlKCBhLCdib3JkZXJSaWdodFdpZHRoJyApICl8fDAgKS0oIHBhcnNlRmxvYXQoIEEuZ2V0UHJvcGVydHlWYWx1ZSggYSwncGFkZGluZ0xlZnQnICkgKXx8MCApLSggcGFyc2VGbG9hdCggQS5nZXRQcm9wZXJ0eVZhbHVlKCBhLCdwYWRkaW5nUmlnaHQnICkgKXx8MCApO3JldHVybiBqKCksbDtcbn1cbn0gdmFyIG07bT1nKCBhICk9PT1kP2IuZ2V0Q29tcHV0ZWRTdHlsZSggYSxudWxsICk6ZyggYSApLmNvbXB1dGVkU3R5bGU/ZyggYSApLmNvbXB1dGVkU3R5bGU6ZyggYSApLmNvbXB1dGVkU3R5bGU9Yi5nZXRDb21wdXRlZFN0eWxlKCBhLG51bGwgKSwnYm9yZGVyQ29sb3InPT09YyYmKCBjPSdib3JkZXJUb3BDb2xvcicgKSxlPTk9PT1wJiYnZmlsdGVyJz09PWM/bS5nZXRQcm9wZXJ0eVZhbHVlKCBjICk6bVsgYyBdLCcnIT09ZSYmbnVsbCE9PWV8fCggZT1hLnN0eWxlWyBjIF0gKSxqKCk7XG59IGlmICggJ2F1dG8nPT09ZSYmL14odG9wfHJpZ2h0fGJvdHRvbXxsZWZ0KSQvaS50ZXN0KCBjICkgKSB7XG52YXIgbj1oKCBhLCdwb3NpdGlvbicgKTsoICdmaXhlZCc9PT1ufHwnYWJzb2x1dGUnPT09biYmL3RvcHxsZWZ0L2kudGVzdCggYyApICkmJiggZT1vKCBhICkucG9zaXRpb24oKVsgYyBdKydweCcgKTtcbn0gcmV0dXJuIGU7XG59IHZhciBpO2lmICggQS5Ib29rcy5yZWdpc3RlcmVkWyBjIF0gKSB7XG52YXIgaj1jLGs9QS5Ib29rcy5nZXRSb290KCBqICk7ZT09PWQmJiggZT1BLmdldFByb3BlcnR5VmFsdWUoIGEsQS5OYW1lcy5wcmVmaXhDaGVjayggayApWyAwIF0gKSApLEEuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFsgayBdJiYoIGU9QS5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkWyBrIF0oICdleHRyYWN0JyxhLGUgKSApLGk9QS5Ib29rcy5leHRyYWN0VmFsdWUoIGosZSApO1xufSBlbHNlIGlmICggQS5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkWyBjIF0gKSB7XG52YXIgbCxtO2w9QS5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkWyBjIF0oICduYW1lJyxhICksJ3RyYW5zZm9ybSchPT1sJiYoIG09aCggYSxBLk5hbWVzLnByZWZpeENoZWNrKCBsIClbIDAgXSApLEEuVmFsdWVzLmlzQ1NTTnVsbFZhbHVlKCBtICkmJkEuSG9va3MudGVtcGxhdGVzWyBjIF0mJiggbT1BLkhvb2tzLnRlbXBsYXRlc1sgYyBdWyAxIF0gKSApLGk9QS5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkWyBjIF0oICdleHRyYWN0JyxhLG0gKTtcbn0gaWYgKCAhL15bXFxkLV0vLnRlc3QoIGkgKSApIHtcbnZhciBuPWcoIGEgKTtpZiAoIG4mJm4uaXNTVkcmJkEuTmFtZXMuU1ZHQXR0cmlidXRlKCBjICkgKSB7XG5pZiAoIC9eKGhlaWdodHx3aWR0aCkkL2kudGVzdCggYyApICkge1xudHJ5IHtcbmk9YS5nZXRCQm94KClbIGMgXTtcbn0gY2F0Y2ggKCBxICkge1xuaT0wO1xufVxufSBlbHNlIHtcbmk9YS5nZXRBdHRyaWJ1dGUoIGMgKTtcbn1cbn0gZWxzZSB7XG5pPWgoIGEsQS5OYW1lcy5wcmVmaXhDaGVjayggYyApWyAwIF0gKTtcbn1cbn0gcmV0dXJuIEEuVmFsdWVzLmlzQ1NTTnVsbFZhbHVlKCBpICkmJiggaT0wICkseS5kZWJ1Zz49MiYmY29uc29sZS5sb2coICdHZXQgJytjKyc6ICcraSApLGk7XG59LHNldFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uKCBhLGMsZCxlLGYgKSB7XG52YXIgaD1jO2lmICggJ3Njcm9sbCc9PT1jICkge1xuZi5jb250YWluZXI/Zi5jb250YWluZXJbICdzY3JvbGwnK2YuZGlyZWN0aW9uIF09ZDonTGVmdCc9PT1mLmRpcmVjdGlvbj9iLnNjcm9sbFRvKCBkLGYuYWx0ZXJuYXRlVmFsdWUgKTpiLnNjcm9sbFRvKCBmLmFsdGVybmF0ZVZhbHVlLGQgKTtcbn0gZWxzZSBpZiAoIEEuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFsgYyBdJiYndHJhbnNmb3JtJz09PUEuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFsgYyBdKCAnbmFtZScsYSApICkge1xuQS5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkWyBjIF0oICdpbmplY3QnLGEsZCApLGg9J3RyYW5zZm9ybScsZD1nKCBhICkudHJhbnNmb3JtQ2FjaGVbIGMgXTtcbn0gZWxzZSB7XG5pZiAoIEEuSG9va3MucmVnaXN0ZXJlZFsgYyBdICkge1xudmFyIGk9YyxqPUEuSG9va3MuZ2V0Um9vdCggYyApO2U9ZXx8QS5nZXRQcm9wZXJ0eVZhbHVlKCBhLGogKSxkPUEuSG9va3MuaW5qZWN0VmFsdWUoIGksZCxlICksYz1qO1xufSBpZiAoIEEuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFsgYyBdJiYoIGQ9QS5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkWyBjIF0oICdpbmplY3QnLGEsZCApLGM9QS5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkWyBjIF0oICduYW1lJyxhICkgKSxoPUEuTmFtZXMucHJlZml4Q2hlY2soIGMgKVsgMCBdLHA8PTggKSB7XG50cnkge1xuYS5zdHlsZVsgaCBdPWQ7XG59IGNhdGNoICggbCApIHtcbnkuZGVidWcmJmNvbnNvbGUubG9nKCAnQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFsnK2QrJ10gZm9yIFsnK2grJ10nICk7XG59XG59IGVsc2Uge1xudmFyIGs9ZyggYSApO2smJmsuaXNTVkcmJkEuTmFtZXMuU1ZHQXR0cmlidXRlKCBjICk/YS5zZXRBdHRyaWJ1dGUoIGMsZCApOmEuc3R5bGVbIGggXT1kO1xufXkuZGVidWc+PTImJmNvbnNvbGUubG9nKCAnU2V0ICcrYysnICgnK2grJyk6ICcrZCApO1xufSByZXR1cm4gWyBoLGQgXTtcbn0sZmx1c2hUcmFuc2Zvcm1DYWNoZTogZnVuY3Rpb24oIGEgKSB7XG52YXIgYj0nJyxjPWcoIGEgKTtpZiAoICggcHx8eS5TdGF0ZS5pc0FuZHJvaWQmJiF5LlN0YXRlLmlzQ2hyb21lICkmJmMmJmMuaXNTVkcgKSB7XG52YXIgZD1mdW5jdGlvbiggYiApIHtcbnJldHVybiBwYXJzZUZsb2F0KCBBLmdldFByb3BlcnR5VmFsdWUoIGEsYiApICk7XG59LGU9e3RyYW5zbGF0ZTogWyBkKCAndHJhbnNsYXRlWCcgKSxkKCAndHJhbnNsYXRlWScgKSBdLHNrZXdYOiBbIGQoICdza2V3WCcgKSBdLHNrZXdZOiBbIGQoICdza2V3WScgKSBdLHNjYWxlOiAxIT09ZCggJ3NjYWxlJyApP1sgZCggJ3NjYWxlJyApLGQoICdzY2FsZScgKSBdOlsgZCggJ3NjYWxlWCcgKSxkKCAnc2NhbGVZJyApIF0scm90YXRlOiBbIGQoICdyb3RhdGVaJyApLDAsMCBdfTtvLmVhY2goIGcoIGEgKS50cmFuc2Zvcm1DYWNoZSxmdW5jdGlvbiggYSApIHtcbi9edHJhbnNsYXRlL2kudGVzdCggYSApP2E9J3RyYW5zbGF0ZSc6L15zY2FsZS9pLnRlc3QoIGEgKT9hPSdzY2FsZSc6L15yb3RhdGUvaS50ZXN0KCBhICkmJiggYT0ncm90YXRlJyApLGVbIGEgXSYmKCBiKz1hKycoJytlWyBhIF0uam9pbiggJyAnICkrJykgJyxkZWxldGUgZVsgYSBdICk7XG59ICk7XG59IGVsc2Uge1xudmFyIGYsaDtvLmVhY2goIGcoIGEgKS50cmFuc2Zvcm1DYWNoZSxmdW5jdGlvbiggYyApIHtcbmlmICggZj1nKCBhICkudHJhbnNmb3JtQ2FjaGVbIGMgXSwndHJhbnNmb3JtUGVyc3BlY3RpdmUnPT09YyApIHtcbnJldHVybiBoPWYsITA7XG59OT09PXAmJidyb3RhdGVaJz09PWMmJiggYz0ncm90YXRlJyApLGIrPWMrZisnICc7XG59ICksaCYmKCBiPSdwZXJzcGVjdGl2ZScraCsnICcrYiApO1xufUEuc2V0UHJvcGVydHlWYWx1ZSggYSwndHJhbnNmb3JtJyxiICk7XG59fTtBLkhvb2tzLnJlZ2lzdGVyKCksQS5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcigpLHkuaG9vaz1mdW5jdGlvbiggYSxiLGMgKSB7XG52YXIgZTtyZXR1cm4gYT1mKCBhICksby5lYWNoKCBhLGZ1bmN0aW9uKCBhLGYgKSB7XG5pZiAoIGcoIGYgKT09PWQmJnkuaW5pdCggZiApLGM9PT1kICkge1xuZT09PWQmJiggZT1BLmdldFByb3BlcnR5VmFsdWUoIGYsYiApICk7XG59IGVsc2Uge1xudmFyIGg9QS5zZXRQcm9wZXJ0eVZhbHVlKCBmLGIsYyApOyd0cmFuc2Zvcm0nPT09aFsgMCBdJiZ5LkNTUy5mbHVzaFRyYW5zZm9ybUNhY2hlKCBmICksZT1oO1xufVxufSApLGU7XG59O3ZhciBCPWZ1bmN0aW9uKCkge1xuZnVuY3Rpb24gYSgpIHtcbnJldHVybiBrP3oucHJvbWlzZXx8bnVsbDpwO1xufSBmdW5jdGlvbiBlKCBhLGUgKSB7XG5mdW5jdGlvbiBmKCBmICkge1xudmFyIGssbjtpZiAoIGkuYmVnaW4mJjA9PT1EICkge1xudHJ5IHtcbmkuYmVnaW4uY2FsbCggcixyICk7XG59IGNhdGNoICggViApIHtcbnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xudGhyb3cgVjtcbn0sMSApO1xufVxufSBpZiAoICdzY3JvbGwnPT09RyApIHtcbnZhciBwLHEsdyx4PS9eeCQvaS50ZXN0KCBpLmF4aXMgKT8nTGVmdCc6J1RvcCcsQj1wYXJzZUZsb2F0KCBpLm9mZnNldCApfHwwO2kuY29udGFpbmVyP3UuaXNXcmFwcGVkKCBpLmNvbnRhaW5lciApfHx1LmlzTm9kZSggaS5jb250YWluZXIgKT8oIGkuY29udGFpbmVyPWkuY29udGFpbmVyWyAwIF18fGkuY29udGFpbmVyLHA9aS5jb250YWluZXJbICdzY3JvbGwnK3ggXSx3PXArbyggYSApLnBvc2l0aW9uKClbIHgudG9Mb3dlckNhc2UoKSBdK0IgKTppLmNvbnRhaW5lcj1udWxsOiggcD15LlN0YXRlLnNjcm9sbEFuY2hvclsgeS5TdGF0ZVsgJ3Njcm9sbFByb3BlcnR5Jyt4IF0gXSxxPXkuU3RhdGUuc2Nyb2xsQW5jaG9yWyB5LlN0YXRlWyAnc2Nyb2xsUHJvcGVydHknKyggJ0xlZnQnPT09eD8nVG9wJzonTGVmdCcgKSBdIF0sdz1vKCBhICkub2Zmc2V0KClbIHgudG9Mb3dlckNhc2UoKSBdK0IgKSxqPXtzY3JvbGw6IHtyb290UHJvcGVydHlWYWx1ZTogITEsc3RhcnRWYWx1ZTogcCxjdXJyZW50VmFsdWU6IHAsZW5kVmFsdWU6IHcsdW5pdFR5cGU6ICcnLGVhc2luZzogaS5lYXNpbmcsc2Nyb2xsRGF0YToge2NvbnRhaW5lcjogaS5jb250YWluZXIsZGlyZWN0aW9uOiB4LGFsdGVybmF0ZVZhbHVlOiBxfX0sZWxlbWVudDogYX0seS5kZWJ1ZyYmY29uc29sZS5sb2coICd0d2VlbnNDb250YWluZXIgKHNjcm9sbCk6ICcsai5zY3JvbGwsYSApO1xufSBlbHNlIGlmICggJ3JldmVyc2UnPT09RyApIHtcbmlmICggISggaz1nKCBhICkgKSApIHtcbnJldHVybjtcbn0gaWYgKCAhay50d2VlbnNDb250YWluZXIgKSB7XG5yZXR1cm4gdm9pZCBvLmRlcXVldWUoIGEsaS5xdWV1ZSApO1xufSdub25lJz09PWsub3B0cy5kaXNwbGF5JiYoIGsub3B0cy5kaXNwbGF5PSdhdXRvJyApLCdoaWRkZW4nPT09ay5vcHRzLnZpc2liaWxpdHkmJiggay5vcHRzLnZpc2liaWxpdHk9J3Zpc2libGUnICksay5vcHRzLmxvb3A9ITEsay5vcHRzLmJlZ2luPW51bGwsay5vcHRzLmNvbXBsZXRlPW51bGwsdi5lYXNpbmd8fGRlbGV0ZSBpLmVhc2luZyx2LmR1cmF0aW9ufHxkZWxldGUgaS5kdXJhdGlvbixpPW8uZXh0ZW5kKCB7fSxrLm9wdHMsaSApLG49by5leHRlbmQoICEwLHt9LGs/ay50d2VlbnNDb250YWluZXI6bnVsbCApO2ZvciAoIHZhciBFIGluIG4gKSB7XG5pZiAoIG4uaGFzT3duUHJvcGVydHkoIEUgKSYmJ2VsZW1lbnQnIT09RSApIHtcbnZhciBGPW5bIEUgXS5zdGFydFZhbHVlO25bIEUgXS5zdGFydFZhbHVlPW5bIEUgXS5jdXJyZW50VmFsdWU9blsgRSBdLmVuZFZhbHVlLG5bIEUgXS5lbmRWYWx1ZT1GLHUuaXNFbXB0eU9iamVjdCggdiApfHwoIG5bIEUgXS5lYXNpbmc9aS5lYXNpbmcgKSx5LmRlYnVnJiZjb25zb2xlLmxvZyggJ3JldmVyc2UgdHdlZW5zQ29udGFpbmVyICgnK0UrJyk6ICcrSlNPTi5zdHJpbmdpZnkoIG5bIEUgXSApLGEgKTtcbn1cbn1qPW47XG59IGVsc2UgaWYgKCAnc3RhcnQnPT09RyApIHtcbms9ZyggYSApLGsmJmsudHdlZW5zQ29udGFpbmVyJiYhMD09PWsuaXNBbmltYXRpbmcmJiggbj1rLnR3ZWVuc0NvbnRhaW5lciApO3ZhciBIPWZ1bmN0aW9uKCBlLGYgKSB7XG52YXIgZyxsPUEuSG9va3MuZ2V0Um9vdCggZSApLG09ITEscD1mWyAwIF0scT1mWyAxIF0scj1mWyAyIF1cbjtpZiAoICEoIGsmJmsuaXNTVkd8fCd0d2Vlbic9PT1sfHwhMSE9PUEuTmFtZXMucHJlZml4Q2hlY2soIGwgKVsgMSBdfHxBLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbIGwgXSE9PWQgKSApIHtcbnJldHVybiB2b2lkKCB5LmRlYnVnJiZjb25zb2xlLmxvZyggJ1NraXBwaW5nIFsnK2wrJ10gZHVlIHRvIGEgbGFjayBvZiBicm93c2VyIHN1cHBvcnQuJyApICk7XG59KCBpLmRpc3BsYXkhPT1kJiZudWxsIT09aS5kaXNwbGF5JiYnbm9uZSchPT1pLmRpc3BsYXl8fGkudmlzaWJpbGl0eSE9PWQmJidoaWRkZW4nIT09aS52aXNpYmlsaXR5ICkmJi9vcGFjaXR5fGZpbHRlci8udGVzdCggZSApJiYhciYmMCE9PXAmJiggcj0wICksaS5fY2FjaGVWYWx1ZXMmJm4mJm5bIGUgXT8oIHI9PT1kJiYoIHI9blsgZSBdLmVuZFZhbHVlK25bIGUgXS51bml0VHlwZSApLG09ay5yb290UHJvcGVydHlWYWx1ZUNhY2hlWyBsIF0gKTpBLkhvb2tzLnJlZ2lzdGVyZWRbIGUgXT9yPT09ZD8oIG09QS5nZXRQcm9wZXJ0eVZhbHVlKCBhLGwgKSxyPUEuZ2V0UHJvcGVydHlWYWx1ZSggYSxlLG0gKSApOm09QS5Ib29rcy50ZW1wbGF0ZXNbIGwgXVsgMSBdOnI9PT1kJiYoIHI9QS5nZXRQcm9wZXJ0eVZhbHVlKCBhLGUgKSApO3ZhciBzLHQsdix3PSExLHg9ZnVuY3Rpb24oIGEsYiApIHtcbnZhciBjLGQ7cmV0dXJuIGQ9KCBifHwnMCcgKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSggL1slQS16XSskLyxmdW5jdGlvbiggYSApIHtcbnJldHVybiBjPWEsJyc7XG59ICksY3x8KCBjPUEuVmFsdWVzLmdldFVuaXRUeXBlKCBhICkgKSxbIGQsYyBdO1xufTtpZiAoIHIhPT1wJiZ1LmlzU3RyaW5nKCByICkmJnUuaXNTdHJpbmcoIHAgKSApIHtcbmc9Jyc7dmFyIHo9MCxCPTAsQz1bXSxEPVtdLEU9MCxGPTAsRz0wO2ZvciAoIHI9QS5Ib29rcy5maXhDb2xvcnMoIHIgKSxwPUEuSG9va3MuZml4Q29sb3JzKCBwICk7ejxyLmxlbmd0aCYmQjxwLmxlbmd0aDsgKSB7XG52YXIgSD1yWyB6IF0sST1wWyBCIF07aWYgKCAvW1xcZFxcLi1dLy50ZXN0KCBIICkmJi9bXFxkXFwuLV0vLnRlc3QoIEkgKSApIHtcbmZvciAoIHZhciBKPUgsSz1JLEw9Jy4nLE49Jy4nOysrejxyLmxlbmd0aDsgKSB7XG5pZiAoICggSD1yWyB6IF0gKT09PUwgKSB7XG5MPScuLic7XG59IGVsc2UgaWYgKCAhL1xcZC8udGVzdCggSCApICkge1xuYnJlYWs7XG59Sis9SDtcbn0gZm9yICggOysrQjxwLmxlbmd0aDsgKSB7XG5pZiAoICggST1wWyBCIF0gKT09PU4gKSB7XG5OPScuLic7XG59IGVsc2UgaWYgKCAhL1xcZC8udGVzdCggSSApICkge1xuYnJlYWs7XG59Sys9STtcbn0gdmFyIE89QS5Ib29rcy5nZXRVbml0KCByLHogKSxQPUEuSG9va3MuZ2V0VW5pdCggcCxCICk7aWYgKCB6Kz1PLmxlbmd0aCxCKz1QLmxlbmd0aCxPPT09UCApIHtcbko9PT1LP2crPUorTzooIGcrPSd7JytDLmxlbmd0aCsoIEY/JyEnOicnICkrJ30nK08sQy5wdXNoKCBwYXJzZUZsb2F0KCBKICkgKSxELnB1c2goIHBhcnNlRmxvYXQoIEsgKSApICk7XG59IGVsc2Uge1xudmFyIFE9cGFyc2VGbG9hdCggSiApLFI9cGFyc2VGbG9hdCggSyApO2crPSggRTw1PydjYWxjJzonJyApKycoJysoIFE/J3snK0MubGVuZ3RoKyggRj8nISc6JycgKSsnfSc6JzAnICkrTysnICsgJysoIFI/J3snKyggQy5sZW5ndGgrKCBRPzE6MCApICkrKCBGPychJzonJyApKyd9JzonMCcgKStQKycpJyxRJiYoIEMucHVzaCggUSApLEQucHVzaCggMCApICksUiYmKCBDLnB1c2goIDAgKSxELnB1c2goIFIgKSApO1xufVxufSBlbHNlIHtcbmlmICggSCE9PUkgKSB7XG5FPTA7YnJlYWs7XG59Zys9SCx6KyssQisrLDA9PT1FJiYnYyc9PT1IfHwxPT09RSYmJ2EnPT09SHx8Mj09PUUmJidsJz09PUh8fDM9PT1FJiYnYyc9PT1IfHxFPj00JiYnKCc9PT1IP0UrKzooIEUmJkU8NXx8RT49NCYmJyknPT09SCYmLS1FPDUgKSYmKCBFPTAgKSwwPT09RiYmJ3InPT09SHx8MT09PUYmJidnJz09PUh8fDI9PT1GJiYnYic9PT1IfHwzPT09RiYmJ2EnPT09SHx8Rj49MyYmJygnPT09SD8oIDM9PT1GJiYnYSc9PT1IJiYoIEc9MSApLEYrKyApOkcmJicsJz09PUg/KytHPjMmJiggRj1HPTAgKTooIEcmJkY8KCBHPzU6NCApfHxGPj0oIEc/NDozICkmJicpJz09PUgmJi0tRjwoIEc/NTo0ICkgKSYmKCBGPUc9MCApO1xufVxufXo9PT1yLmxlbmd0aCYmQj09PXAubGVuZ3RofHwoIHkuZGVidWcmJmNvbnNvbGUuZXJyb3IoICdUcnlpbmcgdG8gcGF0dGVybiBtYXRjaCBtaXMtbWF0Y2hlZCBzdHJpbmdzIFtcIicrcCsnXCIsIFwiJytyKydcIl0nICksZz1kICksZyYmKCBDLmxlbmd0aD8oIHkuZGVidWcmJmNvbnNvbGUubG9nKCAnUGF0dGVybiBmb3VuZCBcIicrZysnXCIgLT4gJyxDLEQsJ1snK3IrJywnK3ArJ10nICkscj1DLHA9RCx0PXY9JycgKTpnPWQgKTtcbn1nfHwoIHM9eCggZSxyICkscj1zWyAwIF0sdj1zWyAxIF0scz14KCBlLHAgKSxwPXNbIDAgXS5yZXBsYWNlKCAvXihbKy1cXC8qXSk9LyxmdW5jdGlvbiggYSxiICkge1xucmV0dXJuIHc9YiwnJztcbn0gKSx0PXNbIDEgXSxyPXBhcnNlRmxvYXQoIHIgKXx8MCxwPXBhcnNlRmxvYXQoIHAgKXx8MCwnJSc9PT10JiYoIC9eKGZvbnRTaXplfGxpbmVIZWlnaHQpJC8udGVzdCggZSApPyggcC89MTAwLHQ9J2VtJyApOi9ec2NhbGUvLnRlc3QoIGUgKT8oIHAvPTEwMCx0PScnICk6LyhSZWR8R3JlZW58Qmx1ZSkkL2kudGVzdCggZSApJiYoIHA9cC8xMDAqMjU1LHQ9JycgKSApICk7aWYgKCAvW1xcLypdLy50ZXN0KCB3ICkgKSB7XG50PXY7XG59IGVsc2UgaWYgKCB2IT09dCYmMCE9PXIgKSB7XG5pZiAoIDA9PT1wICkge1xudD12O1xufSBlbHNlIHtcbmg9aHx8ZnVuY3Rpb24oKSB7XG52YXIgZD17bXlQYXJlbnQ6IGEucGFyZW50Tm9kZXx8Yy5ib2R5LHBvc2l0aW9uOiBBLmdldFByb3BlcnR5VmFsdWUoIGEsJ3Bvc2l0aW9uJyApLGZvbnRTaXplOiBBLmdldFByb3BlcnR5VmFsdWUoIGEsJ2ZvbnRTaXplJyApfSxlPWQucG9zaXRpb249PT1NLmxhc3RQb3NpdGlvbiYmZC5teVBhcmVudD09PU0ubGFzdFBhcmVudCxmPWQuZm9udFNpemU9PT1NLmxhc3RGb250U2l6ZTtNLmxhc3RQYXJlbnQ9ZC5teVBhcmVudCxNLmxhc3RQb3NpdGlvbj1kLnBvc2l0aW9uLE0ubGFzdEZvbnRTaXplPWQuZm9udFNpemU7dmFyIGc9e307aWYgKCBmJiZlICkge1xuZy5lbVRvUHg9TS5sYXN0RW1Ub1B4LGcucGVyY2VudFRvUHhXaWR0aD1NLmxhc3RQZXJjZW50VG9QeFdpZHRoLGcucGVyY2VudFRvUHhIZWlnaHQ9TS5sYXN0UGVyY2VudFRvUHhIZWlnaHQ7XG59IGVsc2Uge1xudmFyIGg9ayYmay5pc1NWRz9jLmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywncmVjdCcgKTpjLmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7eS5pbml0KCBoICksZC5teVBhcmVudC5hcHBlbmRDaGlsZCggaCApLG8uZWFjaCggWyAnb3ZlcmZsb3cnLCdvdmVyZmxvd1gnLCdvdmVyZmxvd1knIF0sZnVuY3Rpb24oIGEsYiApIHtcbnkuQ1NTLnNldFByb3BlcnR5VmFsdWUoIGgsYiwnaGlkZGVuJyApO1xufSApLHkuQ1NTLnNldFByb3BlcnR5VmFsdWUoIGgsJ3Bvc2l0aW9uJyxkLnBvc2l0aW9uICkseS5DU1Muc2V0UHJvcGVydHlWYWx1ZSggaCwnZm9udFNpemUnLGQuZm9udFNpemUgKSx5LkNTUy5zZXRQcm9wZXJ0eVZhbHVlKCBoLCdib3hTaXppbmcnLCdjb250ZW50LWJveCcgKSxvLmVhY2goIFsgJ21pbldpZHRoJywnbWF4V2lkdGgnLCd3aWR0aCcsJ21pbkhlaWdodCcsJ21heEhlaWdodCcsJ2hlaWdodCcgXSxmdW5jdGlvbiggYSxiICkge1xueS5DU1Muc2V0UHJvcGVydHlWYWx1ZSggaCxiLCcxMDAlJyApO1xufSApLHkuQ1NTLnNldFByb3BlcnR5VmFsdWUoIGgsJ3BhZGRpbmdMZWZ0JywnMTAwZW0nICksZy5wZXJjZW50VG9QeFdpZHRoPU0ubGFzdFBlcmNlbnRUb1B4V2lkdGg9KCBwYXJzZUZsb2F0KCBBLmdldFByb3BlcnR5VmFsdWUoIGgsJ3dpZHRoJyxudWxsLCEwICkgKXx8MSApLzEwMCxnLnBlcmNlbnRUb1B4SGVpZ2h0PU0ubGFzdFBlcmNlbnRUb1B4SGVpZ2h0PSggcGFyc2VGbG9hdCggQS5nZXRQcm9wZXJ0eVZhbHVlKCBoLCdoZWlnaHQnLG51bGwsITAgKSApfHwxICkvMTAwLGcuZW1Ub1B4PU0ubGFzdEVtVG9QeD0oIHBhcnNlRmxvYXQoIEEuZ2V0UHJvcGVydHlWYWx1ZSggaCwncGFkZGluZ0xlZnQnICkgKXx8MSApLzEwMCxkLm15UGFyZW50LnJlbW92ZUNoaWxkKCBoICk7XG59IHJldHVybiBudWxsPT09TS5yZW1Ub1B4JiYoIE0ucmVtVG9QeD1wYXJzZUZsb2F0KCBBLmdldFByb3BlcnR5VmFsdWUoIGMuYm9keSwnZm9udFNpemUnICkgKXx8MTYgKSxudWxsPT09TS52d1RvUHgmJiggTS52d1RvUHg9cGFyc2VGbG9hdCggYi5pbm5lcldpZHRoICkvMTAwLE0udmhUb1B4PXBhcnNlRmxvYXQoIGIuaW5uZXJIZWlnaHQgKS8xMDAgKSxnLnJlbVRvUHg9TS5yZW1Ub1B4LGcudndUb1B4PU0udndUb1B4LGcudmhUb1B4PU0udmhUb1B4LHkuZGVidWc+PTEmJmNvbnNvbGUubG9nKCAnVW5pdCByYXRpb3M6ICcrSlNPTi5zdHJpbmdpZnkoIGcgKSxhICksZztcbn0oKTt2YXIgUz0vbWFyZ2lufHBhZGRpbmd8bGVmdHxyaWdodHx3aWR0aHx0ZXh0fHdvcmR8bGV0dGVyL2kudGVzdCggZSApfHwvWCQvLnRlc3QoIGUgKXx8J3gnPT09ZT8neCc6J3knO3N3aXRjaCAoIHYgKSB7XG5jYXNlICclJzogcio9J3gnPT09Uz9oLnBlcmNlbnRUb1B4V2lkdGg6aC5wZXJjZW50VG9QeEhlaWdodDticmVhaztjYXNlICdweCc6IGJyZWFrO2RlZmF1bHQ6IHIqPWhbIHYrJ1RvUHgnIF07XG59IHN3aXRjaCAoIHQgKSB7XG5jYXNlICclJzogcio9MS8oICd4Jz09PVM/aC5wZXJjZW50VG9QeFdpZHRoOmgucGVyY2VudFRvUHhIZWlnaHQgKTticmVhaztjYXNlICdweCc6IGJyZWFrO2RlZmF1bHQ6IHIqPTEvaFsgdCsnVG9QeCcgXTtcbn1cbn1cbn0gc3dpdGNoICggdyApIHtcbmNhc2UgJysnOiBwPXIrcDticmVhaztjYXNlICctJzogcD1yLXA7YnJlYWs7Y2FzZSAnKic6IHAqPXI7YnJlYWs7Y2FzZSAnLyc6IHA9ci9wO1xufWpbIGUgXT17cm9vdFByb3BlcnR5VmFsdWU6IG0sc3RhcnRWYWx1ZTogcixjdXJyZW50VmFsdWU6IHIsZW5kVmFsdWU6IHAsdW5pdFR5cGU6IHQsZWFzaW5nOiBxfSxnJiYoIGpbIGUgXS5wYXR0ZXJuPWcgKSx5LmRlYnVnJiZjb25zb2xlLmxvZyggJ3R3ZWVuc0NvbnRhaW5lciAoJytlKycpOiAnK0pTT04uc3RyaW5naWZ5KCBqWyBlIF0gKSxhICk7XG59O2ZvciAoIHZhciBJIGluIHMgKSB7XG5pZiAoIHMuaGFzT3duUHJvcGVydHkoIEkgKSApIHtcbnZhciBKPUEuTmFtZXMuY2FtZWxDYXNlKCBJICksSz1mdW5jdGlvbiggYixjICkge1xudmFyIGQsZixnO3JldHVybiB1LmlzRnVuY3Rpb24oIGIgKSYmKCBiPWIuY2FsbCggYSxlLEMgKSApLHUuaXNBcnJheSggYiApPyggZD1iWyAwIF0sIXUuaXNBcnJheSggYlsgMSBdICkmJi9eW1xcZC1dLy50ZXN0KCBiWyAxIF0gKXx8dS5pc0Z1bmN0aW9uKCBiWyAxIF0gKXx8QS5SZWdFeC5pc0hleC50ZXN0KCBiWyAxIF0gKT9nPWJbIDEgXTp1LmlzU3RyaW5nKCBiWyAxIF0gKSYmIUEuUmVnRXguaXNIZXgudGVzdCggYlsgMSBdICkmJnkuRWFzaW5nc1sgYlsgMSBdIF18fHUuaXNBcnJheSggYlsgMSBdICk/KCBmPWM/YlsgMSBdOmwoIGJbIDEgXSxpLmR1cmF0aW9uICksZz1iWyAyIF0gKTpnPWJbIDEgXXx8YlsgMiBdICk6ZD1iLGN8fCggZj1mfHxpLmVhc2luZyApLHUuaXNGdW5jdGlvbiggZCApJiYoIGQ9ZC5jYWxsKCBhLGUsQyApICksdS5pc0Z1bmN0aW9uKCBnICkmJiggZz1nLmNhbGwoIGEsZSxDICkgKSxbIGR8fDAsZixnIF07XG59KCBzWyBJIF0gKTtpZiAoIHQoIEEuTGlzdHMuY29sb3JzLEogKSApIHtcbnZhciBMPUtbIDAgXSxPPUtbIDEgXSxQPUtbIDIgXTtpZiAoIEEuUmVnRXguaXNIZXgudGVzdCggTCApICkge1xuZm9yICggdmFyIFE9WyAnUmVkJywnR3JlZW4nLCdCbHVlJyBdLFI9QS5WYWx1ZXMuaGV4VG9SZ2IoIEwgKSxTPVA/QS5WYWx1ZXMuaGV4VG9SZ2IoIFAgKTpkLFQ9MDtUPFEubGVuZ3RoO1QrKyApIHtcbnZhciBVPVsgUlsgVCBdIF07TyYmVS5wdXNoKCBPICksUyE9PWQmJlUucHVzaCggU1sgVCBdICksSCggSitRWyBUIF0sVSApO1xufSBjb250aW51ZTtcbn1cbn1IKCBKLEsgKTtcbn1cbn1qLmVsZW1lbnQ9YTtcbn1qLmVsZW1lbnQmJiggQS5WYWx1ZXMuYWRkQ2xhc3MoIGEsJ3ZlbG9jaXR5LWFuaW1hdGluZycgKSxOLnB1c2goIGogKSxrPWcoIGEgKSxrJiYoICcnPT09aS5xdWV1ZSYmKCBrLnR3ZWVuc0NvbnRhaW5lcj1qLGsub3B0cz1pICksay5pc0FuaW1hdGluZz0hMCApLEQ9PT1DLTE/KCB5LlN0YXRlLmNhbGxzLnB1c2goIFsgTixyLGksbnVsbCx6LnJlc29sdmVyLG51bGwsMCBdICksITE9PT15LlN0YXRlLmlzVGlja2luZyYmKCB5LlN0YXRlLmlzVGlja2luZz0hMCxtKCkgKSApOkQrKyApO1xufSB2YXIgaCxpPW8uZXh0ZW5kKCB7fSx5LmRlZmF1bHRzLHYgKSxqPXt9O3N3aXRjaCAoIGcoIGEgKT09PWQmJnkuaW5pdCggYSApLHBhcnNlRmxvYXQoIGkuZGVsYXkgKSYmITEhPT1pLnF1ZXVlJiZvLnF1ZXVlKCBhLGkucXVldWUsZnVuY3Rpb24oIGIsYyApIHtcbmlmICggITA9PT1jICkge1xucmV0dXJuICEwO1xufXkudmVsb2NpdHlRdWV1ZUVudHJ5RmxhZz0hMDt2YXIgZD15LlN0YXRlLmRlbGF5ZWRFbGVtZW50cy5jb3VudCsrO3kuU3RhdGUuZGVsYXllZEVsZW1lbnRzWyBkIF09YTt2YXIgZT1mdW5jdGlvbiggYSApIHtcbnJldHVybiBmdW5jdGlvbigpIHtcbnkuU3RhdGUuZGVsYXllZEVsZW1lbnRzWyBhIF09ITEsYigpO1xufTtcbn0oIGQgKTtnKCBhICkuZGVsYXlCZWdpbj0oIG5ldyBEYXRlICkuZ2V0VGltZSgpLGcoIGEgKS5kZWxheT1wYXJzZUZsb2F0KCBpLmRlbGF5ICksZyggYSApLmRlbGF5VGltZXI9e3NldFRpbWVvdXQ6IHNldFRpbWVvdXQoIGIscGFyc2VGbG9hdCggaS5kZWxheSApICksbmV4dDogZX07XG59ICksaS5kdXJhdGlvbi50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgKSB7XG5jYXNlICdmYXN0JzogaS5kdXJhdGlvbj0yMDA7YnJlYWs7Y2FzZSAnbm9ybWFsJzogaS5kdXJhdGlvbj13O2JyZWFrO2Nhc2UgJ3Nsb3cnOiBpLmR1cmF0aW9uPTYwMDticmVhaztkZWZhdWx0OiBpLmR1cmF0aW9uPXBhcnNlRmxvYXQoIGkuZHVyYXRpb24gKXx8MTtcbn0gaWYgKCAhMSE9PXkubW9jayYmKCAhMD09PXkubW9jaz9pLmR1cmF0aW9uPWkuZGVsYXk9MTooIGkuZHVyYXRpb24qPXBhcnNlRmxvYXQoIHkubW9jayApfHwxLGkuZGVsYXkqPXBhcnNlRmxvYXQoIHkubW9jayApfHwxICkgKSxpLmVhc2luZz1sKCBpLmVhc2luZyxpLmR1cmF0aW9uICksaS5iZWdpbiYmIXUuaXNGdW5jdGlvbiggaS5iZWdpbiApJiYoIGkuYmVnaW49bnVsbCApLGkucHJvZ3Jlc3MmJiF1LmlzRnVuY3Rpb24oIGkucHJvZ3Jlc3MgKSYmKCBpLnByb2dyZXNzPW51bGwgKSxpLmNvbXBsZXRlJiYhdS5pc0Z1bmN0aW9uKCBpLmNvbXBsZXRlICkmJiggaS5jb21wbGV0ZT1udWxsICksaS5kaXNwbGF5IT09ZCYmbnVsbCE9PWkuZGlzcGxheSYmKCBpLmRpc3BsYXk9aS5kaXNwbGF5LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSwnYXV0byc9PT1pLmRpc3BsYXkmJiggaS5kaXNwbGF5PXkuQ1NTLlZhbHVlcy5nZXREaXNwbGF5VHlwZSggYSApICkgKSxpLnZpc2liaWxpdHkhPT1kJiZudWxsIT09aS52aXNpYmlsaXR5JiYoIGkudmlzaWJpbGl0eT1pLnZpc2liaWxpdHkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpICksaS5tb2JpbGVIQT1pLm1vYmlsZUhBJiZ5LlN0YXRlLmlzTW9iaWxlJiYheS5TdGF0ZS5pc0dpbmdlcmJyZWFkLCExPT09aS5xdWV1ZSApIHtcbmlmICggaS5kZWxheSApIHtcbnZhciBrPXkuU3RhdGUuZGVsYXllZEVsZW1lbnRzLmNvdW50Kys7eS5TdGF0ZS5kZWxheWVkRWxlbWVudHNbIGsgXT1hO3ZhciBuPWZ1bmN0aW9uKCBhICkge1xucmV0dXJuIGZ1bmN0aW9uKCkge1xueS5TdGF0ZS5kZWxheWVkRWxlbWVudHNbIGEgXT0hMSxmKCk7XG59O1xufSggayApO2coIGEgKS5kZWxheUJlZ2luPSggbmV3IERhdGUgKS5nZXRUaW1lKCksZyggYSApLmRlbGF5PXBhcnNlRmxvYXQoIGkuZGVsYXkgKSxnKCBhICkuZGVsYXlUaW1lcj17c2V0VGltZW91dDogc2V0VGltZW91dCggZixwYXJzZUZsb2F0KCBpLmRlbGF5ICkgKSxuZXh0OiBufTtcbn0gZWxzZSB7XG5mKCk7XG59XG59IGVsc2Uge1xuby5xdWV1ZSggYSxpLnF1ZXVlLGZ1bmN0aW9uKCBhLGIgKSB7XG5pZiAoICEwPT09YiApIHtcbnJldHVybiB6LnByb21pc2UmJnoucmVzb2x2ZXIoIHIgKSwhMDtcbn15LnZlbG9jaXR5UXVldWVFbnRyeUZsYWc9ITAsZiggYSApO1xufSApO1xufScnIT09aS5xdWV1ZSYmJ2Z4JyE9PWkucXVldWV8fCdpbnByb2dyZXNzJz09PW8ucXVldWUoIGEgKVsgMCBdfHxvLmRlcXVldWUoIGEgKTtcbn0gdmFyIGosayxwLHEscixzLHYseD1hcmd1bWVudHNbIDAgXSYmKCBhcmd1bWVudHNbIDAgXS5wfHxvLmlzUGxhaW5PYmplY3QoIGFyZ3VtZW50c1sgMCBdLnByb3BlcnRpZXMgKSYmIWFyZ3VtZW50c1sgMCBdLnByb3BlcnRpZXMubmFtZXN8fHUuaXNTdHJpbmcoIGFyZ3VtZW50c1sgMCBdLnByb3BlcnRpZXMgKSApO3UuaXNXcmFwcGVkKCB0aGlzICk/KCBrPSExLHE9MCxyPXRoaXMscD10aGlzICk6KCBrPSEwLHE9MSxyPXg/YXJndW1lbnRzWyAwIF0uZWxlbWVudHN8fGFyZ3VtZW50c1sgMCBdLmU6YXJndW1lbnRzWyAwIF0gKTt2YXIgej17cHJvbWlzZTogbnVsbCxyZXNvbHZlcjogbnVsbCxyZWplY3RlcjogbnVsbH07aWYgKCBrJiZ5LlByb21pc2UmJiggei5wcm9taXNlPW5ldyB5LlByb21pc2UoIGZ1bmN0aW9uKCBhLGIgKSB7XG56LnJlc29sdmVyPWEsei5yZWplY3Rlcj1iO1xufSApICkseD8oIHM9YXJndW1lbnRzWyAwIF0ucHJvcGVydGllc3x8YXJndW1lbnRzWyAwIF0ucCx2PWFyZ3VtZW50c1sgMCBdLm9wdGlvbnN8fGFyZ3VtZW50c1sgMCBdLm8gKTooIHM9YXJndW1lbnRzWyBxIF0sdj1hcmd1bWVudHNbIHErMSBdICksISggcj1mKCByICkgKSApIHtcbnJldHVybiB2b2lkKCB6LnByb21pc2UmJiggcyYmdiYmITE9PT12LnByb21pc2VSZWplY3RFbXB0eT96LnJlc29sdmVyKCk6ei5yZWplY3RlcigpICkgKTtcbn0gdmFyIEM9ci5sZW5ndGgsRD0wO2lmICggIS9eKHN0b3B8ZmluaXNofGZpbmlzaEFsbHxwYXVzZXxyZXN1bWUpJC9pLnRlc3QoIHMgKSYmIW8uaXNQbGFpbk9iamVjdCggdiApICkge1xudmFyIEU9cSsxO3Y9e307Zm9yICggdmFyIEY9RTtGPGFyZ3VtZW50cy5sZW5ndGg7RisrICkge1xudS5pc0FycmF5KCBhcmd1bWVudHNbIEYgXSApfHwhL14oZmFzdHxub3JtYWx8c2xvdykkL2kudGVzdCggYXJndW1lbnRzWyBGIF0gKSYmIS9eXFxkLy50ZXN0KCBhcmd1bWVudHNbIEYgXSApP3UuaXNTdHJpbmcoIGFyZ3VtZW50c1sgRiBdICl8fHUuaXNBcnJheSggYXJndW1lbnRzWyBGIF0gKT92LmVhc2luZz1hcmd1bWVudHNbIEYgXTp1LmlzRnVuY3Rpb24oIGFyZ3VtZW50c1sgRiBdICkmJiggdi5jb21wbGV0ZT1hcmd1bWVudHNbIEYgXSApOnYuZHVyYXRpb249YXJndW1lbnRzWyBGIF07XG59XG59IHZhciBHO3N3aXRjaCAoIHMgKSB7XG5jYXNlICdzY3JvbGwnOiBHPSdzY3JvbGwnO2JyZWFrO2Nhc2UgJ3JldmVyc2UnOiBHPSdyZXZlcnNlJzticmVhaztjYXNlICdwYXVzZSc6IHZhciBIPSggbmV3IERhdGUgKS5nZXRUaW1lKCk7cmV0dXJuIG8uZWFjaCggcixmdW5jdGlvbiggYSxiICkge1xuaCggYixIICk7XG59ICksby5lYWNoKCB5LlN0YXRlLmNhbGxzLGZ1bmN0aW9uKCBhLGIgKSB7XG52YXIgYz0hMTtiJiZvLmVhY2goIGJbIDEgXSxmdW5jdGlvbiggYSxlICkge1xudmFyIGY9dj09PWQ/Jyc6djtyZXR1cm4gITAhPT1mJiZiWyAyIF0ucXVldWUhPT1mJiYoIHYhPT1kfHwhMSE9PWJbIDIgXS5xdWV1ZSApfHwoIG8uZWFjaCggcixmdW5jdGlvbiggYSxkICkge1xuaWYgKCBkPT09ZSApIHtcbnJldHVybiBiWyA1IF09e3Jlc3VtZTogITF9LGM9ITAsITE7XG59XG59ICksIWMmJnZvaWQgMCApO1xufSApO1xufSApLGEoKTtjYXNlICdyZXN1bWUnOiByZXR1cm4gby5lYWNoKCByLGZ1bmN0aW9uKCBhLGIgKSB7XG5pKCBiLEggKTtcbn0gKSxvLmVhY2goIHkuU3RhdGUuY2FsbHMsZnVuY3Rpb24oIGEsYiApIHtcbnZhciBjPSExO2ImJm8uZWFjaCggYlsgMSBdLGZ1bmN0aW9uKCBhLGUgKSB7XG52YXIgZj12PT09ZD8nJzp2O3JldHVybiAhMCE9PWYmJmJbIDIgXS5xdWV1ZSE9PWYmJiggdiE9PWR8fCExIT09YlsgMiBdLnF1ZXVlICl8fCggIWJbIDUgXXx8KCBvLmVhY2goIHIsZnVuY3Rpb24oIGEsZCApIHtcbmlmICggZD09PWUgKSB7XG5yZXR1cm4gYlsgNSBdLnJlc3VtZT0hMCxjPSEwLCExO1xufVxufSApLCFjJiZ2b2lkIDAgKSApO1xufSApO1xufSApLGEoKTtjYXNlICdmaW5pc2gnOiBjYXNlICdmaW5pc2hBbGwnOiBjYXNlICdzdG9wJzogby5lYWNoKCByLGZ1bmN0aW9uKCBhLGIgKSB7XG5nKCBiICkmJmcoIGIgKS5kZWxheVRpbWVyJiYoIGNsZWFyVGltZW91dCggZyggYiApLmRlbGF5VGltZXIuc2V0VGltZW91dCApLGcoIGIgKS5kZWxheVRpbWVyLm5leHQmJmcoIGIgKS5kZWxheVRpbWVyLm5leHQoKSxkZWxldGUgZyggYiApLmRlbGF5VGltZXIgKSwnZmluaXNoQWxsJyE9PXN8fCEwIT09diYmIXUuaXNTdHJpbmcoIHYgKXx8KCBvLmVhY2goIG8ucXVldWUoIGIsdS5pc1N0cmluZyggdiApP3Y6JycgKSxmdW5jdGlvbiggYSxiICkge1xudS5pc0Z1bmN0aW9uKCBiICkmJmIoKTtcbn0gKSxvLnF1ZXVlKCBiLHUuaXNTdHJpbmcoIHYgKT92OicnLFtdICkgKTtcbn0gKTt2YXIgST1bXTtyZXR1cm4gby5lYWNoKCB5LlN0YXRlLmNhbGxzLGZ1bmN0aW9uKCBhLGIgKSB7XG5iJiZvLmVhY2goIGJbIDEgXSxmdW5jdGlvbiggYyxlICkge1xudmFyIGY9dj09PWQ/Jyc6djtpZiAoICEwIT09ZiYmYlsgMiBdLnF1ZXVlIT09ZiYmKCB2IT09ZHx8ITEhPT1iWyAyIF0ucXVldWUgKSApIHtcbnJldHVybiAhMDtcbn1vLmVhY2goIHIsZnVuY3Rpb24oIGMsZCApIHtcbmlmICggZD09PWUgKSB7XG5pZiAoICggITA9PT12fHx1LmlzU3RyaW5nKCB2ICkgKSYmKCBvLmVhY2goIG8ucXVldWUoIGQsdS5pc1N0cmluZyggdiApP3Y6JycgKSxmdW5jdGlvbiggYSxiICkge1xudS5pc0Z1bmN0aW9uKCBiICkmJmIoIG51bGwsITAgKTtcbn0gKSxvLnF1ZXVlKCBkLHUuaXNTdHJpbmcoIHYgKT92OicnLFtdICkgKSwnc3RvcCc9PT1zICkge1xudmFyIGg9ZyggZCApO2gmJmgudHdlZW5zQ29udGFpbmVyJiYhMSE9PWYmJm8uZWFjaCggaC50d2VlbnNDb250YWluZXIsZnVuY3Rpb24oIGEsYiApIHtcbmIuZW5kVmFsdWU9Yi5jdXJyZW50VmFsdWU7XG59ICksSS5wdXNoKCBhICk7XG59IGVsc2Uge1xuJ2ZpbmlzaCchPT1zJiYnZmluaXNoQWxsJyE9PXN8fCggYlsgMiBdLmR1cmF0aW9uPTEgKTtcbn1cbn1cbn0gKTtcbn0gKTtcbn0gKSwnc3RvcCc9PT1zJiYoIG8uZWFjaCggSSxmdW5jdGlvbiggYSxiICkge1xubiggYiwhMCApO1xufSApLHoucHJvbWlzZSYmei5yZXNvbHZlciggciApICksYSgpO2RlZmF1bHQ6IGlmICggIW8uaXNQbGFpbk9iamVjdCggcyApfHx1LmlzRW1wdHlPYmplY3QoIHMgKSApIHtcbmlmICggdS5pc1N0cmluZyggcyApJiZ5LlJlZGlyZWN0c1sgcyBdICkge1xuaj1vLmV4dGVuZCgge30sdiApO3ZhciBKPWouZHVyYXRpb24sSz1qLmRlbGF5fHwwO3JldHVybiAhMD09PWouYmFja3dhcmRzJiYoIHI9by5leHRlbmQoICEwLFtdLHIgKS5yZXZlcnNlKCkgKSxvLmVhY2goIHIsZnVuY3Rpb24oIGEsYiApIHtcbnBhcnNlRmxvYXQoIGouc3RhZ2dlciApP2ouZGVsYXk9SytwYXJzZUZsb2F0KCBqLnN0YWdnZXIgKSphOnUuaXNGdW5jdGlvbiggai5zdGFnZ2VyICkmJiggai5kZWxheT1LK2ouc3RhZ2dlci5jYWxsKCBiLGEsQyApICksai5kcmFnJiYoIGouZHVyYXRpb249cGFyc2VGbG9hdCggSiApfHwoIC9eKGNhbGxvdXR8dHJhbnNpdGlvbikvLnRlc3QoIHMgKT8xZTM6dyApLGouZHVyYXRpb249TWF0aC5tYXgoIGouZHVyYXRpb24qKCBqLmJhY2t3YXJkcz8xLWEvQzooIGErMSApL0MgKSwuNzUqai5kdXJhdGlvbiwyMDAgKSApLHkuUmVkaXJlY3RzWyBzIF0uY2FsbCggYixiLGp8fHt9LGEsQyxyLHoucHJvbWlzZT96OmQgKTtcbn0gKSxhKCk7XG59IHZhciBMPSdWZWxvY2l0eTogRmlyc3QgYXJndW1lbnQgKCcrcysnKSB3YXMgbm90IGEgcHJvcGVydHkgbWFwLCBhIGtub3duIGFjdGlvbiwgb3IgYSByZWdpc3RlcmVkIHJlZGlyZWN0LiBBYm9ydGluZy4nO3JldHVybiB6LnByb21pc2U/ei5yZWplY3RlciggbmV3IEVycm9yKCBMICkgKTpiLmNvbnNvbGUmJmNvbnNvbGUubG9nKCBMICksYSgpO1xufUc9J3N0YXJ0Jztcbn0gdmFyIE09e2xhc3RQYXJlbnQ6IG51bGwsbGFzdFBvc2l0aW9uOiBudWxsLGxhc3RGb250U2l6ZTogbnVsbCxsYXN0UGVyY2VudFRvUHhXaWR0aDogbnVsbCxsYXN0UGVyY2VudFRvUHhIZWlnaHQ6IG51bGwsbGFzdEVtVG9QeDogbnVsbCxyZW1Ub1B4OiBudWxsLHZ3VG9QeDogbnVsbCx2aFRvUHg6IG51bGx9LE49W107by5lYWNoKCByLGZ1bmN0aW9uKCBhLGIgKSB7XG51LmlzTm9kZSggYiApJiZlKCBiLGEgKTtcbn0gKSxqPW8uZXh0ZW5kKCB7fSx5LmRlZmF1bHRzLHYgKSxqLmxvb3A9cGFyc2VJbnQoIGoubG9vcCwxMCApO3ZhciBPPTIqai5sb29wLTE7aWYgKCBqLmxvb3AgKSB7XG5mb3IgKCB2YXIgUD0wO1A8TztQKysgKSB7XG52YXIgUT17ZGVsYXk6IGouZGVsYXkscHJvZ3Jlc3M6IGoucHJvZ3Jlc3N9O1A9PT1PLTEmJiggUS5kaXNwbGF5PWouZGlzcGxheSxRLnZpc2liaWxpdHk9ai52aXNpYmlsaXR5LFEuY29tcGxldGU9ai5jb21wbGV0ZSApLEIoIHIsJ3JldmVyc2UnLFEgKTtcbn1cbn0gcmV0dXJuIGEoKTtcbn07eT1vLmV4dGVuZCggQix5ICkseS5hbmltYXRlPUI7dmFyIEM9Yi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHE7aWYgKCAheS5TdGF0ZS5pc01vYmlsZSYmYy5oaWRkZW4hPT1kICkge1xudmFyIEQ9ZnVuY3Rpb24oKSB7XG5jLmhpZGRlbj8oIEM9ZnVuY3Rpb24oIGEgKSB7XG5yZXR1cm4gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5hKCAhMCApO1xufSwxNiApO1xufSxtKCkgKTpDPWIucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxxO1xufTtEKCksYy5hZGRFdmVudExpc3RlbmVyKCAndmlzaWJpbGl0eWNoYW5nZScsRCApO1xufSByZXR1cm4gYS5WZWxvY2l0eT15LGEhPT1iJiYoIGEuZm4udmVsb2NpdHk9QixhLmZuLnZlbG9jaXR5LmRlZmF1bHRzPXkuZGVmYXVsdHMgKSxvLmVhY2goIFsgJ0Rvd24nLCdVcCcgXSxmdW5jdGlvbiggYSxiICkge1xueS5SZWRpcmVjdHNbICdzbGlkZScrYiBdPWZ1bmN0aW9uKCBhLGMsZSxmLGcsaCApIHtcbnZhciBpPW8uZXh0ZW5kKCB7fSxjICksaj1pLmJlZ2luLGs9aS5jb21wbGV0ZSxsPXt9LG09e2hlaWdodDogJycsbWFyZ2luVG9wOiAnJyxtYXJnaW5Cb3R0b206ICcnLHBhZGRpbmdUb3A6ICcnLHBhZGRpbmdCb3R0b206ICcnfTtpLmRpc3BsYXk9PT1kJiYoIGkuZGlzcGxheT0nRG93bic9PT1iPydpbmxpbmUnPT09eS5DU1MuVmFsdWVzLmdldERpc3BsYXlUeXBlKCBhICk/J2lubGluZS1ibG9jayc6J2Jsb2NrJzonbm9uZScgKSxpLmJlZ2luPWZ1bmN0aW9uKCkge1xuMD09PWUmJmomJmouY2FsbCggZyxnICk7Zm9yICggdmFyIGMgaW4gbSApIHtcbmlmICggbS5oYXNPd25Qcm9wZXJ0eSggYyApICkge1xubFsgYyBdPWEuc3R5bGVbIGMgXTt2YXIgZD1BLmdldFByb3BlcnR5VmFsdWUoIGEsYyApO21bIGMgXT0nRG93bic9PT1iP1sgZCwwIF06WyAwLGQgXTtcbn1cbn1sLm92ZXJmbG93PWEuc3R5bGUub3ZlcmZsb3csYS5zdHlsZS5vdmVyZmxvdz0naGlkZGVuJztcbn0saS5jb21wbGV0ZT1mdW5jdGlvbigpIHtcbmZvciAoIHZhciBiIGluIGwgKSB7XG5sLmhhc093blByb3BlcnR5KCBiICkmJiggYS5zdHlsZVsgYiBdPWxbIGIgXSApO1xufWU9PT1mLTEmJiggayYmay5jYWxsKCBnLGcgKSxoJiZoLnJlc29sdmVyKCBnICkgKTtcbn0seSggYSxtLGkgKTtcbn07XG59ICksby5lYWNoKCBbICdJbicsJ091dCcgXSxmdW5jdGlvbiggYSxiICkge1xueS5SZWRpcmVjdHNbICdmYWRlJytiIF09ZnVuY3Rpb24oIGEsYyxlLGYsZyxoICkge1xudmFyIGk9by5leHRlbmQoIHt9LGMgKSxqPWkuY29tcGxldGUsaz17b3BhY2l0eTogJ0luJz09PWI/MTowfTswIT09ZSYmKCBpLmJlZ2luPW51bGwgKSxpLmNvbXBsZXRlPWUhPT1mLTE/bnVsbDpmdW5jdGlvbigpIHtcbmomJmouY2FsbCggZyxnICksaCYmaC5yZXNvbHZlciggZyApO1xufSxpLmRpc3BsYXk9PT1kJiYoIGkuZGlzcGxheT0nSW4nPT09Yj8nYXV0byc6J25vbmUnICkseSggdGhpcyxrLGkgKTtcbn07XG59ICkseTtcbn0oIHdpbmRvdy5qUXVlcnl8fHdpbmRvdy5aZXB0b3x8d2luZG93LHdpbmRvdyx3aW5kb3c/d2luZG93LmRvY3VtZW50OnVuZGVmaW5lZCApO1xufSApO1xuXG4vKiAhIEhhbW1lci5KUyAtIHYyLjAuOCAtIDIwMTYtMDQtMjNcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEpvcmlrIFRhbmdlbGRlcjtcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuIWZ1bmN0aW9uKCBhLGIsYyxkICkge1xuJ3VzZSBzdHJpY3QnO2Z1bmN0aW9uIGUoIGEsYixjICkge1xucmV0dXJuIHNldFRpbWVvdXQoIGooIGEsYyApLGIgKTtcbn0gZnVuY3Rpb24gZiggYSxiLGMgKSB7XG5yZXR1cm4gQXJyYXkuaXNBcnJheSggYSApPyggZyggYSxjWyBiIF0sYyApLCEwICk6ITE7XG59IGZ1bmN0aW9uIGcoIGEsYixjICkge1xudmFyIGU7aWYgKCBhICkge1xuaWYgKCBhLmZvckVhY2ggKSB7XG5hLmZvckVhY2goIGIsYyApO1xufSBlbHNlIGlmICggYS5sZW5ndGghPT1kICkge1xuZm9yICggZT0wO2U8YS5sZW5ndGg7ICkge1xuYi5jYWxsKCBjLGFbIGUgXSxlLGEgKSxlKys7XG59XG59IGVsc2Uge1xuZm9yICggZSBpbiBhICkge1xuYS5oYXNPd25Qcm9wZXJ0eSggZSApJiZiLmNhbGwoIGMsYVsgZSBdLGUsYSApO1xufVxufVxufVxufSBmdW5jdGlvbiBoKCBiLGMsZCApIHtcbnZhciBlPSdERVBSRUNBVEVEIE1FVEhPRDogJytjKydcXG4nK2QrJyBBVCBcXG4nO3JldHVybiBmdW5jdGlvbigpIHtcbnZhciBjPW5ldyBFcnJvciggJ2dldC1zdGFjay10cmFjZScgKSxkPWMmJmMuc3RhY2s/Yy5zdGFjay5yZXBsYWNlKCAvXlteXFwoXSs/W1xcbiRdL2dtLCcnICkucmVwbGFjZSggL15cXHMrYXRcXHMrL2dtLCcnICkucmVwbGFjZSggL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCd7YW5vbnltb3VzfSgpQCcgKTonVW5rbm93biBTdGFjayBUcmFjZScsZj1hLmNvbnNvbGUmJiggYS5jb25zb2xlLndhcm58fGEuY29uc29sZS5sb2cgKTtyZXR1cm4gZiYmZi5jYWxsKCBhLmNvbnNvbGUsZSxkICksYi5hcHBseSggdGhpcyxhcmd1bWVudHMgKTtcbn07XG59IGZ1bmN0aW9uIGkoIGEsYixjICkge1xudmFyIGQsZT1iLnByb3RvdHlwZTtkPWEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoIGUgKSxkLmNvbnN0cnVjdG9yPWEsZC5fc3VwZXI9ZSxjJiZsYSggZCxjICk7XG59IGZ1bmN0aW9uIGooIGEsYiApIHtcbnJldHVybiBmdW5jdGlvbigpIHtcbnJldHVybiBhLmFwcGx5KCBiLGFyZ3VtZW50cyApO1xufTtcbn0gZnVuY3Rpb24gayggYSxiICkge1xucmV0dXJuIHR5cGVvZiBhPT1vYT9hLmFwcGx5KCBiP2JbIDAgXXx8ZDpkLGIgKTphO1xufSBmdW5jdGlvbiBsKCBhLGIgKSB7XG5yZXR1cm4gYT09PWQ/YjphO1xufSBmdW5jdGlvbiBtKCBhLGIsYyApIHtcbmcoIHEoIGIgKSxmdW5jdGlvbiggYiApIHtcbmEuYWRkRXZlbnRMaXN0ZW5lciggYixjLCExICk7XG59ICk7XG59IGZ1bmN0aW9uIG4oIGEsYixjICkge1xuZyggcSggYiApLGZ1bmN0aW9uKCBiICkge1xuYS5yZW1vdmVFdmVudExpc3RlbmVyKCBiLGMsITEgKTtcbn0gKTtcbn0gZnVuY3Rpb24gbyggYSxiICkge1xuZm9yICggO2E7ICkge1xuaWYgKCBhPT1iICkge1xucmV0dXJuICEwO1xufWE9YS5wYXJlbnROb2RlO1xufSByZXR1cm4gITE7XG59IGZ1bmN0aW9uIHAoIGEsYiApIHtcbnJldHVybiBhLmluZGV4T2YoIGIgKT4tMTtcbn0gZnVuY3Rpb24gcSggYSApIHtcbnJldHVybiBhLnRyaW0oKS5zcGxpdCggL1xccysvZyApO1xufSBmdW5jdGlvbiByKCBhLGIsYyApIHtcbmlmICggYS5pbmRleE9mJiYhYyApIHtcbnJldHVybiBhLmluZGV4T2YoIGIgKTtcbn0gZm9yICggdmFyIGQ9MDtkPGEubGVuZ3RoOyApIHtcbmlmICggYyYmYVsgZCBdWyBjIF09PWJ8fCFjJiZhWyBkIF09PT1iICkge1xucmV0dXJuIGQ7XG59ZCsrO1xufSByZXR1cm4gLTE7XG59IGZ1bmN0aW9uIHMoIGEgKSB7XG5yZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGEsMCApO1xufSBmdW5jdGlvbiB0KCBhLGIsYyApIHtcbmZvciAoIHZhciBkPVtdLGU9W10sZj0wO2Y8YS5sZW5ndGg7ICkge1xudmFyIGc9Yj9hWyBmIF1bIGIgXTphWyBmIF07ciggZSxnICk8MCYmZC5wdXNoKCBhWyBmIF0gKSxlWyBmIF09ZyxmKys7XG59IHJldHVybiBjJiYoIGQ9Yj9kLnNvcnQoIGZ1bmN0aW9uKCBhLGMgKSB7XG5yZXR1cm4gYVsgYiBdPmNbIGIgXTtcbn0gKTpkLnNvcnQoKSApLGQ7XG59IGZ1bmN0aW9uIHUoIGEsYiApIHtcbmZvciAoIHZhciBjLGUsZj1iWyAwIF0udG9VcHBlckNhc2UoKStiLnNsaWNlKCAxICksZz0wO2c8bWEubGVuZ3RoOyApIHtcbmlmICggYz1tYVsgZyBdLGU9Yz9jK2Y6YixlIGluIGEgKSB7XG5yZXR1cm4gZTtcbn1nKys7XG59IHJldHVybiBkO1xufSBmdW5jdGlvbiB2KCkge1xucmV0dXJuIHVhKys7XG59IGZ1bmN0aW9uIHcoIGIgKSB7XG52YXIgYz1iLm93bmVyRG9jdW1lbnR8fGI7cmV0dXJuIGMuZGVmYXVsdFZpZXd8fGMucGFyZW50V2luZG93fHxhO1xufSBmdW5jdGlvbiB4KCBhLGIgKSB7XG52YXIgYz10aGlzO3RoaXMubWFuYWdlcj1hLHRoaXMuY2FsbGJhY2s9Yix0aGlzLmVsZW1lbnQ9YS5lbGVtZW50LHRoaXMudGFyZ2V0PWEub3B0aW9ucy5pbnB1dFRhcmdldCx0aGlzLmRvbUhhbmRsZXI9ZnVuY3Rpb24oIGIgKSB7XG5rKCBhLm9wdGlvbnMuZW5hYmxlLFsgYSBdICkmJmMuaGFuZGxlciggYiApO1xufSx0aGlzLmluaXQoKTtcbn0gZnVuY3Rpb24geSggYSApIHtcbnZhciBiLGM9YS5vcHRpb25zLmlucHV0Q2xhc3M7cmV0dXJuIG5ldyggYj1jP2M6eGE/TTp5YT9QOndhP1I6TCApKCBhLHogKTtcbn0gZnVuY3Rpb24geiggYSxiLGMgKSB7XG52YXIgZD1jLnBvaW50ZXJzLmxlbmd0aCxlPWMuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aCxmPWImRWEmJmQtZT09PTAsZz1iJiggR2F8SGEgKSYmZC1lPT09MDtjLmlzRmlyc3Q9ISFmLGMuaXNGaW5hbD0hIWcsZiYmKCBhLnNlc3Npb249e30gKSxjLmV2ZW50VHlwZT1iLEEoIGEsYyApLGEuZW1pdCggJ2hhbW1lci5pbnB1dCcsYyApLGEucmVjb2duaXplKCBjICksYS5zZXNzaW9uLnByZXZJbnB1dD1jO1xufSBmdW5jdGlvbiBBKCBhLGIgKSB7XG52YXIgYz1hLnNlc3Npb24sZD1iLnBvaW50ZXJzLGU9ZC5sZW5ndGg7Yy5maXJzdElucHV0fHwoIGMuZmlyc3RJbnB1dD1EKCBiICkgKSxlPjEmJiFjLmZpcnN0TXVsdGlwbGU/Yy5maXJzdE11bHRpcGxlPUQoIGIgKToxPT09ZSYmKCBjLmZpcnN0TXVsdGlwbGU9ITEgKTt2YXIgZj1jLmZpcnN0SW5wdXQsZz1jLmZpcnN0TXVsdGlwbGUsaD1nP2cuY2VudGVyOmYuY2VudGVyLGk9Yi5jZW50ZXI9RSggZCApO2IudGltZVN0YW1wPXJhKCksYi5kZWx0YVRpbWU9Yi50aW1lU3RhbXAtZi50aW1lU3RhbXAsYi5hbmdsZT1JKCBoLGkgKSxiLmRpc3RhbmNlPUgoIGgsaSApLEIoIGMsYiApLGIub2Zmc2V0RGlyZWN0aW9uPUcoIGIuZGVsdGFYLGIuZGVsdGFZICk7dmFyIGo9RiggYi5kZWx0YVRpbWUsYi5kZWx0YVgsYi5kZWx0YVkgKTtiLm92ZXJhbGxWZWxvY2l0eVg9ai54LGIub3ZlcmFsbFZlbG9jaXR5WT1qLnksYi5vdmVyYWxsVmVsb2NpdHk9cWEoIGoueCApPnFhKCBqLnkgKT9qLng6ai55LGIuc2NhbGU9Zz9LKCBnLnBvaW50ZXJzLGQgKToxLGIucm90YXRpb249Zz9KKCBnLnBvaW50ZXJzLGQgKTowLGIubWF4UG9pbnRlcnM9Yy5wcmV2SW5wdXQ/Yi5wb2ludGVycy5sZW5ndGg+Yy5wcmV2SW5wdXQubWF4UG9pbnRlcnM/Yi5wb2ludGVycy5sZW5ndGg6Yy5wcmV2SW5wdXQubWF4UG9pbnRlcnM6Yi5wb2ludGVycy5sZW5ndGgsQyggYyxiICk7dmFyIGs9YS5lbGVtZW50O28oIGIuc3JjRXZlbnQudGFyZ2V0LGsgKSYmKCBrPWIuc3JjRXZlbnQudGFyZ2V0ICksYi50YXJnZXQ9aztcbn0gZnVuY3Rpb24gQiggYSxiICkge1xudmFyIGM9Yi5jZW50ZXIsZD1hLm9mZnNldERlbHRhfHx7fSxlPWEucHJldkRlbHRhfHx7fSxmPWEucHJldklucHV0fHx7fTtiLmV2ZW50VHlwZSE9PUVhJiZmLmV2ZW50VHlwZSE9PUdhfHwoIGU9YS5wcmV2RGVsdGE9e3g6IGYuZGVsdGFYfHwwLHk6IGYuZGVsdGFZfHwwfSxkPWEub2Zmc2V0RGVsdGE9e3g6IGMueCx5OiBjLnl9ICksYi5kZWx0YVg9ZS54KyggYy54LWQueCApLGIuZGVsdGFZPWUueSsoIGMueS1kLnkgKTtcbn0gZnVuY3Rpb24gQyggYSxiICkge1xudmFyIGMsZSxmLGcsaD1hLmxhc3RJbnRlcnZhbHx8YixpPWIudGltZVN0YW1wLWgudGltZVN0YW1wO2lmICggYi5ldmVudFR5cGUhPUhhJiYoIGk+RGF8fGgudmVsb2NpdHk9PT1kICkgKSB7XG52YXIgaj1iLmRlbHRhWC1oLmRlbHRhWCxrPWIuZGVsdGFZLWguZGVsdGFZLGw9RiggaSxqLGsgKTtlPWwueCxmPWwueSxjPXFhKCBsLnggKT5xYSggbC55ICk/bC54OmwueSxnPUcoIGosayApLGEubGFzdEludGVydmFsPWI7XG59IGVsc2Uge1xuYz1oLnZlbG9jaXR5LGU9aC52ZWxvY2l0eVgsZj1oLnZlbG9jaXR5WSxnPWguZGlyZWN0aW9uO1xufWIudmVsb2NpdHk9YyxiLnZlbG9jaXR5WD1lLGIudmVsb2NpdHlZPWYsYi5kaXJlY3Rpb249Zztcbn0gZnVuY3Rpb24gRCggYSApIHtcbmZvciAoIHZhciBiPVtdLGM9MDtjPGEucG9pbnRlcnMubGVuZ3RoOyApIHtcbmJbIGMgXT17Y2xpZW50WDogcGEoIGEucG9pbnRlcnNbIGMgXS5jbGllbnRYICksY2xpZW50WTogcGEoIGEucG9pbnRlcnNbIGMgXS5jbGllbnRZICl9LGMrKztcbn0gcmV0dXJuIHt0aW1lU3RhbXA6IHJhKCkscG9pbnRlcnM6IGIsY2VudGVyOiBFKCBiICksZGVsdGFYOiBhLmRlbHRhWCxkZWx0YVk6IGEuZGVsdGFZfTtcbn0gZnVuY3Rpb24gRSggYSApIHtcbnZhciBiPWEubGVuZ3RoO2lmICggMT09PWIgKSB7XG5yZXR1cm4ge3g6IHBhKCBhWyAwIF0uY2xpZW50WCApLHk6IHBhKCBhWyAwIF0uY2xpZW50WSApfTtcbn0gZm9yICggdmFyIGM9MCxkPTAsZT0wO2I+ZTsgKSB7XG5jKz1hWyBlIF0uY2xpZW50WCxkKz1hWyBlIF0uY2xpZW50WSxlKys7XG59IHJldHVybiB7eDogcGEoIGMvYiApLHk6IHBhKCBkL2IgKX07XG59IGZ1bmN0aW9uIEYoIGEsYixjICkge1xucmV0dXJuIHt4OiBiL2F8fDAseTogYy9hfHwwfTtcbn0gZnVuY3Rpb24gRyggYSxiICkge1xucmV0dXJuIGE9PT1iP0lhOnFhKCBhICk+PXFhKCBiICk/MD5hP0phOkthOjA+Yj9MYTpNYTtcbn0gZnVuY3Rpb24gSCggYSxiLGMgKSB7XG5jfHwoIGM9UWEgKTt2YXIgZD1iWyBjWyAwIF0gXS1hWyBjWyAwIF0gXSxlPWJbIGNbIDEgXSBdLWFbIGNbIDEgXSBdO3JldHVybiBNYXRoLnNxcnQoIGQqZCtlKmUgKTtcbn0gZnVuY3Rpb24gSSggYSxiLGMgKSB7XG5jfHwoIGM9UWEgKTt2YXIgZD1iWyBjWyAwIF0gXS1hWyBjWyAwIF0gXSxlPWJbIGNbIDEgXSBdLWFbIGNbIDEgXSBdO3JldHVybiAxODAqTWF0aC5hdGFuMiggZSxkICkvTWF0aC5QSTtcbn0gZnVuY3Rpb24gSiggYSxiICkge1xucmV0dXJuIEkoIGJbIDEgXSxiWyAwIF0sUmEgKStJKCBhWyAxIF0sYVsgMCBdLFJhICk7XG59IGZ1bmN0aW9uIEsoIGEsYiApIHtcbnJldHVybiBIKCBiWyAwIF0sYlsgMSBdLFJhICkvSCggYVsgMCBdLGFbIDEgXSxSYSApO1xufSBmdW5jdGlvbiBMKCkge1xudGhpcy5ldkVsPVRhLHRoaXMuZXZXaW49VWEsdGhpcy5wcmVzc2VkPSExLHguYXBwbHkoIHRoaXMsYXJndW1lbnRzICk7XG59IGZ1bmN0aW9uIE0oKSB7XG50aGlzLmV2RWw9WGEsdGhpcy5ldldpbj1ZYSx4LmFwcGx5KCB0aGlzLGFyZ3VtZW50cyApLHRoaXMuc3RvcmU9dGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cz1bXTtcbn0gZnVuY3Rpb24gTigpIHtcbnRoaXMuZXZUYXJnZXQ9JGEsdGhpcy5ldldpbj1fYSx0aGlzLnN0YXJ0ZWQ9ITEseC5hcHBseSggdGhpcyxhcmd1bWVudHMgKTtcbn0gZnVuY3Rpb24gTyggYSxiICkge1xudmFyIGM9cyggYS50b3VjaGVzICksZD1zKCBhLmNoYW5nZWRUb3VjaGVzICk7cmV0dXJuIGImKCBHYXxIYSApJiYoIGM9dCggYy5jb25jYXQoIGQgKSwnaWRlbnRpZmllcicsITAgKSApLFsgYyxkIF07XG59IGZ1bmN0aW9uIFAoKSB7XG50aGlzLmV2VGFyZ2V0PWJiLHRoaXMudGFyZ2V0SWRzPXt9LHguYXBwbHkoIHRoaXMsYXJndW1lbnRzICk7XG59IGZ1bmN0aW9uIFEoIGEsYiApIHtcbnZhciBjPXMoIGEudG91Y2hlcyApLGQ9dGhpcy50YXJnZXRJZHM7aWYgKCBiJiggRWF8RmEgKSYmMT09PWMubGVuZ3RoICkge1xucmV0dXJuIGRbIGNbIDAgXS5pZGVudGlmaWVyIF09ITAsWyBjLGMgXTtcbn0gdmFyIGUsZixnPXMoIGEuY2hhbmdlZFRvdWNoZXMgKSxoPVtdLGk9dGhpcy50YXJnZXQ7aWYgKCBmPWMuZmlsdGVyKCBmdW5jdGlvbiggYSApIHtcbnJldHVybiBvKCBhLnRhcmdldCxpICk7XG59ICksYj09PUVhICkge1xuZm9yICggZT0wO2U8Zi5sZW5ndGg7ICkge1xuZFsgZlsgZSBdLmlkZW50aWZpZXIgXT0hMCxlKys7XG59XG59IGZvciAoIGU9MDtlPGcubGVuZ3RoOyApIHtcbmRbIGdbIGUgXS5pZGVudGlmaWVyIF0mJmgucHVzaCggZ1sgZSBdICksYiYoIEdhfEhhICkmJmRlbGV0ZSBkWyBnWyBlIF0uaWRlbnRpZmllciBdLGUrKztcbn0gcmV0dXJuIGgubGVuZ3RoP1sgdCggZi5jb25jYXQoIGggKSwnaWRlbnRpZmllcicsITAgKSxoIF06dm9pZCAwO1xufSBmdW5jdGlvbiBSKCkge1xueC5hcHBseSggdGhpcyxhcmd1bWVudHMgKTt2YXIgYT1qKCB0aGlzLmhhbmRsZXIsdGhpcyApO3RoaXMudG91Y2g9bmV3IFAoIHRoaXMubWFuYWdlcixhICksdGhpcy5tb3VzZT1uZXcgTCggdGhpcy5tYW5hZ2VyLGEgKSx0aGlzLnByaW1hcnlUb3VjaD1udWxsLHRoaXMubGFzdFRvdWNoZXM9W107XG59IGZ1bmN0aW9uIFMoIGEsYiApIHtcbmEmRWE/KCB0aGlzLnByaW1hcnlUb3VjaD1iLmNoYW5nZWRQb2ludGVyc1sgMCBdLmlkZW50aWZpZXIsVC5jYWxsKCB0aGlzLGIgKSApOmEmKCBHYXxIYSApJiZULmNhbGwoIHRoaXMsYiApO1xufSBmdW5jdGlvbiBUKCBhICkge1xudmFyIGI9YS5jaGFuZ2VkUG9pbnRlcnNbIDAgXTtpZiAoIGIuaWRlbnRpZmllcj09PXRoaXMucHJpbWFyeVRvdWNoICkge1xudmFyIGM9e3g6IGIuY2xpZW50WCx5OiBiLmNsaWVudFl9O3RoaXMubGFzdFRvdWNoZXMucHVzaCggYyApO3ZhciBkPXRoaXMubGFzdFRvdWNoZXMsZT1mdW5jdGlvbigpIHtcbnZhciBhPWQuaW5kZXhPZiggYyApO2E+LTEmJmQuc3BsaWNlKCBhLDEgKTtcbn07c2V0VGltZW91dCggZSxjYiApO1xufVxufSBmdW5jdGlvbiBVKCBhICkge1xuZm9yICggdmFyIGI9YS5zcmNFdmVudC5jbGllbnRYLGM9YS5zcmNFdmVudC5jbGllbnRZLGQ9MDtkPHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoO2QrKyApIHtcbnZhciBlPXRoaXMubGFzdFRvdWNoZXNbIGQgXSxmPU1hdGguYWJzKCBiLWUueCApLGc9TWF0aC5hYnMoIGMtZS55ICk7aWYgKCBkYj49ZiYmZGI+PWcgKSB7XG5yZXR1cm4gITA7XG59XG59IHJldHVybiAhMTtcbn0gZnVuY3Rpb24gViggYSxiICkge1xudGhpcy5tYW5hZ2VyPWEsdGhpcy5zZXQoIGIgKTtcbn0gZnVuY3Rpb24gVyggYSApIHtcbmlmICggcCggYSxqYiApICkge1xucmV0dXJuIGpiO1xufSB2YXIgYj1wKCBhLGtiICksYz1wKCBhLGxiICk7cmV0dXJuIGImJmM/amI6Ynx8Yz9iP2tiOmxiOnAoIGEsaWIgKT9pYjpoYjtcbn0gZnVuY3Rpb24gWCgpIHtcbmlmICggIWZiICkge1xucmV0dXJuICExO1xufSB2YXIgYj17fSxjPWEuQ1NTJiZhLkNTUy5zdXBwb3J0cztyZXR1cm4gWyAnYXV0bycsJ21hbmlwdWxhdGlvbicsJ3Bhbi15JywncGFuLXgnLCdwYW4teCBwYW4teScsJ25vbmUnIF0uZm9yRWFjaCggZnVuY3Rpb24oIGQgKSB7XG5iWyBkIF09Yz9hLkNTUy5zdXBwb3J0cyggJ3RvdWNoLWFjdGlvbicsZCApOiEwO1xufSApLGI7XG59IGZ1bmN0aW9uIFkoIGEgKSB7XG50aGlzLm9wdGlvbnM9bGEoIHt9LHRoaXMuZGVmYXVsdHMsYXx8e30gKSx0aGlzLmlkPXYoKSx0aGlzLm1hbmFnZXI9bnVsbCx0aGlzLm9wdGlvbnMuZW5hYmxlPWwoIHRoaXMub3B0aW9ucy5lbmFibGUsITAgKSx0aGlzLnN0YXRlPW5iLHRoaXMuc2ltdWx0YW5lb3VzPXt9LHRoaXMucmVxdWlyZUZhaWw9W107XG59IGZ1bmN0aW9uIFooIGEgKSB7XG5yZXR1cm4gYSZzYj8nY2FuY2VsJzphJnFiPydlbmQnOmEmcGI/J21vdmUnOmEmb2I/J3N0YXJ0JzonJztcbn0gZnVuY3Rpb24gJCggYSApIHtcbnJldHVybiBhPT1NYT8nZG93bic6YT09TGE/J3VwJzphPT1KYT8nbGVmdCc6YT09S2E/J3JpZ2h0JzonJztcbn0gZnVuY3Rpb24gXyggYSxiICkge1xudmFyIGM9Yi5tYW5hZ2VyO3JldHVybiBjP2MuZ2V0KCBhICk6YTtcbn0gZnVuY3Rpb24gYWEoKSB7XG5ZLmFwcGx5KCB0aGlzLGFyZ3VtZW50cyApO1xufSBmdW5jdGlvbiBiYSgpIHtcbmFhLmFwcGx5KCB0aGlzLGFyZ3VtZW50cyApLHRoaXMucFg9bnVsbCx0aGlzLnBZPW51bGw7XG59IGZ1bmN0aW9uIGNhKCkge1xuYWEuYXBwbHkoIHRoaXMsYXJndW1lbnRzICk7XG59IGZ1bmN0aW9uIGRhKCkge1xuWS5hcHBseSggdGhpcyxhcmd1bWVudHMgKSx0aGlzLl90aW1lcj1udWxsLHRoaXMuX2lucHV0PW51bGw7XG59IGZ1bmN0aW9uIGVhKCkge1xuYWEuYXBwbHkoIHRoaXMsYXJndW1lbnRzICk7XG59IGZ1bmN0aW9uIGZhKCkge1xuYWEuYXBwbHkoIHRoaXMsYXJndW1lbnRzICk7XG59IGZ1bmN0aW9uIGdhKCkge1xuWS5hcHBseSggdGhpcyxhcmd1bWVudHMgKSx0aGlzLnBUaW1lPSExLHRoaXMucENlbnRlcj0hMSx0aGlzLl90aW1lcj1udWxsLHRoaXMuX2lucHV0PW51bGwsdGhpcy5jb3VudD0wO1xufSBmdW5jdGlvbiBoYSggYSxiICkge1xucmV0dXJuIGI9Ynx8e30sYi5yZWNvZ25pemVycz1sKCBiLnJlY29nbml6ZXJzLGhhLmRlZmF1bHRzLnByZXNldCApLG5ldyBpYSggYSxiICk7XG59IGZ1bmN0aW9uIGlhKCBhLGIgKSB7XG50aGlzLm9wdGlvbnM9bGEoIHt9LGhhLmRlZmF1bHRzLGJ8fHt9ICksdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0PXRoaXMub3B0aW9ucy5pbnB1dFRhcmdldHx8YSx0aGlzLmhhbmRsZXJzPXt9LHRoaXMuc2Vzc2lvbj17fSx0aGlzLnJlY29nbml6ZXJzPVtdLHRoaXMub2xkQ3NzUHJvcHM9e30sdGhpcy5lbGVtZW50PWEsdGhpcy5pbnB1dD15KCB0aGlzICksdGhpcy50b3VjaEFjdGlvbj1uZXcgViggdGhpcyx0aGlzLm9wdGlvbnMudG91Y2hBY3Rpb24gKSxqYSggdGhpcywhMCApLGcoIHRoaXMub3B0aW9ucy5yZWNvZ25pemVycyxmdW5jdGlvbiggYSApIHtcbnZhciBiPXRoaXMuYWRkKCBuZXcgYVsgMCBdKCBhWyAxIF0gKSApO2FbIDIgXSYmYi5yZWNvZ25pemVXaXRoKCBhWyAyIF0gKSxhWyAzIF0mJmIucmVxdWlyZUZhaWx1cmUoIGFbIDMgXSApO1xufSx0aGlzICk7XG59IGZ1bmN0aW9uIGphKCBhLGIgKSB7XG52YXIgYz1hLmVsZW1lbnQ7aWYgKCBjLnN0eWxlICkge1xudmFyIGQ7ZyggYS5vcHRpb25zLmNzc1Byb3BzLGZ1bmN0aW9uKCBlLGYgKSB7XG5kPXUoIGMuc3R5bGUsZiApLGI/KCBhLm9sZENzc1Byb3BzWyBkIF09Yy5zdHlsZVsgZCBdLGMuc3R5bGVbIGQgXT1lICk6Yy5zdHlsZVsgZCBdPWEub2xkQ3NzUHJvcHNbIGQgXXx8Jyc7XG59ICksYnx8KCBhLm9sZENzc1Byb3BzPXt9ICk7XG59XG59IGZ1bmN0aW9uIGthKCBhLGMgKSB7XG52YXIgZD1iLmNyZWF0ZUV2ZW50KCAnRXZlbnQnICk7ZC5pbml0RXZlbnQoIGEsITAsITAgKSxkLmdlc3R1cmU9YyxjLnRhcmdldC5kaXNwYXRjaEV2ZW50KCBkICk7XG59IHZhciBsYSxtYT1bICcnLCd3ZWJraXQnLCdNb3onLCdNUycsJ21zJywnbycgXSxuYT1iLmNyZWF0ZUVsZW1lbnQoICdkaXYnICksb2E9J2Z1bmN0aW9uJyxwYT1NYXRoLnJvdW5kLHFhPU1hdGguYWJzLHJhPURhdGUubm93O2xhPSdmdW5jdGlvbichPXR5cGVvZiBPYmplY3QuYXNzaWduP2Z1bmN0aW9uKCBhICkge1xuaWYgKCBhPT09ZHx8bnVsbD09PWEgKSB7XG50aHJvdyBuZXcgVHlwZUVycm9yKCAnQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0JyApO1xufSBmb3IgKCB2YXIgYj1PYmplY3QoIGEgKSxjPTE7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKyApIHtcbnZhciBlPWFyZ3VtZW50c1sgYyBdO2lmICggZSE9PWQmJm51bGwhPT1lICkge1xuZm9yICggdmFyIGYgaW4gZSApIHtcbmUuaGFzT3duUHJvcGVydHkoIGYgKSYmKCBiWyBmIF09ZVsgZiBdICk7XG59XG59XG59IHJldHVybiBiO1xufTpPYmplY3QuYXNzaWduO3ZhciBzYT1oKCBmdW5jdGlvbiggYSxiLGMgKSB7XG5mb3IgKCB2YXIgZT1PYmplY3Qua2V5cyggYiApLGY9MDtmPGUubGVuZ3RoOyApIHtcbiggIWN8fGMmJmFbIGVbIGYgXSBdPT09ZCApJiYoIGFbIGVbIGYgXSBdPWJbIGVbIGYgXSBdICksZisrO1xufSByZXR1cm4gYTtcbn0sJ2V4dGVuZCcsJ1VzZSBgYXNzaWduYC4nICksdGE9aCggZnVuY3Rpb24oIGEsYiApIHtcbnJldHVybiBzYSggYSxiLCEwICk7XG59LCdtZXJnZScsJ1VzZSBgYXNzaWduYC4nICksdWE9MSx2YT0vbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2ksd2E9J29udG91Y2hzdGFydCdpbiBhLHhhPXUoIGEsJ1BvaW50ZXJFdmVudCcgKSE9PWQseWE9d2EmJnZhLnRlc3QoIG5hdmlnYXRvci51c2VyQWdlbnQgKSx6YT0ndG91Y2gnLEFhPSdwZW4nLEJhPSdtb3VzZScsQ2E9J2tpbmVjdCcsRGE9MjUsRWE9MSxGYT0yLEdhPTQsSGE9OCxJYT0xLEphPTIsS2E9NCxMYT04LE1hPTE2LE5hPUphfEthLE9hPUxhfE1hLFBhPU5hfE9hLFFhPVsgJ3gnLCd5JyBdLFJhPVsgJ2NsaWVudFgnLCdjbGllbnRZJyBdO3gucHJvdG90eXBlPXtoYW5kbGVyOiBmdW5jdGlvbigpIHt9LGluaXQ6IGZ1bmN0aW9uKCkge1xudGhpcy5ldkVsJiZtKCB0aGlzLmVsZW1lbnQsdGhpcy5ldkVsLHRoaXMuZG9tSGFuZGxlciApLHRoaXMuZXZUYXJnZXQmJm0oIHRoaXMudGFyZ2V0LHRoaXMuZXZUYXJnZXQsdGhpcy5kb21IYW5kbGVyICksdGhpcy5ldldpbiYmbSggdyggdGhpcy5lbGVtZW50ICksdGhpcy5ldldpbix0aGlzLmRvbUhhbmRsZXIgKTtcbn0sZGVzdHJveTogZnVuY3Rpb24oKSB7XG50aGlzLmV2RWwmJm4oIHRoaXMuZWxlbWVudCx0aGlzLmV2RWwsdGhpcy5kb21IYW5kbGVyICksdGhpcy5ldlRhcmdldCYmbiggdGhpcy50YXJnZXQsdGhpcy5ldlRhcmdldCx0aGlzLmRvbUhhbmRsZXIgKSx0aGlzLmV2V2luJiZuKCB3KCB0aGlzLmVsZW1lbnQgKSx0aGlzLmV2V2luLHRoaXMuZG9tSGFuZGxlciApO1xufX07dmFyIFNhPXttb3VzZWRvd246IEVhLG1vdXNlbW92ZTogRmEsbW91c2V1cDogR2F9LFRhPSdtb3VzZWRvd24nLFVhPSdtb3VzZW1vdmUgbW91c2V1cCc7aSggTCx4LHtoYW5kbGVyOiBmdW5jdGlvbiggYSApIHtcbnZhciBiPVNhWyBhLnR5cGUgXTtiJkVhJiYwPT09YS5idXR0b24mJiggdGhpcy5wcmVzc2VkPSEwICksYiZGYSYmMSE9PWEud2hpY2gmJiggYj1HYSApLHRoaXMucHJlc3NlZCYmKCBiJkdhJiYoIHRoaXMucHJlc3NlZD0hMSApLHRoaXMuY2FsbGJhY2soIHRoaXMubWFuYWdlcixiLHtwb2ludGVyczogWyBhIF0sY2hhbmdlZFBvaW50ZXJzOiBbIGEgXSxwb2ludGVyVHlwZTogQmEsc3JjRXZlbnQ6IGF9ICkgKTtcbn19ICk7dmFyIFZhPXtwb2ludGVyZG93bjogRWEscG9pbnRlcm1vdmU6IEZhLHBvaW50ZXJ1cDogR2EscG9pbnRlcmNhbmNlbDogSGEscG9pbnRlcm91dDogSGF9LFdhPXsyOiB6YSwzOiBBYSw0OiBCYSw1OiBDYX0sWGE9J3BvaW50ZXJkb3duJyxZYT0ncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO2EuTVNQb2ludGVyRXZlbnQmJiFhLlBvaW50ZXJFdmVudCYmKCBYYT0nTVNQb2ludGVyRG93bicsWWE9J01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJyApLGkoIE0seCx7aGFuZGxlcjogZnVuY3Rpb24oIGEgKSB7XG52YXIgYj10aGlzLnN0b3JlLGM9ITEsZD1hLnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCAnbXMnLCcnICksZT1WYVsgZCBdLGY9V2FbIGEucG9pbnRlclR5cGUgXXx8YS5wb2ludGVyVHlwZSxnPWY9PXphLGg9ciggYixhLnBvaW50ZXJJZCwncG9pbnRlcklkJyApO2UmRWEmJiggMD09PWEuYnV0dG9ufHxnICk/MD5oJiYoIGIucHVzaCggYSApLGg9Yi5sZW5ndGgtMSApOmUmKCBHYXxIYSApJiYoIGM9ITAgKSwwPmh8fCggYlsgaCBdPWEsdGhpcy5jYWxsYmFjayggdGhpcy5tYW5hZ2VyLGUse3BvaW50ZXJzOiBiLGNoYW5nZWRQb2ludGVyczogWyBhIF0scG9pbnRlclR5cGU6IGYsc3JjRXZlbnQ6IGF9ICksYyYmYi5zcGxpY2UoIGgsMSApICk7XG59fSApO3ZhciBaYT17dG91Y2hzdGFydDogRWEsdG91Y2htb3ZlOiBGYSx0b3VjaGVuZDogR2EsdG91Y2hjYW5jZWw6IEhhfSwkYT0ndG91Y2hzdGFydCcsX2E9J3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztpKCBOLHgse2hhbmRsZXI6IGZ1bmN0aW9uKCBhICkge1xudmFyIGI9WmFbIGEudHlwZSBdO2lmICggYj09PUVhJiYoIHRoaXMuc3RhcnRlZD0hMCApLHRoaXMuc3RhcnRlZCApIHtcbnZhciBjPU8uY2FsbCggdGhpcyxhLGIgKTtiJiggR2F8SGEgKSYmY1sgMCBdLmxlbmd0aC1jWyAxIF0ubGVuZ3RoPT09MCYmKCB0aGlzLnN0YXJ0ZWQ9ITEgKSx0aGlzLmNhbGxiYWNrKCB0aGlzLm1hbmFnZXIsYix7cG9pbnRlcnM6IGNbIDAgXSxjaGFuZ2VkUG9pbnRlcnM6IGNbIDEgXSxwb2ludGVyVHlwZTogemEsc3JjRXZlbnQ6IGF9ICk7XG59XG59fSApO3ZhciBhYj17dG91Y2hzdGFydDogRWEsdG91Y2htb3ZlOiBGYSx0b3VjaGVuZDogR2EsdG91Y2hjYW5jZWw6IEhhfSxiYj0ndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO2koIFAseCx7aGFuZGxlcjogZnVuY3Rpb24oIGEgKSB7XG52YXIgYj1hYlsgYS50eXBlIF0sYz1RLmNhbGwoIHRoaXMsYSxiICk7YyYmdGhpcy5jYWxsYmFjayggdGhpcy5tYW5hZ2VyLGIse3BvaW50ZXJzOiBjWyAwIF0sY2hhbmdlZFBvaW50ZXJzOiBjWyAxIF0scG9pbnRlclR5cGU6IHphLHNyY0V2ZW50OiBhfSApO1xufX0gKTt2YXIgY2I9MjUwMCxkYj0yNTtpKCBSLHgse2hhbmRsZXI6IGZ1bmN0aW9uKCBhLGIsYyApIHtcbnZhciBkPWMucG9pbnRlclR5cGU9PXphLGU9Yy5wb2ludGVyVHlwZT09QmE7aWYgKCAhKCBlJiZjLnNvdXJjZUNhcGFiaWxpdGllcyYmYy5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cyApICkge1xuaWYgKCBkICkge1xuUy5jYWxsKCB0aGlzLGIsYyApO1xufSBlbHNlIGlmICggZSYmVS5jYWxsKCB0aGlzLGMgKSApIHtcbnJldHVybjtcbn0gdGhpcy5jYWxsYmFjayggYSxiLGMgKTtcbn1cbn0sZGVzdHJveTogZnVuY3Rpb24oKSB7XG50aGlzLnRvdWNoLmRlc3Ryb3koKSx0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbn19ICk7dmFyIGViPXUoIG5hLnN0eWxlLCd0b3VjaEFjdGlvbicgKSxmYj1lYiE9PWQsZ2I9J2NvbXB1dGUnLGhiPSdhdXRvJyxpYj0nbWFuaXB1bGF0aW9uJyxqYj0nbm9uZScsa2I9J3Bhbi14JyxsYj0ncGFuLXknLG1iPVgoKTtWLnByb3RvdHlwZT17c2V0OiBmdW5jdGlvbiggYSApIHtcbmE9PWdiJiYoIGE9dGhpcy5jb21wdXRlKCkgKSxmYiYmdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUmJm1iWyBhIF0mJiggdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbIGViIF09YSApLHRoaXMuYWN0aW9ucz1hLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xufSx1cGRhdGU6IGZ1bmN0aW9uKCkge1xudGhpcy5zZXQoIHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uICk7XG59LGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xudmFyIGE9W107cmV0dXJuIGcoIHRoaXMubWFuYWdlci5yZWNvZ25pemVycyxmdW5jdGlvbiggYiApIHtcbmsoIGIub3B0aW9ucy5lbmFibGUsWyBiIF0gKSYmKCBhPWEuY29uY2F0KCBiLmdldFRvdWNoQWN0aW9uKCkgKSApO1xufSApLFcoIGEuam9pbiggJyAnICkgKTtcbn0scHJldmVudERlZmF1bHRzOiBmdW5jdGlvbiggYSApIHtcbnZhciBiPWEuc3JjRXZlbnQsYz1hLm9mZnNldERpcmVjdGlvbjtpZiAoIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCApIHtcbnJldHVybiB2b2lkIGIucHJldmVudERlZmF1bHQoKTtcbn0gdmFyIGQ9dGhpcy5hY3Rpb25zLGU9cCggZCxqYiApJiYhbWJbIGpiIF0sZj1wKCBkLGxiICkmJiFtYlsgbGIgXSxnPXAoIGQsa2IgKSYmIW1iWyBrYiBdO2lmICggZSApIHtcbnZhciBoPTE9PT1hLnBvaW50ZXJzLmxlbmd0aCxpPWEuZGlzdGFuY2U8MixqPWEuZGVsdGFUaW1lPDI1MDtpZiAoIGgmJmkmJmogKSB7XG5yZXR1cm47XG59XG59IHJldHVybiBnJiZmP3ZvaWQgMDplfHxmJiZjJk5hfHxnJiZjJk9hP3RoaXMucHJldmVudFNyYyggYiApOnZvaWQgMDtcbn0scHJldmVudFNyYzogZnVuY3Rpb24oIGEgKSB7XG50aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQ9ITAsYS5wcmV2ZW50RGVmYXVsdCgpO1xufX07dmFyIG5iPTEsb2I9MixwYj00LHFiPTgscmI9cWIsc2I9MTYsdGI9MzI7WS5wcm90b3R5cGU9e2RlZmF1bHRzOiB7fSxzZXQ6IGZ1bmN0aW9uKCBhICkge1xucmV0dXJuIGxhKCB0aGlzLm9wdGlvbnMsYSApLHRoaXMubWFuYWdlciYmdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpLHRoaXM7XG59LHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKCBhICkge1xuaWYgKCBmKCBhLCdyZWNvZ25pemVXaXRoJyx0aGlzICkgKSB7XG5yZXR1cm4gdGhpcztcbn0gdmFyIGI9dGhpcy5zaW11bHRhbmVvdXM7cmV0dXJuIGE9XyggYSx0aGlzICksYlsgYS5pZCBdfHwoIGJbIGEuaWQgXT1hLGEucmVjb2duaXplV2l0aCggdGhpcyApICksdGhpcztcbn0sZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKCBhICkge1xucmV0dXJuIGYoIGEsJ2Ryb3BSZWNvZ25pemVXaXRoJyx0aGlzICk/dGhpczooIGE9XyggYSx0aGlzICksZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzWyBhLmlkIF0sdGhpcyApO1xufSxyZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24oIGEgKSB7XG5pZiAoIGYoIGEsJ3JlcXVpcmVGYWlsdXJlJyx0aGlzICkgKSB7XG5yZXR1cm4gdGhpcztcbn0gdmFyIGI9dGhpcy5yZXF1aXJlRmFpbDtyZXR1cm4gYT1fKCBhLHRoaXMgKSwtMT09PXIoIGIsYSApJiYoIGIucHVzaCggYSApLGEucmVxdWlyZUZhaWx1cmUoIHRoaXMgKSApLHRoaXM7XG59LGRyb3BSZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24oIGEgKSB7XG5pZiAoIGYoIGEsJ2Ryb3BSZXF1aXJlRmFpbHVyZScsdGhpcyApICkge1xucmV0dXJuIHRoaXM7XG59YT1fKCBhLHRoaXMgKTt2YXIgYj1yKCB0aGlzLnJlcXVpcmVGYWlsLGEgKTtyZXR1cm4gYj4tMSYmdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoIGIsMSApLHRoaXM7XG59LGhhc1JlcXVpcmVGYWlsdXJlczogZnVuY3Rpb24oKSB7XG5yZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGg+MDtcbn0sY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24oIGEgKSB7XG5yZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1sgYS5pZCBdO1xufSxlbWl0OiBmdW5jdGlvbiggYSApIHtcbmZ1bmN0aW9uIGIoIGIgKSB7XG5jLm1hbmFnZXIuZW1pdCggYixhICk7XG59IHZhciBjPXRoaXMsZD10aGlzLnN0YXRlO3FiPmQmJmIoIGMub3B0aW9ucy5ldmVudCtaKCBkICkgKSxiKCBjLm9wdGlvbnMuZXZlbnQgKSxhLmFkZGl0aW9uYWxFdmVudCYmYiggYS5hZGRpdGlvbmFsRXZlbnQgKSxkPj1xYiYmYiggYy5vcHRpb25zLmV2ZW50K1ooIGQgKSApO1xufSx0cnlFbWl0OiBmdW5jdGlvbiggYSApIHtcbnJldHVybiB0aGlzLmNhbkVtaXQoKT90aGlzLmVtaXQoIGEgKTp2b2lkKCB0aGlzLnN0YXRlPXRiICk7XG59LGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xuZm9yICggdmFyIGE9MDthPHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoOyApIHtcbmlmICggISggdGhpcy5yZXF1aXJlRmFpbFsgYSBdLnN0YXRlJiggdGJ8bmIgKSApICkge1xucmV0dXJuICExO1xufWErKztcbn0gcmV0dXJuICEwO1xufSxyZWNvZ25pemU6IGZ1bmN0aW9uKCBhICkge1xudmFyIGI9bGEoIHt9LGEgKTtyZXR1cm4gayggdGhpcy5vcHRpb25zLmVuYWJsZSxbIHRoaXMsYiBdICk/KCB0aGlzLnN0YXRlJiggcmJ8c2J8dGIgKSYmKCB0aGlzLnN0YXRlPW5iICksdGhpcy5zdGF0ZT10aGlzLnByb2Nlc3MoIGIgKSx2b2lkKCB0aGlzLnN0YXRlJiggb2J8cGJ8cWJ8c2IgKSYmdGhpcy50cnlFbWl0KCBiICkgKSApOiggdGhpcy5yZXNldCgpLHZvaWQoIHRoaXMuc3RhdGU9dGIgKSApO1xufSxwcm9jZXNzOiBmdW5jdGlvbiggYSApIHt9LGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHt9LHJlc2V0OiBmdW5jdGlvbigpIHt9fSxpKCBhYSxZLHtkZWZhdWx0czoge3BvaW50ZXJzOiAxfSxhdHRyVGVzdDogZnVuY3Rpb24oIGEgKSB7XG52YXIgYj10aGlzLm9wdGlvbnMucG9pbnRlcnM7cmV0dXJuIDA9PT1ifHxhLnBvaW50ZXJzLmxlbmd0aD09PWI7XG59LHByb2Nlc3M6IGZ1bmN0aW9uKCBhICkge1xudmFyIGI9dGhpcy5zdGF0ZSxjPWEuZXZlbnRUeXBlLGQ9YiYoIG9ifHBiICksZT10aGlzLmF0dHJUZXN0KCBhICk7cmV0dXJuIGQmJiggYyZIYXx8IWUgKT9ifHNiOmR8fGU/YyZHYT9ifHFiOmImb2I/YnxwYjpvYjp0Yjtcbn19ICksaSggYmEsYWEse2RlZmF1bHRzOiB7ZXZlbnQ6ICdwYW4nLHRocmVzaG9sZDogMTAscG9pbnRlcnM6IDEsZGlyZWN0aW9uOiBQYX0sZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xudmFyIGE9dGhpcy5vcHRpb25zLmRpcmVjdGlvbixiPVtdO3JldHVybiBhJk5hJiZiLnB1c2goIGxiICksYSZPYSYmYi5wdXNoKCBrYiApLGI7XG59LGRpcmVjdGlvblRlc3Q6IGZ1bmN0aW9uKCBhICkge1xudmFyIGI9dGhpcy5vcHRpb25zLGM9ITAsZD1hLmRpc3RhbmNlLGU9YS5kaXJlY3Rpb24sZj1hLmRlbHRhWCxnPWEuZGVsdGFZO3JldHVybiBlJmIuZGlyZWN0aW9ufHwoIGIuZGlyZWN0aW9uJk5hPyggZT0wPT09Zj9JYTowPmY/SmE6S2EsYz1mIT10aGlzLnBYLGQ9TWF0aC5hYnMoIGEuZGVsdGFYICkgKTooIGU9MD09PWc/SWE6MD5nP0xhOk1hLGM9ZyE9dGhpcy5wWSxkPU1hdGguYWJzKCBhLmRlbHRhWSApICkgKSxhLmRpcmVjdGlvbj1lLGMmJmQ+Yi50aHJlc2hvbGQmJmUmYi5kaXJlY3Rpb247XG59LGF0dHJUZXN0OiBmdW5jdGlvbiggYSApIHtcbnJldHVybiBhYS5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCggdGhpcyxhICkmJiggdGhpcy5zdGF0ZSZvYnx8ISggdGhpcy5zdGF0ZSZvYiApJiZ0aGlzLmRpcmVjdGlvblRlc3QoIGEgKSApO1xufSxlbWl0OiBmdW5jdGlvbiggYSApIHtcbnRoaXMucFg9YS5kZWx0YVgsdGhpcy5wWT1hLmRlbHRhWTt2YXIgYj0kKCBhLmRpcmVjdGlvbiApO2ImJiggYS5hZGRpdGlvbmFsRXZlbnQ9dGhpcy5vcHRpb25zLmV2ZW50K2IgKSx0aGlzLl9zdXBlci5lbWl0LmNhbGwoIHRoaXMsYSApO1xufX0gKSxpKCBjYSxhYSx7ZGVmYXVsdHM6IHtldmVudDogJ3BpbmNoJyx0aHJlc2hvbGQ6IDAscG9pbnRlcnM6IDJ9LGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbnJldHVybiBbIGpiIF07XG59LGF0dHJUZXN0OiBmdW5jdGlvbiggYSApIHtcbnJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKCB0aGlzLGEgKSYmKCBNYXRoLmFicyggYS5zY2FsZS0xICk+IHRoaXMub3B0aW9ucy50aHJlc2hvbGR8fHRoaXMuc3RhdGUmb2IgKTtcbn0sZW1pdDogZnVuY3Rpb24oIGEgKSB7XG5pZiAoIDEhPT1hLnNjYWxlICkge1xudmFyIGI9YS5zY2FsZTwxPydpbic6J291dCc7YS5hZGRpdGlvbmFsRXZlbnQ9dGhpcy5vcHRpb25zLmV2ZW50K2I7XG59IHRoaXMuX3N1cGVyLmVtaXQuY2FsbCggdGhpcyxhICk7XG59fSApLGkoIGRhLFkse2RlZmF1bHRzOiB7ZXZlbnQ6ICdwcmVzcycscG9pbnRlcnM6IDEsdGltZTogMjUxLHRocmVzaG9sZDogOX0sZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xucmV0dXJuIFsgaGIgXTtcbn0scHJvY2VzczogZnVuY3Rpb24oIGEgKSB7XG52YXIgYj10aGlzLm9wdGlvbnMsYz1hLnBvaW50ZXJzLmxlbmd0aD09PWIucG9pbnRlcnMsZD1hLmRpc3RhbmNlPGIudGhyZXNob2xkLGY9YS5kZWx0YVRpbWU+Yi50aW1lO2lmICggdGhpcy5faW5wdXQ9YSwhZHx8IWN8fGEuZXZlbnRUeXBlJiggR2F8SGEgKSYmIWYgKSB7XG50aGlzLnJlc2V0KCk7XG59IGVsc2UgaWYgKCBhLmV2ZW50VHlwZSZFYSApIHtcbnRoaXMucmVzZXQoKSx0aGlzLl90aW1lcj1lKCBmdW5jdGlvbigpIHtcbnRoaXMuc3RhdGU9cmIsdGhpcy50cnlFbWl0KCk7XG59LGIudGltZSx0aGlzICk7XG59IGVsc2UgaWYgKCBhLmV2ZW50VHlwZSZHYSApIHtcbnJldHVybiByYjtcbn0gcmV0dXJuIHRiO1xufSxyZXNldDogZnVuY3Rpb24oKSB7XG5jbGVhclRpbWVvdXQoIHRoaXMuX3RpbWVyICk7XG59LGVtaXQ6IGZ1bmN0aW9uKCBhICkge1xudGhpcy5zdGF0ZT09PXJiJiYoIGEmJmEuZXZlbnRUeXBlJkdhP3RoaXMubWFuYWdlci5lbWl0KCB0aGlzLm9wdGlvbnMuZXZlbnQrJ3VwJyxhICk6KCB0aGlzLl9pbnB1dC50aW1lU3RhbXA9cmEoKSx0aGlzLm1hbmFnZXIuZW1pdCggdGhpcy5vcHRpb25zLmV2ZW50LHRoaXMuX2lucHV0ICkgKSApO1xufX0gKSxpKCBlYSxhYSx7ZGVmYXVsdHM6IHtldmVudDogJ3JvdGF0ZScsdGhyZXNob2xkOiAwLHBvaW50ZXJzOiAyfSxnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG5yZXR1cm4gWyBqYiBdO1xufSxhdHRyVGVzdDogZnVuY3Rpb24oIGEgKSB7XG5yZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCggdGhpcyxhICkmJiggTWF0aC5hYnMoIGEucm90YXRpb24gKT4gdGhpcy5vcHRpb25zLnRocmVzaG9sZHx8dGhpcy5zdGF0ZSZvYiApO1xufX0gKSxpKCBmYSxhYSx7ZGVmYXVsdHM6IHtldmVudDogJ3N3aXBlJyx0aHJlc2hvbGQ6IDEwLHZlbG9jaXR5OiAuMyxkaXJlY3Rpb246IE5hfE9hLHBvaW50ZXJzOiAxfSxnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG5yZXR1cm4gYmEucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwoIHRoaXMgKTtcbn0sYXR0clRlc3Q6IGZ1bmN0aW9uKCBhICkge1xudmFyIGIsYz10aGlzLm9wdGlvbnMuZGlyZWN0aW9uO3JldHVybiBjJiggTmF8T2EgKT9iPWEub3ZlcmFsbFZlbG9jaXR5OmMmTmE/Yj1hLm92ZXJhbGxWZWxvY2l0eVg6YyZPYSYmKCBiPWEub3ZlcmFsbFZlbG9jaXR5WSApLHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwoIHRoaXMsYSApJiZjJmEub2Zmc2V0RGlyZWN0aW9uJiZhLmRpc3RhbmNlPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkJiZhLm1heFBvaW50ZXJzPT10aGlzLm9wdGlvbnMucG9pbnRlcnMmJnFhKCBiICk+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSYmYS5ldmVudFR5cGUmR2E7XG59LGVtaXQ6IGZ1bmN0aW9uKCBhICkge1xudmFyIGI9JCggYS5vZmZzZXREaXJlY3Rpb24gKTtiJiZ0aGlzLm1hbmFnZXIuZW1pdCggdGhpcy5vcHRpb25zLmV2ZW50K2IsYSApLHRoaXMubWFuYWdlci5lbWl0KCB0aGlzLm9wdGlvbnMuZXZlbnQsYSApO1xufX0gKSxpKCBnYSxZLHtkZWZhdWx0czoge2V2ZW50OiAndGFwJyxwb2ludGVyczogMSx0YXBzOiAxLGludGVydmFsOiAzMDAsdGltZTogMjUwLHRocmVzaG9sZDogOSxwb3NUaHJlc2hvbGQ6IDEwfSxnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG5yZXR1cm4gWyBpYiBdO1xufSxwcm9jZXNzOiBmdW5jdGlvbiggYSApIHtcbnZhciBiPXRoaXMub3B0aW9ucyxjPWEucG9pbnRlcnMubGVuZ3RoPT09Yi5wb2ludGVycyxkPWEuZGlzdGFuY2U8Yi50aHJlc2hvbGQsZj1hLmRlbHRhVGltZTxiLnRpbWU7aWYgKCB0aGlzLnJlc2V0KCksYS5ldmVudFR5cGUmRWEmJjA9PT10aGlzLmNvdW50ICkge1xucmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbn0gaWYgKCBkJiZmJiZjICkge1xuaWYgKCBhLmV2ZW50VHlwZSE9R2EgKSB7XG5yZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xufSB2YXIgZz10aGlzLnBUaW1lP2EudGltZVN0YW1wLXRoaXMucFRpbWU8Yi5pbnRlcnZhbDohMCxoPSF0aGlzLnBDZW50ZXJ8fEgoIHRoaXMucENlbnRlcixhLmNlbnRlciApPGIucG9zVGhyZXNob2xkO3RoaXMucFRpbWU9YS50aW1lU3RhbXAsdGhpcy5wQ2VudGVyPWEuY2VudGVyLGgmJmc/dGhpcy5jb3VudCs9MTp0aGlzLmNvdW50PTEsdGhpcy5faW5wdXQ9YTt2YXIgaT10aGlzLmNvdW50JWIudGFwcztpZiAoIDA9PT1pICkge1xucmV0dXJuIHRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCk/KCB0aGlzLl90aW1lcj1lKCBmdW5jdGlvbigpIHtcbnRoaXMuc3RhdGU9cmIsdGhpcy50cnlFbWl0KCk7XG59LGIuaW50ZXJ2YWwsdGhpcyApLG9iICk6cmI7XG59XG59IHJldHVybiB0Yjtcbn0sZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xucmV0dXJuIHRoaXMuX3RpbWVyPWUoIGZ1bmN0aW9uKCkge1xudGhpcy5zdGF0ZT10Yjtcbn0sdGhpcy5vcHRpb25zLmludGVydmFsLHRoaXMgKSx0Yjtcbn0scmVzZXQ6IGZ1bmN0aW9uKCkge1xuY2xlYXJUaW1lb3V0KCB0aGlzLl90aW1lciApO1xufSxlbWl0OiBmdW5jdGlvbigpIHtcbnRoaXMuc3RhdGU9PXJiJiYoIHRoaXMuX2lucHV0LnRhcENvdW50PXRoaXMuY291bnQsdGhpcy5tYW5hZ2VyLmVtaXQoIHRoaXMub3B0aW9ucy5ldmVudCx0aGlzLl9pbnB1dCApICk7XG59fSApLGhhLlZFUlNJT049JzIuMC44JyxoYS5kZWZhdWx0cz17ZG9tRXZlbnRzOiAhMSx0b3VjaEFjdGlvbjogZ2IsZW5hYmxlOiAhMCxpbnB1dFRhcmdldDogbnVsbCxpbnB1dENsYXNzOiBudWxsLHByZXNldDogWyBbIGVhLHtlbmFibGU6ICExfSBdLFsgY2Ese2VuYWJsZTogITF9LFsgJ3JvdGF0ZScgXSBdLFsgZmEse2RpcmVjdGlvbjogTmF9IF0sWyBiYSx7ZGlyZWN0aW9uOiBOYX0sWyAnc3dpcGUnIF0gXSxbIGdhIF0sWyBnYSx7ZXZlbnQ6ICdkb3VibGV0YXAnLHRhcHM6IDJ9LFsgJ3RhcCcgXSBdLFsgZGEgXSBdLGNzc1Byb3BzOiB7dXNlclNlbGVjdDogJ25vbmUnLHRvdWNoU2VsZWN0OiAnbm9uZScsdG91Y2hDYWxsb3V0OiAnbm9uZScsY29udGVudFpvb21pbmc6ICdub25lJyx1c2VyRHJhZzogJ25vbmUnLHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSd9fTt2YXIgdWI9MSx2Yj0yO2lhLnByb3RvdHlwZT17c2V0OiBmdW5jdGlvbiggYSApIHtcbnJldHVybiBsYSggdGhpcy5vcHRpb25zLGEgKSxhLnRvdWNoQWN0aW9uJiZ0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpLGEuaW5wdXRUYXJnZXQmJiggdGhpcy5pbnB1dC5kZXN0cm95KCksdGhpcy5pbnB1dC50YXJnZXQ9YS5pbnB1dFRhcmdldCx0aGlzLmlucHV0LmluaXQoKSApLHRoaXM7XG59LHN0b3A6IGZ1bmN0aW9uKCBhICkge1xudGhpcy5zZXNzaW9uLnN0b3BwZWQ9YT92Yjp1Yjtcbn0scmVjb2duaXplOiBmdW5jdGlvbiggYSApIHtcbnZhciBiPXRoaXMuc2Vzc2lvbjtpZiAoICFiLnN0b3BwZWQgKSB7XG50aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyggYSApO3ZhciBjLGQ9dGhpcy5yZWNvZ25pemVycyxlPWIuY3VyUmVjb2duaXplcjsoICFlfHxlJiZlLnN0YXRlJnJiICkmJiggZT1iLmN1clJlY29nbml6ZXI9bnVsbCApO2ZvciAoIHZhciBmPTA7ZjxkLmxlbmd0aDsgKSB7XG5jPWRbIGYgXSxiLnN0b3BwZWQ9PT12Ynx8ZSYmYyE9ZSYmIWMuY2FuUmVjb2duaXplV2l0aCggZSApP2MucmVzZXQoKTpjLnJlY29nbml6ZSggYSApLCFlJiZjLnN0YXRlJiggb2J8cGJ8cWIgKSYmKCBlPWIuY3VyUmVjb2duaXplcj1jICksZisrO1xufVxufVxufSxnZXQ6IGZ1bmN0aW9uKCBhICkge1xuaWYgKCBhIGluc3RhbmNlb2YgWSApIHtcbnJldHVybiBhO1xufSBmb3IgKCB2YXIgYj10aGlzLnJlY29nbml6ZXJzLGM9MDtjPGIubGVuZ3RoO2MrKyApIHtcbmlmICggYlsgYyBdLm9wdGlvbnMuZXZlbnQ9PWEgKSB7XG5yZXR1cm4gYlsgYyBdO1xufVxufSByZXR1cm4gbnVsbDtcbn0sYWRkOiBmdW5jdGlvbiggYSApIHtcbmlmICggZiggYSwnYWRkJyx0aGlzICkgKSB7XG5yZXR1cm4gdGhpcztcbn0gdmFyIGI9dGhpcy5nZXQoIGEub3B0aW9ucy5ldmVudCApO3JldHVybiBiJiZ0aGlzLnJlbW92ZSggYiApLHRoaXMucmVjb2duaXplcnMucHVzaCggYSApLGEubWFuYWdlcj10aGlzLHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCksYTtcbn0scmVtb3ZlOiBmdW5jdGlvbiggYSApIHtcbmlmICggZiggYSwncmVtb3ZlJyx0aGlzICkgKSB7XG5yZXR1cm4gdGhpcztcbn0gaWYgKCBhPXRoaXMuZ2V0KCBhICkgKSB7XG52YXIgYj10aGlzLnJlY29nbml6ZXJzLGM9ciggYixhICk7LTEhPT1jJiYoIGIuc3BsaWNlKCBjLDEgKSx0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpICk7XG59IHJldHVybiB0aGlzO1xufSxvbjogZnVuY3Rpb24oIGEsYiApIHtcbmlmICggYSE9PWQmJmIhPT1kICkge1xudmFyIGM9dGhpcy5oYW5kbGVycztyZXR1cm4gZyggcSggYSApLGZ1bmN0aW9uKCBhICkge1xuY1sgYSBdPWNbIGEgXXx8W10sY1sgYSBdLnB1c2goIGIgKTtcbn0gKSx0aGlzO1xufVxufSxvZmY6IGZ1bmN0aW9uKCBhLGIgKSB7XG5pZiAoIGEhPT1kICkge1xudmFyIGM9dGhpcy5oYW5kbGVycztyZXR1cm4gZyggcSggYSApLGZ1bmN0aW9uKCBhICkge1xuYj9jWyBhIF0mJmNbIGEgXS5zcGxpY2UoIHIoIGNbIGEgXSxiICksMSApOmRlbGV0ZSBjWyBhIF07XG59ICksdGhpcztcbn1cbn0sZW1pdDogZnVuY3Rpb24oIGEsYiApIHtcbnRoaXMub3B0aW9ucy5kb21FdmVudHMmJmthKCBhLGIgKTt2YXIgYz10aGlzLmhhbmRsZXJzWyBhIF0mJnRoaXMuaGFuZGxlcnNbIGEgXS5zbGljZSgpO2lmICggYyYmYy5sZW5ndGggKSB7XG5iLnR5cGU9YSxiLnByZXZlbnREZWZhdWx0PWZ1bmN0aW9uKCkge1xuYi5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufTtmb3IgKCB2YXIgZD0wO2Q8Yy5sZW5ndGg7ICkge1xuY1sgZCBdKCBiICksZCsrO1xufVxufVxufSxkZXN0cm95OiBmdW5jdGlvbigpIHtcbnRoaXMuZWxlbWVudCYmamEoIHRoaXMsITEgKSx0aGlzLmhhbmRsZXJzPXt9LHRoaXMuc2Vzc2lvbj17fSx0aGlzLmlucHV0LmRlc3Ryb3koKSx0aGlzLmVsZW1lbnQ9bnVsbDtcbn19LGxhKCBoYSx7SU5QVVRfU1RBUlQ6IEVhLElOUFVUX01PVkU6IEZhLElOUFVUX0VORDogR2EsSU5QVVRfQ0FOQ0VMOiBIYSxTVEFURV9QT1NTSUJMRTogbmIsU1RBVEVfQkVHQU46IG9iLFNUQVRFX0NIQU5HRUQ6IHBiLFNUQVRFX0VOREVEOiBxYixTVEFURV9SRUNPR05JWkVEOiByYixTVEFURV9DQU5DRUxMRUQ6IHNiLFNUQVRFX0ZBSUxFRDogdGIsRElSRUNUSU9OX05PTkU6IElhLERJUkVDVElPTl9MRUZUOiBKYSxESVJFQ1RJT05fUklHSFQ6IEthLERJUkVDVElPTl9VUDogTGEsRElSRUNUSU9OX0RPV046IE1hLERJUkVDVElPTl9IT1JJWk9OVEFMOiBOYSxESVJFQ1RJT05fVkVSVElDQUw6IE9hLERJUkVDVElPTl9BTEw6IFBhLE1hbmFnZXI6IGlhLElucHV0OiB4LFRvdWNoQWN0aW9uOiBWLFRvdWNoSW5wdXQ6IFAsTW91c2VJbnB1dDogTCxQb2ludGVyRXZlbnRJbnB1dDogTSxUb3VjaE1vdXNlSW5wdXQ6IFIsU2luZ2xlVG91Y2hJbnB1dDogTixSZWNvZ25pemVyOiBZLEF0dHJSZWNvZ25pemVyOiBhYSxUYXA6IGdhLFBhbjogYmEsU3dpcGU6IGZhLFBpbmNoOiBjYSxSb3RhdGU6IGVhLFByZXNzOiBkYSxvbjogbSxvZmY6IG4sZWFjaDogZyxtZXJnZTogdGEsZXh0ZW5kOiBzYSxhc3NpZ246IGxhLGluaGVyaXQ6IGksYmluZEZuOiBqLHByZWZpeGVkOiB1fSApO3ZhciB3Yj0ndW5kZWZpbmVkJyE9dHlwZW9mIGE/YTondW5kZWZpbmVkJyE9dHlwZW9mIHNlbGY/c2VsZjp7fTt3Yi5IYW1tZXI9aGEsJ2Z1bmN0aW9uJz09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoIGZ1bmN0aW9uKCkge1xucmV0dXJuIGhhO1xufSApOid1bmRlZmluZWQnIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1oYTphWyBjIF09aGE7XG59KCB3aW5kb3csZG9jdW1lbnQsJ0hhbW1lcicgKTtcbi8vICMgc291cmNlTWFwcGluZ1VSTD1oYW1tZXIubWluLmpzLm1hcFxuXG4oIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuICAgIC8vIENvbW1lbnRlZCBvdXQgdGhlIGlmL2Vsc2UtaWYvZWxzZSBmb3Igb3VyIHdlYnBhY2sgYnVpbGQgc2luY2UgdGhlc2UgZGVwZW5kZW5jaWVzIGFyZSByaWdodCBoZXJlIGluIHRoZSBmaWxlXG4gICAgLy8gQW5kIGRvIG5vdCBuZWVkIHRvIGJlIGxvYWRlZCBhcyBleHRlcm5hbCBkZXBlbmRlbmNpZXNcbi8vICAgIElmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuLy8gICAgICAgIERlZmluZSggWyAnanF1ZXJ5JywgJ2hhbW1lcmpzJyBdLCBmYWN0b3J5ICk7XG4vLyAgICB9XG4vLyAgICBFbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuLy8gICAgICAgIEZhY3RvcnkoIHJlcXVpcmUoICdqcXVlcnknICksIHJlcXVpcmUoICdoYW1tZXJqcycgKSApO1xuLy8gICAgfVxuLy8gICAgRWxzZSB7XG4vLyAgICAgICAgRmFjdG9yeSggalF1ZXJ5LCBIYW1tZXIgKTtcbi8vICAgIH1cblxuICAgIC8vIExvYWQgdGhlc2UgdHdvIGRlcGVuZGVuY2llcyBmcm9tIHRoZWlyIGRlY2xhcmF0aW9uIGluIHRoaXMgZmlsZVxuICAgIGZhY3RvcnkoIGpRdWVyeSwgSGFtbWVyICk7XG59KCBmdW5jdGlvbiggJCwgSGFtbWVyICkge1xuICAgIGZ1bmN0aW9uIGhhbW1lcmlmeSggZWwsIG9wdGlvbnMgKSB7XG4gICAgICAgIHZhciAkZWwgPSAkKCBlbCApO1xuICAgICAgICBpZiAoICEkZWwuZGF0YSggJ2hhbW1lcicgKSApIHtcbiAgICAgICAgICAgICRlbC5kYXRhKCAnaGFtbWVyJywgbmV3IEhhbW1lciggJGVsWyAwIF0sIG9wdGlvbnMgKSApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJC5mbi5oYW1tZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoYW1tZXJpZnkoIHRoaXMsIG9wdGlvbnMgKTtcbiAgICAgICAgfSApO1xuICAgIH07XG5cbiAgICAvLyBFeHRlbmQgdGhlIGVtaXQgbWV0aG9kIHRvIGFsc28gdHJpZ2dlciBqUXVlcnkgZXZlbnRzXG4gICAgSGFtbWVyLk1hbmFnZXIucHJvdG90eXBlLmVtaXQgPSAoIGZ1bmN0aW9uKCBvcmlnaW5hbEVtaXQgKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRW1pdC5jYWxsKCB0aGlzLCB0eXBlLCBkYXRhICk7XG4gICAgICAgICAgICAkKCB0aGlzLmVsZW1lbnQgKS50cmlnZ2VyKCB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBnZXN0dXJlOiBkYXRhXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH07XG4gICAgfSApKCBIYW1tZXIuTWFuYWdlci5wcm90b3R5cGUuZW1pdCApO1xufSApICk7XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUpBO0FBQUE7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFaQTtBQVlBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQVJBO0FBU0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFlQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFwQkE7QUFxQkE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUF4Q0E7QUF5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQXBEQTtBQW9EQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFwQkE7QUFwREE7QUFDQTtBQXVFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQXNCQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBTkE7QUFPQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBcENBO0FBb0NBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBREE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFIQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBcEJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUF4REE7QUF3REE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBaEJBO0FBZ0JBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBOUJBO0FBOEJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUE5TUE7QUE4TUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFUQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFuREE7QUFDQTtBQW1EQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFKQTtBQUtBO0FBQ0E7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRkE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFKQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVZBO0FBVUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQWxCQTtBQWtCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQWxDQTtBQWtDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQVJBO0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFSQTtBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQWhCQTtBQWdCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQU5BO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUF0QkE7QUFzQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBbERBO0FBa0RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.materialize.slideshowdependancies.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.optionalScripts.ts":
/*!**************************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.optionalScripts.ts ***!
  \**************************************************************************************/
/*! exports provided: opCountDownTimer, opDynamicContent, opFacebookComments, opFontAwesomeIcons, opOntraForms, opOrderSummary, opPaymentInfo, opRecaptcha */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"opCountDownTimer\", function() { return opCountDownTimer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"opDynamicContent\", function() { return opDynamicContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"opFacebookComments\", function() { return opFacebookComments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"opFontAwesomeIcons\", function() { return opFontAwesomeIcons; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"opOntraForms\", function() { return opOntraForms; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"opOrderSummary\", function() { return opOrderSummary; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"opPaymentInfo\", function() { return opPaymentInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"opRecaptcha\", function() { return opRecaptcha; });\n/*\n * Opt.optionslScritps.ts\n * These functions analyse a page DOM looking for elements that require extra scripts. If an element is detected\n * these functions search for the existance of the script dependencies and add them if they are missing.\n * They may already be on the page if the page was built before the release of the Global Blocks project so we accont\n * for that.\n *\n * Background:\n * When we load a page in the editor our pag template (template.html) contains all possible needed scripts. Including all scripts allows\n * users to add any element without having to manage script injection. When we publish a page and build, all optional\n * scripts are removed from the page. The script will run when a page is served, looking at the DOM and adding what's\n * needed. At least that's the plan.\n *\n * For the future:\n * A note on moonray.paymentplandisplay.js and web components.\n * Once webpack allows dynamic script inclusion we should be able to move the some of these checks to opt-assets.webpack\n * You can do something like\n * if( countdown ){\n *     require( './templates/custom-elements/countdown/countdown-v1.js' );\n * }\n * etc...\n * These requires must happen in order because order summary depends on moonray.paymentplandisplay.js ie\n * require( '../../formeditor/moonrayform/paymentplandisplay/moonrayform.paymentplandisplay.js' );\n * require( './templates/custom-elements/ontraport-order-summary/ontraport-order-summary.js' );\n *\n * We should try to do this because it lets us bundle eveything together and take advantage of webpacks build ( obfiscation etc)\n * The big challenge is making webpack requires dynamic and that moonray.paymentplandisplay.js is its own bundle.\n*/\n/*\n * Append a script tag to the document body, setting the script src to what ever is passed in.\n */\nfunction appendScript(src, target, blocking, context) {\n    if (src) {\n        context = (context !== null && context !== void 0 ? context : document);\n        var script = context.createElement('script');\n        if (blocking) {\n            // Disable asyncronous loading incase the scriptst are order dependent\n            script.async = false;\n        }\n        let appendTo = context.body;\n        script.src = src;\n        if (target) {\n            appendTo = target;\n        }\n        appendTo.appendChild(script);\n        return true;\n    }\n    return false;\n}\nfunction appendLink(href, rel, target = document.head, as, context) {\n    if (!href) {\n        return false;\n    }\n    context = (context !== null && context !== void 0 ? context : document);\n    const linkElement = context.createElement('link');\n    linkElement.setAttribute('href', href);\n    linkElement.setAttribute('rel', rel);\n    if (as) {\n        linkElement.setAttribute('as', as);\n    }\n    target.appendChild(linkElement);\n}\n// HEADER SCRIPTS --------------------------------------------------------------------------------------------------------\n/*\n * Check for font awesome icons\n */\nfunction opFontAwesomeIcons() {\n    let hasFaIcons = document.querySelector('i.fa');\n    let hasFaIconsCss = document.querySelector('.opt-style__font-awesome');\n    if (hasFaIcons && !hasFaIconsCss) {\n        appendLink('//optassets.ontraport.com/opt_assets/opt_boilerplates/v3/font-awesome.min.css', 'preload stylesheet', document.head, 'style');\n        return true;\n    }\n    else if (hasFaIcons && !hasFaIconsCss) {\n        return true;\n    }\n    return false;\n}\n/*\n * Determine if a page contains a recaptcha if it does and doesnt have recaptcha scripts add them.\n */\nfunction opRecaptcha() {\n    let hasRecaptchaElement = document.querySelector('.opt-recaptcha');\n    let hasRecaptchaScript = document.querySelector('.opt-js-recaptcha');\n    if (hasRecaptchaElement && !hasRecaptchaScript) {\n        appendScript('https://www.google.com/recaptcha/api.js', document.head);\n        return true;\n    }\n    else if (hasRecaptchaElement && !hasRecaptchaScript) {\n        return true;\n    }\n    return false;\n}\n// BODY SCRIPTS -----------------------------------------------------------------------------------------------------------\n/*\n * Check for countdown timers\n */\nfunction opCountDownTimer() {\n    let hasCt = document.querySelector('ontraport-countdown');\n    let ctScripts = document.querySelector('[src*=\"countdown-v1.js\"]');\n    let webCompScripts = document.querySelector('[src*=\"custom-elements.min.js\"]');\n    if (hasCt) {\n        // Add the web component scripts\n        if (!webCompScripts) {\n            // Set the blocking parameter to true so that it'll block since the web components need this script to finish\n            // executing before proceeding since they depend on it.\n            appendScript('//optassets.ontraport.com/opt_assets/static/js/custom-elements.min.js', undefined, true);\n        }\n        // Add the countdown scripts\n        if (!ctScripts) {\n            appendScript('//optassets.ontraport.com/opt_assets/templates/custom-elements/countdown/countdown-v1.js');\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * If there is dynamic content on the page, then load the dynamic content JavaScript and CSS.\n */\nfunction opDynamicContent(context = document, forceAdd) {\n    let hasDynamicContent = isDynamicTemplate() || hasDynamicBlocks(context) || hasDynamicElements(context) || forceAdd;\n    if (hasDynamicContent) {\n        appendScript('//optassets.ontraport.com/opt_assets/static/js/dynamic_content_module/dynamic_content.js', undefined, undefined, context);\n    }\n    return hasDynamicContent;\n}\nfunction isDynamicTemplate(context = document) {\n    return window.document.querySelectorAll('.ontraport_panes_dynamic_template').length > 0;\n}\n/**\n * Check if the page has dynamic blocks on the page.\n */\nfunction hasDynamicBlocks(context = document) {\n    return context.querySelectorAll('[data-dc]').length > 0;\n}\n/**\n * Check it the page has dynamic elements on the page.\n */\nfunction hasDynamicElements(context = document) {\n    return context.querySelectorAll('[data-field-name], [data-color-field-name]').length > 0;\n}\n/*\n * Determine if the page contains facebook comments. If it does, add the facebook scripts and the in it call.\n */\nfunction opFacebookComments() {\n    let hasFBC = document.querySelector('.fb-comments-container');\n    let fBscripts = document.querySelector('[src=\"//connect.facebook.net/en_US/sdk.js\"]');\n    if (hasFBC && !fBscripts) {\n        // Add the init scripts\n        let fbcScript = document.createElement('script');\n        let fbcInitScript = document.createTextNode('window.fbAsyncInit = function(){ var $fbCommentsElement = $( \".fb-comments\" ); FB.init( { \"appId\": $fbCommentsElement.attr( \"data-appid\" ), \"xfbml\": true, \"version\": \"v2.3\" } ); };');\n        fbcScript.appendChild(fbcInitScript);\n        document.body.appendChild(fbcScript);\n        // Add the facebook sdk\n        appendScript('//connect.facebook.net/en_US/sdk.js');\n        return true;\n    }\n    else if (hasFBC && fBscripts) {\n        return true;\n    }\n    return false;\n}\n/*\n * Determine if opf.js is needed\n */\nfunction opOntraForms() {\n    let hasOntraForms = document.querySelectorAll('[data-opf-watch-submit], [data-opf-trigger]');\n    let hasOntraFormsScripts = document.querySelector('script[src*=\"opf.js\"]');\n    if (hasOntraForms.length) {\n        if (!hasOntraFormsScripts) {\n            appendScript('//optassets.ontraport.com/opt_assets/static/js/opf.js');\n            return true;\n        }\n    }\n    return false;\n}\n/*\n * Determine if the order summary is presesnt\n */\nfunction opOrderSummary() {\n    let hasOrderSummary = document.querySelector('ontraport-order-summary');\n    let hasOrderSummaryScripts = document.querySelector('[src*=\"ontraport-order-summary.js\"]');\n    let webCompScripts = document.querySelector('[src*=\"document-register-element.js\"]');\n    if (hasOrderSummary) {\n        if (!webCompScripts) {\n            // Set the blocking parameter to true so that it'll block since the web components need this script to finish\n            // executing before proceeding since they depend on it.\n            appendScript('//optassets.ontraport.com/opt_assets/templates/custom-elements/document-register-element/build/document-register-element.js', undefined, true);\n        }\n        if (!hasOrderSummaryScripts) {\n            // Note we disable async loading for these scripts because they are order dependent. The order summary must execute\n            // after the paymentplan code so it can build models.\n            appendScript('//optassets.ontraport.com/opt_assets/static/js/moonrayform.paymentplandisplay.js', undefined, true);\n            appendScript('//optassets.ontraport.com/opt_assets/templates/custom-elements/ontraport-order-summary/dist/order-summary.js', undefined, true);\n        }\n        return true;\n    }\n    return false;\n}\n/*\n * Check for countdown timers\n */\nfunction opPaymentInfo() {\n    let hasPaymentInfo = document.querySelector('payment-info');\n    let paymentInfoScripts = document.querySelector('[src*=\"payment-info.js\"]');\n    let webCompScripts = document.querySelector('[src*=\"custom-elements.min.js\"]');\n    if (hasPaymentInfo) {\n        // Add the web component scripts\n        if (!webCompScripts) {\n            // Set the blocking parameter to true so that it'll block since the web components need this script to finish\n            // executing before proceeding since they depend on it.\n            appendScript('//optassets.ontraport.com/opt_assets/static/js/custom-elements.min.js', undefined, true);\n        }\n        // Add the countdown scripts\n        if (!paymentInfoScripts) {\n            appendScript('//optassets.ontraport.com/opt_assets/templates/custom-elements/payment-info/dist/payment-info.js');\n        }\n        return true;\n    }\n    return false;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9vcHQub3B0aW9uYWxTY3JpcHRzLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vd3d3L2pzLTMuMi4yL29udHJhcG9ydC9vcHRfYXNzZXRzL29wdF9ib2lsZXJwbGF0ZXMvdjMvb3B0Lm9wdGlvbmFsU2NyaXB0cy50cz9iMjZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBPcHQub3B0aW9uc2xTY3JpdHBzLnRzXG4gKiBUaGVzZSBmdW5jdGlvbnMgYW5hbHlzZSBhIHBhZ2UgRE9NIGxvb2tpbmcgZm9yIGVsZW1lbnRzIHRoYXQgcmVxdWlyZSBleHRyYSBzY3JpcHRzLiBJZiBhbiBlbGVtZW50IGlzIGRldGVjdGVkXG4gKiB0aGVzZSBmdW5jdGlvbnMgc2VhcmNoIGZvciB0aGUgZXhpc3RhbmNlIG9mIHRoZSBzY3JpcHQgZGVwZW5kZW5jaWVzIGFuZCBhZGQgdGhlbSBpZiB0aGV5IGFyZSBtaXNzaW5nLlxuICogVGhleSBtYXkgYWxyZWFkeSBiZSBvbiB0aGUgcGFnZSBpZiB0aGUgcGFnZSB3YXMgYnVpbHQgYmVmb3JlIHRoZSByZWxlYXNlIG9mIHRoZSBHbG9iYWwgQmxvY2tzIHByb2plY3Qgc28gd2UgYWNjb250XG4gKiBmb3IgdGhhdC5cbiAqXG4gKiBCYWNrZ3JvdW5kOlxuICogV2hlbiB3ZSBsb2FkIGEgcGFnZSBpbiB0aGUgZWRpdG9yIG91ciBwYWcgdGVtcGxhdGUgKHRlbXBsYXRlLmh0bWwpIGNvbnRhaW5zIGFsbCBwb3NzaWJsZSBuZWVkZWQgc2NyaXB0cy4gSW5jbHVkaW5nIGFsbCBzY3JpcHRzIGFsbG93c1xuICogdXNlcnMgdG8gYWRkIGFueSBlbGVtZW50IHdpdGhvdXQgaGF2aW5nIHRvIG1hbmFnZSBzY3JpcHQgaW5qZWN0aW9uLiBXaGVuIHdlIHB1Ymxpc2ggYSBwYWdlIGFuZCBidWlsZCwgYWxsIG9wdGlvbmFsXG4gKiBzY3JpcHRzIGFyZSByZW1vdmVkIGZyb20gdGhlIHBhZ2UuIFRoZSBzY3JpcHQgd2lsbCBydW4gd2hlbiBhIHBhZ2UgaXMgc2VydmVkLCBsb29raW5nIGF0IHRoZSBET00gYW5kIGFkZGluZyB3aGF0J3NcbiAqIG5lZWRlZC4gQXQgbGVhc3QgdGhhdCdzIHRoZSBwbGFuLlxuICpcbiAqIEZvciB0aGUgZnV0dXJlOlxuICogQSBub3RlIG9uIG1vb25yYXkucGF5bWVudHBsYW5kaXNwbGF5LmpzIGFuZCB3ZWIgY29tcG9uZW50cy5cbiAqIE9uY2Ugd2VicGFjayBhbGxvd3MgZHluYW1pYyBzY3JpcHQgaW5jbHVzaW9uIHdlIHNob3VsZCBiZSBhYmxlIHRvIG1vdmUgdGhlIHNvbWUgb2YgdGhlc2UgY2hlY2tzIHRvIG9wdC1hc3NldHMud2VicGFja1xuICogWW91IGNhbiBkbyBzb21ldGhpbmcgbGlrZVxuICogaWYoIGNvdW50ZG93biApe1xuICogICAgIHJlcXVpcmUoICcuL3RlbXBsYXRlcy9jdXN0b20tZWxlbWVudHMvY291bnRkb3duL2NvdW50ZG93bi12MS5qcycgKTtcbiAqIH1cbiAqIGV0Yy4uLlxuICogVGhlc2UgcmVxdWlyZXMgbXVzdCBoYXBwZW4gaW4gb3JkZXIgYmVjYXVzZSBvcmRlciBzdW1tYXJ5IGRlcGVuZHMgb24gbW9vbnJheS5wYXltZW50cGxhbmRpc3BsYXkuanMgaWVcbiAqIHJlcXVpcmUoICcuLi8uLi9mb3JtZWRpdG9yL21vb25yYXlmb3JtL3BheW1lbnRwbGFuZGlzcGxheS9tb29ucmF5Zm9ybS5wYXltZW50cGxhbmRpc3BsYXkuanMnICk7XG4gKiByZXF1aXJlKCAnLi90ZW1wbGF0ZXMvY3VzdG9tLWVsZW1lbnRzL29udHJhcG9ydC1vcmRlci1zdW1tYXJ5L29udHJhcG9ydC1vcmRlci1zdW1tYXJ5LmpzJyApO1xuICpcbiAqIFdlIHNob3VsZCB0cnkgdG8gZG8gdGhpcyBiZWNhdXNlIGl0IGxldHMgdXMgYnVuZGxlIGV2ZXl0aGluZyB0b2dldGhlciBhbmQgdGFrZSBhZHZhbnRhZ2Ugb2Ygd2VicGFja3MgYnVpbGQgKCBvYmZpc2NhdGlvbiBldGMpXG4gKiBUaGUgYmlnIGNoYWxsZW5nZSBpcyBtYWtpbmcgd2VicGFjayByZXF1aXJlcyBkeW5hbWljIGFuZCB0aGF0IG1vb25yYXkucGF5bWVudHBsYW5kaXNwbGF5LmpzIGlzIGl0cyBvd24gYnVuZGxlLlxuKi9cblxuXG4vKlxuICogQXBwZW5kIGEgc2NyaXB0IHRhZyB0byB0aGUgZG9jdW1lbnQgYm9keSwgc2V0dGluZyB0aGUgc2NyaXB0IHNyYyB0byB3aGF0IGV2ZXIgaXMgcGFzc2VkIGluLlxuICovXG5mdW5jdGlvbiBhcHBlbmRTY3JpcHQoIHNyYyA6IHN0cmluZywgdGFyZ2V0ID86IEhUTUxFbGVtZW50LCBibG9ja2luZyA/OiBib29sZWFuLCBjb250ZXh0ID8gOiBIVE1MRG9jdW1lbnQgKSB7XG4gICAgaWYgKCBzcmMgKSB7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0ID8/IGRvY3VtZW50O1xuXG4gICAgICAgIHZhciBzY3JpcHQgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoICdzY3JpcHQnICk7XG4gICAgICAgIGlmICggYmxvY2tpbmcgKSB7XG4gICAgICAgICAgICAvLyBEaXNhYmxlIGFzeW5jcm9ub3VzIGxvYWRpbmcgaW5jYXNlIHRoZSBzY3JpcHRzdCBhcmUgb3JkZXIgZGVwZW5kZW50XG4gICAgICAgICAgICBzY3JpcHQuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGV0IGFwcGVuZFRvID0gY29udGV4dC5ib2R5O1xuICAgICAgICBzY3JpcHQuc3JjID0gc3JjO1xuICAgICAgICBpZiAoIHRhcmdldCApIHtcbiAgICAgICAgICAgIGFwcGVuZFRvID0gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZFRvLmFwcGVuZENoaWxkKCBzY3JpcHQgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kTGluayggaHJlZiA6IHN0cmluZywgcmVsIDogc3RyaW5nLCB0YXJnZXQgOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LmhlYWQsIGFzIDogc3RyaW5nLCBjb250ZXh0ID8gOiBIVE1MRG9jdW1lbnQgKSB7XG4gICAgaWYgKCAhaHJlZiApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb250ZXh0ID0gY29udGV4dCA/PyBkb2N1bWVudDtcbiAgICBjb25zdCBsaW5rRWxlbWVudCA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggJ2xpbmsnICk7XG4gICAgbGlua0VsZW1lbnQuc2V0QXR0cmlidXRlKCAnaHJlZicsIGhyZWYgKTtcbiAgICBsaW5rRWxlbWVudC5zZXRBdHRyaWJ1dGUoICdyZWwnLCByZWwgKTtcbiAgICBpZiAoIGFzICkge1xuICAgICAgICBsaW5rRWxlbWVudC5zZXRBdHRyaWJ1dGUoICdhcycsIGFzICk7XG4gICAgfVxuICAgIHRhcmdldC5hcHBlbmRDaGlsZCggbGlua0VsZW1lbnQgKTtcbn1cblxuLy8gSEVBREVSIFNDUklQVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qXG4gKiBDaGVjayBmb3IgZm9udCBhd2Vzb21lIGljb25zXG4gKi9cbmZ1bmN0aW9uIG9wRm9udEF3ZXNvbWVJY29ucygpIHtcbiAgICBsZXQgaGFzRmFJY29ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoICdpLmZhJyApO1xuICAgIGxldCBoYXNGYUljb25zQ3NzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggJy5vcHQtc3R5bGVfX2ZvbnQtYXdlc29tZScgKTtcbiAgICBpZiAoIGhhc0ZhSWNvbnMgJiYgIWhhc0ZhSWNvbnNDc3MgKSB7XG4gICAgICAgIGFwcGVuZExpbmsoXG4gICAgICAgICAgICAnLy9vcHRhc3NldHMub250cmFwb3J0LmNvbS9vcHRfYXNzZXRzL29wdF9ib2lsZXJwbGF0ZXMvdjMvZm9udC1hd2Vzb21lLm1pbi5jc3MnLFxuICAgICAgICAgICAgJ3ByZWxvYWQgc3R5bGVzaGVldCcsXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLFxuICAgICAgICAgICAgJ3N0eWxlJyApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCBoYXNGYUljb25zICYmICFoYXNGYUljb25zQ3NzICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKlxuICogRGV0ZXJtaW5lIGlmIGEgcGFnZSBjb250YWlucyBhIHJlY2FwdGNoYSBpZiBpdCBkb2VzIGFuZCBkb2VzbnQgaGF2ZSByZWNhcHRjaGEgc2NyaXB0cyBhZGQgdGhlbS5cbiAqL1xuZnVuY3Rpb24gb3BSZWNhcHRjaGEoKSB7XG4gICAgbGV0IGhhc1JlY2FwdGNoYUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCAnLm9wdC1yZWNhcHRjaGEnICk7XG4gICAgbGV0IGhhc1JlY2FwdGNoYVNjcmlwdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoICcub3B0LWpzLXJlY2FwdGNoYScgKTtcbiAgICBpZiAoIGhhc1JlY2FwdGNoYUVsZW1lbnQgJiYgIWhhc1JlY2FwdGNoYVNjcmlwdCApIHtcbiAgICAgICAgYXBwZW5kU2NyaXB0KCAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9yZWNhcHRjaGEvYXBpLmpzJywgZG9jdW1lbnQuaGVhZCApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCBoYXNSZWNhcHRjaGFFbGVtZW50ICYmICFoYXNSZWNhcHRjaGFTY3JpcHQgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuLy8gQk9EWSBTQ1JJUFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKlxuICogQ2hlY2sgZm9yIGNvdW50ZG93biB0aW1lcnNcbiAqL1xuZnVuY3Rpb24gb3BDb3VudERvd25UaW1lcigpIHtcbiAgICBsZXQgaGFzQ3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCAnb250cmFwb3J0LWNvdW50ZG93bicgKTtcbiAgICBsZXQgY3RTY3JpcHRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggJ1tzcmMqPVwiY291bnRkb3duLXYxLmpzXCJdJyApO1xuICAgIGxldCB3ZWJDb21wU2NyaXB0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoICdbc3JjKj1cImN1c3RvbS1lbGVtZW50cy5taW4uanNcIl0nICk7XG5cbiAgICBpZiAoIGhhc0N0ICkge1xuICAgICAgICAvLyBBZGQgdGhlIHdlYiBjb21wb25lbnQgc2NyaXB0c1xuICAgICAgICBpZiAoICF3ZWJDb21wU2NyaXB0cyApIHtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBibG9ja2luZyBwYXJhbWV0ZXIgdG8gdHJ1ZSBzbyB0aGF0IGl0J2xsIGJsb2NrIHNpbmNlIHRoZSB3ZWIgY29tcG9uZW50cyBuZWVkIHRoaXMgc2NyaXB0IHRvIGZpbmlzaFxuICAgICAgICAgICAgLy8gZXhlY3V0aW5nIGJlZm9yZSBwcm9jZWVkaW5nIHNpbmNlIHRoZXkgZGVwZW5kIG9uIGl0LlxuICAgICAgICAgICAgYXBwZW5kU2NyaXB0KFxuICAgICAgICAgICAgICAgICcvL29wdGFzc2V0cy5vbnRyYXBvcnQuY29tL29wdF9hc3NldHMvc3RhdGljL2pzL2N1c3RvbS1lbGVtZW50cy5taW4uanMnLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0cnVlICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb3VudGRvd24gc2NyaXB0c1xuICAgICAgICBpZiAoICFjdFNjcmlwdHMgKSB7XG4gICAgICAgICAgICBhcHBlbmRTY3JpcHQoICcvL29wdGFzc2V0cy5vbnRyYXBvcnQuY29tL29wdF9hc3NldHMvdGVtcGxhdGVzL2N1c3RvbS1lbGVtZW50cy9jb3VudGRvd24vY291bnRkb3duLXYxLmpzJyApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBJZiB0aGVyZSBpcyBkeW5hbWljIGNvbnRlbnQgb24gdGhlIHBhZ2UsIHRoZW4gbG9hZCB0aGUgZHluYW1pYyBjb250ZW50IEphdmFTY3JpcHQgYW5kIENTUy5cbiAqL1xuZnVuY3Rpb24gb3BEeW5hbWljQ29udGVudCggY29udGV4dCA6IEhUTUxEb2N1bWVudCA9IGRvY3VtZW50LCBmb3JjZUFkZCA6IGJvb2xlYW4gKSB7XG5cbiAgICBsZXQgaGFzRHluYW1pY0NvbnRlbnQgPSBpc0R5bmFtaWNUZW1wbGF0ZSgpIHx8IGhhc0R5bmFtaWNCbG9ja3MoIGNvbnRleHQgKSB8fCBoYXNEeW5hbWljRWxlbWVudHMoIGNvbnRleHQgKSB8fCBmb3JjZUFkZDtcblxuICAgIGlmICggaGFzRHluYW1pY0NvbnRlbnQgKSB7XG4gICAgICAgIGFwcGVuZFNjcmlwdChcbiAgICAgICAgICAgICcvL29wdGFzc2V0cy5vbnRyYXBvcnQuY29tL29wdF9hc3NldHMvc3RhdGljL2pzL2R5bmFtaWNfY29udGVudF9tb2R1bGUvZHluYW1pY19jb250ZW50LmpzJyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbnRleHQgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBoYXNEeW5hbWljQ29udGVudDtcbn1cblxuZnVuY3Rpb24gaXNEeW5hbWljVGVtcGxhdGUoIGNvbnRleHQgOiBIVE1MRG9jdW1lbnQgPSBkb2N1bWVudCApIHtcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICcub250cmFwb3J0X3BhbmVzX2R5bmFtaWNfdGVtcGxhdGUnICkubGVuZ3RoID4gMDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFnZSBoYXMgZHluYW1pYyBibG9ja3Mgb24gdGhlIHBhZ2UuXG4gKi9cbmZ1bmN0aW9uIGhhc0R5bmFtaWNCbG9ja3MoIGNvbnRleHQgOiBIVE1MRG9jdW1lbnQgPSBkb2N1bWVudCApIHtcbiAgICByZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCAnW2RhdGEtZGNdJyApLmxlbmd0aCA+IDA7XG59XG5cbi8qKlxuICogQ2hlY2sgaXQgdGhlIHBhZ2UgaGFzIGR5bmFtaWMgZWxlbWVudHMgb24gdGhlIHBhZ2UuXG4gKi9cbmZ1bmN0aW9uIGhhc0R5bmFtaWNFbGVtZW50cyggY29udGV4dCA6IEhUTUxEb2N1bWVudCA9IGRvY3VtZW50ICkge1xuICAgIHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoICdbZGF0YS1maWVsZC1uYW1lXSwgW2RhdGEtY29sb3ItZmllbGQtbmFtZV0nICkubGVuZ3RoID4gMDtcbn1cblxuLypcbiAqIERldGVybWluZSBpZiB0aGUgcGFnZSBjb250YWlucyBmYWNlYm9vayBjb21tZW50cy4gSWYgaXQgZG9lcywgYWRkIHRoZSBmYWNlYm9vayBzY3JpcHRzIGFuZCB0aGUgaW4gaXQgY2FsbC5cbiAqL1xuZnVuY3Rpb24gb3BGYWNlYm9va0NvbW1lbnRzKCkge1xuICAgIGxldCBoYXNGQkMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCAnLmZiLWNvbW1lbnRzLWNvbnRhaW5lcicgKTtcbiAgICBsZXQgZkJzY3JpcHRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggJ1tzcmM9XCIvL2Nvbm5lY3QuZmFjZWJvb2submV0L2VuX1VTL3Nkay5qc1wiXScgKTtcblxuICAgIGlmICggaGFzRkJDICYmICFmQnNjcmlwdHMgKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgaW5pdCBzY3JpcHRzXG4gICAgICAgIGxldCBmYmNTY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnc2NyaXB0JyApO1xuICAgICAgICBsZXQgZmJjSW5pdFNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCAnd2luZG93LmZiQXN5bmNJbml0ID0gZnVuY3Rpb24oKXsgdmFyICRmYkNvbW1lbnRzRWxlbWVudCA9ICQoIFwiLmZiLWNvbW1lbnRzXCIgKTsgRkIuaW5pdCggeyBcImFwcElkXCI6ICRmYkNvbW1lbnRzRWxlbWVudC5hdHRyKCBcImRhdGEtYXBwaWRcIiApLCBcInhmYm1sXCI6IHRydWUsIFwidmVyc2lvblwiOiBcInYyLjNcIiB9ICk7IH07JyApO1xuICAgICAgICBmYmNTY3JpcHQuYXBwZW5kQ2hpbGQoIGZiY0luaXRTY3JpcHQgKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggZmJjU2NyaXB0ICk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBmYWNlYm9vayBzZGtcbiAgICAgICAgYXBwZW5kU2NyaXB0KCAnLy9jb25uZWN0LmZhY2Vib29rLm5ldC9lbl9VUy9zZGsuanMnICk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIGhhc0ZCQyAmJiBmQnNjcmlwdHMgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qXG4gKiBEZXRlcm1pbmUgaWYgb3BmLmpzIGlzIG5lZWRlZFxuICovXG5mdW5jdGlvbiBvcE9udHJhRm9ybXMoKSB7XG4gICAgbGV0IGhhc09udHJhRm9ybXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCAnW2RhdGEtb3BmLXdhdGNoLXN1Ym1pdF0sIFtkYXRhLW9wZi10cmlnZ2VyXScgKTtcbiAgICBsZXQgaGFzT250cmFGb3Jtc1NjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCAnc2NyaXB0W3NyYyo9XCJvcGYuanNcIl0nICk7XG4gICAgaWYgKCBoYXNPbnRyYUZvcm1zLmxlbmd0aCApIHtcbiAgICAgICAgaWYgKCAhaGFzT250cmFGb3Jtc1NjcmlwdHMgKSB7XG4gICAgICAgICAgICBhcHBlbmRTY3JpcHQoICcvL29wdGFzc2V0cy5vbnRyYXBvcnQuY29tL29wdF9hc3NldHMvc3RhdGljL2pzL29wZi5qcycgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLypcbiAqIERldGVybWluZSBpZiB0aGUgb3JkZXIgc3VtbWFyeSBpcyBwcmVzZXNudFxuICovXG5mdW5jdGlvbiBvcE9yZGVyU3VtbWFyeSgpIHtcbiAgICBsZXQgaGFzT3JkZXJTdW1tYXJ5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggJ29udHJhcG9ydC1vcmRlci1zdW1tYXJ5JyApO1xuICAgIGxldCBoYXNPcmRlclN1bW1hcnlTY3JpcHRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggJ1tzcmMqPVwib250cmFwb3J0LW9yZGVyLXN1bW1hcnkuanNcIl0nICk7XG4gICAgbGV0IHdlYkNvbXBTY3JpcHRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggJ1tzcmMqPVwiZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudC5qc1wiXScgKTtcblxuICAgIGlmICggaGFzT3JkZXJTdW1tYXJ5ICkge1xuICAgICAgICBpZiAoICF3ZWJDb21wU2NyaXB0cyApIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgYmxvY2tpbmcgcGFyYW1ldGVyIHRvIHRydWUgc28gdGhhdCBpdCdsbCBibG9jayBzaW5jZSB0aGUgd2ViIGNvbXBvbmVudHMgbmVlZCB0aGlzIHNjcmlwdCB0byBmaW5pc2hcbiAgICAgICAgICAgIC8vIGV4ZWN1dGluZyBiZWZvcmUgcHJvY2VlZGluZyBzaW5jZSB0aGV5IGRlcGVuZCBvbiBpdC5cbiAgICAgICAgICAgIGFwcGVuZFNjcmlwdChcbiAgICAgICAgICAgICAgICAnLy9vcHRhc3NldHMub250cmFwb3J0LmNvbS9vcHRfYXNzZXRzL3RlbXBsYXRlcy9jdXN0b20tZWxlbWVudHMvZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudC9idWlsZC9kb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50LmpzJyxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICFoYXNPcmRlclN1bW1hcnlTY3JpcHRzICkge1xuICAgICAgICAgICAgLy8gTm90ZSB3ZSBkaXNhYmxlIGFzeW5jIGxvYWRpbmcgZm9yIHRoZXNlIHNjcmlwdHMgYmVjYXVzZSB0aGV5IGFyZSBvcmRlciBkZXBlbmRlbnQuIFRoZSBvcmRlciBzdW1tYXJ5IG11c3QgZXhlY3V0ZVxuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHBheW1lbnRwbGFuIGNvZGUgc28gaXQgY2FuIGJ1aWxkIG1vZGVscy5cbiAgICAgICAgICAgIGFwcGVuZFNjcmlwdChcblxuICAgICAgICAgICAgICAgICcvL29wdGFzc2V0cy5vbnRyYXBvcnQuY29tL29wdF9hc3NldHMvc3RhdGljL2pzL21vb25yYXlmb3JtLnBheW1lbnRwbGFuZGlzcGxheS5qcycsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRydWUgKTtcbiAgICAgICAgICAgIGFwcGVuZFNjcmlwdCggJy8vb3B0YXNzZXRzLm9udHJhcG9ydC5jb20vb3B0X2Fzc2V0cy90ZW1wbGF0ZXMvY3VzdG9tLWVsZW1lbnRzL29udHJhcG9ydC1vcmRlci1zdW1tYXJ5L2Rpc3Qvb3JkZXItc3VtbWFyeS5qcycsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRydWUgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qXG4gKiBDaGVjayBmb3IgY291bnRkb3duIHRpbWVyc1xuICovXG5mdW5jdGlvbiBvcFBheW1lbnRJbmZvKCkge1xuICAgIGxldCBoYXNQYXltZW50SW5mbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoICdwYXltZW50LWluZm8nICk7XG4gICAgbGV0IHBheW1lbnRJbmZvU2NyaXB0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoICdbc3JjKj1cInBheW1lbnQtaW5mby5qc1wiXScgKTtcbiAgICBsZXQgd2ViQ29tcFNjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCAnW3NyYyo9XCJjdXN0b20tZWxlbWVudHMubWluLmpzXCJdJyApO1xuXG4gICAgaWYgKCBoYXNQYXltZW50SW5mbyApIHtcbiAgICAgICAgLy8gQWRkIHRoZSB3ZWIgY29tcG9uZW50IHNjcmlwdHNcbiAgICAgICAgaWYgKCAhd2ViQ29tcFNjcmlwdHMgKSB7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgYmxvY2tpbmcgcGFyYW1ldGVyIHRvIHRydWUgc28gdGhhdCBpdCdsbCBibG9jayBzaW5jZSB0aGUgd2ViIGNvbXBvbmVudHMgbmVlZCB0aGlzIHNjcmlwdCB0byBmaW5pc2hcbiAgICAgICAgICAgIC8vIGV4ZWN1dGluZyBiZWZvcmUgcHJvY2VlZGluZyBzaW5jZSB0aGV5IGRlcGVuZCBvbiBpdC5cbiAgICAgICAgICAgIGFwcGVuZFNjcmlwdChcbiAgICAgICAgICAgICAgICAnLy9vcHRhc3NldHMub250cmFwb3J0LmNvbS9vcHRfYXNzZXRzL3N0YXRpYy9qcy9jdXN0b20tZWxlbWVudHMubWluLmpzJyxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdHJ1ZSApO1xuXG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb3VudGRvd24gc2NyaXB0c1xuICAgICAgICBpZiAoICFwYXltZW50SW5mb1NjcmlwdHMgKSB7XG4gICAgICAgICAgICBhcHBlbmRTY3JpcHQoICcvL29wdGFzc2V0cy5vbnRyYXBvcnQuY29tL29wdF9hc3NldHMvdGVtcGxhdGVzL2N1c3RvbS1lbGVtZW50cy9wYXltZW50LWluZm8vZGlzdC9wYXltZW50LWluZm8uanMnICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbmV4cG9ydCB7IG9wQ291bnREb3duVGltZXIsIG9wRHluYW1pY0NvbnRlbnQsIG9wRmFjZWJvb2tDb21tZW50cywgb3BGb250QXdlc29tZUljb25zLCBvcE9udHJhRm9ybXMsIG9wT3JkZXJTdW1tYXJ5LCBvcFBheW1lbnRJbmZvLCBvcFJlY2FwdGNoYSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/opt.optionalScripts.ts\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/polyfills.js":
/*!****************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/polyfills.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// IE 11 polyfills for the .07 % that call support. I say we doing them a favor letting them know its time for a new laptop.\n// QA says otherwise so here we go.\n// .startsWith\nif (!String.prototype.startsWith) {\n  Object.defineProperty(String.prototype, 'startsWith', {\n    value: function (search, rawPos) {\n      var pos = rawPos > 0 ? rawPos | 0 : 0;\n      return this.substring(pos, pos + search.length) === search;\n    }\n  });\n} // .forEach --------------------------------------------------------------------------------------------------------------------------------------------------\n// Production steps of ECMA-262, Edition 5, 15.4.4.18\n// Reference: http://es5.github.io/#x15.4.4.18\n\n\nif (!Array.prototype.forEach) {\n  Array.prototype.forEach = function (callback\n  /* , thisArg*/\n  ) {\n    var T, k;\n\n    if (this == null) {\n      throw new TypeError('this is null or not defined');\n    } // 1. Let O be the result of calling toObject() passing the\n    // |this| value as the argument.\n\n\n    var O = Object(this); // 2. Let lenValue be the result of calling the Get() internal\n    // method of O with the argument \"length\".\n    // 3. Let len be toUint32(lenValue).\n\n    var len = O.length >>> 0; // 4. If isCallable(callback) is false, throw a TypeError exception.\n    // See: http://es5.github.com/#x9.11\n\n    if (typeof callback !== 'function') {\n      throw new TypeError(callback + ' is not a function');\n    } // 5. If thisArg was supplied, let T be thisArg; else let\n    // T be undefined.\n\n\n    if (arguments.length > 1) {\n      T = arguments[1];\n    } // 6. Let k be 0.\n\n\n    k = 0; // 7. Repeat while k < len.\n\n    while (k < len) {\n      var kValue; // A. Let Pk be ToString(k).\n      //    This is implicit for LHS operands of the in operator.\n      // b. Let kPresent be the result of calling the HasProperty\n      //    internal method of O with argument Pk.\n      //    This step can be combined with c.\n      // c. If kPresent is true, then\n\n      if (k in O) {\n        // I. Let kValue be the result of calling the Get internal\n        // method of O with argument Pk.\n        kValue = O[k]; // Ii. Call the Call internal method of callback with T as\n        // the this value and argument list containing kValue, k, and O.\n\n        callback.call(T, kValue, k, O);\n      } // D. Increase k by 1.\n\n\n      k++;\n    } // 8. return undefined.\n\n  };\n} // NodeList foreach --------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nif (window.NodeList && !NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach;\n} // .closest --------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nif (!Element.prototype.matches) {\n  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n}\n\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function (s) {\n    var el = this;\n\n    if (!document.documentElement.contains(el)) {\n      return null;\n    }\n\n    do {\n      if (el.matches(s)) {\n        return el;\n      }\n\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n\n    return null;\n  };\n} // Array .includes --------------------------------------------------------------------------------------------------------------------------------------------------\n// https://tc39.github.io/ecma262/#sec-array.prototype.includes\n\n\nif (!Array.prototype.includes) {\n  Object.defineProperty(Array.prototype, 'includes', {\n    value: function (searchElement, fromIndex) {\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      } // 1. Let O be ? ToObject(this value).\n\n\n      var o = Object(this); // 2. Let len be ? ToLength(? Get(O, \"length\")).\n\n      var len = o.length >>> 0; // 3. If len is 0, return false.\n\n      if (len === 0) {\n        return false;\n      } // 4. Let n be ? ToInteger(fromIndex).\n      //    (If fromIndex is undefined, this step produces the value 0.)\n\n\n      var n = fromIndex | 0; // 5. If n ≥ 0, then\n      //  a. Let k be n.\n      // 6. Else n < 0,\n      //  a. Let k be len + n.\n      //  b. If k < 0, let k be 0.\n\n      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n      function sameValueZero(x, y) {\n        return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\n      } // 7. Repeat, while k < len\n\n\n      while (k < len) {\n        // A. Let elementK be the result of ? Get(O, ! ToString(k)).\n        // b. If SameValueZero(searchElement, elementK) is true, return true.\n        if (sameValueZero(o[k], searchElement)) {\n          return true;\n        } // C. Increase k by 1.\n\n\n        k++;\n      } // 8. Return false\n\n\n      return false;\n    }\n  });\n} // String .includes --------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nif (!String.prototype.includes) {\n  String.prototype.includes = function (search, start) {\n    'use strict';\n\n    if (typeof start !== 'number') {\n      start = 0;\n    }\n\n    if (start + search.length > this.length) {\n      return false;\n    } else {\n      return this.indexOf(search, start) !== -1;\n    }\n  };\n} // Element remove ----------------------------------------------------------------------------------------------------------------------------------------------------\n// from:https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/remove()/remove().md\n\n\n(function (arr) {\n  arr.forEach(function (item) {\n    if (item.hasOwnProperty('remove')) {\n      return;\n    }\n\n    Object.defineProperty(item, 'remove', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: function remove() {\n        if (this.parentNode !== null) {\n          this.parentNode.removeChild(this);\n        }\n      }\n    });\n  });\n})([Element.prototype, CharacterData.prototype, DocumentType.prototype]); // Array from -------------------------------------------------------------------------------------------------------------------------------------------------------\n// Production steps of ECMA-262, Edition 6, 22.1.2.1\n\n\nif (!Array.from) {\n  Array.from = function () {\n    var toStr = Object.prototype.toString;\n\n    var isCallable = function (fn) {\n      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';\n    };\n\n    var toInteger = function (value) {\n      var number = Number(value);\n\n      if (isNaN(number)) {\n        return 0;\n      }\n\n      if (number === 0 || !isFinite(number)) {\n        return number;\n      }\n\n      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\n    };\n\n    var maxSafeInteger = Math.pow(2, 53) - 1;\n\n    var toLength = function (value) {\n      var len = toInteger(value);\n      return Math.min(Math.max(len, 0), maxSafeInteger);\n    }; // The length property of the from method is 1.\n\n\n    return function from(arrayLike\n    /* , mapFn, thisArg */\n    ) {\n      // 1. Let C be the this value.\n      var C = this; // 2. Let items be ToObject(arrayLike).\n\n      var items = Object(arrayLike); // 3. ReturnIfAbrupt(items).\n\n      if (arrayLike == null) {\n        throw new TypeError('Array.from requires an array-like object - not null or undefined');\n      } // 4. If mapfn is undefined, then let mapping be false.\n\n\n      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;\n      var T;\n\n      if (typeof mapFn !== 'undefined') {\n        // 5. else\n        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\n        if (!isCallable(mapFn)) {\n          throw new TypeError('Array.from: when provided, the second argument must be a function');\n        } // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\n\n\n        if (arguments.length > 2) {\n          T = arguments[2];\n        }\n      } // 10. Let lenValue be Get(items, \"length\").\n      // 11. Let len be ToLength(lenValue).\n\n\n      var len = toLength(items.length); // 13. If IsConstructor(C) is true, then\n      // 13. a. Let A be the result of calling the [[Construct]] internal method\n      // of C with an argument list containing the single item len.\n      // 14. a. Else, Let A be ArrayCreate(len).\n\n      var A = isCallable(C) ? Object(new C(len)) : new Array(len); // 16. Let k be 0.\n\n      var k = 0; // 17. Repeat, while k < len… (also steps a - h)\n\n      var kValue;\n\n      while (k < len) {\n        kValue = items[k];\n\n        if (mapFn) {\n          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);\n        } else {\n          A[k] = kValue;\n        }\n\n        k += 1;\n      } // 18. Let putStatus be Put(A, \"length\", len, true).\n\n\n      A.length = len; // 20. Return A.\n\n      return A;\n    };\n  }();\n} // DOM append() polyfill ----------------------------------------------------------------------------------------------\n// Source: https://github.com/jserz/js_piece/blob/master/DOM/ParentNode/append()/append().md\n\n\n(function (arr) {\n  arr.forEach(function (item) {\n    if (item.hasOwnProperty('append')) {\n      return;\n    }\n\n    Object.defineProperty(item, 'append', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: function append() {\n        var argArr = Array.prototype.slice.call(arguments),\n            docFrag = document.createDocumentFragment();\n        argArr.forEach(function (argItem) {\n          var isNode = argItem instanceof Node;\n          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));\n        });\n        this.appendChild(docFrag);\n      }\n    });\n  });\n})([Element.prototype, Document.prototype, DocumentFragment.prototype]); // DOM prepend() polyfill\n// Source: https://github.com/jserz/js_piece/blob/master/DOM/ParentNode/prepend()/prepend().md\n\n\n(function (arr) {\n  arr.forEach(function (item) {\n    if (item.hasOwnProperty('prepend')) {\n      return;\n    }\n\n    Object.defineProperty(item, 'prepend', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: function prepend() {\n        var argArr = Array.prototype.slice.call(arguments),\n            docFrag = document.createDocumentFragment();\n        argArr.forEach(function (argItem) {\n          var isNode = argItem instanceof Node;\n          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));\n        });\n        this.insertBefore(docFrag, this.firstChild);\n      }\n    });\n  });\n})([Element.prototype, Document.prototype, DocumentFragment.prototype]); // Template tag poly fill for custom elements that use template tags --------------------------------------------------\n\n/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n// minimal template polyfill\n\n\n(function () {\n  'use strict';\n\n  var needsTemplate = typeof HTMLTemplateElement === 'undefined';\n  var brokenDocFragment = !(document.createDocumentFragment().cloneNode() instanceof DocumentFragment);\n  var needsDocFrag = false; // NOTE: Replace DocumentFragment to work around IE11 bug that\n  // causes children of a document fragment modified while\n  // there is a mutation observer to not have a parentNode, or\n  // have a broken parentNode (!?!)\n\n  if (/Trident/.test(navigator.userAgent)) {\n    (function () {\n      needsDocFrag = true;\n      var origCloneNode = Node.prototype.cloneNode;\n\n      Node.prototype.cloneNode = function cloneNode(deep) {\n        var newDom = origCloneNode.call(this, deep);\n\n        if (this instanceof DocumentFragment) {\n          newDom.__proto__ = DocumentFragment.prototype;\n        }\n\n        return newDom;\n      }; // IE's DocumentFragment querySelector code doesn't work when\n      // called on an element instance\n\n\n      DocumentFragment.prototype.querySelectorAll = HTMLElement.prototype.querySelectorAll;\n      DocumentFragment.prototype.querySelector = HTMLElement.prototype.querySelector;\n      Object.defineProperties(DocumentFragment.prototype, {\n        nodeType: {\n          get: function () {\n            return Node.DOCUMENT_FRAGMENT_NODE;\n          },\n          configurable: true\n        },\n        localName: {\n          get: function () {\n            return undefined;\n          },\n          configurable: true\n        },\n        nodeName: {\n          get: function () {\n            return '#document-fragment';\n          },\n          configurable: true\n        }\n      });\n      var origInsertBefore = Node.prototype.insertBefore;\n\n      function insertBefore(newNode, refNode) {\n        if (newNode instanceof DocumentFragment) {\n          var child;\n\n          while (child = newNode.firstChild) {\n            origInsertBefore.call(this, child, refNode);\n          }\n        } else {\n          origInsertBefore.call(this, newNode, refNode);\n        }\n\n        return newNode;\n      }\n\n      Node.prototype.insertBefore = insertBefore;\n      var origAppendChild = Node.prototype.appendChild;\n\n      Node.prototype.appendChild = function appendChild(child) {\n        if (child instanceof DocumentFragment) {\n          insertBefore.call(this, child, null);\n        } else {\n          origAppendChild.call(this, child);\n        }\n\n        return child;\n      };\n\n      var origRemoveChild = Node.prototype.removeChild;\n      var origReplaceChild = Node.prototype.replaceChild;\n\n      Node.prototype.replaceChild = function replaceChild(newChild, oldChild) {\n        if (newChild instanceof DocumentFragment) {\n          insertBefore.call(this, newChild, oldChild);\n          origRemoveChild.call(this, oldChild);\n        } else {\n          origReplaceChild.call(this, newChild, oldChild);\n        }\n\n        return oldChild;\n      };\n\n      Document.prototype.createDocumentFragment = function createDocumentFragment() {\n        var frag = this.createElement('df');\n        frag.__proto__ = DocumentFragment.prototype;\n        return frag;\n      };\n\n      var origImportNode = Document.prototype.importNode;\n\n      Document.prototype.importNode = function importNode(impNode, deep) {\n        deep = deep || false;\n        var newNode = origImportNode.call(this, impNode, deep);\n\n        if (impNode instanceof DocumentFragment) {\n          newNode.__proto__ = DocumentFragment.prototype;\n        }\n\n        return newNode;\n      };\n    })();\n  } // NOTE: we rely on this cloneNode not causing element upgrade.\n  // This means this polyfill must load before the CE polyfill and\n  // this would need to be re-worked if a browser supports native CE\n  // but not <template>.\n\n\n  var capturedCloneNode = Node.prototype.cloneNode;\n  var capturedCreateElement = Document.prototype.createElement;\n  var capturedImportNode = Document.prototype.importNode;\n  var capturedRemoveChild = Node.prototype.removeChild;\n  var capturedAppendChild = Node.prototype.appendChild;\n  var capturedReplaceChild = Node.prototype.replaceChild;\n  var capturedParseFromString = DOMParser.prototype.parseFromString;\n  var capturedHTMLElementInnerHTML = Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, 'innerHTML') || {\n    /**\n    * @this {!HTMLElement}\n    * @return {string}\n    */\n    get: function () {\n      return this.innerHTML;\n    },\n\n    /**\n    * @this {!HTMLElement}\n    * @param {string}\n    */\n    set: function (text) {\n      this.innerHTML = text;\n    }\n  };\n  var capturedChildNodes = Object.getOwnPropertyDescriptor(window.Node.prototype, 'childNodes') || {\n    /**\n    * @this {!Node}\n    * @return {!NodeList}\n    */\n    get: function () {\n      return this.childNodes;\n    }\n  };\n  var elementQuerySelectorAll = Element.prototype.querySelectorAll;\n  var docQuerySelectorAll = Document.prototype.querySelectorAll;\n  var fragQuerySelectorAll = DocumentFragment.prototype.querySelectorAll;\n  var scriptSelector = 'script:not([type]),script[type=\"application/javascript\"],script[type=\"text/javascript\"]';\n\n  function QSA(node, selector) {\n    // IE 11 throws a SyntaxError with `scriptSelector` if the node has no children due to the `:not([type])` syntax\n    if (!node.childNodes.length) {\n      return [];\n    }\n\n    switch (node.nodeType) {\n      case Node.DOCUMENT_NODE:\n        return docQuerySelectorAll.call(node, selector);\n\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        return fragQuerySelectorAll.call(node, selector);\n\n      default:\n        return elementQuerySelectorAll.call(node, selector);\n    }\n  } // Returns true if nested templates cannot be cloned (they cannot be on\n  // some impl's like Safari 8 and Edge)\n  // OR if cloning a document fragment does not result in a document fragment\n\n\n  var needsCloning = function () {\n    if (!needsTemplate) {\n      var t = document.createElement('template');\n      var t2 = document.createElement('template');\n      t2.content.appendChild(document.createElement('div'));\n      t.content.appendChild(t2);\n      var clone = t.cloneNode(true);\n      return clone.content.childNodes.length === 0 || clone.content.firstChild.content.childNodes.length === 0 || brokenDocFragment;\n    }\n  }();\n\n  var TEMPLATE_TAG = 'template';\n\n  var PolyfilledHTMLTemplateElement = function () {};\n\n  if (needsTemplate) {\n    var contentDoc = document.implementation.createHTMLDocument('template');\n    var canDecorate = true;\n    var templateStyle = document.createElement('style');\n    templateStyle.textContent = TEMPLATE_TAG + '{display:none;}';\n    var head = document.head;\n    head.insertBefore(templateStyle, head.firstElementChild);\n    /**\n    Provides a minimal shim for the <template> element.\n    */\n\n    PolyfilledHTMLTemplateElement.prototype = Object.create(HTMLElement.prototype); // If elements do not have `innerHTML` on instances, then\n    // templates can be patched by swizzling their prototypes.\n\n    var canProtoPatch = !document.createElement('div').hasOwnProperty('innerHTML');\n    /**\n    The `decorate` method moves element children to the template's `content`.\n    NOTE: there is no support for dynamically adding elements to templates.\n    */\n\n    PolyfilledHTMLTemplateElement.decorate = function (template) {\n      // If the template is decorated or not in HTML namespace, return fast\n      if (template.content || template.namespaceURI !== document.documentElement.namespaceURI) {\n        return;\n      }\n\n      template.content = contentDoc.createDocumentFragment();\n      var child;\n\n      while (child = template.firstChild) {\n        capturedAppendChild.call(template.content, child);\n      } // NOTE: prefer prototype patching for performance and\n      // because on some browsers (IE11), re-defining `innerHTML`\n      // can result in intermittent errors.\n\n\n      if (canProtoPatch) {\n        template.__proto__ = PolyfilledHTMLTemplateElement.prototype;\n      } else {\n        template.cloneNode = function (deep) {\n          return PolyfilledHTMLTemplateElement._cloneNode(this, deep);\n        }; // Add innerHTML to template, if possible\n        // Note: this throws on Safari 7\n\n\n        if (canDecorate) {\n          try {\n            defineInnerHTML(template);\n            defineOuterHTML(template);\n          } catch (err) {\n            canDecorate = false;\n          }\n        }\n      } // Bootstrap recursively\n\n\n      PolyfilledHTMLTemplateElement.bootstrap(template.content);\n    }; // Taken from https://github.com/jquery/jquery/blob/73d7e6259c63ac45f42c6593da8c2796c6ce9281/src/manipulation/wrapMap.js\n\n\n    var topLevelWrappingMap = {\n      option: ['select'],\n      thead: ['table'],\n      col: ['colgroup', 'table'],\n      tr: ['tbody', 'table'],\n      th: ['tr', 'tbody', 'table'],\n      td: ['tr', 'tbody', 'table']\n    };\n\n    var getTagName = function (text) {\n      // Taken from https://github.com/jquery/jquery/blob/73d7e6259c63ac45f42c6593da8c2796c6ce9281/src/manipulation/var/rtagName.js\n      return (/<([a-z][^/\\0>\\x20\\t\\r\\n\\f]+)/i.exec(text) || ['', ''])[1].toLowerCase();\n    };\n\n    var defineInnerHTML = function defineInnerHTML(obj) {\n      Object.defineProperty(obj, 'innerHTML', {\n        get: function () {\n          return getInnerHTML(this);\n        },\n        set: function (text) {\n          // For IE11, wrap the text in the correct (table) context\n          var wrap = topLevelWrappingMap[getTagName(text)];\n\n          if (wrap) {\n            for (var i = 0; i < wrap.length; i++) {\n              text = '<' + wrap[i] + '>' + text + '</' + wrap[i] + '>';\n            }\n          }\n\n          contentDoc.body.innerHTML = text;\n          PolyfilledHTMLTemplateElement.bootstrap(contentDoc);\n\n          while (this.content.firstChild) {\n            capturedRemoveChild.call(this.content, this.content.firstChild);\n          }\n\n          var body = contentDoc.body; // If we had wrapped, get back to the original node\n\n          if (wrap) {\n            for (var j = 0; j < wrap.length; j++) {\n              body = body.lastChild;\n            }\n          }\n\n          while (body.firstChild) {\n            capturedAppendChild.call(this.content, body.firstChild);\n          }\n        },\n        configurable: true\n      });\n    };\n\n    var defineOuterHTML = function defineOuterHTML(obj) {\n      Object.defineProperty(obj, 'outerHTML', {\n        get: function () {\n          return '<' + TEMPLATE_TAG + '>' + this.innerHTML + '</' + TEMPLATE_TAG + '>';\n        },\n        set: function (innerHTML) {\n          if (this.parentNode) {\n            contentDoc.body.innerHTML = innerHTML;\n            var docFrag = this.ownerDocument.createDocumentFragment();\n\n            while (contentDoc.body.firstChild) {\n              capturedAppendChild.call(docFrag, contentDoc.body.firstChild);\n            }\n\n            capturedReplaceChild.call(this.parentNode, docFrag, this);\n          } else {\n            throw new Error('Failed to set the \\'outerHTML\\' property on \\'Element\\': This element has no parent node.');\n          }\n        },\n        configurable: true\n      });\n    };\n\n    defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);\n    defineOuterHTML(PolyfilledHTMLTemplateElement.prototype);\n    /**\n    The `bootstrap` method is called automatically and \"fixes\" all\n    <template> elements in the document referenced by the `doc` argument.\n    */\n\n    PolyfilledHTMLTemplateElement.bootstrap = function bootstrap(doc) {\n      var templates = QSA(doc, TEMPLATE_TAG);\n\n      for (var i = 0, l = templates.length, t; i < l && (t = templates[i]); i++) {\n        PolyfilledHTMLTemplateElement.decorate(t);\n      }\n    }; // Auto-bootstrapping for main document\n\n\n    document.addEventListener('DOMContentLoaded', function () {\n      PolyfilledHTMLTemplateElement.bootstrap(document);\n    }); // Patch document.createElement to ensure newly created templates have content\n\n    Document.prototype.createElement = function createElement() {\n      var el = capturedCreateElement.apply(this, arguments);\n\n      if (el.localName === 'template') {\n        PolyfilledHTMLTemplateElement.decorate(el);\n      }\n\n      return el;\n    };\n\n    DOMParser.prototype.parseFromString = function () {\n      var el = capturedParseFromString.apply(this, arguments);\n      PolyfilledHTMLTemplateElement.bootstrap(el);\n      return el;\n    };\n\n    Object.defineProperty(HTMLElement.prototype, 'innerHTML', {\n      get: function () {\n        return getInnerHTML(this);\n      },\n      set: function (text) {\n        capturedHTMLElementInnerHTML.set.call(this, text);\n        PolyfilledHTMLTemplateElement.bootstrap(this);\n      },\n      configurable: true,\n      enumerable: true\n    }); // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\n\n    var escapeAttrRegExp = /[&\\u00A0\"]/g;\n    var escapeDataRegExp = /[&\\u00A0<>]/g;\n\n    var escapeReplace = function (c) {\n      switch (c) {\n        case '&':\n          return '&amp;';\n\n        case '<':\n          return '&lt;';\n\n        case '>':\n          return '&gt;';\n\n        case '\"':\n          return '&quot;';\n\n        case '\\u00A0':\n          return '&nbsp;';\n      }\n    };\n\n    var escapeAttr = function (s) {\n      return s.replace(escapeAttrRegExp, escapeReplace);\n    };\n\n    var escapeData = function (s) {\n      return s.replace(escapeDataRegExp, escapeReplace);\n    };\n\n    var makeSet = function (arr) {\n      var set = {};\n\n      for (var i = 0; i < arr.length; i++) {\n        set[arr[i]] = true;\n      }\n\n      return set;\n    }; // http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\n\n    var voidElements = makeSet(['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);\n    var plaintextParents = makeSet(['style', 'script', 'xmp', 'iframe', 'noembed', 'noframes', 'plaintext', 'noscript']);\n    /**\n    * @param {Node} node\n    * @param {Node} parentNode\n    * @param {Function=} callback\n    */\n\n    var getOuterHTML = function (node, parentNode, callback) {\n      switch (node.nodeType) {\n        case Node.ELEMENT_NODE:\n          {\n            var tagName = node.localName;\n            var s = '<' + tagName;\n            var attrs = node.attributes;\n\n            for (var i = 0, attr; attr = attrs[i]; i++) {\n              s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n            }\n\n            s += '>';\n\n            if (voidElements[tagName]) {\n              return s;\n            }\n\n            return s + getInnerHTML(node, callback) + '</' + tagName + '>';\n          }\n\n        case Node.TEXT_NODE:\n          {\n            var data =\n            /** @type {Text} */\n            node.data;\n\n            if (parentNode && plaintextParents[parentNode.localName]) {\n              return data;\n            }\n\n            return escapeData(data);\n          }\n\n        case Node.COMMENT_NODE:\n          {\n            return '<!--' +\n            /** @type {Comment} */\n            node.data + '-->';\n          }\n\n        default:\n          {\n            window.console.error(node);\n            throw new Error('not implemented');\n          }\n      }\n    };\n    /**\n    * @param {Node} node\n    * @param {Function=} callback\n    */\n\n\n    var getInnerHTML = function (node, callback) {\n      if (node.localName === 'template') {\n        node =\n        /** @type {HTMLTemplateElement} */\n        node.content;\n      }\n\n      var s = '';\n      var c$ = callback ? callback(node) : capturedChildNodes.get.call(node);\n\n      for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {\n        s += getOuterHTML(child, node, callback);\n      }\n\n      return s;\n    };\n  } // Make cloning/importing work!\n\n\n  if (needsTemplate || needsCloning) {\n    PolyfilledHTMLTemplateElement._cloneNode = function _cloneNode(template, deep) {\n      var clone = capturedCloneNode.call(template, false); // NOTE: decorate doesn't auto-fix children because they are already\n      // decorated so they need special clone fixup.\n\n      if (this.decorate) {\n        this.decorate(clone);\n      }\n\n      if (deep) {\n        // NOTE: use native clone node to make sure CE's wrapped\n        // cloneNode does not cause elements to upgrade.\n        capturedAppendChild.call(clone.content, capturedCloneNode.call(template.content, true)); // Now ensure nested templates are cloned correctly.\n\n        fixClonedDom(clone.content, template.content);\n      }\n\n      return clone;\n    }; // Given a source and cloned subtree, find <template>'s in the cloned\n    // subtree and replace them with cloned <template>'s from source.\n    // We must do this because only the source templates have proper .content.\n\n\n    var fixClonedDom = function fixClonedDom(clone, source) {\n      // Do nothing if cloned node is not an element\n      if (!source.querySelectorAll) {\n        return;\n      } // These two lists should be coincident\n\n\n      var s$ = QSA(source, TEMPLATE_TAG);\n\n      if (s$.length === 0) {\n        return;\n      }\n\n      var t$ = QSA(clone, TEMPLATE_TAG);\n\n      for (var i = 0, l = t$.length, t, s; i < l; i++) {\n        s = s$[i];\n        t = t$[i];\n\n        if (PolyfilledHTMLTemplateElement && PolyfilledHTMLTemplateElement.decorate) {\n          PolyfilledHTMLTemplateElement.decorate(s);\n        }\n\n        capturedReplaceChild.call(t.parentNode, cloneNode.call(s, true), t);\n      }\n    }; // Make sure scripts inside of a cloned template are executable\n\n\n    var fixClonedScripts = function fixClonedScripts(fragment) {\n      var scripts = QSA(fragment, scriptSelector);\n\n      for (var ns, s, i = 0; i < scripts.length; i++) {\n        s = scripts[i];\n        ns = capturedCreateElement.call(document, 'script');\n        ns.textContent = s.textContent;\n        var attrs = s.attributes;\n\n        for (var ai = 0, a; ai < attrs.length; ai++) {\n          a = attrs[ai];\n          ns.setAttribute(a.name, a.value);\n        }\n\n        capturedReplaceChild.call(s.parentNode, ns, s);\n      }\n    }; // Override all cloning to fix the cloned subtree to contain properly\n    // cloned templates.\n\n\n    var cloneNode = Node.prototype.cloneNode = function cloneNode(deep) {\n      var dom; // Workaround for Edge bug cloning documentFragments\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8619646/\n\n      if (!needsDocFrag && brokenDocFragment && this instanceof DocumentFragment) {\n        if (!deep) {\n          return this.ownerDocument.createDocumentFragment();\n        } else {\n          dom = importNode.call(this.ownerDocument, this, true);\n        }\n      } else if (this.nodeType === Node.ELEMENT_NODE && this.localName === TEMPLATE_TAG && this.namespaceURI == document.documentElement.namespaceURI) {\n        dom = PolyfilledHTMLTemplateElement._cloneNode(this, deep);\n      } else {\n        dom = capturedCloneNode.call(this, deep);\n      } // Template.content is cloned iff `deep`.\n\n\n      if (deep) {\n        fixClonedDom(dom, this);\n      }\n\n      return dom;\n    }; // NOTE: we are cloning instead of importing <template>'s.\n    // However, the ownerDocument of the cloned template will be correct!\n    // This is because the native import node creates the right document owned\n    // subtree and `fixClonedDom` inserts cloned templates into this subtree,\n    // thus updating the owner doc.\n\n\n    var importNode = Document.prototype.importNode = function importNode(element, deep) {\n      deep = deep || false;\n\n      if (element.localName === TEMPLATE_TAG) {\n        return PolyfilledHTMLTemplateElement._cloneNode(element, deep);\n      } else {\n        var dom = capturedImportNode.call(this, element, deep);\n\n        if (deep) {\n          fixClonedDom(dom, element);\n          fixClonedScripts(dom);\n        }\n\n        return dom;\n      }\n    };\n  }\n\n  if (needsTemplate) {\n    window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;\n  }\n})(); // .fill polyfil\n\n\nif (!Array.prototype.fill) {\n  Object.defineProperty(Array.prototype, 'fill', {\n    value: function (value) {\n      // Steps 1-2.\n      if (this == null) {\n        throw new TypeError('this is null or not defined');\n      }\n\n      var O = Object(this); // Steps 3-5.\n\n      var len = O.length >>> 0; // Steps 6-7.\n\n      var start = arguments[1];\n      var relativeStart = start >> 0; // Step 8.\n\n      var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len); // Steps 9-10.\n\n      var end = arguments[2];\n      var relativeEnd = end === undefined ? len : end >> 0; // Step 11.\n\n      var finalValue = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len); // Step 12.\n\n      while (k < finalValue) {\n        O[k] = value;\n        k++;\n      } // Step 13.\n\n\n      return O;\n    }\n  });\n} // Object assign\n\n\nif (typeof Object.assign !== 'function') {\n  // Must be writable: true, enumerable: false, configurable: true\n  Object.defineProperty(Object, 'assign', {\n    value: function assign(target, varArgs) {\n      // .length of function is 2\n      'use strict';\n\n      if (target === null || target === undefined) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource !== null && nextSource !== undefined) {\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n\n      return to;\n    },\n    writable: true,\n    configurable: true\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9wb2x5ZmlsbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9wb2x5ZmlsbHMuanM/YWUwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJRSAxMSBwb2x5ZmlsbHMgZm9yIHRoZSAuMDcgJSB0aGF0IGNhbGwgc3VwcG9ydC4gSSBzYXkgd2UgZG9pbmcgdGhlbSBhIGZhdm9yIGxldHRpbmcgdGhlbSBrbm93IGl0cyB0aW1lIGZvciBhIG5ldyBsYXB0b3AuXG4vLyBRQSBzYXlzIG90aGVyd2lzZSBzbyBoZXJlIHdlIGdvLlxuLy8gLnN0YXJ0c1dpdGhcbmlmICggIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCApIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIFN0cmluZy5wcm90b3R5cGUsICdzdGFydHNXaXRoJywge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oIHNlYXJjaCwgcmF3UG9zICkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHJhd1BvcyA+IDAgPyByYXdQb3MgfCAwIDogMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnN0cmluZyggcG9zLCBwb3MgKyBzZWFyY2gubGVuZ3RoICkgPT09IHNlYXJjaDtcbiAgICAgICAgfVxuICAgIH0gKTtcbn0gLy8gLmZvckVhY2ggLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByb2R1Y3Rpb24gc3RlcHMgb2YgRUNNQS0yNjIsIEVkaXRpb24gNSwgMTUuNC40LjE4XG4vLyBSZWZlcmVuY2U6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNC40LjE4XG5cblxuaWYgKCAhQXJyYXkucHJvdG90eXBlLmZvckVhY2ggKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiggY2FsbGJhY2tcblxuICAgICAgICAvKiAsIHRoaXNBcmcqL1xuICAgICkge1xuICAgICAgICB2YXIgVCwgaztcblxuICAgICAgICBpZiAoIHRoaXMgPT0gbnVsbCApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICd0aGlzIGlzIG51bGwgb3Igbm90IGRlZmluZWQnICk7XG4gICAgICAgIH0gLy8gMS4gTGV0IE8gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRvT2JqZWN0KCkgcGFzc2luZyB0aGVcbiAgICAgICAgLy8gfHRoaXN8IHZhbHVlIGFzIHRoZSBhcmd1bWVudC5cblxuXG4gICAgICAgIHZhciBPID0gT2JqZWN0KCB0aGlzICk7IC8vIDIuIExldCBsZW5WYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCgpIGludGVybmFsXG4gICAgICAgIC8vIG1ldGhvZCBvZiBPIHdpdGggdGhlIGFyZ3VtZW50IFwibGVuZ3RoXCIuXG4gICAgICAgIC8vIDMuIExldCBsZW4gYmUgdG9VaW50MzIobGVuVmFsdWUpLlxuXG4gICAgICAgIHZhciBsZW4gPSBPLmxlbmd0aCA+Pj4gMDsgLy8gNC4gSWYgaXNDYWxsYWJsZShjYWxsYmFjaykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gU2VlOiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjExXG5cbiAgICAgICAgaWYgKCB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCBjYWxsYmFjayArICcgaXMgbm90IGEgZnVuY3Rpb24nICk7XG4gICAgICAgIH0gLy8gNS4gSWYgdGhpc0FyZyB3YXMgc3VwcGxpZWQsIGxldCBUIGJlIHRoaXNBcmc7IGVsc2UgbGV0XG4gICAgICAgIC8vIFQgYmUgdW5kZWZpbmVkLlxuXG5cbiAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcbiAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbIDEgXTtcbiAgICAgICAgfSAvLyA2LiBMZXQgayBiZSAwLlxuXG5cbiAgICAgICAgayA9IDA7IC8vIDcuIFJlcGVhdCB3aGlsZSBrIDwgbGVuLlxuXG4gICAgICAgIHdoaWxlICggayA8IGxlbiApIHtcbiAgICAgICAgICAgIHZhciBrVmFsdWU7IC8vIEEuIExldCBQayBiZSBUb1N0cmluZyhrKS5cbiAgICAgICAgICAgIC8vICAgIFRoaXMgaXMgaW1wbGljaXQgZm9yIExIUyBvcGVyYW5kcyBvZiB0aGUgaW4gb3BlcmF0b3IuXG4gICAgICAgICAgICAvLyBiLiBMZXQga1ByZXNlbnQgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBIYXNQcm9wZXJ0eVxuICAgICAgICAgICAgLy8gICAgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cbiAgICAgICAgICAgIC8vICAgIFRoaXMgc3RlcCBjYW4gYmUgY29tYmluZWQgd2l0aCBjLlxuICAgICAgICAgICAgLy8gYy4gSWYga1ByZXNlbnQgaXMgdHJ1ZSwgdGhlblxuXG4gICAgICAgICAgICBpZiAoIGsgaW4gTyApIHtcbiAgICAgICAgICAgICAgICAvLyBJLiBMZXQga1ZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgR2V0IGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cbiAgICAgICAgICAgICAgICBrVmFsdWUgPSBPWyBrIF07IC8vIElpLiBDYWxsIHRoZSBDYWxsIGludGVybmFsIG1ldGhvZCBvZiBjYWxsYmFjayB3aXRoIFQgYXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgdGhpcyB2YWx1ZSBhbmQgYXJndW1lbnQgbGlzdCBjb250YWluaW5nIGtWYWx1ZSwgaywgYW5kIE8uXG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKCBULCBrVmFsdWUsIGssIE8gKTtcbiAgICAgICAgICAgIH0gLy8gRC4gSW5jcmVhc2UgayBieSAxLlxuXG5cbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfSAvLyA4LiByZXR1cm4gdW5kZWZpbmVkLlxuXG4gICAgfTtcbn0gLy8gTm9kZUxpc3QgZm9yZWFjaCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbmlmICggd2luZG93Lk5vZGVMaXN0ICYmICFOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCApIHtcbiAgICBOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xufSAvLyAuY2xvc2VzdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbmlmICggIUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgKSB7XG4gICAgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjtcbn1cblxuaWYgKCAhRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCApIHtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24oIHMgKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKCBlbCApICkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoIGVsLm1hdGNoZXMoIHMgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlO1xuICAgICAgICB9IHdoaWxlICggZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEgKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufSAvLyBBcnJheSAuaW5jbHVkZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuXG5cbmlmICggIUFycmF5LnByb3RvdHlwZS5pbmNsdWRlcyApIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIEFycmF5LnByb3RvdHlwZSwgJ2luY2x1ZGVzJywge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCApIHtcbiAgICAgICAgICAgIGlmICggdGhpcyA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyApO1xuICAgICAgICAgICAgfSAvLyAxLiBMZXQgTyBiZSA/IFRvT2JqZWN0KHRoaXMgdmFsdWUpLlxuXG5cbiAgICAgICAgICAgIHZhciBvID0gT2JqZWN0KCB0aGlzICk7IC8vIDIuIExldCBsZW4gYmUgPyBUb0xlbmd0aCg/IEdldChPLCBcImxlbmd0aFwiKSkuXG5cbiAgICAgICAgICAgIHZhciBsZW4gPSBvLmxlbmd0aCA+Pj4gMDsgLy8gMy4gSWYgbGVuIGlzIDAsIHJldHVybiBmYWxzZS5cblxuICAgICAgICAgICAgaWYgKCBsZW4gPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvLyA0LiBMZXQgbiBiZSA/IFRvSW50ZWdlcihmcm9tSW5kZXgpLlxuICAgICAgICAgICAgLy8gICAgKElmIGZyb21JbmRleCBpcyB1bmRlZmluZWQsIHRoaXMgc3RlcCBwcm9kdWNlcyB0aGUgdmFsdWUgMC4pXG5cblxuICAgICAgICAgICAgdmFyIG4gPSBmcm9tSW5kZXggfCAwOyAvLyA1LiBJZiBuIOKJpSAwLCB0aGVuXG4gICAgICAgICAgICAvLyAgYS4gTGV0IGsgYmUgbi5cbiAgICAgICAgICAgIC8vIDYuIEVsc2UgbiA8IDAsXG4gICAgICAgICAgICAvLyAgYS4gTGV0IGsgYmUgbGVuICsgbi5cbiAgICAgICAgICAgIC8vICBiLiBJZiBrIDwgMCwgbGV0IGsgYmUgMC5cblxuICAgICAgICAgICAgdmFyIGsgPSBNYXRoLm1heCggbiA+PSAwID8gbiA6IGxlbiAtIE1hdGguYWJzKCBuICksIDAgKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc2FtZVZhbHVlWmVybyggeCwgeSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geCA9PT0geSB8fCB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHkgPT09ICdudW1iZXInICYmIGlzTmFOKCB4ICkgJiYgaXNOYU4oIHkgKTtcbiAgICAgICAgICAgIH0gLy8gNy4gUmVwZWF0LCB3aGlsZSBrIDwgbGVuXG5cblxuICAgICAgICAgICAgd2hpbGUgKCBrIDwgbGVuICkge1xuICAgICAgICAgICAgICAgIC8vIEEuIExldCBlbGVtZW50SyBiZSB0aGUgcmVzdWx0IG9mID8gR2V0KE8sICEgVG9TdHJpbmcoaykpLlxuICAgICAgICAgICAgICAgIC8vIGIuIElmIFNhbWVWYWx1ZVplcm8oc2VhcmNoRWxlbWVudCwgZWxlbWVudEspIGlzIHRydWUsIHJldHVybiB0cnVlLlxuICAgICAgICAgICAgICAgIGlmICggc2FtZVZhbHVlWmVybyggb1sgayBdLCBzZWFyY2hFbGVtZW50ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gLy8gQy4gSW5jcmVhc2UgayBieSAxLlxuXG5cbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9IC8vIDguIFJldHVybiBmYWxzZVxuXG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gKTtcbn0gLy8gU3RyaW5nIC5pbmNsdWRlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbmlmICggIVN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMgKSB7XG4gICAgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKCBzZWFyY2gsIHN0YXJ0ICkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYgKCB0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBzdGFydCArIHNlYXJjaC5sZW5ndGggPiB0aGlzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YoIHNlYXJjaCwgc3RhcnQgKSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICB9O1xufSAvLyBFbGVtZW50IHJlbW92ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBmcm9tOmh0dHBzOi8vZ2l0aHViLmNvbS9qc2Vyei9qc19waWVjZS9ibG9iL21hc3Rlci9ET00vQ2hpbGROb2RlL3JlbW92ZSgpL3JlbW92ZSgpLm1kXG5cblxuKCBmdW5jdGlvbiggYXJyICkge1xuICAgIGFyci5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICAgICAgaWYgKCBpdGVtLmhhc093blByb3BlcnR5KCAncmVtb3ZlJyApICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBpdGVtLCAncmVtb3ZlJywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMucGFyZW50Tm9kZSAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9ICk7XG4gICAgfSApO1xufSApKCBbIEVsZW1lbnQucHJvdG90eXBlLCBDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSwgRG9jdW1lbnRUeXBlLnByb3RvdHlwZSBdICk7IC8vIEFycmF5IGZyb20gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJvZHVjdGlvbiBzdGVwcyBvZiBFQ01BLTI2MiwgRWRpdGlvbiA2LCAyMi4xLjIuMVxuXG5cbmlmICggIUFycmF5LmZyb20gKSB7XG4gICAgQXJyYXkuZnJvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgICAgIHZhciBpc0NhbGxhYmxlID0gZnVuY3Rpb24oIGZuICkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKCBmbiApID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0b0ludGVnZXIgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gTnVtYmVyKCB2YWx1ZSApO1xuXG4gICAgICAgICAgICBpZiAoIGlzTmFOKCBudW1iZXIgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBudW1iZXIgPT09IDAgfHwgIWlzRmluaXRlKCBudW1iZXIgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKCBudW1iZXIgPiAwID8gMSA6IC0xICkgKiBNYXRoLmZsb29yKCBNYXRoLmFicyggbnVtYmVyICkgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdyggMiwgNTMgKSAtIDE7XG5cbiAgICAgICAgdmFyIHRvTGVuZ3RoID0gZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRvSW50ZWdlciggdmFsdWUgKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbiggTWF0aC5tYXgoIGxlbiwgMCApLCBtYXhTYWZlSW50ZWdlciApO1xuICAgICAgICB9OyAvLyBUaGUgbGVuZ3RoIHByb3BlcnR5IG9mIHRoZSBmcm9tIG1ldGhvZCBpcyAxLlxuXG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGZyb20oIGFycmF5TGlrZVxuXG4gICAgICAgICAgICAvKiAsIG1hcEZuLCB0aGlzQXJnICovXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gMS4gTGV0IEMgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICB2YXIgQyA9IHRoaXM7IC8vIDIuIExldCBpdGVtcyBiZSBUb09iamVjdChhcnJheUxpa2UpLlxuXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBPYmplY3QoIGFycmF5TGlrZSApOyAvLyAzLiBSZXR1cm5JZkFicnVwdChpdGVtcykuXG5cbiAgICAgICAgICAgIGlmICggYXJyYXlMaWtlID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggJ0FycmF5LmZyb20gcmVxdWlyZXMgYW4gYXJyYXktbGlrZSBvYmplY3QgLSBub3QgbnVsbCBvciB1bmRlZmluZWQnICk7XG4gICAgICAgICAgICB9IC8vIDQuIElmIG1hcGZuIGlzIHVuZGVmaW5lZCwgdGhlbiBsZXQgbWFwcGluZyBiZSBmYWxzZS5cblxuXG4gICAgICAgICAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sgMSBdIDogdm9pZCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgVDtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgbWFwRm4gIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICAgIC8vIDUuIGVsc2VcbiAgICAgICAgICAgICAgICAvLyA1LiBhIElmIElzQ2FsbGFibGUobWFwZm4pIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgICAgICAgICAgaWYgKCAhaXNDYWxsYWJsZSggbWFwRm4gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggJ0FycmF5LmZyb206IHdoZW4gcHJvdmlkZWQsIHRoZSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyApO1xuICAgICAgICAgICAgICAgIH0gLy8gNS4gYi4gSWYgdGhpc0FyZyB3YXMgc3VwcGxpZWQsIGxldCBUIGJlIHRoaXNBcmc7IGVsc2UgbGV0IFQgYmUgdW5kZWZpbmVkLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAyICkge1xuICAgICAgICAgICAgICAgICAgICBUID0gYXJndW1lbnRzWyAyIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyAxMC4gTGV0IGxlblZhbHVlIGJlIEdldChpdGVtcywgXCJsZW5ndGhcIikuXG4gICAgICAgICAgICAvLyAxMS4gTGV0IGxlbiBiZSBUb0xlbmd0aChsZW5WYWx1ZSkuXG5cblxuICAgICAgICAgICAgdmFyIGxlbiA9IHRvTGVuZ3RoKCBpdGVtcy5sZW5ndGggKTsgLy8gMTMuIElmIElzQ29uc3RydWN0b3IoQykgaXMgdHJ1ZSwgdGhlblxuICAgICAgICAgICAgLy8gMTMuIGEuIExldCBBIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgIC8vIG9mIEMgd2l0aCBhbiBhcmd1bWVudCBsaXN0IGNvbnRhaW5pbmcgdGhlIHNpbmdsZSBpdGVtIGxlbi5cbiAgICAgICAgICAgIC8vIDE0LiBhLiBFbHNlLCBMZXQgQSBiZSBBcnJheUNyZWF0ZShsZW4pLlxuXG4gICAgICAgICAgICB2YXIgQSA9IGlzQ2FsbGFibGUoIEMgKSA/IE9iamVjdCggbmV3IEMoIGxlbiApICkgOiBuZXcgQXJyYXkoIGxlbiApOyAvLyAxNi4gTGV0IGsgYmUgMC5cblxuICAgICAgICAgICAgdmFyIGsgPSAwOyAvLyAxNy4gUmVwZWF0LCB3aGlsZSBrIDwgbGVu4oCmIChhbHNvIHN0ZXBzIGEgLSBoKVxuXG4gICAgICAgICAgICB2YXIga1ZhbHVlO1xuXG4gICAgICAgICAgICB3aGlsZSAoIGsgPCBsZW4gKSB7XG4gICAgICAgICAgICAgICAga1ZhbHVlID0gaXRlbXNbIGsgXTtcblxuICAgICAgICAgICAgICAgIGlmICggbWFwRm4gKSB7XG4gICAgICAgICAgICAgICAgICAgIEFbIGsgXSA9IHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IG1hcEZuKCBrVmFsdWUsIGsgKSA6IG1hcEZuLmNhbGwoIFQsIGtWYWx1ZSwgayApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEFbIGsgXSA9IGtWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBrICs9IDE7XG4gICAgICAgICAgICB9IC8vIDE4LiBMZXQgcHV0U3RhdHVzIGJlIFB1dChBLCBcImxlbmd0aFwiLCBsZW4sIHRydWUpLlxuXG5cbiAgICAgICAgICAgIEEubGVuZ3RoID0gbGVuOyAvLyAyMC4gUmV0dXJuIEEuXG5cbiAgICAgICAgICAgIHJldHVybiBBO1xuICAgICAgICB9O1xuICAgIH0oKTtcbn0gLy8gRE9NIGFwcGVuZCgpIHBvbHlmaWxsIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2pzZXJ6L2pzX3BpZWNlL2Jsb2IvbWFzdGVyL0RPTS9QYXJlbnROb2RlL2FwcGVuZCgpL2FwcGVuZCgpLm1kXG5cblxuKCBmdW5jdGlvbiggYXJyICkge1xuICAgIGFyci5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICAgICAgaWYgKCBpdGVtLmhhc093blByb3BlcnR5KCAnYXBwZW5kJyApICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBpdGVtLCAnYXBwZW5kJywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnQXJyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuICAgICAgICAgICAgICAgICAgICBkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIGFyZ0Fyci5mb3JFYWNoKCBmdW5jdGlvbiggYXJnSXRlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTm9kZSA9IGFyZ0l0ZW0gaW5zdGFuY2VvZiBOb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb2NGcmFnLmFwcGVuZENoaWxkKCBpc05vZGUgPyBhcmdJdGVtIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIFN0cmluZyggYXJnSXRlbSApICkgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCggZG9jRnJhZyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICk7XG4gICAgfSApO1xufSApKCBbIEVsZW1lbnQucHJvdG90eXBlLCBEb2N1bWVudC5wcm90b3R5cGUsIERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlIF0gKTsgLy8gRE9NIHByZXBlbmQoKSBwb2x5ZmlsbFxuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vanNlcnovanNfcGllY2UvYmxvYi9tYXN0ZXIvRE9NL1BhcmVudE5vZGUvcHJlcGVuZCgpL3ByZXBlbmQoKS5tZFxuXG5cbiggZnVuY3Rpb24oIGFyciApIHtcbiAgICBhcnIuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgICAgIGlmICggaXRlbS5oYXNPd25Qcm9wZXJ0eSggJ3ByZXBlbmQnICkgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIGl0ZW0sICdwcmVwZW5kJywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBlbmQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ0FyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcbiAgICAgICAgICAgICAgICAgICAgZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICBhcmdBcnIuZm9yRWFjaCggZnVuY3Rpb24oIGFyZ0l0ZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc05vZGUgPSBhcmdJdGVtIGluc3RhbmNlb2YgTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZG9jRnJhZy5hcHBlbmRDaGlsZCggaXNOb2RlID8gYXJnSXRlbSA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCBTdHJpbmcoIGFyZ0l0ZW0gKSApICk7XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKCBkb2NGcmFnLCB0aGlzLmZpcnN0Q2hpbGQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgIH0gKTtcbn0gKSggWyBFbGVtZW50LnByb3RvdHlwZSwgRG9jdW1lbnQucHJvdG90eXBlLCBEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSBdICk7IC8vIFRlbXBsYXRlIHRhZyBwb2x5IGZpbGwgZm9yIGN1c3RvbSBlbGVtZW50cyB0aGF0IHVzZSB0ZW1wbGF0ZSB0YWdzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLy8gbWluaW1hbCB0ZW1wbGF0ZSBwb2x5ZmlsbFxuXG5cbiggZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5lZWRzVGVtcGxhdGUgPSB0eXBlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGJyb2tlbkRvY0ZyYWdtZW50ID0gISggZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLmNsb25lTm9kZSgpIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCApO1xuICAgIHZhciBuZWVkc0RvY0ZyYWcgPSBmYWxzZTsgLy8gTk9URTogUmVwbGFjZSBEb2N1bWVudEZyYWdtZW50IHRvIHdvcmsgYXJvdW5kIElFMTEgYnVnIHRoYXRcbiAgICAvLyBjYXVzZXMgY2hpbGRyZW4gb2YgYSBkb2N1bWVudCBmcmFnbWVudCBtb2RpZmllZCB3aGlsZVxuICAgIC8vIHRoZXJlIGlzIGEgbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbm90IGhhdmUgYSBwYXJlbnROb2RlLCBvclxuICAgIC8vIGhhdmUgYSBicm9rZW4gcGFyZW50Tm9kZSAoIT8hKVxuXG4gICAgaWYgKCAvVHJpZGVudC8udGVzdCggbmF2aWdhdG9yLnVzZXJBZ2VudCApICkge1xuICAgICAgICAoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbmVlZHNEb2NGcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvcmlnQ2xvbmVOb2RlID0gTm9kZS5wcm90b3R5cGUuY2xvbmVOb2RlO1xuXG4gICAgICAgICAgICBOb2RlLnByb3RvdHlwZS5jbG9uZU5vZGUgPSBmdW5jdGlvbiBjbG9uZU5vZGUoIGRlZXAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0RvbSA9IG9yaWdDbG9uZU5vZGUuY2FsbCggdGhpcywgZGVlcCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RG9tLl9fcHJvdG9fXyA9IERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdEb207XG4gICAgICAgICAgICB9OyAvLyBJRSdzIERvY3VtZW50RnJhZ21lbnQgcXVlcnlTZWxlY3RvciBjb2RlIGRvZXNuJ3Qgd29yayB3aGVuXG4gICAgICAgICAgICAvLyBjYWxsZWQgb24gYW4gZWxlbWVudCBpbnN0YW5jZVxuXG5cbiAgICAgICAgICAgIERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwgPSBIVE1MRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbDtcbiAgICAgICAgICAgIERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPSBIVE1MRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvcjtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgICAgIG5vZGVUeXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvY2FsTmFtZToge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBub2RlTmFtZToge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcjZG9jdW1lbnQtZnJhZ21lbnQnO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB2YXIgb3JpZ0luc2VydEJlZm9yZSA9IE5vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKCBuZXdOb2RlLCByZWZOb2RlICkge1xuICAgICAgICAgICAgICAgIGlmICggbmV3Tm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZDtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGNoaWxkID0gbmV3Tm9kZS5maXJzdENoaWxkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ0luc2VydEJlZm9yZS5jYWxsKCB0aGlzLCBjaGlsZCwgcmVmTm9kZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ0luc2VydEJlZm9yZS5jYWxsKCB0aGlzLCBuZXdOb2RlLCByZWZOb2RlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGluc2VydEJlZm9yZTtcbiAgICAgICAgICAgIHZhciBvcmlnQXBwZW5kQ2hpbGQgPSBOb2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZDtcblxuICAgICAgICAgICAgTm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZCggY2hpbGQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjaGlsZCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZS5jYWxsKCB0aGlzLCBjaGlsZCwgbnVsbCApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdBcHBlbmRDaGlsZC5jYWxsKCB0aGlzLCBjaGlsZCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBvcmlnUmVtb3ZlQ2hpbGQgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZDtcbiAgICAgICAgICAgIHZhciBvcmlnUmVwbGFjZUNoaWxkID0gTm9kZS5wcm90b3R5cGUucmVwbGFjZUNoaWxkO1xuXG4gICAgICAgICAgICBOb2RlLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQgPSBmdW5jdGlvbiByZXBsYWNlQ2hpbGQoIG5ld0NoaWxkLCBvbGRDaGlsZCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIG5ld0NoaWxkIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlLmNhbGwoIHRoaXMsIG5ld0NoaWxkLCBvbGRDaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICBvcmlnUmVtb3ZlQ2hpbGQuY2FsbCggdGhpcywgb2xkQ2hpbGQgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcmlnUmVwbGFjZUNoaWxkLmNhbGwoIHRoaXMsIG5ld0NoaWxkLCBvbGRDaGlsZCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvbGRDaGlsZDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIERvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZyA9IHRoaXMuY3JlYXRlRWxlbWVudCggJ2RmJyApO1xuICAgICAgICAgICAgICAgIGZyYWcuX19wcm90b19fID0gRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgb3JpZ0ltcG9ydE5vZGUgPSBEb2N1bWVudC5wcm90b3R5cGUuaW1wb3J0Tm9kZTtcblxuICAgICAgICAgICAgRG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGUgPSBmdW5jdGlvbiBpbXBvcnROb2RlKCBpbXBOb2RlLCBkZWVwICkge1xuICAgICAgICAgICAgICAgIGRlZXAgPSBkZWVwIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gb3JpZ0ltcG9ydE5vZGUuY2FsbCggdGhpcywgaW1wTm9kZSwgZGVlcCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpbXBOb2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5fX3Byb3RvX18gPSBEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gKSgpO1xuICAgIH0gLy8gTk9URTogd2UgcmVseSBvbiB0aGlzIGNsb25lTm9kZSBub3QgY2F1c2luZyBlbGVtZW50IHVwZ3JhZGUuXG4gICAgLy8gVGhpcyBtZWFucyB0aGlzIHBvbHlmaWxsIG11c3QgbG9hZCBiZWZvcmUgdGhlIENFIHBvbHlmaWxsIGFuZFxuICAgIC8vIHRoaXMgd291bGQgbmVlZCB0byBiZSByZS13b3JrZWQgaWYgYSBicm93c2VyIHN1cHBvcnRzIG5hdGl2ZSBDRVxuICAgIC8vIGJ1dCBub3QgPHRlbXBsYXRlPi5cblxuXG4gICAgdmFyIGNhcHR1cmVkQ2xvbmVOb2RlID0gTm9kZS5wcm90b3R5cGUuY2xvbmVOb2RlO1xuICAgIHZhciBjYXB0dXJlZENyZWF0ZUVsZW1lbnQgPSBEb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudDtcbiAgICB2YXIgY2FwdHVyZWRJbXBvcnROb2RlID0gRG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGU7XG4gICAgdmFyIGNhcHR1cmVkUmVtb3ZlQ2hpbGQgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZDtcbiAgICB2YXIgY2FwdHVyZWRBcHBlbmRDaGlsZCA9IE5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkO1xuICAgIHZhciBjYXB0dXJlZFJlcGxhY2VDaGlsZCA9IE5vZGUucHJvdG90eXBlLnJlcGxhY2VDaGlsZDtcbiAgICB2YXIgY2FwdHVyZWRQYXJzZUZyb21TdHJpbmcgPSBET01QYXJzZXIucHJvdG90eXBlLnBhcnNlRnJvbVN0cmluZztcbiAgICB2YXIgY2FwdHVyZWRIVE1MRWxlbWVudElubmVySFRNTCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUsICdpbm5lckhUTUwnICkgfHwge1xuXG4gICAgICAgIC8qKlxuICAgICAqIEB0aGlzIHshSFRNTEVsZW1lbnR9XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJIVE1MO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAqIEB0aGlzIHshSFRNTEVsZW1lbnR9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9XG4gICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24oIHRleHQgKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVySFRNTCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjYXB0dXJlZENoaWxkTm9kZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB3aW5kb3cuTm9kZS5wcm90b3R5cGUsICdjaGlsZE5vZGVzJyApIHx8IHtcblxuICAgICAgICAvKipcbiAgICAgKiBAdGhpcyB7IU5vZGV9XG4gICAgICogQHJldHVybiB7IU5vZGVMaXN0fVxuICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2RlcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGVsZW1lbnRRdWVyeVNlbGVjdG9yQWxsID0gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbDtcbiAgICB2YXIgZG9jUXVlcnlTZWxlY3RvckFsbCA9IERvY3VtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsO1xuICAgIHZhciBmcmFnUXVlcnlTZWxlY3RvckFsbCA9IERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGw7XG4gICAgdmFyIHNjcmlwdFNlbGVjdG9yID0gJ3NjcmlwdDpub3QoW3R5cGVdKSxzY3JpcHRbdHlwZT1cImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIl0sc2NyaXB0W3R5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIl0nO1xuXG4gICAgZnVuY3Rpb24gUVNBKCBub2RlLCBzZWxlY3RvciApIHtcbiAgICAvLyBJRSAxMSB0aHJvd3MgYSBTeW50YXhFcnJvciB3aXRoIGBzY3JpcHRTZWxlY3RvcmAgaWYgdGhlIG5vZGUgaGFzIG5vIGNoaWxkcmVuIGR1ZSB0byB0aGUgYDpub3QoW3R5cGVdKWAgc3ludGF4XG4gICAgICAgIGlmICggIW5vZGUuY2hpbGROb2Rlcy5sZW5ndGggKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKCBub2RlLm5vZGVUeXBlICkge1xuICAgICAgICBjYXNlIE5vZGUuRE9DVU1FTlRfTk9ERTpcbiAgICAgICAgICAgIHJldHVybiBkb2NRdWVyeVNlbGVjdG9yQWxsLmNhbGwoIG5vZGUsIHNlbGVjdG9yICk7XG5cbiAgICAgICAgY2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgICAgICByZXR1cm4gZnJhZ1F1ZXJ5U2VsZWN0b3JBbGwuY2FsbCggbm9kZSwgc2VsZWN0b3IgKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRRdWVyeVNlbGVjdG9yQWxsLmNhbGwoIG5vZGUsIHNlbGVjdG9yICk7XG4gICAgICAgIH1cbiAgICB9IC8vIFJldHVybnMgdHJ1ZSBpZiBuZXN0ZWQgdGVtcGxhdGVzIGNhbm5vdCBiZSBjbG9uZWQgKHRoZXkgY2Fubm90IGJlIG9uXG4gICAgLy8gc29tZSBpbXBsJ3MgbGlrZSBTYWZhcmkgOCBhbmQgRWRnZSlcbiAgICAvLyBPUiBpZiBjbG9uaW5nIGEgZG9jdW1lbnQgZnJhZ21lbnQgZG9lcyBub3QgcmVzdWx0IGluIGEgZG9jdW1lbnQgZnJhZ21lbnRcblxuXG4gICAgdmFyIG5lZWRzQ2xvbmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoICFuZWVkc1RlbXBsYXRlICkge1xuICAgICAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAndGVtcGxhdGUnICk7XG4gICAgICAgICAgICB2YXIgdDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAndGVtcGxhdGUnICk7XG4gICAgICAgICAgICB0Mi5jb250ZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApICk7XG4gICAgICAgICAgICB0LmNvbnRlbnQuYXBwZW5kQ2hpbGQoIHQyICk7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSB0LmNsb25lTm9kZSggdHJ1ZSApO1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lLmNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgfHwgY2xvbmUuY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgfHwgYnJva2VuRG9jRnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9KCk7XG5cbiAgICB2YXIgVEVNUExBVEVfVEFHID0gJ3RlbXBsYXRlJztcblxuICAgIHZhciBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICBpZiAoIG5lZWRzVGVtcGxhdGUgKSB7XG4gICAgICAgIHZhciBjb250ZW50RG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCAndGVtcGxhdGUnICk7XG4gICAgICAgIHZhciBjYW5EZWNvcmF0ZSA9IHRydWU7XG4gICAgICAgIHZhciB0ZW1wbGF0ZVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3N0eWxlJyApO1xuICAgICAgICB0ZW1wbGF0ZVN0eWxlLnRleHRDb250ZW50ID0gVEVNUExBVEVfVEFHICsgJ3tkaXNwbGF5Om5vbmU7fSc7XG4gICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZDtcbiAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoIHRlbXBsYXRlU3R5bGUsIGhlYWQuZmlyc3RFbGVtZW50Q2hpbGQgKTtcblxuICAgICAgICAvKipcbiAgICAgIFByb3ZpZGVzIGEgbWluaW1hbCBzaGltIGZvciB0aGUgPHRlbXBsYXRlPiBlbGVtZW50LlxuICAgICovXG5cbiAgICAgICAgUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSFRNTEVsZW1lbnQucHJvdG90eXBlICk7IC8vIElmIGVsZW1lbnRzIGRvIG5vdCBoYXZlIGBpbm5lckhUTUxgIG9uIGluc3RhbmNlcywgdGhlblxuICAgICAgICAvLyB0ZW1wbGF0ZXMgY2FuIGJlIHBhdGNoZWQgYnkgc3dpenpsaW5nIHRoZWlyIHByb3RvdHlwZXMuXG5cbiAgICAgICAgdmFyIGNhblByb3RvUGF0Y2ggPSAhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKS5oYXNPd25Qcm9wZXJ0eSggJ2lubmVySFRNTCcgKTtcblxuICAgICAgICAvKipcbiAgICAgIFRoZSBgZGVjb3JhdGVgIG1ldGhvZCBtb3ZlcyBlbGVtZW50IGNoaWxkcmVuIHRvIHRoZSB0ZW1wbGF0ZSdzIGBjb250ZW50YC5cbiAgICAgIE5PVEU6IHRoZXJlIGlzIG5vIHN1cHBvcnQgZm9yIGR5bmFtaWNhbGx5IGFkZGluZyBlbGVtZW50cyB0byB0ZW1wbGF0ZXMuXG4gICAgKi9cblxuICAgICAgICBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSA9IGZ1bmN0aW9uKCB0ZW1wbGF0ZSApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0ZW1wbGF0ZSBpcyBkZWNvcmF0ZWQgb3Igbm90IGluIEhUTUwgbmFtZXNwYWNlLCByZXR1cm4gZmFzdFxuICAgICAgICAgICAgaWYgKCB0ZW1wbGF0ZS5jb250ZW50IHx8IHRlbXBsYXRlLm5hbWVzcGFjZVVSSSAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQgPSBjb250ZW50RG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZDtcblxuICAgICAgICAgICAgd2hpbGUgKCBjaGlsZCA9IHRlbXBsYXRlLmZpcnN0Q2hpbGQgKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZWRBcHBlbmRDaGlsZC5jYWxsKCB0ZW1wbGF0ZS5jb250ZW50LCBjaGlsZCApO1xuICAgICAgICAgICAgfSAvLyBOT1RFOiBwcmVmZXIgcHJvdG90eXBlIHBhdGNoaW5nIGZvciBwZXJmb3JtYW5jZSBhbmRcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugb24gc29tZSBicm93c2VycyAoSUUxMSksIHJlLWRlZmluaW5nIGBpbm5lckhUTUxgXG4gICAgICAgICAgICAvLyBjYW4gcmVzdWx0IGluIGludGVybWl0dGVudCBlcnJvcnMuXG5cblxuICAgICAgICAgICAgaWYgKCBjYW5Qcm90b1BhdGNoICkge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlLl9fcHJvdG9fXyA9IFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50LnByb3RvdHlwZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUuY2xvbmVOb2RlID0gZnVuY3Rpb24oIGRlZXAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5fY2xvbmVOb2RlKCB0aGlzLCBkZWVwICk7XG4gICAgICAgICAgICAgICAgfTsgLy8gQWRkIGlubmVySFRNTCB0byB0ZW1wbGF0ZSwgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGlzIHRocm93cyBvbiBTYWZhcmkgN1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoIGNhbkRlY29yYXRlICkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lSW5uZXJIVE1MKCB0ZW1wbGF0ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lT3V0ZXJIVE1MKCB0ZW1wbGF0ZSApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZXJyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuRGVjb3JhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gQm9vdHN0cmFwIHJlY3Vyc2l2ZWx5XG5cblxuICAgICAgICAgICAgUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuYm9vdHN0cmFwKCB0ZW1wbGF0ZS5jb250ZW50ICk7XG4gICAgICAgIH07IC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi83M2Q3ZTYyNTljNjNhYzQ1ZjQyYzY1OTNkYThjMjc5NmM2Y2U5MjgxL3NyYy9tYW5pcHVsYXRpb24vd3JhcE1hcC5qc1xuXG5cbiAgICAgICAgdmFyIHRvcExldmVsV3JhcHBpbmdNYXAgPSB7XG4gICAgICAgICAgICBvcHRpb246IFsgJ3NlbGVjdCcgXSxcbiAgICAgICAgICAgIHRoZWFkOiBbICd0YWJsZScgXSxcbiAgICAgICAgICAgIGNvbDogWyAnY29sZ3JvdXAnLCAndGFibGUnIF0sXG4gICAgICAgICAgICB0cjogWyAndGJvZHknLCAndGFibGUnIF0sXG4gICAgICAgICAgICB0aDogWyAndHInLCAndGJvZHknLCAndGFibGUnIF0sXG4gICAgICAgICAgICB0ZDogWyAndHInLCAndGJvZHknLCAndGFibGUnIF1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0VGFnTmFtZSA9IGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgICAgICAgLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzczZDdlNjI1OWM2M2FjNDVmNDJjNjU5M2RhOGMyNzk2YzZjZTkyODEvc3JjL21hbmlwdWxhdGlvbi92YXIvcnRhZ05hbWUuanNcbiAgICAgICAgICAgIHJldHVybiAoIC88KFthLXpdW14vXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kuZXhlYyggdGV4dCApIHx8IFsgJycsICcnIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRlZmluZUlubmVySFRNTCA9IGZ1bmN0aW9uIGRlZmluZUlubmVySFRNTCggb2JqICkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosICdpbm5lckhUTUwnLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldElubmVySFRNTCggdGhpcyApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggdGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIElFMTEsIHdyYXAgdGhlIHRleHQgaW4gdGhlIGNvcnJlY3QgKHRhYmxlKSBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwID0gdG9wTGV2ZWxXcmFwcGluZ01hcFsgZ2V0VGFnTmFtZSggdGV4dCApIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB3cmFwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJzwnICsgd3JhcFsgaSBdICsgJz4nICsgdGV4dCArICc8LycgKyB3cmFwWyBpIF0gKyAnPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50RG9jLmJvZHkuaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuYm9vdHN0cmFwKCBjb250ZW50RG9jICk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmVkUmVtb3ZlQ2hpbGQuY2FsbCggdGhpcy5jb250ZW50LCB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBjb250ZW50RG9jLmJvZHk7IC8vIElmIHdlIGhhZCB3cmFwcGVkLCBnZXQgYmFjayB0byB0aGUgb3JpZ2luYWwgbm9kZVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggd3JhcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IHdyYXAubGVuZ3RoOyBqKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGJvZHkubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBib2R5LmZpcnN0Q2hpbGQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlZEFwcGVuZENoaWxkLmNhbGwoIHRoaXMuY29udGVudCwgYm9keS5maXJzdENoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkZWZpbmVPdXRlckhUTUwgPSBmdW5jdGlvbiBkZWZpbmVPdXRlckhUTUwoIG9iaiApIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqLCAnb3V0ZXJIVE1MJywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnPCcgKyBURU1QTEFURV9UQUcgKyAnPicgKyB0aGlzLmlubmVySFRNTCArICc8LycgKyBURU1QTEFURV9UQUcgKyAnPic7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBpbm5lckhUTUwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudERvYy5ib2R5LmlubmVySFRNTCA9IGlubmVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2NGcmFnID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBjb250ZW50RG9jLmJvZHkuZmlyc3RDaGlsZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlZEFwcGVuZENoaWxkLmNhbGwoIGRvY0ZyYWcsIGNvbnRlbnREb2MuYm9keS5maXJzdENoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmVkUmVwbGFjZUNoaWxkLmNhbGwoIHRoaXMucGFyZW50Tm9kZSwgZG9jRnJhZywgdGhpcyApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnRmFpbGVkIHRvIHNldCB0aGUgXFwnb3V0ZXJIVE1MXFwnIHByb3BlcnR5IG9uIFxcJ0VsZW1lbnRcXCc6IFRoaXMgZWxlbWVudCBoYXMgbm8gcGFyZW50IG5vZGUuJyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfTtcblxuICAgICAgICBkZWZpbmVJbm5lckhUTUwoIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50LnByb3RvdHlwZSApO1xuICAgICAgICBkZWZpbmVPdXRlckhUTUwoIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50LnByb3RvdHlwZSApO1xuXG4gICAgICAgIC8qKlxuICAgICAgVGhlIGBib290c3RyYXBgIG1ldGhvZCBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBhbmQgXCJmaXhlc1wiIGFsbFxuICAgICAgPHRlbXBsYXRlPiBlbGVtZW50cyBpbiB0aGUgZG9jdW1lbnQgcmVmZXJlbmNlZCBieSB0aGUgYGRvY2AgYXJndW1lbnQuXG4gICAgKi9cblxuICAgICAgICBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5ib290c3RyYXAgPSBmdW5jdGlvbiBib290c3RyYXAoIGRvYyApIHtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZXMgPSBRU0EoIGRvYywgVEVNUExBVEVfVEFHICk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRlbXBsYXRlcy5sZW5ndGgsIHQ7IGkgPCBsICYmICggdCA9IHRlbXBsYXRlc1sgaSBdICk7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSggdCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9OyAvLyBBdXRvLWJvb3RzdHJhcHBpbmcgZm9yIG1haW4gZG9jdW1lbnRcblxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5ib290c3RyYXAoIGRvY3VtZW50ICk7XG4gICAgICAgIH0gKTsgLy8gUGF0Y2ggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCB0byBlbnN1cmUgbmV3bHkgY3JlYXRlZCB0ZW1wbGF0ZXMgaGF2ZSBjb250ZW50XG5cbiAgICAgICAgRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KCkge1xuICAgICAgICAgICAgdmFyIGVsID0gY2FwdHVyZWRDcmVhdGVFbGVtZW50LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuICAgICAgICAgICAgaWYgKCBlbC5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScgKSB7XG4gICAgICAgICAgICAgICAgUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuZGVjb3JhdGUoIGVsICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfTtcblxuICAgICAgICBET01QYXJzZXIucHJvdG90eXBlLnBhcnNlRnJvbVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsID0gY2FwdHVyZWRQYXJzZUZyb21TdHJpbmcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuYm9vdHN0cmFwKCBlbCApO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5uZXJIVE1MJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5uZXJIVE1MKCB0aGlzICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggdGV4dCApIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlZEhUTUxFbGVtZW50SW5uZXJIVE1MLnNldC5jYWxsKCB0aGlzLCB0ZXh0ICk7XG4gICAgICAgICAgICAgICAgUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuYm9vdHN0cmFwKCB0aGlzICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9ICk7IC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1lbmQuaHRtbCNlc2NhcGluZ1N0cmluZ1xuXG4gICAgICAgIHZhciBlc2NhcGVBdHRyUmVnRXhwID0gL1smXFx1MDBBMFwiXS9nO1xuICAgICAgICB2YXIgZXNjYXBlRGF0YVJlZ0V4cCA9IC9bJlxcdTAwQTA8Pl0vZztcblxuICAgICAgICB2YXIgZXNjYXBlUmVwbGFjZSA9IGZ1bmN0aW9uKCBjICkge1xuICAgICAgICAgICAgc3dpdGNoICggYyApIHtcbiAgICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnJmFtcDsnO1xuXG4gICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuXG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJyZndDsnO1xuXG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICcmcXVvdDsnO1xuXG4gICAgICAgICAgICBjYXNlICdcXHUwMEEwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJyZuYnNwOyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVzY2FwZUF0dHIgPSBmdW5jdGlvbiggcyApIHtcbiAgICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoIGVzY2FwZUF0dHJSZWdFeHAsIGVzY2FwZVJlcGxhY2UgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXNjYXBlRGF0YSA9IGZ1bmN0aW9uKCBzICkge1xuICAgICAgICAgICAgcmV0dXJuIHMucmVwbGFjZSggZXNjYXBlRGF0YVJlZ0V4cCwgZXNjYXBlUmVwbGFjZSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtYWtlU2V0ID0gZnVuY3Rpb24oIGFyciApIHtcbiAgICAgICAgICAgIHZhciBzZXQgPSB7fTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIHNldFsgYXJyWyBpIF0gXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgIH07IC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvI3ZvaWQtZWxlbWVudHNcblxuXG4gICAgICAgIHZhciB2b2lkRWxlbWVudHMgPSBtYWtlU2V0KCBbICdhcmVhJywgJ2Jhc2UnLCAnYnInLCAnY29sJywgJ2NvbW1hbmQnLCAnZW1iZWQnLCAnaHInLCAnaW1nJywgJ2lucHV0JywgJ2tleWdlbicsICdsaW5rJywgJ21ldGEnLCAncGFyYW0nLCAnc291cmNlJywgJ3RyYWNrJywgJ3dicicgXSApO1xuICAgICAgICB2YXIgcGxhaW50ZXh0UGFyZW50cyA9IG1ha2VTZXQoIFsgJ3N0eWxlJywgJ3NjcmlwdCcsICd4bXAnLCAnaWZyYW1lJywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAncGxhaW50ZXh0JywgJ25vc2NyaXB0JyBdICk7XG5cbiAgICAgICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtOb2RlfSBwYXJlbnROb2RlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrXG4gICAgICovXG5cbiAgICAgICAgdmFyIGdldE91dGVySFRNTCA9IGZ1bmN0aW9uKCBub2RlLCBwYXJlbnROb2RlLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHN3aXRjaCAoIG5vZGUubm9kZVR5cGUgKSB7XG4gICAgICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB0YWdOYW1lID0gbm9kZS5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSAnPCcgKyB0YWdOYW1lO1xuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgYXR0cjsgYXR0ciA9IGF0dHJzWyBpIF07IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgcyArPSAnICcgKyBhdHRyLm5hbWUgKyAnPVwiJyArIGVzY2FwZUF0dHIoIGF0dHIudmFsdWUgKSArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcyArPSAnPic7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZvaWRFbGVtZW50c1sgdGFnTmFtZSBdICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcyArIGdldElubmVySFRNTCggbm9kZSwgY2FsbGJhY2sgKSArICc8LycgKyB0YWdOYW1lICsgJz4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID1cblxuICAgICAgICAgICAgLyoqIEB0eXBlIHtUZXh0fSAqL1xuICAgICAgICAgICAgbm9kZS5kYXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwYXJlbnROb2RlICYmIHBsYWludGV4dFBhcmVudHNbIHBhcmVudE5vZGUubG9jYWxOYW1lIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVEYXRhKCBkYXRhICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgTm9kZS5DT01NRU5UX05PREU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8IS0tJyArXG5cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7Q29tbWVudH0gKi9cbiAgICAgICAgICAgIG5vZGUuZGF0YSArICctLT4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmVycm9yKCBub2RlICk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnbm90IGltcGxlbWVudGVkJyApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFja1xuICAgICAqL1xuXG5cbiAgICAgICAgdmFyIGdldElubmVySFRNTCA9IGZ1bmN0aW9uKCBub2RlLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIGlmICggbm9kZS5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScgKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9XG5cbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqL1xuICAgICAgICBub2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgICAgICB2YXIgYyQgPSBjYWxsYmFjayA/IGNhbGxiYWNrKCBub2RlICkgOiBjYXB0dXJlZENoaWxkTm9kZXMuZ2V0LmNhbGwoIG5vZGUgKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gYyQubGVuZ3RoLCBjaGlsZDsgaSA8IGwgJiYgKCBjaGlsZCA9IGMkWyBpIF0gKTsgaSsrICkge1xuICAgICAgICAgICAgICAgIHMgKz0gZ2V0T3V0ZXJIVE1MKCBjaGlsZCwgbm9kZSwgY2FsbGJhY2sgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG4gICAgfSAvLyBNYWtlIGNsb25pbmcvaW1wb3J0aW5nIHdvcmshXG5cblxuICAgIGlmICggbmVlZHNUZW1wbGF0ZSB8fCBuZWVkc0Nsb25pbmcgKSB7XG4gICAgICAgIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50Ll9jbG9uZU5vZGUgPSBmdW5jdGlvbiBfY2xvbmVOb2RlKCB0ZW1wbGF0ZSwgZGVlcCApIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IGNhcHR1cmVkQ2xvbmVOb2RlLmNhbGwoIHRlbXBsYXRlLCBmYWxzZSApOyAvLyBOT1RFOiBkZWNvcmF0ZSBkb2Vzbid0IGF1dG8tZml4IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBhcmUgYWxyZWFkeVxuICAgICAgICAgICAgLy8gZGVjb3JhdGVkIHNvIHRoZXkgbmVlZCBzcGVjaWFsIGNsb25lIGZpeHVwLlxuXG4gICAgICAgICAgICBpZiAoIHRoaXMuZGVjb3JhdGUgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZSggY2xvbmUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBkZWVwICkge1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IHVzZSBuYXRpdmUgY2xvbmUgbm9kZSB0byBtYWtlIHN1cmUgQ0UncyB3cmFwcGVkXG4gICAgICAgICAgICAgICAgLy8gY2xvbmVOb2RlIGRvZXMgbm90IGNhdXNlIGVsZW1lbnRzIHRvIHVwZ3JhZGUuXG4gICAgICAgICAgICAgICAgY2FwdHVyZWRBcHBlbmRDaGlsZC5jYWxsKCBjbG9uZS5jb250ZW50LCBjYXB0dXJlZENsb25lTm9kZS5jYWxsKCB0ZW1wbGF0ZS5jb250ZW50LCB0cnVlICkgKTsgLy8gTm93IGVuc3VyZSBuZXN0ZWQgdGVtcGxhdGVzIGFyZSBjbG9uZWQgY29ycmVjdGx5LlxuXG4gICAgICAgICAgICAgICAgZml4Q2xvbmVkRG9tKCBjbG9uZS5jb250ZW50LCB0ZW1wbGF0ZS5jb250ZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfTsgLy8gR2l2ZW4gYSBzb3VyY2UgYW5kIGNsb25lZCBzdWJ0cmVlLCBmaW5kIDx0ZW1wbGF0ZT4ncyBpbiB0aGUgY2xvbmVkXG4gICAgICAgIC8vIHN1YnRyZWUgYW5kIHJlcGxhY2UgdGhlbSB3aXRoIGNsb25lZCA8dGVtcGxhdGU+J3MgZnJvbSBzb3VyY2UuXG4gICAgICAgIC8vIFdlIG11c3QgZG8gdGhpcyBiZWNhdXNlIG9ubHkgdGhlIHNvdXJjZSB0ZW1wbGF0ZXMgaGF2ZSBwcm9wZXIgLmNvbnRlbnQuXG5cblxuICAgICAgICB2YXIgZml4Q2xvbmVkRG9tID0gZnVuY3Rpb24gZml4Q2xvbmVkRG9tKCBjbG9uZSwgc291cmNlICkge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjbG9uZWQgbm9kZSBpcyBub3QgYW4gZWxlbWVudFxuICAgICAgICAgICAgaWYgKCAhc291cmNlLnF1ZXJ5U2VsZWN0b3JBbGwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSAvLyBUaGVzZSB0d28gbGlzdHMgc2hvdWxkIGJlIGNvaW5jaWRlbnRcblxuXG4gICAgICAgICAgICB2YXIgcyQgPSBRU0EoIHNvdXJjZSwgVEVNUExBVEVfVEFHICk7XG5cbiAgICAgICAgICAgIGlmICggcyQubGVuZ3RoID09PSAwICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHQkID0gUVNBKCBjbG9uZSwgVEVNUExBVEVfVEFHICk7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHQkLmxlbmd0aCwgdCwgczsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBzID0gcyRbIGkgXTtcbiAgICAgICAgICAgICAgICB0ID0gdCRbIGkgXTtcblxuICAgICAgICAgICAgICAgIGlmICggUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQgJiYgUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuZGVjb3JhdGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKCBzICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FwdHVyZWRSZXBsYWNlQ2hpbGQuY2FsbCggdC5wYXJlbnROb2RlLCBjbG9uZU5vZGUuY2FsbCggcywgdHJ1ZSApLCB0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07IC8vIE1ha2Ugc3VyZSBzY3JpcHRzIGluc2lkZSBvZiBhIGNsb25lZCB0ZW1wbGF0ZSBhcmUgZXhlY3V0YWJsZVxuXG5cbiAgICAgICAgdmFyIGZpeENsb25lZFNjcmlwdHMgPSBmdW5jdGlvbiBmaXhDbG9uZWRTY3JpcHRzKCBmcmFnbWVudCApIHtcbiAgICAgICAgICAgIHZhciBzY3JpcHRzID0gUVNBKCBmcmFnbWVudCwgc2NyaXB0U2VsZWN0b3IgKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIG5zLCBzLCBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgcyA9IHNjcmlwdHNbIGkgXTtcbiAgICAgICAgICAgICAgICBucyA9IGNhcHR1cmVkQ3JlYXRlRWxlbWVudC5jYWxsKCBkb2N1bWVudCwgJ3NjcmlwdCcgKTtcbiAgICAgICAgICAgICAgICBucy50ZXh0Q29udGVudCA9IHMudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gcy5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGFpID0gMCwgYTsgYWkgPCBhdHRycy5sZW5ndGg7IGFpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBhdHRyc1sgYWkgXTtcbiAgICAgICAgICAgICAgICAgICAgbnMuc2V0QXR0cmlidXRlKCBhLm5hbWUsIGEudmFsdWUgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXB0dXJlZFJlcGxhY2VDaGlsZC5jYWxsKCBzLnBhcmVudE5vZGUsIG5zLCBzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07IC8vIE92ZXJyaWRlIGFsbCBjbG9uaW5nIHRvIGZpeCB0aGUgY2xvbmVkIHN1YnRyZWUgdG8gY29udGFpbiBwcm9wZXJseVxuICAgICAgICAvLyBjbG9uZWQgdGVtcGxhdGVzLlxuXG5cbiAgICAgICAgdmFyIGNsb25lTm9kZSA9IE5vZGUucHJvdG90eXBlLmNsb25lTm9kZSA9IGZ1bmN0aW9uIGNsb25lTm9kZSggZGVlcCApIHtcbiAgICAgICAgICAgIHZhciBkb207IC8vIFdvcmthcm91bmQgZm9yIEVkZ2UgYnVnIGNsb25pbmcgZG9jdW1lbnRGcmFnbWVudHNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg2MTk2NDYvXG5cbiAgICAgICAgICAgIGlmICggIW5lZWRzRG9jRnJhZyAmJiBicm9rZW5Eb2NGcmFnbWVudCAmJiB0aGlzIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCApIHtcbiAgICAgICAgICAgICAgICBpZiAoICFkZWVwICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb20gPSBpbXBvcnROb2RlLmNhbGwoIHRoaXMub3duZXJEb2N1bWVudCwgdGhpcywgdHJ1ZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHRoaXMubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIHRoaXMubG9jYWxOYW1lID09PSBURU1QTEFURV9UQUcgJiYgdGhpcy5uYW1lc3BhY2VVUkkgPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSApIHtcbiAgICAgICAgICAgICAgICBkb20gPSBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5fY2xvbmVOb2RlKCB0aGlzLCBkZWVwICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbSA9IGNhcHR1cmVkQ2xvbmVOb2RlLmNhbGwoIHRoaXMsIGRlZXAgKTtcbiAgICAgICAgICAgIH0gLy8gVGVtcGxhdGUuY29udGVudCBpcyBjbG9uZWQgaWZmIGBkZWVwYC5cblxuXG4gICAgICAgICAgICBpZiAoIGRlZXAgKSB7XG4gICAgICAgICAgICAgICAgZml4Q2xvbmVkRG9tKCBkb20sIHRoaXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRvbTtcbiAgICAgICAgfTsgLy8gTk9URTogd2UgYXJlIGNsb25pbmcgaW5zdGVhZCBvZiBpbXBvcnRpbmcgPHRlbXBsYXRlPidzLlxuICAgICAgICAvLyBIb3dldmVyLCB0aGUgb3duZXJEb2N1bWVudCBvZiB0aGUgY2xvbmVkIHRlbXBsYXRlIHdpbGwgYmUgY29ycmVjdCFcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZSBuYXRpdmUgaW1wb3J0IG5vZGUgY3JlYXRlcyB0aGUgcmlnaHQgZG9jdW1lbnQgb3duZWRcbiAgICAgICAgLy8gc3VidHJlZSBhbmQgYGZpeENsb25lZERvbWAgaW5zZXJ0cyBjbG9uZWQgdGVtcGxhdGVzIGludG8gdGhpcyBzdWJ0cmVlLFxuICAgICAgICAvLyB0aHVzIHVwZGF0aW5nIHRoZSBvd25lciBkb2MuXG5cblxuICAgICAgICB2YXIgaW1wb3J0Tm9kZSA9IERvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlID0gZnVuY3Rpb24gaW1wb3J0Tm9kZSggZWxlbWVudCwgZGVlcCApIHtcbiAgICAgICAgICAgIGRlZXAgPSBkZWVwIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoIGVsZW1lbnQubG9jYWxOYW1lID09PSBURU1QTEFURV9UQUcgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50Ll9jbG9uZU5vZGUoIGVsZW1lbnQsIGRlZXAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbSA9IGNhcHR1cmVkSW1wb3J0Tm9kZS5jYWxsKCB0aGlzLCBlbGVtZW50LCBkZWVwICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGRlZXAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpeENsb25lZERvbSggZG9tLCBlbGVtZW50ICk7XG4gICAgICAgICAgICAgICAgICAgIGZpeENsb25lZFNjcmlwdHMoIGRvbSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCBuZWVkc1RlbXBsYXRlICkge1xuICAgICAgICB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudCA9IFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50O1xuICAgIH1cbn0gKSgpOyAvLyAuZmlsbCBwb2x5ZmlsXG5cblxuaWYgKCAhQXJyYXkucHJvdG90eXBlLmZpbGwgKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBBcnJheS5wcm90b3R5cGUsICdmaWxsJywge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgLy8gU3RlcHMgMS0yLlxuICAgICAgICAgICAgaWYgKCB0aGlzID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggJ3RoaXMgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIE8gPSBPYmplY3QoIHRoaXMgKTsgLy8gU3RlcHMgMy01LlxuXG4gICAgICAgICAgICB2YXIgbGVuID0gTy5sZW5ndGggPj4+IDA7IC8vIFN0ZXBzIDYtNy5cblxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWyAxIF07XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVTdGFydCA9IHN0YXJ0ID4+IDA7IC8vIFN0ZXAgOC5cblxuICAgICAgICAgICAgdmFyIGsgPSByZWxhdGl2ZVN0YXJ0IDwgMCA/IE1hdGgubWF4KCBsZW4gKyByZWxhdGl2ZVN0YXJ0LCAwICkgOiBNYXRoLm1pbiggcmVsYXRpdmVTdGFydCwgbGVuICk7IC8vIFN0ZXBzIDktMTAuXG5cbiAgICAgICAgICAgIHZhciBlbmQgPSBhcmd1bWVudHNbIDIgXTtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZUVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kID4+IDA7IC8vIFN0ZXAgMTEuXG5cbiAgICAgICAgICAgIHZhciBmaW5hbFZhbHVlID0gcmVsYXRpdmVFbmQgPCAwID8gTWF0aC5tYXgoIGxlbiArIHJlbGF0aXZlRW5kLCAwICkgOiBNYXRoLm1pbiggcmVsYXRpdmVFbmQsIGxlbiApOyAvLyBTdGVwIDEyLlxuXG4gICAgICAgICAgICB3aGlsZSAoIGsgPCBmaW5hbFZhbHVlICkge1xuICAgICAgICAgICAgICAgIE9bIGsgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH0gLy8gU3RlcCAxMy5cblxuXG4gICAgICAgICAgICByZXR1cm4gTztcbiAgICAgICAgfVxuICAgIH0gKTtcbn0gLy8gT2JqZWN0IGFzc2lnblxuXG5cbmlmICggdHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicgKSB7XG4gICAgLy8gTXVzdCBiZSB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggT2JqZWN0LCAnYXNzaWduJywge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXNzaWduKCB0YXJnZXQsIHZhckFyZ3MgKSB7XG4gICAgICAgICAgICAvLyAubGVuZ3RoIG9mIGZ1bmN0aW9uIGlzIDJcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgaWYgKCB0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvID0gT2JqZWN0KCB0YXJnZXQgKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzWyBpbmRleCBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBuZXh0U291cmNlICE9PSBudWxsICYmIG5leHRTb3VyY2UgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIG5leHRLZXkgaW4gbmV4dFNvdXJjZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIG5leHRTb3VyY2UsIG5leHRLZXkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1sgbmV4dEtleSBdID0gbmV4dFNvdXJjZVsgbmV4dEtleSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9ICk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0NBO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBYkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakNBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlDQTtBQWdEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1QkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBNkJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/polyfills.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/postmessage.js":
/*!******************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/postmessage.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * A backwards compatable implementation of postMessage\n * by Josh Fraser (joshfraser.com)\n * released under the Apache 2.0 license.\n *\n * this code was adapted from Ben Alman's jQuery postMessage code found at:\n * http://benalman.com/projects/jquery-postmessage-plugin/\n *\n * other inspiration was taken from Luke Shepard's code for Facebook Connect:\n * http://github.com/facebook/connect-js/blob/master/src/core/xd.js\n *\n * the goal of this project was to make a backwards compatable version of postMessage\n * without having any dependency on jQuery or the FB Connect libraries\n *\n * my goal was to keep this as terse as possible since my own purpose was to use this\n * as part of a distributed widget where filesize could be sensative.\n *\n */\n// Everything is wrapped in the XD function to reduce namespace collisions\n\n(() => {\n  var XD = function () {\n    var interval_id,\n        last_hash,\n        cache_bust = 1,\n        attached_callback = function () {},\n        _window = this || window;\n\n    return {\n      postMessage: function (message, target_url, target) {\n        if (!target_url) {\n          return;\n        }\n\n        target = target || parent; // Default to parent\n\n        if (_window.postMessage) {\n          // The browser supports window.postMessage, so call it with a targetOrigin\n          // Set appropriately, based on the target_url parameter.\n          target.postMessage(message, target_url.replace(/([^:]+:\\/\\/[^\\/]+).*/, '$1'));\n        } else if (target_url) {\n          // The browser does not support window.postMessage, so set the location\n          // Of the target to target_url#message. A bit ugly, but it works! A cache\n          // Bust parameter is added to ensure that repeat messages trigger the callback.\n          target.location = target_url.replace(/#.*$/, '') + '#' + +new Date() + cache_bust++ + '&' + message;\n        }\n      },\n      receiveMessage: function (callback, source_origin) {\n        // Browser supports window.postMessage\n        if (_window.postMessage) {\n          // Bind the callback to the actual event associated with window.postMessage\n          if (callback) {\n            attached_callback = function (e) {\n              if (typeof source_origin === 'string' && e.origin !== source_origin || Object.prototype.toString.call(source_origin) === '[object Function]' && source_origin(e.origin) === !1) {\n                return !1;\n              }\n\n              callback(e);\n            };\n          }\n\n          if (_window.addEventListener) {\n            _window[callback ? 'addEventListener' : 'removeEventListener']('message', attached_callback, !1);\n          } else {\n            _window[callback ? 'attachEvent' : 'detachEvent']('onmessage', attached_callback);\n          }\n        } else {\n          // A polling loop is started & callback is called whenever the location.hash changes\n          interval_id && clearInterval(interval_id);\n          interval_id = null;\n\n          if (callback) {\n            interval_id = setInterval(function () {\n              var hash = document.location.hash,\n                  re = /^#?\\d+&/;\n\n              if (hash !== last_hash && re.test(hash)) {\n                last_hash = hash;\n                callback({\n                  data: hash.replace(re, '')\n                });\n              }\n            }, 100);\n          }\n        }\n      }\n    };\n  }(); // Export common js / node else browser\n\n\n  if ( true && typeof module.exports !== 'undefined') {\n    module.exports = XD;\n  } else {\n    window.XD = XD;\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My9wb3N0bWVzc2FnZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3d3dy9qcy0zLjIuMi9vbnRyYXBvcnQvb3B0X2Fzc2V0cy9vcHRfYm9pbGVycGxhdGVzL3YzL3Bvc3RtZXNzYWdlLmpzP2Q5ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKlxuICogQSBiYWNrd2FyZHMgY29tcGF0YWJsZSBpbXBsZW1lbnRhdGlvbiBvZiBwb3N0TWVzc2FnZVxuICogYnkgSm9zaCBGcmFzZXIgKGpvc2hmcmFzZXIuY29tKVxuICogcmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSAyLjAgbGljZW5zZS5cbiAqXG4gKiB0aGlzIGNvZGUgd2FzIGFkYXB0ZWQgZnJvbSBCZW4gQWxtYW4ncyBqUXVlcnkgcG9zdE1lc3NhZ2UgY29kZSBmb3VuZCBhdDpcbiAqIGh0dHA6Ly9iZW5hbG1hbi5jb20vcHJvamVjdHMvanF1ZXJ5LXBvc3RtZXNzYWdlLXBsdWdpbi9cbiAqXG4gKiBvdGhlciBpbnNwaXJhdGlvbiB3YXMgdGFrZW4gZnJvbSBMdWtlIFNoZXBhcmQncyBjb2RlIGZvciBGYWNlYm9vayBDb25uZWN0OlxuICogaHR0cDovL2dpdGh1Yi5jb20vZmFjZWJvb2svY29ubmVjdC1qcy9ibG9iL21hc3Rlci9zcmMvY29yZS94ZC5qc1xuICpcbiAqIHRoZSBnb2FsIG9mIHRoaXMgcHJvamVjdCB3YXMgdG8gbWFrZSBhIGJhY2t3YXJkcyBjb21wYXRhYmxlIHZlcnNpb24gb2YgcG9zdE1lc3NhZ2VcbiAqIHdpdGhvdXQgaGF2aW5nIGFueSBkZXBlbmRlbmN5IG9uIGpRdWVyeSBvciB0aGUgRkIgQ29ubmVjdCBsaWJyYXJpZXNcbiAqXG4gKiBteSBnb2FsIHdhcyB0byBrZWVwIHRoaXMgYXMgdGVyc2UgYXMgcG9zc2libGUgc2luY2UgbXkgb3duIHB1cnBvc2Ugd2FzIHRvIHVzZSB0aGlzXG4gKiBhcyBwYXJ0IG9mIGEgZGlzdHJpYnV0ZWQgd2lkZ2V0IHdoZXJlIGZpbGVzaXplIGNvdWxkIGJlIHNlbnNhdGl2ZS5cbiAqXG4gKi9cblxuLy8gRXZlcnl0aGluZyBpcyB3cmFwcGVkIGluIHRoZSBYRCBmdW5jdGlvbiB0byByZWR1Y2UgbmFtZXNwYWNlIGNvbGxpc2lvbnNcbiggKCkgPT4ge1xuICAgIHZhciBYRCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBpbnRlcnZhbF9pZCxcbiAgICAgICAgICAgIGxhc3RfaGFzaCxcbiAgICAgICAgICAgIGNhY2hlX2J1c3QgPSAxLFxuICAgICAgICAgICAgYXR0YWNoZWRfY2FsbGJhY2s9ZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIF93aW5kb3cgPSB0aGlzIHx8IHdpbmRvdztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKCBtZXNzYWdlLCB0YXJnZXRfdXJsLCB0YXJnZXQgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoICF0YXJnZXRfdXJsICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHBhcmVudDsgLy8gRGVmYXVsdCB0byBwYXJlbnRcblxuICAgICAgICAgICAgICAgIGlmICggX3dpbmRvdy5wb3N0TWVzc2FnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJyb3dzZXIgc3VwcG9ydHMgd2luZG93LnBvc3RNZXNzYWdlLCBzbyBjYWxsIGl0IHdpdGggYSB0YXJnZXRPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFwcHJvcHJpYXRlbHksIGJhc2VkIG9uIHRoZSB0YXJnZXRfdXJsIHBhcmFtZXRlci5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBvc3RNZXNzYWdlKCBtZXNzYWdlLCB0YXJnZXRfdXJsLnJlcGxhY2UoIC8oW146XSs6XFwvXFwvW15cXC9dKykuKi8sICckMScgKSApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdGFyZ2V0X3VybCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3aW5kb3cucG9zdE1lc3NhZ2UsIHNvIHNldCB0aGUgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gT2YgdGhlIHRhcmdldCB0byB0YXJnZXRfdXJsI21lc3NhZ2UuIEEgYml0IHVnbHksIGJ1dCBpdCB3b3JrcyEgQSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAvLyBCdXN0IHBhcmFtZXRlciBpcyBhZGRlZCB0byBlbnN1cmUgdGhhdCByZXBlYXQgbWVzc2FnZXMgdHJpZ2dlciB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5sb2NhdGlvbiA9IHRhcmdldF91cmwucmVwbGFjZSggLyMuKiQvLCAnJyApICsgJyMnICsgKCArbmV3IERhdGUoKSApICsgKCBjYWNoZV9idXN0KysgKSArICcmJyArIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVjZWl2ZU1lc3NhZ2U6IGZ1bmN0aW9uKCBjYWxsYmFjaywgc291cmNlX29yaWdpbiApIHtcblxuICAgICAgICAgICAgICAgIC8vIEJyb3dzZXIgc3VwcG9ydHMgd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgICAgICAgICAgaWYgKCBfd2luZG93LnBvc3RNZXNzYWdlICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCaW5kIHRoZSBjYWxsYmFjayB0byB0aGUgYWN0dWFsIGV2ZW50IGFzc29jaWF0ZWQgd2l0aCB3aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaGVkX2NhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHR5cGVvZiBzb3VyY2Vfb3JpZ2luID09PSAnc3RyaW5nJyAmJiBlLm9yaWdpbiAhPT0gc291cmNlX29yaWdpbiApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIHNvdXJjZV9vcmlnaW4gKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyAmJiBzb3VyY2Vfb3JpZ2luKCBlLm9yaWdpbiApID09PSAhMSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCBlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggX3dpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3dpbmRvd1sgY2FsbGJhY2sgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgXSggJ21lc3NhZ2UnLCBhdHRhY2hlZF9jYWxsYmFjaywgITEgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF93aW5kb3dbIGNhbGxiYWNrID8gJ2F0dGFjaEV2ZW50JyA6ICdkZXRhY2hFdmVudCcgXSggJ29ubWVzc2FnZScsIGF0dGFjaGVkX2NhbGxiYWNrICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHBvbGxpbmcgbG9vcCBpcyBzdGFydGVkICYgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBsb2NhdGlvbi5oYXNoIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxfaWQgJiYgY2xlYXJJbnRlcnZhbCggaW50ZXJ2YWxfaWQgKTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxfaWQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbF9pZCA9IHNldEludGVydmFsKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IGRvY3VtZW50LmxvY2F0aW9uLmhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlID0gL14jP1xcZCsmLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc2ggIT09IGxhc3RfaGFzaCAmJiByZS50ZXN0KCBoYXNoICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfaGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCB7ZGF0YTogaGFzaC5yZXBsYWNlKCByZSwgJycgKX0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICAvLyBFeHBvcnQgY29tbW9uIGpzIC8gbm9kZSBlbHNlIGJyb3dzZXJcbiAgICBpZiAoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gWEQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LlhEID0gWEQ7XG4gICAgfVxufSApKCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpEQTtBQTJEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/postmessage.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/uiLocker.js":
/*!***************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/uiLocker.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n     * Dialog / ui locker\n     * copied from v2.4 cart_orderForm.js\n     */\n(function ($) {\n  $.fn.moonrayUILockerV2 = function () {\n    let defaultTemplate = '<div class=\"moonrayUILockerMessage moonrayUILockerMessage-closebutton-{closeButton} theme--{theme}\">' + '<i class=\"close-button material-icons left\">close</i>' + '<div class=\"title h2 dark-color-text\">{title}</div>' + '<div class=\"message label dark-color-text\">{message}</div>' + '<div class=\"progress light-color-background\"><div class=\"indeterminate primary-color-background\"></div></div>' + '</div>';\n    /**\n     * EligibleToPop\n     *\n     * Added a setTimeout() to the spawning of the processing dialog so it had sometime to request the fonts\n     * when the element was appended to the document. This also fades the dialog in when it's showed.\n     *\n     * This ended up causing a funny bug in Firefox though because Firefox resubmits post data on history.go( -1 ).\n     *\n     *      To recreate with Firefox:\n     *          1. Fillout the form.\n     *          2. Get redirected to the thank you page.\n     *          3. Click the back button on the browser.\n     *\n     * Firefox tries to resubmit the form's post data when the page returns to the previously filled out form.\n     *      AND MOZILLA THOUGHT THAT THIS WAS A GOOD IDEA!\n     *      TSK TSK.\n     *\n     * Since this plugin now opens the processing dialog in a setTimeout(), it was possible for the dialog to\n     * defer it's open long enough that the secondary call to close it would happen before it even opened.\n     *\n     * Enter \"eligibleToPop\":\n     * Stop the processing dialog from opening if we've attempted to close it before the setTimeout() executes.\n     *\n     */\n\n    var eligibleToPop = false;\n\n    var closeUILocker = function () {\n      var $this = $(document.body);\n      $this.children('.moonrayUILockerOverlay').remove();\n      $this.children('.moonrayUILockerMessage').remove();\n    };\n    /**\n     * Handles the moonray.uiLockerV2 event that gets triggered across our forms.\n     * This is the \"processing\" dialog that appears when the user fills out a form.\n     *\n     * @param e {Event} The event object.\n     * @param options {object} Model that drives the UI locker. It should have a format like:\n     * {\n     *     message: The single message to display in the dialog\n     *     title: The title to display in the dialog.\n     *     theme: The theme/format for the dialog. Right now we have two types: processing and multiple\n     *          processing: the most basic format for the dialog. It just displays the message.\n     *          multiple: it displays multiple messages based on the interval property.\n     *     template: The DOM markup to use to generate the contents of the dialog.\n     *          The markup uses {PROPERTY-NAME} string replacement to inject data into the markup.\n     *          Where PROPERTY-NAME matches one of the property names of this object.\n     *          So {title} is replaced with the value of the title property of this object.\n     * }\n     */\n\n\n    var uiLockerHandler = function (e, options) {\n      /*\n       * Super small templating engine\n       * http://mir.aculo.us/2011/03/09/little-helpers-a-tweet-sized-javascript-templating-engine/\n       *\n       * used to display the status messages when contacting the server\n       */\n      function t(s, d) {\n        for (var p in d) {\n          s = s.replace(new RegExp('{' + p + '}', 'g'), d[p]);\n        }\n\n        return s;\n      }\n\n      var defaults = {\n        // If no message, then hide\n        message: '',\n        title: '',\n        // Processing, error, warning\n        theme: 'processing',\n        // Show the close button\n        closeButton: false\n      };\n      var settings = $.extend({}, defaults, options),\n          $this = $(this);\n      /*\n       *  Title based on theme\n       */\n\n      if (options) {\n        $this.append('<div class=\"ui-widget-overlay moonrayUILockerOverlay\"></div>'); // Process our template and inject our data properties\n\n        const templateMarkup = options.template || defaultTemplate;\n        const $content = $(t(templateMarkup, settings)).appendTo($this);\n        $content.css({\n          opacity: 0,\n          transition: 'opacity .25s ease-in-out'\n        });\n        eligibleToPop = true;\n        setTimeout(function () {\n          if (!eligibleToPop) {\n            return;\n          } // If the window location and window.parent location are different, then we're in an iframe\n\n\n          var inIframe = window.parent && window.parent.location !== window.location;\n\n          if (!inIframe) {\n            $content.css('opacity', 1);\n          } else {\n            var bodyHeight = $this.outerHeight(),\n                windowOuterHeight = window.outerHeight; // If the body of the iframe is smaller than the window, then the iframe will not have a scroll bar.\n            // So simply center the ui locker on the body\n\n            if (bodyHeight < windowOuterHeight) {\n              $content.position({\n                of: $this,\n                at: 'center center',\n                my: 'center center'\n              }).css('opacity', 1); // If the body of the iframe is larger than the window, then the iframe could be scrolled\n              // So run special logic to center ui locker in the currently scrolled position of the iframe\n            } else {\n              // Take into account how far down they're scrolled when positioning the processing dialog\n              var viewportVerticalCenter = windowOuterHeight / 2;\n              var dialogHeight = $content.outerHeight(); // Take the entire height of the body and subtract the viewport height. This will give you\n              // Where the viewport starts\n\n              var viewportTop = bodyHeight - windowOuterHeight;\n              var dialogTop = viewportTop + (viewportVerticalCenter - dialogHeight / 2); // Now calculate the horizontal positioning of the processing dialog\n\n              var windowHorizontalCenter = $this.outerWidth() / 2;\n\n              var _templateWidth = $content.outerWidth();\n\n              var dialogCenter = windowHorizontalCenter - _templateWidth / 2; // Manually position it\n\n              $content.css({\n                left: dialogCenter,\n                top: dialogTop,\n                opacity: 1\n              });\n            }\n          }\n\n          eligibleToPop = false; //\n          // Adding some time here to allow the thing to render with the google fonts and what not.\n          //\n        }, 25);\n      } else {\n        closeUILocker();\n        eligibleToPop = false;\n      }\n    };\n\n    return this.bind('moonray.uiLockerV2', uiLockerHandler.bind(this)).delegate('.moonrayUILockerMessage-closebutton-true .close-button', 'click', function () {\n      // Close up shop\n      $(document.body).trigger('moonray.uiLockerV2');\n    });\n  };\n})(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My91aUxvY2tlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3d3dy9qcy0zLjIuMi9vbnRyYXBvcnQvb3B0X2Fzc2V0cy9vcHRfYm9pbGVycGxhdGVzL3YzL3VpTG9ja2VyLmpzP2FhYmUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICAgKiBEaWFsb2cgLyB1aSBsb2NrZXJcbiAgICAgKiBjb3BpZWQgZnJvbSB2Mi40IGNhcnRfb3JkZXJGb3JtLmpzXG4gICAgICovXG4oIGZ1bmN0aW9uKCAkICkge1xuICAgICQuZm4ubW9vbnJheVVJTG9ja2VyVjI9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGxldCBkZWZhdWx0VGVtcGxhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJtb29ucmF5VUlMb2NrZXJNZXNzYWdlIG1vb25yYXlVSUxvY2tlck1lc3NhZ2UtY2xvc2VidXR0b24te2Nsb3NlQnV0dG9ufSB0aGVtZS0te3RoZW1lfVwiPicrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxpIGNsYXNzPVwiY2xvc2UtYnV0dG9uIG1hdGVyaWFsLWljb25zIGxlZnRcIj5jbG9zZTwvaT4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidGl0bGUgaDIgZGFyay1jb2xvci10ZXh0XCI+e3RpdGxlfTwvZGl2PicrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJtZXNzYWdlIGxhYmVsIGRhcmstY29sb3ItdGV4dFwiPnttZXNzYWdlfTwvZGl2PicrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJwcm9ncmVzcyBsaWdodC1jb2xvci1iYWNrZ3JvdW5kXCI+PGRpdiBjbGFzcz1cImluZGV0ZXJtaW5hdGUgcHJpbWFyeS1jb2xvci1iYWNrZ3JvdW5kXCI+PC9kaXY+PC9kaXY+JytcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVsaWdpYmxlVG9Qb3BcbiAgICAgICAgICpcbiAgICAgICAgICogQWRkZWQgYSBzZXRUaW1lb3V0KCkgdG8gdGhlIHNwYXduaW5nIG9mIHRoZSBwcm9jZXNzaW5nIGRpYWxvZyBzbyBpdCBoYWQgc29tZXRpbWUgdG8gcmVxdWVzdCB0aGUgZm9udHNcbiAgICAgICAgICogd2hlbiB0aGUgZWxlbWVudCB3YXMgYXBwZW5kZWQgdG8gdGhlIGRvY3VtZW50LiBUaGlzIGFsc28gZmFkZXMgdGhlIGRpYWxvZyBpbiB3aGVuIGl0J3Mgc2hvd2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGVuZGVkIHVwIGNhdXNpbmcgYSBmdW5ueSBidWcgaW4gRmlyZWZveCB0aG91Z2ggYmVjYXVzZSBGaXJlZm94IHJlc3VibWl0cyBwb3N0IGRhdGEgb24gaGlzdG9yeS5nbyggLTEgKS5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBUbyByZWNyZWF0ZSB3aXRoIEZpcmVmb3g6XG4gICAgICAgICAqICAgICAgICAgIDEuIEZpbGxvdXQgdGhlIGZvcm0uXG4gICAgICAgICAqICAgICAgICAgIDIuIEdldCByZWRpcmVjdGVkIHRvIHRoZSB0aGFuayB5b3UgcGFnZS5cbiAgICAgICAgICogICAgICAgICAgMy4gQ2xpY2sgdGhlIGJhY2sgYnV0dG9uIG9uIHRoZSBicm93c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGaXJlZm94IHRyaWVzIHRvIHJlc3VibWl0IHRoZSBmb3JtJ3MgcG9zdCBkYXRhIHdoZW4gdGhlIHBhZ2UgcmV0dXJucyB0byB0aGUgcHJldmlvdXNseSBmaWxsZWQgb3V0IGZvcm0uXG4gICAgICAgICAqICAgICAgQU5EIE1PWklMTEEgVEhPVUdIVCBUSEFUIFRISVMgV0FTIEEgR09PRCBJREVBIVxuICAgICAgICAgKiAgICAgIFRTSyBUU0suXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpbmNlIHRoaXMgcGx1Z2luIG5vdyBvcGVucyB0aGUgcHJvY2Vzc2luZyBkaWFsb2cgaW4gYSBzZXRUaW1lb3V0KCksIGl0IHdhcyBwb3NzaWJsZSBmb3IgdGhlIGRpYWxvZyB0b1xuICAgICAgICAgKiBkZWZlciBpdCdzIG9wZW4gbG9uZyBlbm91Z2ggdGhhdCB0aGUgc2Vjb25kYXJ5IGNhbGwgdG8gY2xvc2UgaXQgd291bGQgaGFwcGVuIGJlZm9yZSBpdCBldmVuIG9wZW5lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogRW50ZXIgXCJlbGlnaWJsZVRvUG9wXCI6XG4gICAgICAgICAqIFN0b3AgdGhlIHByb2Nlc3NpbmcgZGlhbG9nIGZyb20gb3BlbmluZyBpZiB3ZSd2ZSBhdHRlbXB0ZWQgdG8gY2xvc2UgaXQgYmVmb3JlIHRoZSBzZXRUaW1lb3V0KCkgZXhlY3V0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZWxpZ2libGVUb1BvcCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBjbG9zZVVJTG9ja2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKCBkb2N1bWVudC5ib2R5ICk7XG4gICAgICAgICAgICAkdGhpcy5jaGlsZHJlbiggJy5tb29ucmF5VUlMb2NrZXJPdmVybGF5JyApLnJlbW92ZSgpO1xuICAgICAgICAgICAgJHRoaXMuY2hpbGRyZW4oICcubW9vbnJheVVJTG9ja2VyTWVzc2FnZScgKS5yZW1vdmUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyB0aGUgbW9vbnJheS51aUxvY2tlclYyIGV2ZW50IHRoYXQgZ2V0cyB0cmlnZ2VyZWQgYWNyb3NzIG91ciBmb3Jtcy5cbiAgICAgICAgICogVGhpcyBpcyB0aGUgXCJwcm9jZXNzaW5nXCIgZGlhbG9nIHRoYXQgYXBwZWFycyB3aGVuIHRoZSB1c2VyIGZpbGxzIG91dCBhIGZvcm0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlIHtFdmVudH0gVGhlIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH0gTW9kZWwgdGhhdCBkcml2ZXMgdGhlIFVJIGxvY2tlci4gSXQgc2hvdWxkIGhhdmUgYSBmb3JtYXQgbGlrZTpcbiAgICAgICAgICoge1xuICAgICAgICAgKiAgICAgbWVzc2FnZTogVGhlIHNpbmdsZSBtZXNzYWdlIHRvIGRpc3BsYXkgaW4gdGhlIGRpYWxvZ1xuICAgICAgICAgKiAgICAgdGl0bGU6IFRoZSB0aXRsZSB0byBkaXNwbGF5IGluIHRoZSBkaWFsb2cuXG4gICAgICAgICAqICAgICB0aGVtZTogVGhlIHRoZW1lL2Zvcm1hdCBmb3IgdGhlIGRpYWxvZy4gUmlnaHQgbm93IHdlIGhhdmUgdHdvIHR5cGVzOiBwcm9jZXNzaW5nIGFuZCBtdWx0aXBsZVxuICAgICAgICAgKiAgICAgICAgICBwcm9jZXNzaW5nOiB0aGUgbW9zdCBiYXNpYyBmb3JtYXQgZm9yIHRoZSBkaWFsb2cuIEl0IGp1c3QgZGlzcGxheXMgdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqICAgICAgICAgIG11bHRpcGxlOiBpdCBkaXNwbGF5cyBtdWx0aXBsZSBtZXNzYWdlcyBiYXNlZCBvbiB0aGUgaW50ZXJ2YWwgcHJvcGVydHkuXG4gICAgICAgICAqICAgICB0ZW1wbGF0ZTogVGhlIERPTSBtYXJrdXAgdG8gdXNlIHRvIGdlbmVyYXRlIHRoZSBjb250ZW50cyBvZiB0aGUgZGlhbG9nLlxuICAgICAgICAgKiAgICAgICAgICBUaGUgbWFya3VwIHVzZXMge1BST1BFUlRZLU5BTUV9IHN0cmluZyByZXBsYWNlbWVudCB0byBpbmplY3QgZGF0YSBpbnRvIHRoZSBtYXJrdXAuXG4gICAgICAgICAqICAgICAgICAgIFdoZXJlIFBST1BFUlRZLU5BTUUgbWF0Y2hlcyBvbmUgb2YgdGhlIHByb3BlcnR5IG5hbWVzIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKiAgICAgICAgICBTbyB7dGl0bGV9IGlzIHJlcGxhY2VkIHdpdGggdGhlIHZhbHVlIG9mIHRoZSB0aXRsZSBwcm9wZXJ0eSBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICogfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHVpTG9ja2VySGFuZGxlciA9IGZ1bmN0aW9uKCBlLCBvcHRpb25zICkge1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogU3VwZXIgc21hbGwgdGVtcGxhdGluZyBlbmdpbmVcbiAgICAgICAgICAgICAqIGh0dHA6Ly9taXIuYWN1bG8udXMvMjAxMS8wMy8wOS9saXR0bGUtaGVscGVycy1hLXR3ZWV0LXNpemVkLWphdmFzY3JpcHQtdGVtcGxhdGluZy1lbmdpbmUvXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogdXNlZCB0byBkaXNwbGF5IHRoZSBzdGF0dXMgbWVzc2FnZXMgd2hlbiBjb250YWN0aW5nIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gdCggcywgZCApIHtcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgcCBpbiBkICkge1xuICAgICAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCBuZXcgUmVnRXhwKCAneycgKyBwICsgJ30nLCAnZycgKSwgZFsgcCBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gbWVzc2FnZSwgdGhlbiBoaWRlXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJycsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3NpbmcsIGVycm9yLCB3YXJuaW5nXG4gICAgICAgICAgICAgICAgdGhlbWU6ICdwcm9jZXNzaW5nJyxcbiAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSBjbG9zZSBidXR0b25cbiAgICAgICAgICAgICAgICBjbG9zZUJ1dHRvbjogZmFsc2VcblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMgKSxcbiAgICAgICAgICAgICAgICAkdGhpcyA9ICQoIHRoaXMgKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqICBUaXRsZSBiYXNlZCBvbiB0aGVtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXBwZW5kKCAnPGRpdiBjbGFzcz1cInVpLXdpZGdldC1vdmVybGF5IG1vb25yYXlVSUxvY2tlck92ZXJsYXlcIj48L2Rpdj4nICk7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBvdXIgdGVtcGxhdGUgYW5kIGluamVjdCBvdXIgZGF0YSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVNYXJrdXAgPSBvcHRpb25zLnRlbXBsYXRlIHx8IGRlZmF1bHRUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCAkY29udGVudCA9ICQoIHQoIHRlbXBsYXRlTWFya3VwLCBzZXR0aW5ncyApICkuYXBwZW5kVG8oICR0aGlzICk7XG5cbiAgICAgICAgICAgICAgICAkY29udGVudC5jc3MoIHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ29wYWNpdHkgLjI1cyBlYXNlLWluLW91dCdcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICBlbGlnaWJsZVRvUG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhZWxpZ2libGVUb1BvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB3aW5kb3cgbG9jYXRpb24gYW5kIHdpbmRvdy5wYXJlbnQgbG9jYXRpb24gYXJlIGRpZmZlcmVudCwgdGhlbiB3ZSdyZSBpbiBhbiBpZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluSWZyYW1lID0gKCB3aW5kb3cucGFyZW50ICYmIHdpbmRvdy5wYXJlbnQubG9jYXRpb24gIT09IHdpbmRvdy5sb2NhdGlvbiApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFpbklmcmFtZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRjb250ZW50LmNzcyggJ29wYWNpdHknLCAxICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9keUhlaWdodCA9ICR0aGlzLm91dGVySGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93T3V0ZXJIZWlnaHQgPSB3aW5kb3cub3V0ZXJIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBib2R5IG9mIHRoZSBpZnJhbWUgaXMgc21hbGxlciB0aGFuIHRoZSB3aW5kb3csIHRoZW4gdGhlIGlmcmFtZSB3aWxsIG5vdCBoYXZlIGEgc2Nyb2xsIGJhci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvIHNpbXBseSBjZW50ZXIgdGhlIHVpIGxvY2tlciBvbiB0aGUgYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBib2R5SGVpZ2h0IDwgd2luZG93T3V0ZXJIZWlnaHQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnBvc2l0aW9uKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZjogJHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdDogJ2NlbnRlciBjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXk6ICdjZW50ZXIgY2VudGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyggJ29wYWNpdHknLCAxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBib2R5IG9mIHRoZSBpZnJhbWUgaXMgbGFyZ2VyIHRoYW4gdGhlIHdpbmRvdywgdGhlbiB0aGUgaWZyYW1lIGNvdWxkIGJlIHNjcm9sbGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbyBydW4gc3BlY2lhbCBsb2dpYyB0byBjZW50ZXIgdWkgbG9ja2VyIGluIHRoZSBjdXJyZW50bHkgc2Nyb2xsZWQgcG9zaXRpb24gb2YgdGhlIGlmcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IGhvdyBmYXIgZG93biB0aGV5J3JlIHNjcm9sbGVkIHdoZW4gcG9zaXRpb25pbmcgdGhlIHByb2Nlc3NpbmcgZGlhbG9nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0VmVydGljYWxDZW50ZXIgPSB3aW5kb3dPdXRlckhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWxvZ0hlaWdodCA9ICRjb250ZW50Lm91dGVySGVpZ2h0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBlbnRpcmUgaGVpZ2h0IG9mIHRoZSBib2R5IGFuZCBzdWJ0cmFjdCB0aGUgdmlld3BvcnQgaGVpZ2h0LiBUaGlzIHdpbGwgZ2l2ZSB5b3VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVyZSB0aGUgdmlld3BvcnQgc3RhcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0VG9wID0gYm9keUhlaWdodCAtIHdpbmRvd091dGVySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWFsb2dUb3AgPSB2aWV3cG9ydFRvcCArICggdmlld3BvcnRWZXJ0aWNhbENlbnRlciAtIGRpYWxvZ0hlaWdodCAvIDIgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdyBjYWxjdWxhdGUgdGhlIGhvcml6b250YWwgcG9zaXRpb25pbmcgb2YgdGhlIHByb2Nlc3NpbmcgZGlhbG9nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd0hvcml6b250YWxDZW50ZXIgPSAkdGhpcy5vdXRlcldpZHRoKCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGVtcGxhdGVXaWR0aCA9ICRjb250ZW50Lm91dGVyV2lkdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlhbG9nQ2VudGVyID0gd2luZG93SG9yaXpvbnRhbENlbnRlciAtIF90ZW1wbGF0ZVdpZHRoIC8gMjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IHBvc2l0aW9uIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNvbnRlbnQuY3NzKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGRpYWxvZ0NlbnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBkaWFsb2dUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWxpZ2libGVUb1BvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGRpbmcgc29tZSB0aW1lIGhlcmUgdG8gYWxsb3cgdGhlIHRoaW5nIHRvIHJlbmRlciB3aXRoIHRoZSBnb29nbGUgZm9udHMgYW5kIHdoYXQgbm90LlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIH0sIDI1ICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvc2VVSUxvY2tlcigpO1xuICAgICAgICAgICAgICAgIGVsaWdpYmxlVG9Qb3AgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5iaW5kKCAnbW9vbnJheS51aUxvY2tlclYyJywgdWlMb2NrZXJIYW5kbGVyLmJpbmQoIHRoaXMgKSApXG4gICAgICAgICAgICAuZGVsZWdhdGUoICcubW9vbnJheVVJTG9ja2VyTWVzc2FnZS1jbG9zZWJ1dHRvbi10cnVlIC5jbG9zZS1idXR0b24nLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSB1cCBzaG9wXG4gICAgICAgICAgICAgICAgJCggZG9jdW1lbnQuYm9keSApLnRyaWdnZXIoICdtb29ucmF5LnVpTG9ja2VyVjInICk7XG4gICAgICAgICAgICB9ICk7XG5cblxuICAgIH07XG59ICkoIGpRdWVyeSApO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/uiLocker.js\n");

/***/ }),

/***/ "./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/validator.js":
/*!****************************************************************************!*\
  !*** ./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/validator.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @license\n * jQuery Tools Validator @VERSION - HTML5 is here. Now use it.\n *\n * NO COPYRIGHTS OR LICENSES. DO WHAT YOU LIKE.\n *\n * http://flowplayer.org/tools/form/validator/\n *\n * Since: Mar 2010\n * Date: @DATE\n *\n * @brief Ontrapages V3 form validation 4/10/2018. This file also exists on in legacey ontraforms, we are duping it\n *        here to provide some insulation and decouple ontrapages forms from legacey form editor code.\n */\n\n(function ($) {\n  $.tools = $.tools || {\n    version: '@VERSION'\n  }; // Globals\n\n  var typeRe = /\\[type=([a-z]+)\\]/,\n      numRe = /^-?[0-9]*(\\.[0-9]+)?$/,\n      dateInput = $.tools.dateinput,\n      // http://net.tutsplus.com/tutorials/other/8-regular-expressions-you-should-know/\n  // Domain name TLDs can have a maximum of 63 characters\n  emailRe = /^([a-z0-9_\\.\\-\\+]+)@([\\da-z\\.\\-]+)\\.([a-z\\.]{2,63})$/i,\n      emailBlackList = /(\\.@)|(@\\.)/i,\n      // Dont allow periods just before @ nor right after.\n  urlRe = /^(https?:\\/\\/)?[\\da-z\\.\\-]+\\.[a-z\\.]{2,6}[#&+_\\?\\/\\w \\.\\-=]*$/i,\n      v,\n      localizedMessages;\n\n  if (window.op && op.localizedValidationMessages) {\n    localizedMessages = op.localizedValidationMessages;\n  } else {\n    localizedMessages = {\n      creditCardNumber: 'Please enter a valid credit card number.',\n      email: 'Please enter a valid email address.',\n      confirmEmail: 'Your email addresses do not match.',\n      url: 'Please enter a valid URL.',\n      number: 'Please enter a numeric value.',\n      max: 'Please enter a value no larger than',\n      min: 'Please enter a value of at least',\n      required: 'Please complete this mandatory field.',\n      radio: 'Please select an option.',\n      listMinPrefix: 'Minimum selection',\n      listMinSuffix: 'required.',\n      listMaxPrefix: 'Maximum selection',\n      listMaxSuffix: 'exceeded.',\n      expirationDate: 'Please select a future date.'\n    };\n  }\n\n  v = $.tools.validator = {\n    conf: {\n      grouped: false,\n      // Show all error messages at once inside the container\n      effect: 'default',\n      // Show/hide effect for error message. only 'default' is built-in\n      errorClass: 'invalid',\n      // Input field class name in case of validation error\n      // When to check for validity?\n      inputEvent: null,\n      // Change, blur, keyup, null\n      errorInputEvent: 'keyup',\n      // Change, blur, keyup, null\n      formEvent: 'submit',\n      // Submit, null\n      lang: 'en',\n      // Default language for error messages\n      message: '<div/>',\n      messageAttr: 'data-message',\n      // Name of the attribute for overridden error message\n      messageClass: 'error',\n      // Error message element's class name\n      offset: [0, 0],\n      position: 'center right',\n      singleError: false,\n      // Validate all inputs at once\n      speed: 'normal' // Message's fade-in speed\n\n    },\n\n    /* The Error Messages */\n    messages: {\n      '*': {\n        en: 'Please correct this value.'\n      }\n    },\n    localize: function (lang, messages) {\n      $.each(messages, function (key, msg) {\n        v.messages[key] = v.messages[key] || {};\n        v.messages[key][lang] = msg;\n      });\n    },\n    localizeFn: function (key, messages) {\n      v.messages[key] = v.messages[key] || {};\n      $.extend(v.messages[key], messages);\n    },\n\n    /**\n     * Adds a new validator\n     */\n    fn: function (matcher, msg, fn) {\n      // No message supplied\n      if ($.isFunction(msg)) {\n        fn = msg; // Message(s) on second argument\n      } else {\n        if (typeof msg == 'string') {\n          msg = {\n            en: msg\n          };\n        }\n\n        this.messages[matcher.key || matcher] = msg;\n      } // Check for \"[type=xxx]\" (not supported by jQuery)\n\n\n      var test = typeRe.exec(matcher);\n\n      if (test) {\n        matcher = isType(test[1]);\n      } // Add validator to the arsenal\n\n\n      fns.push([matcher, fn]);\n    },\n\n    /* Add new show/hide effect */\n    addEffect: function (name, showFn, closeFn) {\n      effects[name] = [showFn, closeFn];\n    }\n  };\n  /* Calculate error message position relative to the input */\n\n  function getPosition(trigger, el, conf) {\n    // Get the first element in the selector set\n    el = $(el).first() || el; // Get origin top/left position\n\n    var top = trigger.offset().top,\n        left = trigger.offset().left,\n        pos = conf.position.split(/,?\\s+/),\n        y = pos[0],\n        x = pos[1];\n    top -= el.outerHeight() - conf.offset[0];\n    left += trigger.outerWidth() + conf.offset[1]; // IPad position fix\n\n    if (/iPad/i.test(navigator.userAgent)) {\n      top -= $(window).scrollTop();\n    } // Adjust Y\n\n\n    var height = el.outerHeight() + trigger.outerHeight();\n\n    if (y == 'center') {\n      top += height / 2;\n    }\n\n    if (y == 'bottom') {\n      top += height;\n    } // Adjust X\n\n\n    var width = trigger.outerWidth();\n\n    if (x == 'center') {\n      left -= (width + el.outerWidth()) / 2;\n    }\n\n    if (x == 'left') {\n      left -= width;\n    }\n\n    return {\n      top: top,\n      left: left\n    };\n  } // $.is(\"[type=xxx]\") or $.filter(\"[type=xxx]\") not working in jQuery 1.3.2 or 1.4.2\n\n\n  function isType(type) {\n    function fn() {\n      return this.getAttribute('type') == type;\n    }\n\n    fn.key = '[type=\"' + type + '\"]';\n    return fn;\n  }\n\n  var fns = [],\n      effects = {\n    'default': [// Show errors function\n    function (errs) {\n      var conf = this.getConf(); // Loop errors\n\n      $.each(errs, function (i, err) {\n        // Add error class\n        var input = err.input;\n        input.addClass(conf.errorClass); // Get handle to the error container\n\n        var msg = input.data('msg.el'); // Create it if not present\n\n        if (!msg) {\n          msg = $(conf.message).addClass(conf.messageClass).appendTo(document.body);\n          input.data('msg.el', msg);\n        } // Clear the container\n\n\n        msg.css({\n          visibility: 'hidden'\n        }).find('p').remove(); // Populate messages\n\n        $.each(err.messages, function (i, m) {\n          $('<p/>').html(m).appendTo(msg);\n        }); // Make sure the width is not full body width so it can be positioned correctly\n\n        if (msg.outerWidth() == msg.parent().width()) {\n          msg.add(msg.find('p')).css({\n            display: 'inline'\n          });\n        } // Insert into correct position (relative to the field)\n\n\n        var pos = getPosition(input, msg, conf);\n        msg.css({\n          visibility: 'visible',\n          position: 'absolute',\n          top: pos.top,\n          left: pos.left\n        }).fadeIn(conf.speed);\n      }); // Hide errors function\n    }, function (inputs) {\n      var conf = this.getConf();\n      inputs.removeClass(conf.errorClass).each(function () {\n        var msg = $(this).data('msg.el');\n\n        if (msg) {\n          msg.css({\n            visibility: 'hidden'\n          });\n        }\n      });\n    }]\n  };\n  /* Special selectors */\n\n  $.each('email,url,number'.split(','), function (i, key) {\n    $.expr[':'][key] = function (el) {\n      return el.getAttribute('type') === key;\n    };\n  });\n  /*\n      Oninvalid() jQuery plugin.\n      Usage: $(\"input:eq(2)\").oninvalid(function() { ... });\n  */\n\n  $.fn.oninvalid = function (fn) {\n    return this[fn ? 'on' : 'trigger']('OI', fn);\n  };\n  /** ***** Built-in HTML5 standard validators *********/\n\n  /*\n   * Validate credit card number. Just use a LUHN check.\n   */\n\n\n  v.fn('[name=\"payment_number\"]', localizedMessages.creditCardNumber, function (el, cardNumber) {\n    // Spaces and dashes may be valid characters, but must be stripped to calculate the checksum.\n    var valid = false,\n        cardNumber = cardNumber.replace(/ +/g, '').replace(/-+/g, '');\n    var numDigits = cardNumber.length;\n\n    if (numDigits >= 14 && numDigits <= 16 && parseInt(cardNumber) > 0) {\n      var sum = 0,\n          i = numDigits - 1,\n          pos = 1,\n          digit,\n          luhn = new String();\n\n      do {\n        digit = parseInt(cardNumber.charAt(i));\n        luhn += pos++ % 2 == 0 ? digit * 2 : digit;\n      } while (--i >= 0);\n\n      for (i = 0; i < luhn.length; i++) {\n        sum += parseInt(luhn.charAt(i));\n      }\n\n      valid = sum % 10 == 0;\n    }\n\n    return !!valid;\n  });\n  v.fn(':email', 'Please enter a valid email address.', function (el, v) {\n    return !v || emailRe.test(v) && !emailBlackList.test(v) && v.split('@')[1].indexOf('..') === -1;\n  });\n  v.fn(':url', localizedMessages.url, function (el, v) {\n    return !v || urlRe.test(v);\n  });\n  v.fn(':number', localizedMessages.number, function (el, v) {\n    numRe.test(v);\n    return numRe.test(v);\n  });\n  v.fn('input[type=\\'text\\'][opt-numeric]', localizedMessages.number, function (el, v) {\n    return numRe.test(v);\n  });\n  v.fn('[max]', localizedMessages.max + ' $1.', function (el, v) {\n    // Skip empty values and dateinputs\n    if (v === '' || dateInput && el.is(':date') || el.hasClass('opt-date-time-field')) {\n      return true;\n    }\n\n    var max = el.attr('max');\n    return parseFloat(v) <= parseFloat(max) ? true : [max];\n  });\n  v.fn('[min]', localizedMessages.min + ' $1.', function (el, v) {\n    // Skip empty values and dateinputs\n    if (v === '' || dateInput && el.is(':date') || el.hasClass('opt-date-time-field')) {\n      return true;\n    }\n\n    var min = el.attr('min');\n    return parseFloat(v) >= parseFloat(min) ? true : [min];\n  });\n  v.fn('[required]', localizedMessages.required, function (el, v) {\n    // If field is hidden (such as shipping field when \"shipping different from billing\" checkbox is unchecked) return true\n    // Note though, dropdown fields have the \"required\" attr on the select element, which isn't always visible.\n    // Date Time fields also store dates in hidden fields\n    if (!el.is(':visible') && !el.is('select')) {\n      return true;\n    }\n\n    if (el.is(':checkbox')) {\n      return el.is(':checked');\n    } // Check selectable lists\n    else if (Array.isArray(v)) {\n        // User has selected at least 1 truthy option\n        return v.some(el => el);\n      }\n\n    return !!v.trim();\n  });\n  v.fn(':radio', localizedMessages.radio, function (el) {\n    var checked = false;\n    $('[name=\\'' + el.attr('name') + '\\']').each(function (i, el) {\n      if ($(el).is(':checked')) {\n        checked = true;\n      }\n    });\n    return checked ? true : false;\n  });\n  /*\n   * OPV3 Selectable list minimum selected validation\n   */\n\n  v.fn('[opt-list-min]', localizedMessages.listMinPrefix + ' (%s) ' + localizedMessages.listMinSuffix, function (el, v) {\n    var selected = v.length,\n        min = +el.attr('opt-list-min');\n    return {\n      validation: selected >= min,\n      messageData: min\n    };\n  });\n  /*\n   * OPV3 Selectable list maximum selected validation\n   */\n\n  v.fn('[opt-list-max]', localizedMessages.listMaxPrefix + ' (%s) ' + localizedMessages.listMaxSuffix, function (el, v) {\n    var selected = v.length,\n        max = +el.attr('opt-list-max');\n    return {\n      validation: selected <= max,\n      messageData: max\n    };\n  });\n  /*\n   * OPV3 Expiration date validation\n   */\n\n  v.fn('[opt-validate-expiration=\"true\"]', localizedMessages.expirationDate, function (el, v) {\n    var form = el[0].closest('form'),\n        expMonth = parseInt(form.querySelector('[name=\"payment_expire_month\"]').value || 0),\n        expYear = parseInt(form.querySelector('[name=\"payment_expire_year\"]').value || 0),\n        currentDate = new Date(),\n        currentMonth = currentDate.getMonth(),\n        currentYear = currentDate.getFullYear();\n    return expYear > currentYear || expYear === currentYear && expMonth > currentMonth;\n  });\n  /*\n  *\tValidation for confirm email field.  Will only validate IFF\n  *\t the confirm_email field is present AND an email field.\n  */\n\n  v.fn('[name=confirm_email]', localizedMessages.confirmEmail, function (el, value) {\n    var _form = $(el).parents('form').first();\n\n    if (_form.length > 0) {\n      var _emailField = _form.find('input[name=\\'email\\']').first();\n\n      if (_emailField.length > 0) {\n        var _emailVal = _emailField.val().toLowerCase();\n\n        return value.toLowerCase() == _emailVal;\n      }\n    }\n\n    return true;\n  });\n\n  function Validator(inputs, form, conf) {\n    // Private variables\n    var self = this,\n        fire = form.add(self); // Make sure there are input fields available\n\n    inputs = inputs.not(':button, :image, :reset, :submit'); // Prevent default Firefox validation\n\n    form.attr('novalidate', 'novalidate'); // Utility function\n\n    function pushMessage(to, matcher, returnValue, msgCustomization) {\n      // Only one message allowed\n      if (!conf.grouped && to.length) {\n        return;\n      } // The error message\n\n\n      var msg; // Substitutions are returned\n\n      if (returnValue === false || $.isArray(returnValue)) {\n        msg = v.messages[matcher.key || matcher] || v.messages['*'];\n        msg = msg[conf.lang] || v.messages['*'].en;\n        msg = msgCustomization ? msg.replace('%s', msgCustomization) : msg; // Substitution\n\n        var matches = msg.match(/\\$\\d/g);\n\n        if (matches && $.isArray(returnValue)) {\n          $.each(matches, function (i) {\n            msg = msg.replace(this, returnValue[i]);\n          });\n        } // Error message is returned directly\n\n      } else {\n        msg = returnValue[conf.lang] || returnValue;\n      }\n\n      to.push(msg);\n    } // API methods\n\n\n    $.extend(self, {\n      getConf: function () {\n        return conf;\n      },\n      getForm: function () {\n        return form;\n      },\n      getInputs: function () {\n        return inputs;\n      },\n      reflow: function () {\n        inputs.each(function () {\n          var input = $(this),\n              msg = input.data('msg.el');\n\n          if (msg) {\n            var pos = getPosition(input, msg, conf);\n            msg.css({\n              top: pos.top,\n              left: pos.left\n            });\n          }\n        });\n        return self;\n      },\n\n      /* @param e - for internal use only */\n      invalidate: function (errs, e) {\n        // Errors are given manually: { fieldName1: 'message1', fieldName2: 'message2' }\n        if (!e) {\n          var errors = [];\n          $.each(errs, function (key, val) {\n            var input = inputs.filter('[name=\\'' + key + '\\']');\n\n            if (input.length) {\n              // Trigger HTML5 ininvalid event\n              input.trigger('OI', [val]);\n              errors.push({\n                input: input,\n                messages: [val]\n              });\n            }\n          });\n          errs = errors;\n          e = $.Event();\n        } // OnFail callback\n\n\n        e.type = 'onFail';\n        fire.trigger(e, [errs]); // Call the effect\n\n        if (!e.isDefaultPrevented()) {\n          effects[conf.effect][0].call(self, errs, e);\n        }\n\n        return self;\n      },\n      reset: function (els) {\n        els = els || inputs;\n        els.removeClass(conf.errorClass).each(function () {\n          var msg = $(this).data('msg.el');\n\n          if (msg) {\n            msg.remove();\n            $(this).data('msg.el', null);\n          }\n        }).off(conf.errorInputEvent + '.v' || false);\n        return self;\n      },\n      destroy: function () {\n        form.off(conf.formEvent + '.V reset.V');\n        inputs.off(conf.inputEvent + '.V change.V');\n        return self.reset();\n      },\n\n      /* @returns boolean */\n      checkValidity: function (els, e, payPalBtnSubmit) {\n        els = els || inputs;\n        els = els.filter(function (el) {\n          return $(el).hasClass('opt-date-time-field') || $(el).not(':disabled');\n        }); // Filter duplicate elements by name\n\n        var names = {};\n        els = els.filter(function () {\n          var name = $(this).attr('name');\n\n          if (!names[name]) {\n            names[name] = true;\n            return $(this);\n          }\n        });\n\n        if (!els.length) {\n          return true;\n        }\n\n        e = e || $.Event(); // OnBeforeValidate\n\n        e.type = 'onBeforeValidate';\n        fire.trigger(e, [els]);\n\n        if (e.isDefaultPrevented()) {\n          return e.result;\n        } // Container for errors\n\n\n        var errs = []; // Loop trough the inputs\n\n        els.each(function () {\n          // Field and it's error message container\n          var msgs = [],\n              el = $(this).data('messages', msgs),\n              nameAttr = el.attr('name'),\n              event = dateInput && el.is(':date') ? 'onHide.v' : conf.errorInputEvent + '.v'; // If the input hold the value for the MaterializeCSS picker then listen for lib events\n\n          if (el.hasClass('opt-date-time-field')) {\n            event = 'dateTimePickerSave.v';\n          } // Cleanup previous validation event\n\n\n          el.off(event); // Loop all validator functions\n\n          $.each(fns, function () {\n            var fn = this,\n                match = fn[0]; // Match found\n\n            if (el.filter(match).length) {\n              // Execute a validator function\n              var msgCustomization = false,\n                  returnValue; // If field is a payment field and we submitted via paypal, always return true for validation\n\n              if (payPalBtnSubmit && nameAttr && nameAttr.includes('payment_')) {\n                returnValue = true;\n              } else if (event === 'dateTimePickerSave.v' && e && e.detail && e.detail.dateTimeString) {\n                // The `checkValidity` can be invoked multiple ways. If invoked by the event listener we'll\n                // have the data that's about to be saved by the lib and we'll check against that value\n                // because the actual DOM input hasn't been updated yet\n                returnValue = fn[1].call(self, el, e.detail.dateTimeString);\n              } else {\n                returnValue = fn[1].call(self, el, el.val());\n              } // If the validation function returned an object it is dynamically customizing the message\n\n\n              if (typeof returnValue === 'object' && !Array.isArray(returnValue)) {\n                msgCustomization = returnValue.messageData;\n                returnValue = returnValue.validation;\n              } // Validation failed. multiple substitutions can be returned with an array\n\n\n              if (returnValue !== true) {\n                // OnBeforeFail\n                e.type = 'onBeforeFail';\n                fire.trigger(e, [el, match]);\n\n                if (e.isDefaultPrevented()) {\n                  return false;\n                } // Overridden custom message\n\n\n                var msg = el.attr(conf.messageAttr);\n\n                if (msg) {\n                  msgs = [msg];\n                  return false;\n                } else {\n                  pushMessage(msgs, match, returnValue, msgCustomization);\n                }\n              }\n            }\n          });\n\n          if (msgs.length) {\n            errs.push({\n              input: el,\n              messages: msgs\n            }); // Trigger HTML5 ininvalid event\n\n            el.trigger('OI', [msgs]); // Begin validating upon error event type (such as keyup)\n\n            if (conf.errorInputEvent) {\n              el.on(event, function (e) {\n                self.checkValidity(el, e);\n              });\n            }\n          }\n\n          if (conf.singleError && errs.length) {\n            return false;\n          }\n        }); // Validation done. now check that we have a proper effect at hand\n\n        var eff = effects[conf.effect];\n\n        if (!eff) {\n          throw 'Validator: cannot find effect \"' + conf.effect + '\"';\n        } // Errors found\n\n\n        if (errs.length) {\n          self.invalidate(errs, e);\n          return false; // No errors\n        } else {\n          // Call the effect\n          eff[1].call(self, els, e); // OnSuccess callback\n\n          e.type = 'onSuccess';\n          fire.trigger(e, [els]);\n          els.off(conf.errorInputEvent + '.v');\n        }\n\n        return true;\n      }\n    }); // Callbacks\n\n    $.each('onBeforeValidate,onBeforeFail,onFail,onSuccess'.split(','), function (i, name) {\n      // Configuration\n      if ($.isFunction(conf[name])) {\n        $(self).on(name, conf[name]);\n      } // API methods\n\n\n      self[name] = function (fn) {\n        if (fn) {\n          $(self).on(name, fn);\n        }\n\n        return self;\n      };\n    }); // Form validation\n\n    if (conf.formEvent) {\n      form.on(conf.formEvent + '.V', function (e) {\n        if (!self.checkValidity(null, e)) {\n          return e.preventDefault();\n        } // Reset event type and target\n\n\n        e.target = form;\n        e.type = conf.formEvent;\n      });\n    } // Form reset\n\n\n    form.on('reset.V', function () {\n      self.reset();\n    }); // Disable browser's default validation mechanism\n\n    if (inputs[0] && inputs[0].validity) {\n      inputs.each(function () {\n        this.oninvalid = function () {\n          return false;\n        };\n      });\n    } // Web Forms 2.0 compatibility\n\n\n    if (form[0]) {\n      form[0].checkValidity = self.checkValidity;\n    } // Input validation\n\n\n    if (conf.inputEvent) {\n      inputs.on(conf.inputEvent + '.V', function (e) {\n        var delay = this.type === 'checkbox' ? 750 : 0,\n            el = this;\n        setTimeout(function (el) {\n          this.checkValidity($(el), e);\n          el = null;\n        }.bind(self, el), delay);\n      });\n    } // Checkboxes and selects are checked separately\n\n\n    inputs.filter(':checkbox, select').filter('[required]').on('change.V', function (e) {\n      var el = $(this);\n\n      if (this.checked || el.is('select') && $(this).val()) {\n        effects[conf.effect][1].call(self, el, e);\n      }\n    }); // DateTime component\n\n    const dateTimeInputs = inputs.filter('.opt-date-time-field');\n    dateTimeInputs.filter('.opt-date-time-field').on('dateTimePickerSave.V', function (e) {\n      var el = $(this);\n\n      if (e.detail && e.detail.dateTimeString) {\n        effects[conf.effect][1].call(self, el, e);\n      }\n    }); // If the clear input button is clicked run validition against this input in case\n\n    dateTimeInputs.each(function (_index, input) {\n      $(input).siblings().filter('.opt-date-time__icon--x').on('click', function (e) {\n        const el = $(input);\n\n        if (el) {\n          // We need to wait for an event loop cycle in order for the input to be updated\n          setTimeout(function () {\n            self.checkValidity(el, e);\n          }, 0);\n        }\n      });\n    }); // Get radio groups by name\n\n    inputs.filter(':radio[required]').on('change.V', function (e) {\n      var els = $('[name=\\'' + $(e.srcElement).attr('name') + '\\']');\n\n      if (els !== null && els.length !== 0) {\n        self.checkValidity(els, e);\n      }\n    }); // Reposition tooltips when window is resized\n    // Deboucing reflow call is good for perf & fixes issue with\n    // Mobile browsers that trigger window resize when the nav bar is visible, the position tends be off because of the\n    // Scroll inertia\n\n    var reflowTimer = null;\n    $(window).on('resize.V', function () {\n      clearTimeout(reflowTimer);\n      reflowTimer = setTimeout(function () {\n        self.reflow();\n      }, 300);\n    });\n  } // JQuery plugin initialization\n\n\n  $.fn.validator = function (conf) {\n    var instance = this.data('validator'); // Destroy existing instance\n\n    if (instance) {\n      instance.destroy();\n      this.removeData('validator');\n    } // Configuration\n\n\n    conf = $.extend(true, {}, v.conf, conf); // Selector is a form\n\n    if (this.is('form')) {\n      return this.each(function () {\n        var form = $(this);\n        instance = new Validator(form.find(':input'), form, conf);\n        form.data('validator', instance);\n      });\n    } else {\n      instance = new Validator(this, this.eq(0).closest('form'), conf);\n      return this.data('validator', instance);\n    }\n  };\n\n  var validationElems = [];\n  $.tools.validator.addEffect('opt-v3', function (errs) {\n    var conf = this.getConf(),\n        validationElems = [],\n        $input,\n        $inputParent,\n        $optEl,\n        inputType,\n        inputHeight,\n        inputPosition,\n        customErrorMsg,\n        messageText,\n        errorGUID,\n        $errorMessage,\n        $msgSpan,\n        errorHeight,\n        $errorIcon,\n        errorIconTop,\n        errorIconMargin; // Loop errors\n\n    $.each(errs, function (i, err) {\n      $.guid || ($.guid = 0); // Add error class\n\n      $input = err.input, $inputParent = $input.parent(), $optEl = $input.closest('.opt-element'), inputType = $input.attr('type'), inputHeight = $input.outerHeight(), inputPosition = $input.position(), customErrorMsg = $optEl.attr('opt-error-msg'), messageText = customErrorMsg ? customErrorMsg : err.messages.map(function (el) {\n        return '<div>' + el + '</div>';\n      }).join(''), errorGUID = 'opf-error--' + $.guid++, $errorMessage = $('<span id=\"' + errorGUID + '\" class=\"opf-error\" ><span class=\"opf-error__message\"><span class=\"opf-error__message-padding\">' + messageText + '</span></span>' + '<i class=\"material-icons\">error</i></span>'), $msgSpan = $errorMessage.find('.opf-error__message'), errorHeight = 0; // Add error class to the parent wrapper in order to namespace it\n\n      $inputParent.addClass('opf-error__input-wrapper--error'); // Remove any existing errors\n\n      if (!$inputParent.find('.opf-error').length) {\n        $inputParent.find('.opf-error').remove();\n        $inputParent.find('style').remove();\n        $inputParent.append($errorMessage);\n      } else {\n        $inputParent.find('.opf-error').attr('id', errorGUID);\n      }\n\n      $input.addClass(conf.errorClass).data('opf-error-selector', '#' + errorGUID);\n      errorHeight = Math.ceil($msgSpan.css({\n        'min-height': 'initial',\n        'max-height': 'initial'\n      }).outerHeight());\n      $msgSpan.css({\n        'min-height': '',\n        'max-height': ''\n      });\n\n      if ($optEl.attr('opt-input-style') === 'default') {\n        // Materialize icon\n        // If the message is smaller than the input wrapper we make the message grow to to full height of the input wrapper.\n        if (errorHeight < inputHeight) {\n          $errorMessage.addClass('opf-error--no-max-height');\n        } else {\n          $inputParent.append($('<style>#' + errorGUID + ':hover .opf-error__message{ max-height: ' + errorHeight + 'px; }</style>'));\n        }\n      } else {\n        // Custom icon special stuff, postiong the error icon and message over the input\n        $errorIcon = $optEl.find('.opf-error i');\n        errorIconTop = inputPosition.top; // This checks if the input is small and we can't use the default error icon margin. If it is small\n        // We calculate the margin based on the size available, or we add 8 px to match the default we user materialize inputs.\n\n        errorIconMargin = inputHeight < 40 ? (inputHeight - 24) / 2 : 8;\n        $errorIcon.css({\n          top: errorIconMargin > 0 ? errorIconTop + errorIconMargin : errorIconTop\n        });\n        $msgSpan.css({\n          top: errorIconTop\n        });\n\n        if (errorHeight < inputHeight) {\n          errorHeight = inputHeight;\n        }\n\n        $inputParent.append($('<style>#' + errorGUID + ':hover .opf-error__message{ min-height: ' + errorHeight + 'px; }</style>'));\n      }\n\n      validationElems.push({\n        inputElem: $input,\n        errorElem: $errorMessage\n      });\n      setTimeout(function ($input, $errorMessage) {\n        return function () {\n          if ($input.hasClass('opt-date-field')) {\n            var newLeft = $errorMessage.css('left');\n            /**\n             * The error icon blocks the small button that pops out the\n             * date time picker, preventing the user from clicking it,\n             * so move it over.\n             */\n\n            newLeft = +newLeft.replace('px', '') + 36;\n            $errorMessage.css({\n              left: newLeft\n            });\n          }\n\n          $errorMessage.css('opacity', 1);\n          $input = $errorMessage = null;\n        };\n      }($input, $errorMessage), 1);\n    });\n    $inputParent = $msgSpan = $optEl = null; // Hide errors function\n  }, function (inputs) {\n    var conf = this.getConf();\n    inputs.removeClass(conf.errorClass).each(function () {\n      var $this = $(this),\n          $parent = $this.parent(),\n          errorTargetClass = $this.data('opf-error-selector');\n\n      if (errorTargetClass) {\n        $(errorTargetClass).remove();\n      } // Remove the error namespace class iff exists\n\n\n      if ($parent.hasClass('opf-error__input-wrapper--error')) {\n        $parent.removeClass('opf-error__input-wrapper--error');\n      }\n    });\n    validationElems = [];\n  });\n  var reflowTimer = null;\n  $(window).on('resize.V', function () {\n    clearTimeout(reflowTimer);\n    reflowTimer = setTimeout(function () {\n      if (validationElems && validationElems.length) {\n        for (var i = 0; i < validationElems.length; i++) {\n          // Re-position the error message.\n          validationElems[i].errorElem.position({\n            of: validationElems[i].inputElem,\n            at: 'right center',\n            my: 'right-8 center'\n          });\n        }\n      }\n    }, 300);\n  });\n})(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My92YWxpZGF0b3IuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi93d3cvanMtMy4yLjIvb250cmFwb3J0L29wdF9hc3NldHMvb3B0X2JvaWxlcnBsYXRlcy92My92YWxpZGF0b3IuanM/NGI1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIGpRdWVyeSBUb29scyBWYWxpZGF0b3IgQFZFUlNJT04gLSBIVE1MNSBpcyBoZXJlLiBOb3cgdXNlIGl0LlxuICpcbiAqIE5PIENPUFlSSUdIVFMgT1IgTElDRU5TRVMuIERPIFdIQVQgWU9VIExJS0UuXG4gKlxuICogaHR0cDovL2Zsb3dwbGF5ZXIub3JnL3Rvb2xzL2Zvcm0vdmFsaWRhdG9yL1xuICpcbiAqIFNpbmNlOiBNYXIgMjAxMFxuICogRGF0ZTogQERBVEVcbiAqXG4gKiBAYnJpZWYgT250cmFwYWdlcyBWMyBmb3JtIHZhbGlkYXRpb24gNC8xMC8yMDE4LiBUaGlzIGZpbGUgYWxzbyBleGlzdHMgb24gaW4gbGVnYWNleSBvbnRyYWZvcm1zLCB3ZSBhcmUgZHVwaW5nIGl0XG4gKiAgICAgICAgaGVyZSB0byBwcm92aWRlIHNvbWUgaW5zdWxhdGlvbiBhbmQgZGVjb3VwbGUgb250cmFwYWdlcyBmb3JtcyBmcm9tIGxlZ2FjZXkgZm9ybSBlZGl0b3IgY29kZS5cbiAqL1xuKCBmdW5jdGlvbiggJCApIHtcblxuICAgICQudG9vbHMgPSAkLnRvb2xzIHx8IHt2ZXJzaW9uOiAnQFZFUlNJT04nfTtcblxuICAgIC8vIEdsb2JhbHNcbiAgICB2YXIgdHlwZVJlID0gL1xcW3R5cGU9KFthLXpdKylcXF0vLFxuICAgICAgICBudW1SZSA9IC9eLT9bMC05XSooXFwuWzAtOV0rKT8kLyxcbiAgICAgICAgZGF0ZUlucHV0ID0gJC50b29scy5kYXRlaW5wdXQsXG5cbiAgICAgICAgLy8gaHR0cDovL25ldC50dXRzcGx1cy5jb20vdHV0b3JpYWxzL290aGVyLzgtcmVndWxhci1leHByZXNzaW9ucy15b3Utc2hvdWxkLWtub3cvXG4gICAgICAgIC8vIERvbWFpbiBuYW1lIFRMRHMgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDYzIGNoYXJhY3RlcnNcbiAgICAgICAgZW1haWxSZSA9IC9eKFthLXowLTlfXFwuXFwtXFwrXSspQChbXFxkYS16XFwuXFwtXSspXFwuKFthLXpcXC5dezIsNjN9KSQvaSxcbiAgICAgICAgZW1haWxCbGFja0xpc3QgPSAvKFxcLkApfChAXFwuKS9pLCAvLyBEb250IGFsbG93IHBlcmlvZHMganVzdCBiZWZvcmUgQCBub3IgcmlnaHQgYWZ0ZXIuXG4gICAgICAgIHVybFJlID0gL14oaHR0cHM/OlxcL1xcLyk/W1xcZGEtelxcLlxcLV0rXFwuW2EtelxcLl17Miw2fVsjJitfXFw/XFwvXFx3IFxcLlxcLT1dKiQvaSxcbiAgICAgICAgdixcbiAgICAgICAgbG9jYWxpemVkTWVzc2FnZXM7XG5cbiAgICBpZiAoIHdpbmRvdy5vcCAmJiBvcC5sb2NhbGl6ZWRWYWxpZGF0aW9uTWVzc2FnZXMgKSB7XG4gICAgICAgIGxvY2FsaXplZE1lc3NhZ2VzID0gb3AubG9jYWxpemVkVmFsaWRhdGlvbk1lc3NhZ2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2FsaXplZE1lc3NhZ2VzID0ge1xuICAgICAgICAgICAgY3JlZGl0Q2FyZE51bWJlcjogJ1BsZWFzZSBlbnRlciBhIHZhbGlkIGNyZWRpdCBjYXJkIG51bWJlci4nLFxuICAgICAgICAgICAgZW1haWw6ICdQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLicsXG4gICAgICAgICAgICBjb25maXJtRW1haWw6ICdZb3VyIGVtYWlsIGFkZHJlc3NlcyBkbyBub3QgbWF0Y2guJyxcbiAgICAgICAgICAgIHVybDogJ1BsZWFzZSBlbnRlciBhIHZhbGlkIFVSTC4nLFxuICAgICAgICAgICAgbnVtYmVyOiAnUGxlYXNlIGVudGVyIGEgbnVtZXJpYyB2YWx1ZS4nLFxuICAgICAgICAgICAgbWF4OiAnUGxlYXNlIGVudGVyIGEgdmFsdWUgbm8gbGFyZ2VyIHRoYW4nLFxuICAgICAgICAgICAgbWluOiAnUGxlYXNlIGVudGVyIGEgdmFsdWUgb2YgYXQgbGVhc3QnLFxuICAgICAgICAgICAgcmVxdWlyZWQ6ICdQbGVhc2UgY29tcGxldGUgdGhpcyBtYW5kYXRvcnkgZmllbGQuJyxcbiAgICAgICAgICAgIHJhZGlvOiAnUGxlYXNlIHNlbGVjdCBhbiBvcHRpb24uJyxcbiAgICAgICAgICAgIGxpc3RNaW5QcmVmaXg6ICdNaW5pbXVtIHNlbGVjdGlvbicsXG4gICAgICAgICAgICBsaXN0TWluU3VmZml4OiAncmVxdWlyZWQuJyxcbiAgICAgICAgICAgIGxpc3RNYXhQcmVmaXg6ICdNYXhpbXVtIHNlbGVjdGlvbicsXG4gICAgICAgICAgICBsaXN0TWF4U3VmZml4OiAnZXhjZWVkZWQuJyxcbiAgICAgICAgICAgIGV4cGlyYXRpb25EYXRlOiAnUGxlYXNlIHNlbGVjdCBhIGZ1dHVyZSBkYXRlLidcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2ID0gJC50b29scy52YWxpZGF0b3IgPSB7XG5cbiAgICAgICAgY29uZjoge1xuICAgICAgICAgICAgZ3JvdXBlZDogZmFsc2UsIC8vIFNob3cgYWxsIGVycm9yIG1lc3NhZ2VzIGF0IG9uY2UgaW5zaWRlIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgIGVmZmVjdDogJ2RlZmF1bHQnLCAvLyBTaG93L2hpZGUgZWZmZWN0IGZvciBlcnJvciBtZXNzYWdlLiBvbmx5ICdkZWZhdWx0JyBpcyBidWlsdC1pblxuICAgICAgICAgICAgZXJyb3JDbGFzczogJ2ludmFsaWQnLCAvLyBJbnB1dCBmaWVsZCBjbGFzcyBuYW1lIGluIGNhc2Ugb2YgdmFsaWRhdGlvbiBlcnJvclxuXG4gICAgICAgICAgICAvLyBXaGVuIHRvIGNoZWNrIGZvciB2YWxpZGl0eT9cbiAgICAgICAgICAgIGlucHV0RXZlbnQ6IG51bGwsIC8vIENoYW5nZSwgYmx1ciwga2V5dXAsIG51bGxcbiAgICAgICAgICAgIGVycm9ySW5wdXRFdmVudDogJ2tleXVwJywgLy8gQ2hhbmdlLCBibHVyLCBrZXl1cCwgbnVsbFxuICAgICAgICAgICAgZm9ybUV2ZW50OiAnc3VibWl0JywgLy8gU3VibWl0LCBudWxsXG5cbiAgICAgICAgICAgIGxhbmc6ICdlbicsIC8vIERlZmF1bHQgbGFuZ3VhZ2UgZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgICAgICAgICBtZXNzYWdlOiAnPGRpdi8+JyxcbiAgICAgICAgICAgIG1lc3NhZ2VBdHRyOiAnZGF0YS1tZXNzYWdlJywgLy8gTmFtZSBvZiB0aGUgYXR0cmlidXRlIGZvciBvdmVycmlkZGVuIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIG1lc3NhZ2VDbGFzczogJ2Vycm9yJywgLy8gRXJyb3IgbWVzc2FnZSBlbGVtZW50J3MgY2xhc3MgbmFtZVxuICAgICAgICAgICAgb2Zmc2V0OiBbIDAsIDAgXSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnY2VudGVyIHJpZ2h0JyxcbiAgICAgICAgICAgIHNpbmdsZUVycm9yOiBmYWxzZSwgLy8gVmFsaWRhdGUgYWxsIGlucHV0cyBhdCBvbmNlXG4gICAgICAgICAgICBzcGVlZDogJ25vcm1hbCcgLy8gTWVzc2FnZSdzIGZhZGUtaW4gc3BlZWRcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qIFRoZSBFcnJvciBNZXNzYWdlcyAqL1xuICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgJyonOiB7IGVuOiAnUGxlYXNlIGNvcnJlY3QgdGhpcyB2YWx1ZS4nIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsb2NhbGl6ZTogZnVuY3Rpb24oIGxhbmcsIG1lc3NhZ2VzICkge1xuICAgICAgICAgICAgJC5lYWNoKCBtZXNzYWdlcywgZnVuY3Rpb24oIGtleSwgbXNnICkge1xuICAgICAgICAgICAgICAgIHYubWVzc2FnZXNbIGtleSBdID0gdi5tZXNzYWdlc1sga2V5IF0gfHwge307XG4gICAgICAgICAgICAgICAgdi5tZXNzYWdlc1sga2V5IF1bIGxhbmcgXSA9IG1zZztcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsb2NhbGl6ZUZuOiBmdW5jdGlvbigga2V5LCBtZXNzYWdlcyApIHtcbiAgICAgICAgICAgIHYubWVzc2FnZXNbIGtleSBdID0gdi5tZXNzYWdlc1sga2V5IF0gfHwge307XG4gICAgICAgICAgICAkLmV4dGVuZCggdi5tZXNzYWdlc1sga2V5IF0sIG1lc3NhZ2VzICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBuZXcgdmFsaWRhdG9yXG4gICAgICAgICAqL1xuICAgICAgICBmbjogZnVuY3Rpb24oIG1hdGNoZXIsIG1zZywgZm4gKSB7XG5cbiAgICAgICAgICAgIC8vIE5vIG1lc3NhZ2Ugc3VwcGxpZWRcbiAgICAgICAgICAgIGlmICggJC5pc0Z1bmN0aW9uKCBtc2cgKSApIHtcbiAgICAgICAgICAgICAgICBmbiA9IG1zZztcblxuICAgICAgICAgICAgLy8gTWVzc2FnZShzKSBvbiBzZWNvbmQgYXJndW1lbnRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgbXNnID09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSB7ZW46IG1zZ307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNbIG1hdGNoZXIua2V5IHx8IG1hdGNoZXIgXSA9IG1zZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIFwiW3R5cGU9eHh4XVwiIChub3Qgc3VwcG9ydGVkIGJ5IGpRdWVyeSlcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gdHlwZVJlLmV4ZWMoIG1hdGNoZXIgKTtcbiAgICAgICAgICAgIGlmICggdGVzdCApIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVyID0gaXNUeXBlKCB0ZXN0WyAxIF0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHZhbGlkYXRvciB0byB0aGUgYXJzZW5hbFxuICAgICAgICAgICAgZm5zLnB1c2goIFsgbWF0Y2hlciwgZm4gXSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIEFkZCBuZXcgc2hvdy9oaWRlIGVmZmVjdCAqL1xuICAgICAgICBhZGRFZmZlY3Q6IGZ1bmN0aW9uKCBuYW1lLCBzaG93Rm4sIGNsb3NlRm4gKSB7XG4gICAgICAgICAgICBlZmZlY3RzWyBuYW1lIF0gPSBbIHNob3dGbiwgY2xvc2VGbiBdO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyogQ2FsY3VsYXRlIGVycm9yIG1lc3NhZ2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGlucHV0ICovXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oIHRyaWdnZXIsIGVsLCBjb25mICkge1xuXG4gICAgICAgIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2VsZWN0b3Igc2V0XG4gICAgICAgIGVsID0gJCggZWwgKS5maXJzdCgpIHx8IGVsO1xuXG4gICAgICAgIC8vIEdldCBvcmlnaW4gdG9wL2xlZnQgcG9zaXRpb25cbiAgICAgICAgdmFyIHRvcCA9IHRyaWdnZXIub2Zmc2V0KCkudG9wLFxuICAgICAgICAgICAgbGVmdCA9IHRyaWdnZXIub2Zmc2V0KCkubGVmdCxcbiAgICAgICAgICAgIHBvcyA9IGNvbmYucG9zaXRpb24uc3BsaXQoIC8sP1xccysvICksXG4gICAgICAgICAgICB5ID0gcG9zWyAwIF0sXG4gICAgICAgICAgICB4ID0gcG9zWyAxIF07XG5cbiAgICAgICAgdG9wIC09IGVsLm91dGVySGVpZ2h0KCkgLSBjb25mLm9mZnNldFsgMCBdO1xuICAgICAgICBsZWZ0ICs9IHRyaWdnZXIub3V0ZXJXaWR0aCgpICsgY29uZi5vZmZzZXRbIDEgXTtcblxuICAgICAgICAvLyBJUGFkIHBvc2l0aW9uIGZpeFxuICAgICAgICBpZiAoIC9pUGFkL2kudGVzdCggbmF2aWdhdG9yLnVzZXJBZ2VudCApICkge1xuICAgICAgICAgICAgdG9wIC09ICQoIHdpbmRvdyApLnNjcm9sbFRvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRqdXN0IFlcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsLm91dGVySGVpZ2h0KCkgKyB0cmlnZ2VyLm91dGVySGVpZ2h0KCk7XG4gICAgICAgIGlmICggeSA9PSAnY2VudGVyJyApIHtcbiAgICAgICAgICAgIHRvcCArPSBoZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmICggeSA9PSAnYm90dG9tJyApIHtcbiAgICAgICAgICAgIHRvcCArPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3QgWFxuICAgICAgICB2YXIgd2lkdGggPSB0cmlnZ2VyLm91dGVyV2lkdGgoKTtcbiAgICAgICAgaWYgKCB4ID09ICdjZW50ZXInICkge1xuICAgICAgICAgICAgbGVmdCAtPSAoIHdpZHRoICsgZWwub3V0ZXJXaWR0aCgpICkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmICggeCA9PSAnbGVmdCcgKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHt0b3A6IHRvcCwgbGVmdDogbGVmdH07XG4gICAgfVxuXG5cbiAgICAvLyAkLmlzKFwiW3R5cGU9eHh4XVwiKSBvciAkLmZpbHRlcihcIlt0eXBlPXh4eF1cIikgbm90IHdvcmtpbmcgaW4galF1ZXJ5IDEuMy4yIG9yIDEuNC4yXG4gICAgZnVuY3Rpb24gaXNUeXBlKCB0eXBlICkge1xuICAgICAgICBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSggJ3R5cGUnICkgPT0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBmbi5rZXkgPSAnW3R5cGU9XCInICsgdHlwZSArICdcIl0nO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuXG5cbiAgICB2YXIgZm5zID0gW10sIGVmZmVjdHMgPSB7XG5cbiAgICAgICAgJ2RlZmF1bHQnOiBbXG5cbiAgICAgICAgICAgIC8vIFNob3cgZXJyb3JzIGZ1bmN0aW9uXG4gICAgICAgICAgICBmdW5jdGlvbiggZXJycyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjb25mID0gdGhpcy5nZXRDb25mKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBMb29wIGVycm9yc1xuICAgICAgICAgICAgICAgICQuZWFjaCggZXJycywgZnVuY3Rpb24oIGksIGVyciApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZXJyb3IgY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gZXJyLmlucHV0O1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5hZGRDbGFzcyggY29uZi5lcnJvckNsYXNzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGhhbmRsZSB0byB0aGUgZXJyb3IgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBpbnB1dC5kYXRhKCAnbXNnLmVsJyApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBpdCBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICBpZiAoICFtc2cgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSAkKCBjb25mLm1lc3NhZ2UgKS5hZGRDbGFzcyggY29uZi5tZXNzYWdlQ2xhc3MgKS5hcHBlbmRUbyggZG9jdW1lbnQuYm9keSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuZGF0YSggJ21zZy5lbCcsIG1zZyApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICBtc2cuY3NzKCB7dmlzaWJpbGl0eTogJ2hpZGRlbid9ICkuZmluZCggJ3AnICkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKCBlcnIubWVzc2FnZXMsIGZ1bmN0aW9uKCBpLCBtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCggJzxwLz4nICkuaHRtbCggbSApLmFwcGVuZFRvKCBtc2cgKTtcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgd2lkdGggaXMgbm90IGZ1bGwgYm9keSB3aWR0aCBzbyBpdCBjYW4gYmUgcG9zaXRpb25lZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtc2cub3V0ZXJXaWR0aCgpID09IG1zZy5wYXJlbnQoKS53aWR0aCgpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLmFkZCggbXNnLmZpbmQoICdwJyApICkuY3NzKCB7ZGlzcGxheTogJ2lubGluZSd9ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgaW50byBjb3JyZWN0IHBvc2l0aW9uIChyZWxhdGl2ZSB0byB0aGUgZmllbGQpXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBnZXRQb3NpdGlvbiggaW5wdXQsIG1zZywgY29uZiApO1xuXG4gICAgICAgICAgICAgICAgICAgIG1zZy5jc3MoIHsgdmlzaWJpbGl0eTogJ3Zpc2libGUnLCBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiBwb3MudG9wLCBsZWZ0OiBwb3MubGVmdCB9IClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mYWRlSW4oIGNvbmYuc3BlZWQgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG5cblxuICAgICAgICAgICAgLy8gSGlkZSBlcnJvcnMgZnVuY3Rpb25cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCBpbnB1dHMgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29uZiA9IHRoaXMuZ2V0Q29uZigpO1xuICAgICAgICAgICAgICAgIGlucHV0cy5yZW1vdmVDbGFzcyggY29uZi5lcnJvckNsYXNzICkuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSAkKCB0aGlzICkuZGF0YSggJ21zZy5lbCcgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtc2cgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cuY3NzKCB7dmlzaWJpbGl0eTogJ2hpZGRlbid9ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9O1xuXG5cbiAgICAvKiBTcGVjaWFsIHNlbGVjdG9ycyAqL1xuICAgICQuZWFjaCggJ2VtYWlsLHVybCxudW1iZXInLnNwbGl0KCAnLCcgKSwgZnVuY3Rpb24oIGksIGtleSApIHtcbiAgICAgICAgJC5leHByWyAnOicgXVsga2V5IF0gPSBmdW5jdGlvbiggZWwgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCAndHlwZScgKSA9PT0ga2V5O1xuICAgICAgICB9O1xuICAgIH0gKTtcblxuXG4gICAgLypcbiAgICAgICAgT25pbnZhbGlkKCkgalF1ZXJ5IHBsdWdpbi5cbiAgICAgICAgVXNhZ2U6ICQoXCJpbnB1dDplcSgyKVwiKS5vbmludmFsaWQoZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgICAqL1xuICAgICQuZm4ub25pbnZhbGlkID0gZnVuY3Rpb24oIGZuICkge1xuICAgICAgICByZXR1cm4gdGhpc1sgZm4gPyAnb24nIDogJ3RyaWdnZXInIF0oICdPSScsIGZuICk7XG4gICAgfTtcblxuXG4gICAgLyoqICoqKioqIEJ1aWx0LWluIEhUTUw1IHN0YW5kYXJkIHZhbGlkYXRvcnMgKioqKioqKioqL1xuXG4gICAgLypcbiAgICAgKiBWYWxpZGF0ZSBjcmVkaXQgY2FyZCBudW1iZXIuIEp1c3QgdXNlIGEgTFVITiBjaGVjay5cbiAgICAgKi9cbiAgICB2LmZuKCAnW25hbWU9XCJwYXltZW50X251bWJlclwiXScsIGxvY2FsaXplZE1lc3NhZ2VzLmNyZWRpdENhcmROdW1iZXIsIGZ1bmN0aW9uKCBlbCwgY2FyZE51bWJlciApIHtcblxuICAgICAgICAvLyBTcGFjZXMgYW5kIGRhc2hlcyBtYXkgYmUgdmFsaWQgY2hhcmFjdGVycywgYnV0IG11c3QgYmUgc3RyaXBwZWQgdG8gY2FsY3VsYXRlIHRoZSBjaGVja3N1bS5cbiAgICAgICAgdmFyIHZhbGlkID0gZmFsc2UsIGNhcmROdW1iZXIgPSBjYXJkTnVtYmVyLnJlcGxhY2UoIC8gKy9nLCAnJyApLnJlcGxhY2UoIC8tKy9nLCAnJyApO1xuXG4gICAgICAgIHZhciBudW1EaWdpdHMgPSBjYXJkTnVtYmVyLmxlbmd0aDtcbiAgICAgICAgaWYgKCBudW1EaWdpdHMgPj0gMTQgJiYgbnVtRGlnaXRzIDw9IDE2ICYmIHBhcnNlSW50KCBjYXJkTnVtYmVyICkgPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgc3VtID0gMCwgaSA9IG51bURpZ2l0cyAtIDEsIHBvcyA9IDEsIGRpZ2l0LCBsdWhuID0gbmV3IFN0cmluZygpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGRpZ2l0ID0gcGFyc2VJbnQoIGNhcmROdW1iZXIuY2hhckF0KCBpICkgKTtcbiAgICAgICAgICAgICAgICBsdWhuICs9ICggcG9zKysgJSAyID09IDAgKSA/IGRpZ2l0ICogMiA6IGRpZ2l0O1xuICAgICAgICAgICAgfSB3aGlsZSAoIC0taSA+PSAwICk7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbHVobi5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcGFyc2VJbnQoIGx1aG4uY2hhckF0KCBpICkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkID0gc3VtICUgMTAgPT0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhIXZhbGlkO1xuICAgIH0gKTtcblxuICAgIHYuZm4oICc6ZW1haWwnLCAnUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzcy4nLCBmdW5jdGlvbiggZWwsIHYgKSB7XG4gICAgICAgIHJldHVybiAhdiB8fCAoIGVtYWlsUmUudGVzdCggdiApICYmICFlbWFpbEJsYWNrTGlzdC50ZXN0KCB2ICkgJiYgdi5zcGxpdCggJ0AnIClbIDEgXS5pbmRleE9mKCAnLi4nICkgPT09IC0xICk7XG4gICAgfSApO1xuXG4gICAgdi5mbiggJzp1cmwnLCBsb2NhbGl6ZWRNZXNzYWdlcy51cmwsIGZ1bmN0aW9uKCBlbCwgdiApIHtcbiAgICAgICAgcmV0dXJuICF2IHx8IHVybFJlLnRlc3QoIHYgKTtcbiAgICB9ICk7XG5cbiAgICB2LmZuKCAnOm51bWJlcicsIGxvY2FsaXplZE1lc3NhZ2VzLm51bWJlciwgZnVuY3Rpb24oIGVsLCB2ICkge1xuICAgICAgICBudW1SZS50ZXN0KCB2ICk7XG4gICAgICAgIHJldHVybiBudW1SZS50ZXN0KCB2ICk7XG4gICAgfSApO1xuXG4gICAgdi5mbiggJ2lucHV0W3R5cGU9XFwndGV4dFxcJ11bb3B0LW51bWVyaWNdJywgbG9jYWxpemVkTWVzc2FnZXMubnVtYmVyLCBmdW5jdGlvbiggZWwsIHYgKSB7XG4gICAgICAgIHJldHVybiBudW1SZS50ZXN0KCB2ICk7XG4gICAgfSApO1xuXG4gICAgdi5mbiggJ1ttYXhdJywgbG9jYWxpemVkTWVzc2FnZXMubWF4ICsgJyAkMS4nLCBmdW5jdGlvbiggZWwsIHYgKSB7XG5cbiAgICAgICAgLy8gU2tpcCBlbXB0eSB2YWx1ZXMgYW5kIGRhdGVpbnB1dHNcbiAgICAgICAgaWYgKCB2ID09PSAnJyB8fCBkYXRlSW5wdXQgJiYgZWwuaXMoICc6ZGF0ZScgKSB8fCBlbC5oYXNDbGFzcyggJ29wdC1kYXRlLXRpbWUtZmllbGQnICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXggPSBlbC5hdHRyKCAnbWF4JyApO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCggdiApIDw9IHBhcnNlRmxvYXQoIG1heCApID8gdHJ1ZSA6IFsgbWF4IF07XG4gICAgfSApO1xuXG4gICAgdi5mbiggJ1ttaW5dJywgbG9jYWxpemVkTWVzc2FnZXMubWluICsgJyAkMS4nLCBmdW5jdGlvbiggZWwsIHYgKSB7XG5cbiAgICAgICAgLy8gU2tpcCBlbXB0eSB2YWx1ZXMgYW5kIGRhdGVpbnB1dHNcbiAgICAgICAgaWYgKCB2ID09PSAnJyB8fCBkYXRlSW5wdXQgJiYgZWwuaXMoICc6ZGF0ZScgKSB8fCBlbC5oYXNDbGFzcyggJ29wdC1kYXRlLXRpbWUtZmllbGQnICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW4gPSBlbC5hdHRyKCAnbWluJyApO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCggdiApID49IHBhcnNlRmxvYXQoIG1pbiApID8gdHJ1ZSA6IFsgbWluIF07XG4gICAgfSApO1xuXG4gICAgdi5mbiggJ1tyZXF1aXJlZF0nLCBsb2NhbGl6ZWRNZXNzYWdlcy5yZXF1aXJlZCwgZnVuY3Rpb24oIGVsLCB2ICkge1xuICAgICAgICAvLyBJZiBmaWVsZCBpcyBoaWRkZW4gKHN1Y2ggYXMgc2hpcHBpbmcgZmllbGQgd2hlbiBcInNoaXBwaW5nIGRpZmZlcmVudCBmcm9tIGJpbGxpbmdcIiBjaGVja2JveCBpcyB1bmNoZWNrZWQpIHJldHVybiB0cnVlXG4gICAgICAgIC8vIE5vdGUgdGhvdWdoLCBkcm9wZG93biBmaWVsZHMgaGF2ZSB0aGUgXCJyZXF1aXJlZFwiIGF0dHIgb24gdGhlIHNlbGVjdCBlbGVtZW50LCB3aGljaCBpc24ndCBhbHdheXMgdmlzaWJsZS5cbiAgICAgICAgLy8gRGF0ZSBUaW1lIGZpZWxkcyBhbHNvIHN0b3JlIGRhdGVzIGluIGhpZGRlbiBmaWVsZHNcbiAgICAgICAgaWYgKCAhZWwuaXMoICc6dmlzaWJsZScgKSAmJiAhZWwuaXMoICdzZWxlY3QnICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZWwuaXMoICc6Y2hlY2tib3gnICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuaXMoICc6Y2hlY2tlZCcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHNlbGVjdGFibGUgbGlzdHNcbiAgICAgICAgZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHYgKSApIHtcbiAgICAgICAgICAgIC8vIFVzZXIgaGFzIHNlbGVjdGVkIGF0IGxlYXN0IDEgdHJ1dGh5IG9wdGlvblxuICAgICAgICAgICAgcmV0dXJuIHYuc29tZSggKCBlbCApID0+IGVsICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEoIHYudHJpbSgpICk7XG4gICAgfSApO1xuXG4gICAgdi5mbiggJzpyYWRpbycsIGxvY2FsaXplZE1lc3NhZ2VzLnJhZGlvLCBmdW5jdGlvbiggZWwgKSB7XG4gICAgICAgIHZhciBjaGVja2VkID0gZmFsc2U7XG4gICAgICAgICQoICdbbmFtZT1cXCcnICsgZWwuYXR0ciggJ25hbWUnICkgKyAnXFwnXScgKS5lYWNoKCBmdW5jdGlvbiggaSwgZWwgKSB7XG4gICAgICAgICAgICBpZiAoICQoIGVsICkuaXMoICc6Y2hlY2tlZCcgKSApIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgICAgICByZXR1cm4gKCBjaGVja2VkICkgPyB0cnVlIDogZmFsc2U7XG4gICAgfSApO1xuXG4gICAgLypcbiAgICAgKiBPUFYzIFNlbGVjdGFibGUgbGlzdCBtaW5pbXVtIHNlbGVjdGVkIHZhbGlkYXRpb25cbiAgICAgKi9cbiAgICB2LmZuKCAnW29wdC1saXN0LW1pbl0nLCBsb2NhbGl6ZWRNZXNzYWdlcy5saXN0TWluUHJlZml4ICsgJyAoJXMpICcgKyBsb2NhbGl6ZWRNZXNzYWdlcy5saXN0TWluU3VmZml4LCBmdW5jdGlvbiggZWwsIHYgKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IHYubGVuZ3RoLFxuICAgICAgICAgICAgbWluID0gK2VsLmF0dHIoICdvcHQtbGlzdC1taW4nICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBzZWxlY3RlZCA+PSBtaW4sXG4gICAgICAgICAgICBtZXNzYWdlRGF0YTogbWluXG4gICAgICAgIH07XG4gICAgfSApO1xuXG4gICAgLypcbiAgICAgKiBPUFYzIFNlbGVjdGFibGUgbGlzdCBtYXhpbXVtIHNlbGVjdGVkIHZhbGlkYXRpb25cbiAgICAgKi9cbiAgICB2LmZuKCAnW29wdC1saXN0LW1heF0nLCBsb2NhbGl6ZWRNZXNzYWdlcy5saXN0TWF4UHJlZml4ICsgJyAoJXMpICcgKyBsb2NhbGl6ZWRNZXNzYWdlcy5saXN0TWF4U3VmZml4LCBmdW5jdGlvbiggZWwsIHYgKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IHYubGVuZ3RoLFxuICAgICAgICAgICAgbWF4ID0gK2VsLmF0dHIoICdvcHQtbGlzdC1tYXgnICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBzZWxlY3RlZCA8PSBtYXgsXG4gICAgICAgICAgICBtZXNzYWdlRGF0YTogbWF4XG4gICAgICAgIH07XG4gICAgfSApO1xuXG4gICAgLypcbiAgICAgKiBPUFYzIEV4cGlyYXRpb24gZGF0ZSB2YWxpZGF0aW9uXG4gICAgICovXG4gICAgdi5mbiggJ1tvcHQtdmFsaWRhdGUtZXhwaXJhdGlvbj1cInRydWVcIl0nLCBsb2NhbGl6ZWRNZXNzYWdlcy5leHBpcmF0aW9uRGF0ZSwgZnVuY3Rpb24oIGVsLCB2ICkge1xuICAgICAgICB2YXIgZm9ybSA9IGVsWyAwIF0uY2xvc2VzdCggJ2Zvcm0nICksXG4gICAgICAgICAgICBleHBNb250aCA9IHBhcnNlSW50KCBmb3JtLnF1ZXJ5U2VsZWN0b3IoICdbbmFtZT1cInBheW1lbnRfZXhwaXJlX21vbnRoXCJdJyApLnZhbHVlIHx8IDAgKSxcbiAgICAgICAgICAgIGV4cFllYXIgPSBwYXJzZUludCggZm9ybS5xdWVyeVNlbGVjdG9yKCAnW25hbWU9XCJwYXltZW50X2V4cGlyZV95ZWFyXCJdJyApLnZhbHVlIHx8IDAgKSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGN1cnJlbnRNb250aCA9IGN1cnJlbnREYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICBjdXJyZW50WWVhciA9IGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgcmV0dXJuICggKCBleHBZZWFyID4gY3VycmVudFllYXIgKSB8fCAoIGV4cFllYXIgPT09IGN1cnJlbnRZZWFyICYmIGV4cE1vbnRoID4gY3VycmVudE1vbnRoICkgKTtcblxuICAgIH0gKTtcblxuICAgIC8qXG5cdCAqXHRWYWxpZGF0aW9uIGZvciBjb25maXJtIGVtYWlsIGZpZWxkLiAgV2lsbCBvbmx5IHZhbGlkYXRlIElGRlxuXHQgKlx0IHRoZSBjb25maXJtX2VtYWlsIGZpZWxkIGlzIHByZXNlbnQgQU5EIGFuIGVtYWlsIGZpZWxkLlxuXHQgKi9cbiAgICB2LmZuKCAnW25hbWU9Y29uZmlybV9lbWFpbF0nLCBsb2NhbGl6ZWRNZXNzYWdlcy5jb25maXJtRW1haWwsIGZ1bmN0aW9uKCBlbCwgdmFsdWUgKSB7XG4gICAgICAgIHZhciBfZm9ybSA9ICQoIGVsICkucGFyZW50cyggJ2Zvcm0nICkuZmlyc3QoKTtcblxuICAgICAgICBpZiAoIF9mb3JtLmxlbmd0aCA+IDAgKSB7XG5cdCAgICAgICAgdmFyIF9lbWFpbEZpZWxkID0gX2Zvcm0uZmluZCggJ2lucHV0W25hbWU9XFwnZW1haWxcXCddJyApLmZpcnN0KCk7XG5cdCAgICAgICAgaWYgKCBfZW1haWxGaWVsZC5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICAgIHZhciBfZW1haWxWYWwgPSBfZW1haWxGaWVsZC52YWwoKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0ICAgICAgICByZXR1cm4gKCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09IF9lbWFpbFZhbCApO1xuXHQgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9ICk7XG5cbiAgICBmdW5jdGlvbiBWYWxpZGF0b3IoIGlucHV0cywgZm9ybSwgY29uZiApIHtcblxuICAgICAgICAvLyBQcml2YXRlIHZhcmlhYmxlc1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBmaXJlID0gZm9ybS5hZGQoIHNlbGYgKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIGlucHV0IGZpZWxkcyBhdmFpbGFibGVcbiAgICAgICAgaW5wdXRzID0gaW5wdXRzLm5vdCggJzpidXR0b24sIDppbWFnZSwgOnJlc2V0LCA6c3VibWl0JyApO1xuXG4gICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBGaXJlZm94IHZhbGlkYXRpb25cbiAgICAgICAgZm9ybS5hdHRyKCAnbm92YWxpZGF0ZScsICdub3ZhbGlkYXRlJyApO1xuXG4gICAgICAgIC8vIFV0aWxpdHkgZnVuY3Rpb25cbiAgICAgICAgZnVuY3Rpb24gcHVzaE1lc3NhZ2UoIHRvLCBtYXRjaGVyLCByZXR1cm5WYWx1ZSwgbXNnQ3VzdG9taXphdGlvbiApIHtcblxuICAgICAgICAgICAgLy8gT25seSBvbmUgbWVzc2FnZSBhbGxvd2VkXG4gICAgICAgICAgICBpZiAoICFjb25mLmdyb3VwZWQgJiYgdG8ubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIHZhciBtc2c7XG5cbiAgICAgICAgICAgIC8vIFN1YnN0aXR1dGlvbnMgYXJlIHJldHVybmVkXG4gICAgICAgICAgICBpZiAoIHJldHVyblZhbHVlID09PSBmYWxzZSB8fCAkLmlzQXJyYXkoIHJldHVyblZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgbXNnID0gdi5tZXNzYWdlc1sgbWF0Y2hlci5rZXkgfHwgbWF0Y2hlciBdIHx8IHYubWVzc2FnZXNbICcqJyBdO1xuICAgICAgICAgICAgICAgIG1zZyA9IG1zZ1sgY29uZi5sYW5nIF0gfHwgdi5tZXNzYWdlc1sgJyonIF0uZW47XG5cbiAgICAgICAgICAgICAgICBtc2cgPSAoIG1zZ0N1c3RvbWl6YXRpb24gKT8gbXNnLnJlcGxhY2UoICclcycsIG1zZ0N1c3RvbWl6YXRpb24gKSA6IG1zZztcblxuICAgICAgICAgICAgICAgIC8vIFN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbXNnLm1hdGNoKCAvXFwkXFxkL2cgKTtcblxuICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlcyAmJiAkLmlzQXJyYXkoIHJldHVyblZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaCggbWF0Y2hlcywgZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSggdGhpcywgcmV0dXJuVmFsdWVbIGkgXSApO1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFcnJvciBtZXNzYWdlIGlzIHJldHVybmVkIGRpcmVjdGx5XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1zZyA9IHJldHVyblZhbHVlWyBjb25mLmxhbmcgXSB8fCByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG8ucHVzaCggbXNnICk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEFQSSBtZXRob2RzXG4gICAgICAgICQuZXh0ZW5kKCBzZWxmLCB7XG5cbiAgICAgICAgICAgIGdldENvbmY6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25mO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Rm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRJbnB1dHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZWZsb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlucHV0cy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gJCggdGhpcyApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gaW5wdXQuZGF0YSggJ21zZy5lbCcgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1zZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBnZXRQb3NpdGlvbiggaW5wdXQsIG1zZywgY29uZiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLmNzcygge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcG9zLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBwb3MubGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogQHBhcmFtIGUgLSBmb3IgaW50ZXJuYWwgdXNlIG9ubHkgKi9cbiAgICAgICAgICAgIGludmFsaWRhdGU6IGZ1bmN0aW9uKCBlcnJzLCBlICkge1xuXG4gICAgICAgICAgICAgICAgLy8gRXJyb3JzIGFyZSBnaXZlbiBtYW51YWxseTogeyBmaWVsZE5hbWUxOiAnbWVzc2FnZTEnLCBmaWVsZE5hbWUyOiAnbWVzc2FnZTInIH1cbiAgICAgICAgICAgICAgICBpZiAoICFlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaCggZXJycywgZnVuY3Rpb24oIGtleSwgdmFsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzLmZpbHRlciggJ1tuYW1lPVxcJycgKyBrZXkgKyAnXFwnXScgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5wdXQubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBIVE1MNSBpbmludmFsaWQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC50cmlnZ2VyKCAnT0knLCBbIHZhbCBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCggeyBpbnB1dDogaW5wdXQsIG1lc3NhZ2VzOiBbIHZhbCBdfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJycyA9IGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgZSA9ICQuRXZlbnQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPbkZhaWwgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBlLnR5cGUgPSAnb25GYWlsJztcbiAgICAgICAgICAgICAgICBmaXJlLnRyaWdnZXIoIGUsIFsgZXJycyBdICk7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBlZmZlY3RcbiAgICAgICAgICAgICAgICBpZiAoICFlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzWyBjb25mLmVmZmVjdCBdWyAwIF0uY2FsbCggc2VsZiwgZXJycywgZSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCBlbHMgKSB7XG4gICAgICAgICAgICAgICAgZWxzID0gZWxzIHx8IGlucHV0cztcbiAgICAgICAgICAgICAgICBlbHMucmVtb3ZlQ2xhc3MoIGNvbmYuZXJyb3JDbGFzcyApLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gJCggdGhpcyApLmRhdGEoICdtc2cuZWwnICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggbXNnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCggdGhpcyApLmRhdGEoICdtc2cuZWwnLCBudWxsICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICkub2ZmKCBjb25mLmVycm9ySW5wdXRFdmVudCArICcudicgfHwgJycgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvcm0ub2ZmKCBjb25mLmZvcm1FdmVudCArICcuViByZXNldC5WJyApO1xuICAgICAgICAgICAgICAgIGlucHV0cy5vZmYoIGNvbmYuaW5wdXRFdmVudCArICcuViBjaGFuZ2UuVicgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yZXNldCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogQHJldHVybnMgYm9vbGVhbiAqL1xuICAgICAgICAgICAgY2hlY2tWYWxpZGl0eTogZnVuY3Rpb24oIGVscywgZSwgcGF5UGFsQnRuU3VibWl0ICkge1xuXG4gICAgICAgICAgICAgICAgZWxzID0gZWxzIHx8IGlucHV0cztcbiAgICAgICAgICAgICAgICBlbHMgPSBlbHMuZmlsdGVyKCBmdW5jdGlvbiggZWwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoICQoIGVsICkuaGFzQ2xhc3MoICdvcHQtZGF0ZS10aW1lLWZpZWxkJyApIHx8ICQoIGVsICkubm90KCAnOmRpc2FibGVkJyApICk7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIGR1cGxpY2F0ZSBlbGVtZW50cyBieSBuYW1lXG4gICAgICAgICAgICAgICAgdmFyIG5hbWVzID0ge307XG4gICAgICAgICAgICAgICAgZWxzID0gZWxzLmZpbHRlciggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gJCggdGhpcyApLmF0dHIoICduYW1lJyApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFuYW1lc1sgbmFtZSBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNbIG5hbWUgXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCggdGhpcyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhZWxzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZSA9IGUgfHwgJC5FdmVudCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gT25CZWZvcmVWYWxpZGF0ZVxuICAgICAgICAgICAgICAgIGUudHlwZSA9ICdvbkJlZm9yZVZhbGlkYXRlJztcbiAgICAgICAgICAgICAgICBmaXJlLnRyaWdnZXIoIGUsIFsgZWxzIF0gKTtcbiAgICAgICAgICAgICAgICBpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb250YWluZXIgZm9yIGVycm9yc1xuICAgICAgICAgICAgICAgIHZhciBlcnJzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBMb29wIHRyb3VnaCB0aGUgaW5wdXRzXG4gICAgICAgICAgICAgICAgZWxzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpZWxkIGFuZCBpdCdzIGVycm9yIG1lc3NhZ2UgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2dzID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9ICQoIHRoaXMgKS5kYXRhKCAnbWVzc2FnZXMnLCBtc2dzICksXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lQXR0ciA9IGVsLmF0dHIoICduYW1lJyApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkYXRlSW5wdXQgJiYgZWwuaXMoICc6ZGF0ZScgKSA/ICdvbkhpZGUudicgOiBjb25mLmVycm9ySW5wdXRFdmVudCArICcudic7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGlucHV0IGhvbGQgdGhlIHZhbHVlIGZvciB0aGUgTWF0ZXJpYWxpemVDU1MgcGlja2VyIHRoZW4gbGlzdGVuIGZvciBsaWIgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICggZWwuaGFzQ2xhc3MoICdvcHQtZGF0ZS10aW1lLWZpZWxkJyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSAnZGF0ZVRpbWVQaWNrZXJTYXZlLnYnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW51cCBwcmV2aW91cyB2YWxpZGF0aW9uIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGVsLm9mZiggZXZlbnQgKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb3AgYWxsIHZhbGlkYXRvciBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKCBmbnMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gdGhpcywgbWF0Y2ggPSBmblsgMCBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbC5maWx0ZXIoIG1hdGNoICkubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSBhIHZhbGlkYXRvciBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2dDdXN0b21pemF0aW9uID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZmllbGQgaXMgYSBwYXltZW50IGZpZWxkIGFuZCB3ZSBzdWJtaXR0ZWQgdmlhIHBheXBhbCwgYWx3YXlzIHJldHVybiB0cnVlIGZvciB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwYXlQYWxCdG5TdWJtaXQgJiYgbmFtZUF0dHIgJiYgbmFtZUF0dHIuaW5jbHVkZXMoICdwYXltZW50XycgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGV2ZW50ID09PSAnZGF0ZVRpbWVQaWNrZXJTYXZlLnYnICYmIGUgJiYgZS5kZXRhaWwgJiYgZS5kZXRhaWwuZGF0ZVRpbWVTdHJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBgY2hlY2tWYWxpZGl0eWAgY2FuIGJlIGludm9rZWQgbXVsdGlwbGUgd2F5cy4gSWYgaW52b2tlZCBieSB0aGUgZXZlbnQgbGlzdGVuZXIgd2UnbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0aGUgZGF0YSB0aGF0J3MgYWJvdXQgdG8gYmUgc2F2ZWQgYnkgdGhlIGxpYiBhbmQgd2UnbGwgY2hlY2sgYWdhaW5zdCB0aGF0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGFjdHVhbCBET00gaW5wdXQgaGFzbid0IGJlZW4gdXBkYXRlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmblsgMSBdLmNhbGwoIHNlbGYsIGVsLCBlLmRldGFpbC5kYXRlVGltZVN0cmluZyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gZm5bIDEgXS5jYWxsKCBzZWxmLCBlbCwgZWwudmFsKCkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmFsaWRhdGlvbiBmdW5jdGlvbiByZXR1cm5lZCBhbiBvYmplY3QgaXQgaXMgZHluYW1pY2FsbHkgY3VzdG9taXppbmcgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiByZXR1cm5WYWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoIHJldHVyblZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZ0N1c3RvbWl6YXRpb24gPSByZXR1cm5WYWx1ZS5tZXNzYWdlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZS52YWxpZGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRpb24gZmFpbGVkLiBtdWx0aXBsZSBzdWJzdGl0dXRpb25zIGNhbiBiZSByZXR1cm5lZCB3aXRoIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZXR1cm5WYWx1ZSAhPT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbkJlZm9yZUZhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50eXBlID0gJ29uQmVmb3JlRmFpbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUudHJpZ2dlciggZSwgWyBlbCwgbWF0Y2ggXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZGVuIGN1c3RvbSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBlbC5hdHRyKCBjb25mLm1lc3NhZ2VBdHRyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbXNnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNncyA9IFsgbXNnIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoTWVzc2FnZSggbXNncywgbWF0Y2gsIHJldHVyblZhbHVlLCBtc2dDdXN0b21pemF0aW9uICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1zZ3MubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJzLnB1c2goIHtpbnB1dDogZWwsIG1lc3NhZ2VzOiBtc2dzfSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIEhUTUw1IGluaW52YWxpZCBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZWwudHJpZ2dlciggJ09JJywgWyBtc2dzIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVnaW4gdmFsaWRhdGluZyB1cG9uIGVycm9yIGV2ZW50IHR5cGUgKHN1Y2ggYXMga2V5dXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbmYuZXJyb3JJbnB1dEV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLm9uKCBldmVudCwgZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2hlY2tWYWxpZGl0eSggZWwsIGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29uZi5zaW5nbGVFcnJvciAmJiBlcnJzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSApO1xuXG5cbiAgICAgICAgICAgICAgICAvLyBWYWxpZGF0aW9uIGRvbmUuIG5vdyBjaGVjayB0aGF0IHdlIGhhdmUgYSBwcm9wZXIgZWZmZWN0IGF0IGhhbmRcbiAgICAgICAgICAgICAgICB2YXIgZWZmID0gZWZmZWN0c1sgY29uZi5lZmZlY3QgXTtcbiAgICAgICAgICAgICAgICBpZiAoICFlZmYgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdWYWxpZGF0b3I6IGNhbm5vdCBmaW5kIGVmZmVjdCBcIicgKyBjb25mLmVmZmVjdCArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRXJyb3JzIGZvdW5kXG4gICAgICAgICAgICAgICAgaWYgKCBlcnJzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnZhbGlkYXRlKCBlcnJzLCBlICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIE5vIGVycm9yc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgZWZmZWN0XG4gICAgICAgICAgICAgICAgICAgIGVmZlsgMSBdLmNhbGwoIHNlbGYsIGVscywgZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9uU3VjY2VzcyBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBlLnR5cGUgPSAnb25TdWNjZXNzJztcbiAgICAgICAgICAgICAgICAgICAgZmlyZS50cmlnZ2VyKCBlLCBbIGVscyBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWxzLm9mZiggY29uZi5lcnJvcklucHV0RXZlbnQgKyAnLnYnICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9ICk7XG5cbiAgICAgICAgLy8gQ2FsbGJhY2tzXG4gICAgICAgICQuZWFjaCggJ29uQmVmb3JlVmFsaWRhdGUsb25CZWZvcmVGYWlsLG9uRmFpbCxvblN1Y2Nlc3MnLnNwbGl0KCAnLCcgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cbiAgICAgICAgICAgIC8vIENvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIGlmICggJC5pc0Z1bmN0aW9uKCBjb25mWyBuYW1lIF0gKSApIHtcbiAgICAgICAgICAgICAgICAkKCBzZWxmICkub24oIG5hbWUsIGNvbmZbIG5hbWUgXSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBUEkgbWV0aG9kc1xuICAgICAgICAgICAgc2VsZlsgbmFtZSBdID0gZnVuY3Rpb24oIGZuICkge1xuICAgICAgICAgICAgICAgIGlmICggZm4gKSB7XG4gICAgICAgICAgICAgICAgICAgICQoIHNlbGYgKS5vbiggbmFtZSwgZm4gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9ICk7XG5cblxuICAgICAgICAvLyBGb3JtIHZhbGlkYXRpb25cbiAgICAgICAgaWYgKCBjb25mLmZvcm1FdmVudCApIHtcbiAgICAgICAgICAgIGZvcm0ub24oIGNvbmYuZm9ybUV2ZW50ICsgJy5WJywgZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhc2VsZi5jaGVja1ZhbGlkaXR5KCBudWxsLCBlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGV2ZW50IHR5cGUgYW5kIHRhcmdldFxuICAgICAgICAgICAgICAgIGUudGFyZ2V0ID0gZm9ybTtcbiAgICAgICAgICAgICAgICBlLnR5cGUgPSBjb25mLmZvcm1FdmVudDtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvcm0gcmVzZXRcbiAgICAgICAgZm9ybS5vbiggJ3Jlc2V0LlYnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucmVzZXQoKTtcbiAgICAgICAgfSApO1xuXG4gICAgICAgIC8vIERpc2FibGUgYnJvd3NlcidzIGRlZmF1bHQgdmFsaWRhdGlvbiBtZWNoYW5pc21cbiAgICAgICAgaWYgKCBpbnB1dHNbIDAgXSAmJiBpbnB1dHNbIDAgXS52YWxpZGl0eSApIHtcbiAgICAgICAgICAgIGlucHV0cy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uaW52YWxpZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlYiBGb3JtcyAyLjAgY29tcGF0aWJpbGl0eVxuICAgICAgICBpZiAoIGZvcm1bIDAgXSApIHtcbiAgICAgICAgICAgIGZvcm1bIDAgXS5jaGVja1ZhbGlkaXR5ID0gc2VsZi5jaGVja1ZhbGlkaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5wdXQgdmFsaWRhdGlvblxuICAgICAgICBpZiAoIGNvbmYuaW5wdXRFdmVudCApIHtcbiAgICAgICAgICAgIGlucHV0cy5vbiggY29uZi5pbnB1dEV2ZW50ICsgJy5WJywgZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGF5ID0gKCB0aGlzLnR5cGUgPT09ICdjaGVja2JveCcgKT8gNzUwOiAwLFxuICAgICAgICAgICAgICAgICAgICBlbCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oIGVsICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVmFsaWRpdHkoICQoIGVsICksIGUgKTtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0uYmluZCggc2VsZiwgZWwgKSwgZGVsYXkgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrYm94ZXMgYW5kIHNlbGVjdHMgYXJlIGNoZWNrZWQgc2VwYXJhdGVseVxuICAgICAgICBpbnB1dHMuZmlsdGVyKCAnOmNoZWNrYm94LCBzZWxlY3QnICkuZmlsdGVyKCAnW3JlcXVpcmVkXScgKS5vbiggJ2NoYW5nZS5WJywgZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSAkKCB0aGlzICk7XG4gICAgICAgICAgICBpZiAoIHRoaXMuY2hlY2tlZCB8fCAoIGVsLmlzKCAnc2VsZWN0JyApICYmICQoIHRoaXMgKS52YWwoKSApICkge1xuICAgICAgICAgICAgICAgIGVmZmVjdHNbIGNvbmYuZWZmZWN0IF1bIDEgXS5jYWxsKCBzZWxmLCBlbCwgZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgLy8gRGF0ZVRpbWUgY29tcG9uZW50XG4gICAgICAgIGNvbnN0IGRhdGVUaW1lSW5wdXRzID0gaW5wdXRzLmZpbHRlciggJy5vcHQtZGF0ZS10aW1lLWZpZWxkJyApO1xuXG4gICAgICAgIGRhdGVUaW1lSW5wdXRzLmZpbHRlciggJy5vcHQtZGF0ZS10aW1lLWZpZWxkJyApLm9uKCAnZGF0ZVRpbWVQaWNrZXJTYXZlLlYnLCBmdW5jdGlvbiggZSApIHtcbiAgICAgICAgICAgIHZhciBlbCA9ICQoIHRoaXMgKTtcblxuICAgICAgICAgICAgaWYgKCBlLmRldGFpbCAmJiBlLmRldGFpbC5kYXRlVGltZVN0cmluZyApIHtcbiAgICAgICAgICAgICAgICBlZmZlY3RzWyBjb25mLmVmZmVjdCBdWyAxIF0uY2FsbCggc2VsZiwgZWwsIGUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBjbGVhciBpbnB1dCBidXR0b24gaXMgY2xpY2tlZCBydW4gdmFsaWRpdGlvbiBhZ2FpbnN0IHRoaXMgaW5wdXQgaW4gY2FzZVxuICAgICAgICBkYXRlVGltZUlucHV0cy5lYWNoKCBmdW5jdGlvbiggX2luZGV4LCBpbnB1dCApIHtcbiAgICAgICAgICAgICQoIGlucHV0ICkuc2libGluZ3MoKS5maWx0ZXIoICcub3B0LWRhdGUtdGltZV9faWNvbi0teCcgKS5vbiggJ2NsaWNrJywgZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSAkKCBpbnB1dCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBlbCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB3YWl0IGZvciBhbiBldmVudCBsb29wIGN5Y2xlIGluIG9yZGVyIGZvciB0aGUgaW5wdXQgdG8gYmUgdXBkYXRlZFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2hlY2tWYWxpZGl0eSggZWwsIGUgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgIH0gKTtcblxuICAgICAgICAvLyBHZXQgcmFkaW8gZ3JvdXBzIGJ5IG5hbWVcbiAgICAgICAgaW5wdXRzLmZpbHRlciggJzpyYWRpb1tyZXF1aXJlZF0nICkub24oICdjaGFuZ2UuVicsIGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgdmFyIGVscyA9ICQoICdbbmFtZT1cXCcnICsgJCggZS5zcmNFbGVtZW50ICkuYXR0ciggJ25hbWUnICkgKyAnXFwnXScgKTtcbiAgICAgICAgICAgIGlmICggKCBlbHMgIT09IG51bGwgKSAmJiAoIGVscy5sZW5ndGggIT09IDAgKSApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNoZWNrVmFsaWRpdHkoIGVscywgZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgLy8gUmVwb3NpdGlvbiB0b29sdGlwcyB3aGVuIHdpbmRvdyBpcyByZXNpemVkXG4gICAgICAgIC8vIERlYm91Y2luZyByZWZsb3cgY2FsbCBpcyBnb29kIGZvciBwZXJmICYgZml4ZXMgaXNzdWUgd2l0aFxuICAgICAgICAvLyBNb2JpbGUgYnJvd3NlcnMgdGhhdCB0cmlnZ2VyIHdpbmRvdyByZXNpemUgd2hlbiB0aGUgbmF2IGJhciBpcyB2aXNpYmxlLCB0aGUgcG9zaXRpb24gdGVuZHMgYmUgb2ZmIGJlY2F1c2Ugb2YgdGhlXG4gICAgICAgIC8vIFNjcm9sbCBpbmVydGlhXG4gICAgICAgIHZhciByZWZsb3dUaW1lciA9IG51bGw7XG4gICAgICAgICQoIHdpbmRvdyApLm9uKCAncmVzaXplLlYnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCggcmVmbG93VGltZXIgKTtcbiAgICAgICAgICAgIHJlZmxvd1RpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWZsb3coKTtcbiAgICAgICAgICAgIH0sIDMwMCApO1xuICAgICAgICB9ICk7XG5cbiAgICB9XG5cblxuICAgIC8vIEpRdWVyeSBwbHVnaW4gaW5pdGlhbGl6YXRpb25cbiAgICAkLmZuLnZhbGlkYXRvciA9IGZ1bmN0aW9uKCBjb25mICkge1xuXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZGF0YSggJ3ZhbGlkYXRvcicgKTtcblxuICAgICAgICAvLyBEZXN0cm95IGV4aXN0aW5nIGluc3RhbmNlXG4gICAgICAgIGlmICggaW5zdGFuY2UgKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZURhdGEoICd2YWxpZGF0b3InICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25maWd1cmF0aW9uXG4gICAgICAgIGNvbmYgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHYuY29uZiwgY29uZiApO1xuXG4gICAgICAgIC8vIFNlbGVjdG9yIGlzIGEgZm9ybVxuICAgICAgICBpZiAoIHRoaXMuaXMoICdmb3JtJyApICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm0gPSAkKCB0aGlzICk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBuZXcgVmFsaWRhdG9yKCBmb3JtLmZpbmQoICc6aW5wdXQnICksIGZvcm0sIGNvbmYgKTtcbiAgICAgICAgICAgICAgICBmb3JtLmRhdGEoICd2YWxpZGF0b3InLCBpbnN0YW5jZSApO1xuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IG5ldyBWYWxpZGF0b3IoIHRoaXMsIHRoaXMuZXEoIDAgKS5jbG9zZXN0KCAnZm9ybScgKSwgY29uZiApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSggJ3ZhbGlkYXRvcicsIGluc3RhbmNlICk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB2YXIgdmFsaWRhdGlvbkVsZW1zID0gW107XG5cbiAgICAkLnRvb2xzLnZhbGlkYXRvci5hZGRFZmZlY3QoICdvcHQtdjMnLCBmdW5jdGlvbiggZXJycyApIHtcblxuICAgICAgICB2YXIgY29uZiA9IHRoaXMuZ2V0Q29uZigpLFxuICAgICAgICAgICAgdmFsaWRhdGlvbkVsZW1zID0gW10sXG4gICAgICAgICAgICAkaW5wdXQsXG4gICAgICAgICAgICAkaW5wdXRQYXJlbnQsXG4gICAgICAgICAgICAkb3B0RWwsXG4gICAgICAgICAgICBpbnB1dFR5cGUsXG4gICAgICAgICAgICBpbnB1dEhlaWdodCxcbiAgICAgICAgICAgIGlucHV0UG9zaXRpb24sXG4gICAgICAgICAgICBjdXN0b21FcnJvck1zZyxcbiAgICAgICAgICAgIG1lc3NhZ2VUZXh0LFxuICAgICAgICAgICAgZXJyb3JHVUlELFxuICAgICAgICAgICAgJGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICRtc2dTcGFuLFxuICAgICAgICAgICAgZXJyb3JIZWlnaHQsXG4gICAgICAgICAgICAkZXJyb3JJY29uLFxuICAgICAgICAgICAgZXJyb3JJY29uVG9wLFxuICAgICAgICAgICAgZXJyb3JJY29uTWFyZ2luO1xuXG4gICAgICAgIC8vIExvb3AgZXJyb3JzXG4gICAgICAgICQuZWFjaCggZXJycywgZnVuY3Rpb24oIGksIGVyciApIHtcbiAgICAgICAgICAgICQuZ3VpZCB8fCAoICQuZ3VpZCA9IDAgKTtcblxuICAgICAgICAgICAgLy8gQWRkIGVycm9yIGNsYXNzXG4gICAgICAgICAgICAkaW5wdXQgPSBlcnIuaW5wdXQsXG4gICAgICAgICAgICAkaW5wdXRQYXJlbnQgPSAkaW5wdXQucGFyZW50KCksXG4gICAgICAgICAgICAkb3B0RWwgPSAkaW5wdXQuY2xvc2VzdCggJy5vcHQtZWxlbWVudCcgKSxcbiAgICAgICAgICAgIGlucHV0VHlwZSA9ICRpbnB1dC5hdHRyKCAndHlwZScgKSxcbiAgICAgICAgICAgIGlucHV0SGVpZ2h0ID0gJGlucHV0Lm91dGVySGVpZ2h0KCksXG4gICAgICAgICAgICBpbnB1dFBvc2l0aW9uID0gJGlucHV0LnBvc2l0aW9uKCksXG4gICAgICAgICAgICBjdXN0b21FcnJvck1zZyA9ICRvcHRFbC5hdHRyKCAnb3B0LWVycm9yLW1zZycgKSxcbiAgICAgICAgICAgIG1lc3NhZ2VUZXh0ID0gKCBjdXN0b21FcnJvck1zZyApID8gY3VzdG9tRXJyb3JNc2cgOiBlcnIubWVzc2FnZXMubWFwKCBmdW5jdGlvbiggZWwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2PicrZWwrJzwvZGl2Pic7XG4gICAgICAgICAgICB9ICkuam9pbiggJycgKSxcbiAgICAgICAgICAgIGVycm9yR1VJRCA9ICggJ29wZi1lcnJvci0tJyArICQuZ3VpZCsrICksXG4gICAgICAgICAgICAkZXJyb3JNZXNzYWdlID0gJCggJzxzcGFuIGlkPVwiJytlcnJvckdVSUQrJ1wiIGNsYXNzPVwib3BmLWVycm9yXCIgPjxzcGFuIGNsYXNzPVwib3BmLWVycm9yX19tZXNzYWdlXCI+PHNwYW4gY2xhc3M9XCJvcGYtZXJyb3JfX21lc3NhZ2UtcGFkZGluZ1wiPicrbWVzc2FnZVRleHQrJzwvc3Bhbj48L3NwYW4+JytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGkgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmVycm9yPC9pPjwvc3Bhbj4nICksXG4gICAgICAgICAgICAkbXNnU3BhbiA9ICRlcnJvck1lc3NhZ2UuZmluZCggJy5vcGYtZXJyb3JfX21lc3NhZ2UnICksXG4gICAgICAgICAgICBlcnJvckhlaWdodCA9IDA7XG5cbiAgICAgICAgICAgIC8vIEFkZCBlcnJvciBjbGFzcyB0byB0aGUgcGFyZW50IHdyYXBwZXIgaW4gb3JkZXIgdG8gbmFtZXNwYWNlIGl0XG4gICAgICAgICAgICAkaW5wdXRQYXJlbnQuYWRkQ2xhc3MoICdvcGYtZXJyb3JfX2lucHV0LXdyYXBwZXItLWVycm9yJyApO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGVycm9yc1xuICAgICAgICAgICAgaWYgKCAhJGlucHV0UGFyZW50LmZpbmQoICcub3BmLWVycm9yJyApLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAkaW5wdXRQYXJlbnQuZmluZCggJy5vcGYtZXJyb3InICkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgJGlucHV0UGFyZW50LmZpbmQoICdzdHlsZScgKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAkaW5wdXRQYXJlbnQuYXBwZW5kKCAkZXJyb3JNZXNzYWdlICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRpbnB1dFBhcmVudC5maW5kKCAnLm9wZi1lcnJvcicgKS5hdHRyKCAnaWQnLCBlcnJvckdVSUQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGlucHV0LmFkZENsYXNzKCBjb25mLmVycm9yQ2xhc3MgKS5kYXRhKCAnb3BmLWVycm9yLXNlbGVjdG9yJywgKCAnIycgKyBlcnJvckdVSUQgKSApO1xuXG5cbiAgICAgICAgICAgIGVycm9ySGVpZ2h0ID0gTWF0aC5jZWlsKCAkbXNnU3Bhbi5jc3MoIHsgJ21pbi1oZWlnaHQnOiAnaW5pdGlhbCcsICdtYXgtaGVpZ2h0JzogJ2luaXRpYWwnIH0gKS5vdXRlckhlaWdodCgpICk7XG4gICAgICAgICAgICAkbXNnU3Bhbi5jc3MoIHsgJ21pbi1oZWlnaHQnOiAnJywgJ21heC1oZWlnaHQnOiAnJyB9ICk7XG5cbiAgICAgICAgICAgIGlmICggJG9wdEVsLmF0dHIoICdvcHQtaW5wdXQtc3R5bGUnICkgPT09ICdkZWZhdWx0JyApIHtcblxuICAgICAgICAgICAgICAgIC8vIE1hdGVyaWFsaXplIGljb25cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbWVzc2FnZSBpcyBzbWFsbGVyIHRoYW4gdGhlIGlucHV0IHdyYXBwZXIgd2UgbWFrZSB0aGUgbWVzc2FnZSBncm93IHRvIHRvIGZ1bGwgaGVpZ2h0IG9mIHRoZSBpbnB1dCB3cmFwcGVyLlxuICAgICAgICAgICAgICAgIGlmICggZXJyb3JIZWlnaHQgPCBpbnB1dEhlaWdodCApIHtcbiAgICAgICAgICAgICAgICAgICAgJGVycm9yTWVzc2FnZS5hZGRDbGFzcyggJ29wZi1lcnJvci0tbm8tbWF4LWhlaWdodCcgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkaW5wdXRQYXJlbnQuYXBwZW5kKCAkKCAnPHN0eWxlPiMnK2Vycm9yR1VJRCsnOmhvdmVyIC5vcGYtZXJyb3JfX21lc3NhZ2V7IG1heC1oZWlnaHQ6ICcrZXJyb3JIZWlnaHQrJ3B4OyB9PC9zdHlsZT4nICkgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDdXN0b20gaWNvbiBzcGVjaWFsIHN0dWZmLCBwb3N0aW9uZyB0aGUgZXJyb3IgaWNvbiBhbmQgbWVzc2FnZSBvdmVyIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAgICRlcnJvckljb24gPSAkb3B0RWwuZmluZCggJy5vcGYtZXJyb3IgaScgKTtcbiAgICAgICAgICAgICAgICBlcnJvckljb25Ub3AgPSBpbnB1dFBvc2l0aW9uLnRvcDtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2hlY2tzIGlmIHRoZSBpbnB1dCBpcyBzbWFsbCBhbmQgd2UgY2FuJ3QgdXNlIHRoZSBkZWZhdWx0IGVycm9yIGljb24gbWFyZ2luLiBJZiBpdCBpcyBzbWFsbFxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbGN1bGF0ZSB0aGUgbWFyZ2luIGJhc2VkIG9uIHRoZSBzaXplIGF2YWlsYWJsZSwgb3Igd2UgYWRkIDggcHggdG8gbWF0Y2ggdGhlIGRlZmF1bHQgd2UgdXNlciBtYXRlcmlhbGl6ZSBpbnB1dHMuXG4gICAgICAgICAgICAgICAgZXJyb3JJY29uTWFyZ2luID0gKCBpbnB1dEhlaWdodCA8IDQwICkgPyAoICggaW5wdXRIZWlnaHQgLSAyNCApIC8gMiApIDogODtcblxuICAgICAgICAgICAgICAgICRlcnJvckljb24uY3NzKCB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogKCBlcnJvckljb25NYXJnaW4gPiAwICkgPyBlcnJvckljb25Ub3AgKyBlcnJvckljb25NYXJnaW4gOiBlcnJvckljb25Ub3BcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgJG1zZ1NwYW4uY3NzKCB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogZXJyb3JJY29uVG9wXG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBlcnJvckhlaWdodCA8IGlucHV0SGVpZ2h0ICkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckhlaWdodCA9IGlucHV0SGVpZ2h0IDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGlucHV0UGFyZW50LmFwcGVuZCggJCggJzxzdHlsZT4jJytlcnJvckdVSUQrJzpob3ZlciAub3BmLWVycm9yX19tZXNzYWdleyBtaW4taGVpZ2h0OiAnK2Vycm9ySGVpZ2h0KydweDsgfTwvc3R5bGU+JyApICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbGlkYXRpb25FbGVtcy5wdXNoKCB7aW5wdXRFbGVtOiAkaW5wdXQsIGVycm9yRWxlbTogJGVycm9yTWVzc2FnZSB9ICk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCAkaW5wdXQsICRlcnJvck1lc3NhZ2UgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICRpbnB1dC5oYXNDbGFzcyggJ29wdC1kYXRlLWZpZWxkJyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0xlZnQgPSAkZXJyb3JNZXNzYWdlLmNzcyggJ2xlZnQnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGVycm9yIGljb24gYmxvY2tzIHRoZSBzbWFsbCBidXR0b24gdGhhdCBwb3BzIG91dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGRhdGUgdGltZSBwaWNrZXIsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBjbGlja2luZyBpdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNvIG1vdmUgaXQgb3Zlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVmdCA9ICtuZXdMZWZ0LnJlcGxhY2UoICdweCcsICcnICkgKyAzNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICRlcnJvck1lc3NhZ2UuY3NzKCB7IGxlZnQ6IG5ld0xlZnQgfSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRlcnJvck1lc3NhZ2UuY3NzKCAnb3BhY2l0eScsIDEgKTtcblxuICAgICAgICAgICAgICAgICAgICAkaW5wdXQgPSAkZXJyb3JNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSggJGlucHV0LCAkZXJyb3JNZXNzYWdlICksIDEgKTtcblxuICAgICAgICB9ICk7XG5cbiAgICAgICAgJGlucHV0UGFyZW50ID0gJG1zZ1NwYW4gPSAkb3B0RWwgPW51bGw7XG5cblxuICAgICAgICAvLyBIaWRlIGVycm9ycyBmdW5jdGlvblxuICAgIH0sIGZ1bmN0aW9uKCBpbnB1dHMgKSB7XG5cbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmdldENvbmYoKTtcblxuICAgICAgICBpbnB1dHMucmVtb3ZlQ2xhc3MoIGNvbmYuZXJyb3JDbGFzcyApLmVhY2goIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCggdGhpcyApLFxuICAgICAgICAgICAgICAgICAgICAkcGFyZW50ID0gJHRoaXMucGFyZW50KCksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yVGFyZ2V0Q2xhc3MgPSAkdGhpcy5kYXRhKCAnb3BmLWVycm9yLXNlbGVjdG9yJyApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBlcnJvclRhcmdldENsYXNzICkge1xuICAgICAgICAgICAgICAgICAgICAkKCBlcnJvclRhcmdldENsYXNzICkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBlcnJvciBuYW1lc3BhY2UgY2xhc3MgaWZmIGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmICggJHBhcmVudC5oYXNDbGFzcyggJ29wZi1lcnJvcl9faW5wdXQtd3JhcHBlci0tZXJyb3InICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoICdvcGYtZXJyb3JfX2lucHV0LXdyYXBwZXItLWVycm9yJyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICB2YWxpZGF0aW9uRWxlbXMgPSBbXTtcbiAgICB9ICk7XG5cbiAgICB2YXIgcmVmbG93VGltZXIgPSBudWxsO1xuICAgICQoIHdpbmRvdyApLm9uKCAncmVzaXplLlYnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KCByZWZsb3dUaW1lciApO1xuICAgICAgICByZWZsb3dUaW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZiAoIHZhbGlkYXRpb25FbGVtcyAmJiB2YWxpZGF0aW9uRWxlbXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdmFsaWRhdGlvbkVsZW1zLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlLXBvc2l0aW9uIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRWxlbXNbIGkgXS5lcnJvckVsZW0ucG9zaXRpb24oIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mOiB2YWxpZGF0aW9uRWxlbXNbIGkgXS5pbnB1dEVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdDogJ3JpZ2h0IGNlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBteTogJ3JpZ2h0LTggY2VudGVyJ1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LDMwMCApO1xuICAgIH0gKTtcblxuXG59ICkoIGpRdWVyeSApO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFOQTtBQUFBO0FBUUE7QUFSQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFsQkE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRFQTtBQTBFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBeERBO0FBNkRBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF6T0E7QUFDQTtBQTZPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFJQTtBQUVBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/js-3.2.2/ontraport/opt_assets/opt_boilerplates/v3/validator.js\n");

/***/ })

/******/ });